diff --git a/PXE/Tests.module b/PXE/Tests.module
index e69de29..12fb44b 100644
--- a/PXE/Tests.module
+++ b/PXE/Tests.module
@@ -0,0 +1 @@
+threads
\ No newline at end of file
diff --git a/postbuild/paths.cmd b/postbuild/paths.cmd
index cec924b..e6e76e6 100644
--- a/postbuild/paths.cmd
+++ b/postbuild/paths.cmd
@@ -12,6 +12,7 @@ set PATH_TO_VM_DISK=__EMPTY__
 set PATH_TO_VM_TOOLS=__EMPTY__
 set VOL_MOUNT_LETTER=__EMPTY__
 
+if _%COMPUTERNAME%_==_DESKTOP-HFLFI90_ goto config_DESKTOP-HFLFI90
 if _%COMPUTERNAME%_==_AGURZOU-DEV-PC_ goto config_AGURZOU-DEV
 if _%COMPUTERNAME%_==_ALEX-PC_ goto config_ALEX-PC
 if _%COMPUTERNAME%_==_AGURZOU-LPT_ goto config_AGURZOU-LPT
@@ -69,4 +70,13 @@ set BOCHS_PATH="c:\Program Files (x86)\Bochs-2.6.8\"
 
 goto end
 
+:config_DESKTOP-HFLFI90
+
+SET PATH_TO_VM_DISK="D:\Facultate\UTCN\An IV\Semestrul 1\Proiectarea Sistemelor de Operare\Laborator\Setup\HAL9000\VM\HAL9000_VM\HAL9000.vmdk"
+SET PATH_TO_VIX_TOOLS="C:\Program Files (x86)\VMware\VMware Workstation"
+SET PXE_PATH="D:\Facultate\UTCN\An IV\Semestrul 1\Proiectarea Sistemelor de Operare\Laborator\Setup\HAL9000\PXE"
+SET PATH_TO_LOG_FILE="D:\Facultate\UTCN\An IV\Semestrul 1\Proiectarea Sistemelor de Operare\Laborator\Setup\HAL9000\VM\HAL9000_VM\HAL9000.log"
+SET PATH_TO_VM_FILE="D:\Facultate\UTCN\An IV\Semestrul 1\Proiectarea Sistemelor de Operare\Laborator\Setup\HAL9000\VM\HAL9000_VM\HAL9000.vmx"
+goto end
+
 :end
\ No newline at end of file
diff --git a/src/.vs/ProjectSettings.json b/src/.vs/ProjectSettings.json
new file mode 100644
index 0000000..0cf5ea5
--- /dev/null
+++ b/src/.vs/ProjectSettings.json
@@ -0,0 +1,3 @@
+{
+  "CurrentProjectSetting": "No Configurations"
+}
\ No newline at end of file
diff --git a/src/.vs/VSWorkspaceState.json b/src/.vs/VSWorkspaceState.json
new file mode 100644
index 0000000..b01a333
--- /dev/null
+++ b/src/.vs/VSWorkspaceState.json
@@ -0,0 +1,8 @@
+{
+  "ExpandedNodes": [
+    "",
+    "\\HAL9000"
+  ],
+  "SelectedNode": "\\HAL9000.sln",
+  "PreviewInSolutionExplorer": false
+}
\ No newline at end of file
diff --git a/src/.vs/slnx.sqlite b/src/.vs/slnx.sqlite
new file mode 100644
index 0000000..e68986f
Binary files /dev/null and b/src/.vs/slnx.sqlite differ
diff --git a/src/HAL9000/headers/thread_internal.h b/src/HAL9000/headers/thread_internal.h
index be2588a..8dc3909 100644
--- a/src/HAL9000/headers/thread_internal.h
+++ b/src/HAL9000/headers/thread_internal.h
@@ -33,6 +33,9 @@ typedef DWORD           THREAD_FLAGS;
 
 typedef struct _THREAD
 {
+    // The TID of the parent thread
+    TID                     ParentId;
+
     REF_COUNT               RefCnt;
 
     struct _THREAD          *Self;
diff --git a/src/HAL9000/src/cmd_thread_helper.c b/src/HAL9000/src/cmd_thread_helper.c
index f794c95..24bafb5 100644
--- a/src/HAL9000/src/cmd_thread_helper.c
+++ b/src/HAL9000/src/cmd_thread_helper.c
@@ -16,6 +16,7 @@
 #include "ex_timer.h"
 #include "vmm.h"
 #include "pit.h"
+#include "thread.h"
 
 
 #pragma warning(push)
@@ -129,7 +130,9 @@ void
 
     ASSERT(NumberOfParameters == 0);
 
+    LOG("%7s", "TotalNumberOfThreadsInTheSystem|");
     LOG("%7s", "TID|");
+    LOG("%7s", "Parent TID|");
     LOG("%20s", "Name|");
     LOG("%5s", "Prio|");
     LOG("%8s", "State|");
@@ -685,7 +688,9 @@ STATUS
 
     pThread = CONTAINING_RECORD(ListEntry, THREAD, AllList );
 
+    LOG("%4d%c", GetTotalNumberOfThreadsInTheSystem(), '|');
     LOG("%6x%c", pThread->Id, '|');
+    LOG("%6x%c", pThread->ParentId, '|');
     LOG("%19s%c", pThread->Name, '|');
     LOG("%4U%c", pThread->Priority, '|');
     LOG("%7s%c", _CmdThreadStateToName(pThread->State), '|');
diff --git a/src/HAL9000/src/cpumu.c b/src/HAL9000/src/cpumu.c
index 82fe2ec..8b6eb81 100644
--- a/src/HAL9000/src/cpumu.c
+++ b/src/HAL9000/src/cpumu.c
@@ -124,8 +124,8 @@ typedef struct _DUMMY_THREAD
 
     struct _THREAD* Self;
 } DUMMY_THREAD;
-static_assert(sizeof(DUMMY_THREAD) == FIELD_OFFSET(THREAD, Id) && FIELD_OFFSET(DUMMY_THREAD, Self) == FIELD_OFFSET(THREAD, Self),
-    "Safety measure, if someone modified the THREAD structure we may need to modify this DUMMY_THREAD as well");
+//static_assert(sizeof(DUMMY_THREAD) == FIELD_OFFSET(THREAD, Id) && FIELD_OFFSET(DUMMY_THREAD, Self) == FIELD_OFFSET(THREAD, Self),
+    //"Safety measure, if someone modified the THREAD structure we may need to modify this DUMMY_THREAD as well");
 
 // mark .Self as NULL such that GetCurrentThread will return always NULL until we setup the first real thread later in the boot
 // set up both for dummy CPU and for the real CPU structure until threading system is initialized
diff --git a/src/HAL9000/src/thread.c b/src/HAL9000/src/thread.c
index b311f0c..5adeec3 100644
--- a/src/HAL9000/src/thread.c
+++ b/src/HAL9000/src/thread.c
@@ -7,12 +7,13 @@
 #include "vmm.h"
 #include "process_internal.h"
 #include "isr.h"
+
 #include "gdtmu.h"
 #include "pe_exports.h"
 
-#define TID_INCREMENT               4
+#define TID_INCREMENT               0x10
 
-#define THREAD_TIME_SLICE           1
+#define THREAD_TIME_SLICE           4
 
 extern void ThreadStart();
 
@@ -27,6 +28,7 @@ extern FUNC_ThreadSwitch            ThreadSwitch;
 
 typedef struct _THREAD_SYSTEM_DATA
 {
+    LOCK                TotalNumberOfThreadsInTheSystemLock;
     LOCK                AllThreadsLock;
 
     _Guarded_by_(AllThreadsLock)
@@ -36,10 +38,19 @@ typedef struct _THREAD_SYSTEM_DATA
 
     _Guarded_by_(ReadyThreadsLock)
     LIST_ENTRY          ReadyThreadsList;
+
+    _Guarded_by_(TotalNumberOfThreadsInTheSystemLock)
+    QWORD               TotalNumberOfThreadsInTheSystem;
 } THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
 
 static THREAD_SYSTEM_DATA m_threadSystemData;
 
+QWORD
+GetTotalNumberOfThreadsInTheSystem()
+{
+    return m_threadSystemData.TotalNumberOfThreadsInTheSystem;
+}
+
 __forceinline
 static
 TID
@@ -145,6 +156,8 @@ ThreadSystemPreinit(
 
     InitializeListHead(&m_threadSystemData.ReadyThreadsList);
     LockInit(&m_threadSystemData.ReadyThreadsLock);
+
+    LockInit(&m_threadSystemData.TotalNumberOfThreadsInTheSystemLock);
 }
 
 STATUS
@@ -414,6 +427,11 @@ ThreadCreateEx(
     }
 
     *Thread = pThread;
+    //m_threadSystemData.TotalNumberOfThreadsInTheSystem = m_threadSystemData->TotalNumberOfThreadsInTheSystem + 1;
+
+    LOG("The thread with the name %s and id %d was created!\n", pThread->Name, pThread->Id);
+
+    pThread->ParentId = GetCurrentThread()->Id;
 
     return status;
 }
@@ -564,9 +582,12 @@ ThreadExit(
 
     ProcessNotifyThreadTermination(pThread);
 
+    LOG("The thread with the name %s and id %d was finished!\n", pThread->Name, pThread->Id);
+
     LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
     _ThreadSchedule();
     NOT_REACHED;
+
 }
 
 BOOLEAN
@@ -793,12 +814,15 @@ _ThreadInit(
         pThread->Id = _ThreadSystemGetNextTid();
         pThread->State = ThreadStateBlocked;
         pThread->Priority = Priority;
-
         LockInit(&pThread->BlockLock);
 
         LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
         InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
         LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
+
+        LockAcquire(&m_threadSystemData.TotalNumberOfThreadsInTheSystemLock, &oldIntrState);
+        m_threadSystemData.TotalNumberOfThreadsInTheSystem++;
+        LockRelease(&m_threadSystemData.TotalNumberOfThreadsInTheSystemLock, oldIntrState);
     }
     __finally
     {
diff --git a/src/shared/kernel/thread.h b/src/shared/kernel/thread.h
index acc7153..6592e8d 100644
--- a/src/shared/kernel/thread.h
+++ b/src/shared/kernel/thread.h
@@ -2,6 +2,9 @@
 
 #include "thread_defs.h"
 
+QWORD
+GetTotalNumberOfThreadsInTheSystem();
+
 //******************************************************************************
 // Function:     ThreadCreate
 // Description:  Spawns a new thread named Name with priority Function which
diff --git a/src_proiect/.vs/ProjectSettings.json b/src_proiect/.vs/ProjectSettings.json
new file mode 100644
index 0000000..0cf5ea5
--- /dev/null
+++ b/src_proiect/.vs/ProjectSettings.json
@@ -0,0 +1,3 @@
+{
+  "CurrentProjectSetting": "No Configurations"
+}
\ No newline at end of file
diff --git a/src_proiect/.vs/VSWorkspaceState.json b/src_proiect/.vs/VSWorkspaceState.json
new file mode 100644
index 0000000..b01a333
--- /dev/null
+++ b/src_proiect/.vs/VSWorkspaceState.json
@@ -0,0 +1,8 @@
+{
+  "ExpandedNodes": [
+    "",
+    "\\HAL9000"
+  ],
+  "SelectedNode": "\\HAL9000.sln",
+  "PreviewInSolutionExplorer": false
+}
\ No newline at end of file
diff --git a/src_proiect/.vs/slnx.sqlite b/src_proiect/.vs/slnx.sqlite
new file mode 100644
index 0000000..e68986f
Binary files /dev/null and b/src_proiect/.vs/slnx.sqlite differ
diff --git a/src_proiect/Ata/Ata.vcxproj b/src_proiect/Ata/Ata.vcxproj
new file mode 100644
index 0000000..437c476
--- /dev/null
+++ b/src_proiect/Ata/Ata.vcxproj
@@ -0,0 +1,136 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}</ProjectGuid>
+    <RootNamespace>Ata</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\ata_base.h" />
+    <ClInclude Include="headers\ata_commands.h" />
+    <ClInclude Include="headers\ata_dispatch.h" />
+    <ClInclude Include="headers\ata_operations.h" />
+    <ClInclude Include="headers\ata_registers.h" />
+    <ClInclude Include="headers\ata_structures.h" />
+    <ClInclude Include="inc\ata.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\ata_operations.c" />
+    <ClCompile Include="src\ata_dispatch.c" />
+    <ClCompile Include="src\ata.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Ata/Ata.vcxproj.filters b/src_proiect/Ata/Ata.vcxproj.filters
new file mode 100644
index 0000000..439f678
--- /dev/null
+++ b/src_proiect/Ata/Ata.vcxproj.filters
@@ -0,0 +1,54 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{f1a817fe-e7cc-46b8-8237-dc9b4b168df2}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\ata_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\ata.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ata_commands.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ata_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ata_dispatch.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ata_operations.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ata_registers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\ata_dispatch.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ata_operations.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ata.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Ata/headers/ata_base.h b/src_proiect/Ata/headers/ata_base.h
new file mode 100644
index 0000000..512aa03
--- /dev/null
+++ b/src_proiect/Ata/headers/ata_base.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#include "common_lib.h"
+#include "log.h"
+#include "io.h"
+#include "ata_structures.h"
\ No newline at end of file
diff --git a/src_proiect/Ata/headers/ata_commands.h b/src_proiect/Ata/headers/ata_commands.h
new file mode 100644
index 0000000..82b94f8
--- /dev/null
+++ b/src_proiect/Ata/headers/ata_commands.h
@@ -0,0 +1,78 @@
+#pragma once
+
+// ATA commands
+
+// The extended version is needed for LBA48 addressing
+#define ATA_CMD_READ_SECTORS            0x20
+#define ATA_CMD_READ_SECTORS_EXT        0x24
+#define ATA_CMD_READ_DMA_EXT            0x25
+#define ATA_CMD_WRITE_SECTORS           0x30
+#define ATA_CMD_WRITE_SECTORS_EXT       0x34
+#define ATA_CMD_WRITE_DMA_EXT           0x35
+#define ATA_CMD_READ_DMA                0xC8
+#define ATA_CMD_WRITE_DMA               0xCA
+
+// used for identifying ATA devices
+#define ATA_CMD_IDENTIFY                0xEC
+
+#pragma pack(push,1)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+#define ATA_SERIAL_NO_CHARS             20
+#define ATA_MODEL_NO_CHARS              40
+
+typedef struct _ATA_IDENTIFY_RESPONSE
+    {
+    /*
+    0 General configuration information
+    1 Number of logical cylinders in the default CHS translation 
+    3 Number of logical heads in the default CHS translation
+    6 Number of logical sectors per track in the default CHS translation 
+    10-19 Serial number (20 ASCII characters)
+    23-26 Firmware revision (8 ASCII characters) 
+    27-46 Model number (40 ASCII characters)
+    54 Number of logical cylinders in the current CHS translation 
+    55 Number of current logical heads in the current CHS translation
+    56 Number of current logical sectors per track in the current CHS translation 
+    57-58 Capacity in sectors in the current CHS translation
+    60-61 Total number of addressable sectors (28-bit LBA addressing) 
+    100-103 Total number of addressable sectors (48-bit LBA addressing)
+    160-255 Reserved
+    */
+    WORD        GeneralConfig;                              // 0
+    WORD        LogicalCylinders;                           // 2
+    WORD        Reserved0;                                  // 4
+    WORD        LogicalHeads;                               // 6
+    WORD        Reserved1[2];                               // 8
+    WORD        LogicalSectors;                             // 12
+    WORD        Reserved2[3];                               // 14
+    char        SerialNumbers[ATA_SERIAL_NO_CHARS];         // 20
+    WORD        Reserved3[3];                               // 40
+    char        FirmwareRevision[8];                        // 46
+    char        ModelNumber[ATA_MODEL_NO_CHARS];            // 54
+    WORD        Reserved4[7];                               // 94
+    WORD        LogicalCylindersCurrent;                    // 108
+    WORD        LogicalHeadsCurrent;                        // 110
+    WORD        LogicalSectorsCurrent;                      // 112
+    DWORD       SectorCapacity;                             // 114
+    WORD        Reserved5;                                  // 118
+    DWORD       Address28Bit;                               // 120
+    WORD        Reserved6[20];                              // 124
+    struct {
+        WORD    Reserved0       :  4;
+        WORD    PacketFeature   :  1;
+        WORD    Reserved1       : 11;
+        WORD    Reserved2       : 10;
+        WORD    SupportLba48    :  1;
+        WORD    Reserved3       :  5;
+        WORD    Reserved4;
+    } Features;
+    WORD        Reserved7[15];                              // 170
+    QWORD       Address48Bit;                               // 200
+    WORD        Reserved8[152];                             // 208
+} ATA_IDENTIFY_RESPONSE, *PATA_IDENTIFY_RESPONSE;
+STATIC_ASSERT(sizeof(ATA_IDENTIFY_RESPONSE) == SECTOR_SIZE);
+#pragma warning(default:4124)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src_proiect/Ata/headers/ata_dispatch.h b/src_proiect/Ata/headers/ata_dispatch.h
new file mode 100644
index 0000000..64297fc
--- /dev/null
+++ b/src_proiect/Ata/headers/ata_dispatch.h
@@ -0,0 +1,4 @@
+#pragma once
+
+FUNC_DriverDispatch              AtaDispatchReadWrite;
+FUNC_DriverDispatch              AtaDispatchDeviceControl;
\ No newline at end of file
diff --git a/src_proiect/Ata/headers/ata_operations.h b/src_proiect/Ata/headers/ata_operations.h
new file mode 100644
index 0000000..36d32bf
--- /dev/null
+++ b/src_proiect/Ata/headers/ata_operations.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#define ATA_NO_OF_BARS_USED     5
+
+STATUS
+AtaInitialize(
+    IN                              PPCI_DEVICE_DESCRIPTION     PciDevice,
+    IN                              BOOLEAN                     SecondaryChannel,
+    IN                              BOOLEAN                     Slave,
+    IN                              PDEVICE_OBJECT              Device
+    );
+
+STATUS
+AtaReadWriteSectors(
+    IN                              PATA_DEVICE                 Device,
+    IN                              QWORD                       SectorIndex,
+    IN                              WORD                        SectorCount,
+    _When_(WriteOperation, OUT_WRITES_BYTES(SectorCount*SECTOR_SIZE))
+    _When_(!WriteOperation, IN_READS_BYTES(SectorCount*SECTOR_SIZE))
+                                    PVOID                       Buffer,
+    OUT                             WORD*                       SectorsReadWriten,
+    IN                              BOOLEAN                     Asynchronous,
+    IN                              BOOLEAN                     WriteOperation
+    );
\ No newline at end of file
diff --git a/src_proiect/Ata/headers/ata_registers.h b/src_proiect/Ata/headers/ata_registers.h
new file mode 100644
index 0000000..eee83c0
--- /dev/null
+++ b/src_proiect/Ata/headers/ata_registers.h
@@ -0,0 +1,122 @@
+#pragma once
+
+typedef enum _ATA_REGISTER
+{
+    AtaRegisterData,                                        // 0x0  16b register
+    AtaRegisterError,                                       // 0x1
+    AtaRegisterFeatures = AtaRegisterError,                 // 0x1  Read - Write
+    AtaRegisterSectorCount,                                 // 0x2
+    AtaRegisterLbaLowRegister,                              // 0x3
+    AtaRegisterLbaMidRegister,                              // 0x4
+    AtaRegisterLbaHighRegister,                             // 0x5
+    AtaRegisterDevice,                                      // 0x6
+    AtaRegisterStatus,                                      // 0x7
+    AtaRegisterCommand = AtaRegisterStatus,                 // 0x7  Read - Write
+
+                                                            // these 4 registers are pseudo-registers
+                                                            // When using 48-bit LBA addressing these registers together with
+                                                            // their counterparts represent a two-byte deep FIFO
+    AtaRegisterSectorCountHigh,                             // 0x8 (0x2)
+    AtaRegisterLbaLowRegisterHigh,                          // 0x9 (0x3)
+    AtaRegisterLbaMidRegisterHigh,                          // 0xA (0x4)
+    AtaRegisterLbaHighRegisterHigh,                         // 0xB (0x5)
+
+                                                            // these 3 registers start at a different base
+    AtaRegisterAlternateStatus,                             // 0xC
+    AtaRegisterDeviceControl = AtaRegisterAlternateStatus,  // 0xC Read - Write
+    AtaRegisterDeviceAddress,                               // 0xD
+
+                                                            // registers for the Bus controller
+    AtaRegisterBusCommand,                                  // 0xE
+    AtaRegisterBusStatus = AtaRegisterBusCommand + 2,       // 0x10
+    AtaRegisterPrdtAddress = AtaRegisterBusStatus + 2,      // 0x12
+    AtaRegisterReserved = AtaRegisterPrdtAddress + 4        // 0x16
+} ATA_REGISTER;
+
+// Status register values
+// device is busy
+#define ATA_SREG_BUSY                           (1<<7)
+
+// device is ready
+#define ATA_SREG_DRDY                           (1<<6)
+
+// device fault
+#define ATA_SREG_DF                             (1<<5)
+
+// disk drive is ready to transmit data
+#define ATA_SREG_DRQ                            (1<<3)
+
+// error
+#define ATA_SREG_ERR                            (1<<0)
+
+// Error register values
+
+// Device register values
+#define ATA_DEV_REG_LBA                         (1<<6)
+#define ATA_DEV_REG_DEV                         (1<<4)
+
+// Device control register values
+#define ATA_DCTRL_REG_HOB                       (1<<7)
+#define ATA_DCTRL_REG_NIEN                      (1<<1)
+
+// BUS command
+#define ATA_BUS_CMD_START_BIT                   (1<<0)
+#define ATA_BUS_CMD_READ_BIT                    (1<<3)
+
+// Status command
+#define ATA_BUS_DMA_IRQ                         (1<<2)
+#define ATA_BUS_STATUS_MASTER_DMA_INITIALIZED   (1<<5)
+#define ATA_BUS_STATUS_SLAVE_DMA_INITIALIZED    (1<<6)
+
+#define ATA_BASE_PRIMARY_CHANNEL                0x1F0
+#define ATA_BASE_SECONDARY_CHANNEL              0x170
+
+#define ATA_CONTROL_PRIMARY_CHANNEL             0x3F6
+#define ATA_CONTROL_SECONDARY_CHANNEL           0x376
+
+#define ATA_NO_OF_CHANNELS                      2
+
+#define ATA_PRD_ENTRY_PREDEFINED_SIZE           8
+#define ATA_PRD_ALIGNMENT                       4
+
+#define ATA_DMA_MAX_PHYSICAL_LEN                (64 * KB_SIZE - 1)
+#define ATA_DMA_PHYSICAL_BOUNDARY               (64 * KB_SIZE)
+#define ATA_DMA_MAX_PHYSICAL_ADDRESS            MAX_DWORD
+#define ATA_DMA_ALIGNMENT                       4
+
+// PRD (Physical Region Descriptor)
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+typedef union _PRD_ENTRY
+{
+    struct
+    {
+        // Physical address of the buffer
+        // addresses must be below 4 GB
+
+        // And this address CANNOT cross a 64K boundary
+        // Q: Does this mean 0xF000 -> 0x11000 is not valid as an example?
+        // A: Yes
+        DWORD                               PhysicalAddress;
+
+        // ByteCount of 0 => 64K
+        // Must match the sector count else controller error
+        WORD                                ByteCount;
+
+        WORD                                __Reserved0 : 15;
+
+        // if set => this is the last entry in the PRD table
+        WORD                                LastEntry : 1;
+    };
+
+    QWORD                                   Raw;
+} PRD_ENTRY, *PPRD_ENTRY;
+STATIC_ASSERT(ATA_PRD_ENTRY_PREDEFINED_SIZE == sizeof(PRD_ENTRY));
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/Ata/headers/ata_structures.h b/src_proiect/Ata/headers/ata_structures.h
new file mode 100644
index 0000000..ac43a7b
--- /dev/null
+++ b/src_proiect/Ata/headers/ata_structures.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "ex_event.h"
+
+typedef enum _ATA_TRANSFER_STATE
+{
+    AtaTransferStateFree,
+    AtaTransferStateInProgress,
+    AtaTransferStateFinished
+} ATA_TRANSFER_STATE;
+
+typedef struct _ATA_CURRENT_TRANSFER
+{
+    volatile DWORD              State;
+    EX_EVENT                    TransferReady;
+
+    union _PRD_ENTRY*           Prdt;
+} ATA_CURRENT_TRANSFER, *PATA_CURRENT_TRANSPER;
+
+typedef struct _ATA_DEVICE_REGISTERS
+{
+    WORD                        BaseRegister;
+    WORD                        ControlBase;
+    WORD                        BusMasterBase;
+    BYTE                        NoInterrupt;
+} ATA_DEVICE_REGISTERS, *PATA_DEVICE_REGISTERS;
+
+typedef struct _ATA_DEVICE
+{
+    ATA_DEVICE_REGISTERS        DeviceRegisters;
+    QWORD                       TotalSectors;
+    BOOLEAN                     SecondaryChannel;
+    BOOLEAN                     Slave;
+    BOOLEAN                     Initialized;
+
+    ATA_CURRENT_TRANSFER        CurrentTransfer;
+} ATA_DEVICE, *PATA_DEVICE;
\ No newline at end of file
diff --git a/src_proiect/Ata/inc/ata.h b/src_proiect/Ata/inc/ata.h
new file mode 100644
index 0000000..8ced120
--- /dev/null
+++ b/src_proiect/Ata/inc/ata.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry                                AtaDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/Ata/src/ata.c b/src_proiect/Ata/src/ata.c
new file mode 100644
index 0000000..a7764c8
--- /dev/null
+++ b/src_proiect/Ata/src/ata.c
@@ -0,0 +1,115 @@
+#include "ata_base.h"
+#include "ata.h"
+#include "ata_dispatch.h"
+#include "ata_operations.h"
+
+STATUS
+(__cdecl AtaDriverEntry)(
+    INOUT       PDRIVER_OBJECT      Driver
+    )
+{
+    STATUS status;
+    PPCI_DEVICE_DESCRIPTION* pPciDevices;
+    DWORD i;
+    DWORD j;
+    DWORD k;
+    PDEVICE_OBJECT pAtaDevice;
+    BOOLEAN foundDevice;
+    DWORD noOfDevices;
+    PCI_SPEC pciSpec;
+
+    ASSERT(NULL != Driver);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pPciDevices = NULL;
+    pAtaDevice = NULL;
+    foundDevice = FALSE;
+    noOfDevices = 0;
+    i = 0;
+    j = 0;
+    k = 0;
+    memzero(&pciSpec, sizeof(PCI_SPEC));
+
+    pciSpec.MatchClass = TRUE;
+    pciSpec.MatchSubclass = TRUE;
+
+    pciSpec.Description.ClassCode = PciDeviceClassMassStorageController;
+    pciSpec.Description.Subclass = PciMassStorageIDE;
+
+    status = IoGetPciDevicesMatchingSpecification( pciSpec, &pPciDevices, &noOfDevices);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetPciDevicesMatchingClassAndSubclass", status);
+        return status;
+    }
+    ASSERT(noOfDevices == 0 || pPciDevices != NULL);
+    LOGL("Found %d IDE devices\n", noOfDevices );
+
+    Driver->DispatchFunctions[IRP_MJ_READ] = AtaDispatchReadWrite;
+    Driver->DispatchFunctions[IRP_MJ_WRITE] = AtaDispatchReadWrite;
+    Driver->DispatchFunctions[IRP_MJ_DEVICE_CONTROL] = AtaDispatchDeviceControl;
+
+    // lets try to initialize the device
+    for (i = 0; i < noOfDevices; ++i)
+    {
+        ASSERT(pPciDevices[i] != NULL);
+
+        for (j = 0; j < 2; ++j)
+        {
+            for (k = 0; k < 2; ++k)
+            {
+                if (NULL != pAtaDevice)
+                {
+                    IoDeleteDevice(pAtaDevice);
+                    pAtaDevice = NULL;
+                }
+
+                // create device object
+                pAtaDevice = IoCreateDevice(Driver, sizeof(ATA_DEVICE), DeviceTypeHarddiskController);
+                if (NULL == pAtaDevice)
+                {
+                    LOG_FUNC_ERROR_ALLOC("IoCreateDevice", sizeof(ATA_DEVICE));
+                    return STATUS_DEVICE_COULD_NOT_BE_CREATED;
+                }
+                pAtaDevice->DeviceAlignment = SECTOR_SIZE;
+
+                // initialize ATA device
+                status = AtaInitialize(pPciDevices[i], (BOOLEAN)j, (BOOLEAN)k, pAtaDevice);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_WARNING("AtaInitialize failed with status: 0x%x\n", status);
+                    continue;
+                }
+                LOG("AtaInitialize succeded\n");
+
+                foundDevice = TRUE;
+                pAtaDevice = NULL;
+            }
+        }
+    }
+
+    if (NULL != pPciDevices)
+    {
+        IoFreeTemporaryData(pPciDevices);
+        pPciDevices = NULL;
+    }
+
+    if (NULL != pAtaDevice)
+    {
+        // it means something failed
+        IoDeleteDevice(pAtaDevice);
+        pAtaDevice = NULL;
+    }
+
+    if (foundDevice)
+    {
+        // if we found at least a device we succeeded
+        status = STATUS_SUCCESS;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/Ata/src/ata_dispatch.c b/src_proiect/Ata/src/ata_dispatch.c
new file mode 100644
index 0000000..dab599e
--- /dev/null
+++ b/src_proiect/Ata/src/ata_dispatch.c
@@ -0,0 +1,209 @@
+#include "ata_base.h"
+#include "ata_dispatch.h"
+#include "ata_operations.h"
+
+#define LBA48_MAX_VALUE                 0x0000'FFFF'FFFF'FFFFULL
+
+__forceinline
+static
+STATUS
+_AtaCheckAlignment(
+    IN                                          QWORD           Size,
+    IN                                          QWORD           Offset
+    )
+{
+    if (!IsAddressAligned(Size, SECTOR_SIZE))
+    {
+        return STATUS_DEVICE_DATA_ALIGNMENT_ERROR;
+    }
+
+    if (!IsAddressAligned(Offset, SECTOR_SIZE))
+    {
+        return STATUS_DEVICE_DATA_ALIGNMENT_ERROR;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+__forceinline
+static
+STATUS
+_AtaCheckIOParameters(
+    IN                                          PATA_DEVICE     Device,
+    IN                                          QWORD           SectorIndex,
+    IN                                          WORD            SectorCount
+    )
+{
+    ASSERT(NULL != Device);
+
+    if (!Device->Initialized)
+    {
+        return STATUS_DEVICE_NOT_INITIALIZED;
+    }
+
+    if (SectorIndex >= Device->TotalSectors)
+    {
+        // how can we read at an index higher than our total sector count?
+        return STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED;
+    }
+
+    if (SectorIndex >= LBA48_MAX_VALUE)
+    {
+        // sector index is only a 48-bit value
+        return STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED;
+    }
+
+    if (Device->TotalSectors - SectorIndex < SectorCount)
+    {
+        // sorry, we really don't have that much
+        return STATUS_DEVICE_SECTOR_COUNT_EXCEEDED;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl AtaDispatchReadWrite)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    PATA_DEVICE pAtaDevice;
+    QWORD sectorIndex;
+    QWORD sectorCount;
+    PIO_STACK_LOCATION pStackLocation;
+    STATUS status;
+    QWORD sizeInBytes;
+    QWORD offset;
+    WORD sectorsRead;
+    BOOLEAN writeOperation;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    pAtaDevice = NULL;
+    sectorIndex = 0;
+    sectorCount = 0;
+    pStackLocation = NULL;
+    status = STATUS_SUCCESS;
+    sizeInBytes = 0;
+    offset = 0;
+    sectorsRead = 0;
+    writeOperation = FALSE;
+
+    pAtaDevice = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pAtaDevice);
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+
+    ASSERT(IRP_MJ_READ == pStackLocation->MajorFunction || IRP_MJ_WRITE == pStackLocation->MajorFunction);
+    writeOperation = IRP_MJ_WRITE == pStackLocation->MajorFunction;
+
+    sizeInBytes = pStackLocation->Parameters.ReadWrite.Length;
+    offset = pStackLocation->Parameters.ReadWrite.Offset;
+
+    LOG_TRACE_STORAGE("Offset: 0x%X\n", offset);
+    LOG_TRACE_STORAGE("Size in bytes: 0x%x\n", sizeInBytes);
+
+    __try
+    {
+        status = _AtaCheckAlignment(sizeInBytes, offset);
+        if (!SUCCEEDED(status))
+        {
+            __leave;
+        }
+
+        LOG_TRACE_STORAGE("Sizes are properly aligned to sector size\n");
+
+        sectorIndex = offset / SECTOR_SIZE;
+        sectorCount = sizeInBytes / SECTOR_SIZE;
+
+        LOG_TRACE_STORAGE("Sector index, Sector count: 0x%X, 0x%X\n", sectorIndex, sectorCount);
+
+        if (sectorCount > MAX_WORD)
+        {
+            status = STATUS_DEVICE_SECTOR_COUNT_EXCEEDED;
+            __leave;
+        }
+
+        status = _AtaCheckIOParameters(pAtaDevice, sectorIndex, (WORD)sectorCount);
+        if (!SUCCEEDED(status))
+        {
+            __leave;
+        }
+
+        LOG_TRACE_STORAGE("IO parameters are valid\n");
+        LOG_TRACE_STORAGE("Sector index: 0x%X\n", sectorIndex);
+        LOG_TRACE_STORAGE("Sector count: 0x%X\n", sectorCount);
+
+        ASSERT(AtaTransferStateFree == _InterlockedCompareExchange(&pAtaDevice->CurrentTransfer.State, AtaTransferStateInProgress, AtaTransferStateFree));
+
+        status = AtaReadWriteSectors(pAtaDevice, sectorIndex, (WORD)sectorCount, Irp->Buffer, &sectorsRead, (BOOLEAN)Irp->Flags.Asynchronous, writeOperation);
+
+        _InterlockedExchange(&pAtaDevice->CurrentTransfer.State, AtaTransferStateFree);
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = sectorsRead * SECTOR_SIZE;
+
+        // complete IRP
+        IoCompleteIrp(Irp);
+        Irp = NULL;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl AtaDispatchDeviceControl)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    DWORD information;
+    PATA_DEVICE pAtaDevice;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    information = 0;
+    pAtaDevice = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pAtaDevice);
+
+    ASSERT(IRP_MJ_DEVICE_CONTROL == pStackLocation->MajorFunction);
+
+    switch (pStackLocation->Parameters.DeviceControl.IoControlCode)
+    {
+    case IOCTL_DISK_GET_LENGTH_INFO:
+        {
+            GET_LENGTH_INFORMATION result;
+
+            information = sizeof(GET_LENGTH_INFORMATION);
+            memzero(&result, information);
+
+            if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+            {
+                status = STATUS_BUFFER_TOO_SMALL;
+                break;
+            }
+
+            result.Length = pAtaDevice->TotalSectors * SECTOR_SIZE;
+
+            // copy result
+            memcpy(pStackLocation->Parameters.DeviceControl.OutputBuffer, &result, information);
+        }
+        break;
+    default:
+        status = STATUS_UNSUPPORTED;
+    }
+
+    Irp->IoStatus.Status = status;
+    Irp->IoStatus.Information = information;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Ata/src/ata_operations.c b/src_proiect/Ata/src/ata_operations.c
new file mode 100644
index 0000000..a637b3c
--- /dev/null
+++ b/src_proiect/Ata/src/ata_operations.c
@@ -0,0 +1,908 @@
+#include "ata_base.h"
+#include "ata_operations.h"
+#include "ata_commands.h"
+#include "ata_registers.h"
+
+/// to remove
+#include "../../HAL9000/headers/dmp_ata.h"
+
+#define ATA_DEFAULT_IRQ_NO                                  14
+
+static const DWORD ATA_FIXED_BASE_ADDRESS[ATA_NO_OF_CHANNELS] = { ATA_BASE_PRIMARY_CHANNEL, ATA_BASE_SECONDARY_CHANNEL };
+static const DWORD ATA_FIXED_CONTROL_ADDRESS[ATA_NO_OF_CHANNELS] = { ATA_CONTROL_PRIMARY_CHANNEL, ATA_CONTROL_SECONDARY_CHANNEL };
+
+static FUNC_InterruptFunction           _AtaDmaInterrupt;
+
+static
+void
+_AtaWriteRegister(
+    IN      PATA_DEVICE_REGISTERS       AtaDevice,
+    IN      BYTE                        RegisterOffset,
+    IN      BYTE                        Data
+    );
+
+static
+BYTE
+_AtaReadRegister(
+    IN      PATA_DEVICE_REGISTERS       AtaDevice,
+    IN      BYTE                        RegisterOffset
+    );
+
+static
+void
+_AtaReadBuffer(
+    IN                          PATA_DEVICE_REGISTERS       AtaDevice,
+    OUT_WRITES_ALL(WordsToRead) PWORD                       Buffer,
+    IN                          DWORD                       WordsToRead
+    );
+
+static
+void
+_AtaWriteBuffer(
+    IN                          PATA_DEVICE_REGISTERS       AtaDevice,
+    IN_READS(WordsToRead)       PWORD                       Buffer,
+    IN                          DWORD                       WordsToRead
+    );
+
+static
+STATUS
+_AtaPrepareDmaTransfer(
+    IN          PATA_DEVICE_REGISTERS                       AtaDevice,
+    INOUT       PATA_CURRENT_TRANSPER                       CurrentTransfer,
+    IN          PVOID                                       Buffer,
+    IN          WORD                                        SectorCount,
+    IN          BOOLEAN                                     WriteOperation
+    );
+
+static
+STATUS
+_AtaValidateTranslationPair(
+    IN          PMDL_TRANSLATION_PAIR                       TranslationPair
+    );
+
+static
+void
+_AtaWriteDmaRegisters(
+    IN          PATA_DEVICE_REGISTERS                       AtaDevice,
+    IN          DWORD                                       Prdt,
+    IN          BOOLEAN                                     WriteOperation
+    );
+
+__forceinline
+static
+void
+_AtaWaitIdle(
+    IN      PATA_DEVICE_REGISTERS       Device
+    )
+{
+    while (IsBooleanFlagOn(__inbyte(Device->BaseRegister + AtaRegisterStatus), ATA_SREG_BUSY));
+}
+
+__forceinline
+static
+void
+_AtaWaitDataRequest(
+    IN      PATA_DEVICE_REGISTERS       Device
+    )
+{
+    while (!IsBooleanFlagOn(__inbyte(Device->BaseRegister + AtaRegisterStatus), ATA_SREG_DRQ));
+}
+
+__forceinline
+static
+void
+_AtaWaitDeviceReady(
+    IN      PATA_DEVICE_REGISTERS       Device
+    )
+{
+    while (!IsBooleanFlagOn(__inbyte(Device->BaseRegister + AtaRegisterStatus), ATA_SREG_DRDY));
+}
+
+__forceinline
+static
+void
+_AtaSelectDevice(
+    IN      PATA_DEVICE_REGISTERS       Device,
+    IN      BOOLEAN                     Slave
+    )
+{
+    // Warning C6323 Use of arithmetic operator on Boolean type(s)
+#pragma warning(suppress:6323)
+    _AtaWriteRegister(Device, AtaRegisterDevice, ATA_DEV_REG_LBA | ( ATA_DEV_REG_DEV * Slave ) );
+}
+
+static
+void
+_AtaWriteIOParameters(
+    IN      PATA_DEVICE_REGISTERS       Device,
+    IN      QWORD                       LbaAddress,
+    IN      WORD                        SectorCount
+    )
+{
+    PBYTE lba;
+
+    ASSERT(NULL != Device);
+
+    lba = (PBYTE)&LbaAddress;
+
+    // WRITE HIGH-order values
+    _AtaWriteRegister(Device, AtaRegisterSectorCountHigh, WORD_HIGH(SectorCount));
+
+    // bits 47:40
+    _AtaWriteRegister(Device, AtaRegisterLbaHighRegisterHigh, lba[5]);
+
+    // bits 39:32
+    _AtaWriteRegister(Device, AtaRegisterLbaMidRegisterHigh, lba[4]);
+
+    // bits 31:24
+    _AtaWriteRegister(Device, AtaRegisterLbaLowRegisterHigh, lba[3]);
+
+    // WRITE LOW-order values
+    _AtaWriteRegister(Device, AtaRegisterSectorCount, WORD_LOW(SectorCount));
+
+    // bits 23:16
+    _AtaWriteRegister(Device, AtaRegisterLbaHighRegister, lba[2]);
+
+    // bits 15:8
+    _AtaWriteRegister(Device, AtaRegisterLbaMidRegister, lba[1]);
+
+    // bits 7:0
+    _AtaWriteRegister(Device, AtaRegisterLbaLowRegister, lba[0]);
+}
+
+static
+void
+_AtaWriteRegister(
+    IN      PATA_DEVICE_REGISTERS       AtaDevice,
+    IN      BYTE                        RegisterOffset,
+    IN      BYTE                        Data
+    )
+{
+    ASSERT(NULL != AtaDevice);
+
+    if (RegisterOffset >= AtaRegisterSectorCountHigh && RegisterOffset <= AtaRegisterLbaHighRegisterHigh)
+    {
+        // we need to set HOB
+        _AtaWriteRegister(AtaDevice, AtaRegisterDeviceControl, ATA_DCTRL_REG_HOB | AtaDevice->NoInterrupt);
+    }
+
+    if (RegisterOffset < AtaRegisterSectorCountHigh)
+    {
+        // normal registers
+        __outbyte(AtaDevice->BaseRegister + RegisterOffset, Data);
+    }
+    else if( RegisterOffset < AtaRegisterAlternateStatus)
+    {
+        // 2 byte FIFO registers
+        __outbyte(AtaDevice->BaseRegister + RegisterOffset - (AtaRegisterSectorCountHigh - AtaRegisterSectorCount), Data);
+    }
+    else if (RegisterOffset <= AtaRegisterDeviceAddress)
+    {
+        // write to control register
+        __outbyte(AtaDevice->ControlBase + RegisterOffset - AtaRegisterAlternateStatus, Data);
+    }
+    else if (RegisterOffset < AtaRegisterPrdtAddress)
+    {
+        // write to bus controller
+        __outbyte(AtaDevice->BusMasterBase + RegisterOffset - AtaRegisterBusCommand, Data);
+    }
+    else
+    {
+        NOT_REACHED;
+    }
+
+    if (RegisterOffset >= AtaRegisterSectorCountHigh && RegisterOffset <= AtaRegisterLbaHighRegisterHigh)
+    {
+        /// Note is this really necessary? According to L10 IOS writing to any register except
+        /// Device Control resets HOB
+        // we need to remove HOB
+        _AtaWriteRegister(AtaDevice, AtaRegisterDeviceControl, AtaDevice->NoInterrupt);
+    }
+}
+
+static
+BYTE
+_AtaReadRegister(
+    IN      PATA_DEVICE_REGISTERS       AtaDevice,
+    IN      BYTE                        RegisterOffset
+    )
+{
+    BYTE result;
+
+    result = 0;
+
+    ASSERT(NULL != AtaDevice);
+
+    if (RegisterOffset >= AtaRegisterSectorCountHigh && RegisterOffset <= AtaRegisterLbaHighRegisterHigh)
+    {
+        // we need to set HOB
+        _AtaWriteRegister(AtaDevice, AtaRegisterDeviceControl, ATA_DCTRL_REG_HOB | AtaDevice->NoInterrupt);
+    }
+
+    if (RegisterOffset < AtaRegisterSectorCountHigh)
+    {
+        // normal registers
+        result = __inbyte(AtaDevice->BaseRegister + RegisterOffset);
+    }
+    else if (RegisterOffset < AtaRegisterAlternateStatus)
+    {
+        // 2 byte FIFO registers
+        result = __inbyte(AtaDevice->BaseRegister + RegisterOffset - (AtaRegisterSectorCountHigh - AtaRegisterSectorCount));
+    }
+    else if (RegisterOffset <= AtaRegisterDeviceAddress)
+    {
+        // write to control register
+        // the control registers we are interested in start at BAR1 + 2
+        result = __inbyte(AtaDevice->ControlBase + RegisterOffset - (AtaRegisterAlternateStatus - 2));
+    }
+    else if (RegisterOffset < AtaRegisterPrdtAddress)
+    {
+        // write to bus controller
+        result = __inbyte(AtaDevice->BusMasterBase + RegisterOffset - AtaRegisterBusCommand);
+    }
+    else
+    {
+        NOT_REACHED;
+    }
+
+    if (RegisterOffset >= AtaRegisterSectorCountHigh && RegisterOffset <= AtaRegisterLbaHighRegisterHigh)
+    {
+        /// Note is this really necessary? According to L10 IOS writing to any register except
+        /// Device Control resets HOB
+        // we need to remove HOB
+        _AtaWriteRegister(AtaDevice, AtaRegisterDeviceControl, AtaDevice->NoInterrupt);
+    }
+
+    return result;
+}
+
+static
+void
+_AtaReadBuffer(
+    IN                          PATA_DEVICE_REGISTERS       AtaDevice,
+    OUT_WRITES_ALL(WordsToRead) PWORD                       Buffer,
+    IN                          DWORD                       WordsToRead
+    )
+{
+    DWORD i;
+    WORD tempData;
+
+    ASSERT(NULL != AtaDevice);
+    ASSERT(NULL != Buffer);
+
+    for (i = 0; i < WordsToRead; ++i)
+    {
+        // wait device to be IDLE
+        _AtaWaitIdle(AtaDevice);
+
+        // wait device to be ready
+        _AtaWaitDataRequest(AtaDevice);
+
+        tempData = __inword(AtaDevice->BaseRegister + AtaRegisterData);
+        memcpy(Buffer + i, &tempData, sizeof(WORD));
+    }
+}
+
+static
+void
+_AtaWriteBuffer(
+    IN                          PATA_DEVICE_REGISTERS       AtaDevice,
+    IN_READS(WordsToRead)       PWORD                       Buffer,
+    IN                          DWORD                       WordsToRead
+    )
+{
+    DWORD i;
+
+    ASSERT(NULL != AtaDevice);
+    ASSERT(NULL != Buffer);
+
+    for (i = 0; i < WordsToRead; ++i)
+    {
+        // wait device to be IDLE
+        _AtaWaitIdle(AtaDevice);
+
+        // wait device to be ready
+        _AtaWaitDataRequest(AtaDevice);
+
+        __outword(AtaDevice->BaseRegister + AtaRegisterData, Buffer[i]);
+    }
+}
+
+static
+STATUS
+_AtaPrepareDmaTransfer(
+    IN          PATA_DEVICE_REGISTERS                       AtaDevice,
+    INOUT       PATA_CURRENT_TRANSPER                       CurrentTransfer,
+    IN          PVOID                                       Buffer,
+    IN          WORD                                        SectorCount,
+    IN          BOOLEAN                                     WriteOperation
+    )
+{
+    PMDL pMdl;
+    STATUS status;
+    DWORD byteCount;
+    DWORD noOfMdlTranslationEntries;
+    DWORD indexInPrdEntries;
+    PPRD_ENTRY prdTable;
+    DWORD i;
+    PHYSICAL_ADDRESS prdtPa;
+    DWORD bytesRemaining;
+    DWORD allocationSize;
+
+    LOG_FUNC_START;
+
+    ASSERT( NULL != AtaDevice );
+    ASSERT( NULL != CurrentTransfer );
+    ASSERT( NULL != Buffer );
+    ASSERT( 0 != SectorCount );
+
+    pMdl = NULL;
+    status = STATUS_SUCCESS;
+    byteCount = SectorCount * SECTOR_SIZE;
+    noOfMdlTranslationEntries = 0;
+    prdTable = NULL;
+    prdtPa = NULL;
+    bytesRemaining = SectorCount * SECTOR_SIZE;
+    indexInPrdEntries = 0;
+    allocationSize = 0;
+
+    status = IoAllocateMdl(Buffer,byteCount,NULL,&pMdl);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoAllocateMdl", status);
+        return status;
+    }
+
+    noOfMdlTranslationEntries = IoMdlGetNumberOfPairs(pMdl);
+    ASSERT( 0 != noOfMdlTranslationEntries );
+
+    // we allocate twice as many entries because we may have translations which cross
+    // the 64KB boundary => we will split such translations into 2 distinct PRD entries
+    allocationSize = sizeof(PRD_ENTRY) * noOfMdlTranslationEntries * 2;
+
+    __try
+    {
+        // also we align at allocationSize so that we can make sure we do not cross page boundaries
+        prdTable = IoAllocateContinuousMemoryEx(allocationSize, TRUE);
+        if (NULL == prdTable)
+        {
+            LOG_FUNC_ERROR("HeapAllocatePoolWithTag", allocationSize);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+        ASSERT(IsInSameBoundary(prdTable, allocationSize, PAGE_SIZE));
+
+        for (i = 0; i < noOfMdlTranslationEntries; ++i)
+        {
+            WORD byteCountForPrd;
+            WORD byteCountForAlignment;
+
+            MDL_TRANSLATION_PAIR* pCurPair = IoMdlGetTranslationPair(pMdl, i);
+            ASSERT(NULL != pCurPair);
+
+            status = _AtaValidateTranslationPair(pCurPair);
+            if (!SUCCEEDED(status))
+            {
+                __leave;
+            }
+
+            byteCountForPrd = (WORD)min(pCurPair->NumberOfBytes, bytesRemaining);
+            byteCountForAlignment = 0;
+
+            if (!IsInSameBoundary(pCurPair->Address, byteCountForPrd, ATA_DMA_PHYSICAL_BOUNDARY))
+            {
+                byteCountForAlignment = (WORD)(ATA_DMA_PHYSICAL_BOUNDARY - AddressOffset(pCurPair->Address, ATA_DMA_PHYSICAL_BOUNDARY));
+
+                // warning C4311: 'type cast': pointer truncation from 'PHYSICAL_ADDRESS' to 'DWORD'
+#pragma warning(suppress:4311)
+                prdTable[indexInPrdEntries].PhysicalAddress = (DWORD)pCurPair->Address;
+                prdTable[indexInPrdEntries].ByteCount = byteCountForAlignment;
+                prdTable[indexInPrdEntries].LastEntry = 0;
+
+                indexInPrdEntries++;
+            }
+
+            // warning C4311: 'type cast': pointer truncation from 'PHYSICAL_ADDRESS' to 'DWORD'
+#pragma warning(suppress:4311)
+            prdTable[indexInPrdEntries].PhysicalAddress = (DWORD)pCurPair->Address + byteCountForAlignment;
+            prdTable[indexInPrdEntries].ByteCount = byteCountForPrd - byteCountForAlignment;
+            prdTable[indexInPrdEntries].LastEntry = 0;
+
+            // increment lbaOffset
+            bytesRemaining = bytesRemaining - byteCountForPrd;
+
+            indexInPrdEntries++;
+        }
+
+        ASSERT(0 == bytesRemaining);
+
+        // mark last entry
+        prdTable[indexInPrdEntries - 1].LastEntry = 1;
+
+        LOG_TRACE_STORAGE("Number of entries: 0x%x\n", indexInPrdEntries);
+        for (i = 0; i < indexInPrdEntries; ++i)
+        {
+            LOG_TRACE_STORAGE("prdTable[i].PhysicalAddress: 0x%x\n", prdTable[i].PhysicalAddress);
+            LOG_TRACE_STORAGE("prdTable[i].ByteCount: 0x%x\n", prdTable[i].ByteCount);
+            LOG_TRACE_STORAGE("prdTable[i].LastEntry: 0x%x\n", prdTable[i].LastEntry);
+            LOG_TRACE_STORAGE("prdTable[i].Raw: 0x%X\n", prdTable[i].Raw);
+        }
+
+        prdtPa = IoGetPhysicalAddress(prdTable);
+        ASSERT(NULL != prdtPa);
+        if ((QWORD)prdtPa > MAX_DWORD)
+        {
+            status = STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH;
+            __leave;
+        }
+
+        LOG_TRACE_STORAGE("About to set up DMA registers!\n");
+
+        // setup DMA registers
+
+    // warning C4311: 'type cast': pointer truncation from 'PHYSICAL_ADDRESS' to 'DWORD'
+#pragma warning(suppress:4311)
+        _AtaWriteDmaRegisters(AtaDevice, (DWORD)prdtPa, WriteOperation);
+
+        CurrentTransfer->Prdt = prdTable;
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != prdTable)
+            {
+                IoFreeContinuousMemory(prdTable);
+                prdTable = NULL;
+            }
+        }
+        if (NULL != pMdl)
+        {
+            IoFreeMdl(pMdl);
+            pMdl = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_AtaValidateTranslationPair(
+    IN          PMDL_TRANSLATION_PAIR                       TranslationPair
+    )
+{
+    ASSERT( NULL != TranslationPair );
+
+    if ((QWORD)TranslationPair->Address > ATA_DMA_MAX_PHYSICAL_ADDRESS)
+    {
+        return STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH;
+    }
+
+    if (!IsAddressAligned(TranslationPair->Address, ATA_DMA_ALIGNMENT))
+    {
+        return STATUS_DEVICE_DATA_ALIGNMENT_ERROR;
+    }
+
+    if (TranslationPair->NumberOfBytes > ATA_DMA_MAX_PHYSICAL_LEN)
+    {
+        return STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE;
+    }
+
+    if (!IsAddressAligned(TranslationPair->NumberOfBytes, ATA_DMA_ALIGNMENT))
+    {
+        return STATUS_DEVICE_DATA_ALIGNMENT_ERROR;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+_AtaWriteDmaRegisters(
+    IN          PATA_DEVICE_REGISTERS                       AtaDevice,
+    IN          DWORD                                       Prdt,
+    IN          BOOLEAN                                     WriteOperation
+    )
+{
+    BYTE dmaStatus;
+
+    ASSERT( NULL != AtaDevice );
+
+    dmaStatus = _AtaReadRegister( AtaDevice, AtaRegisterBusStatus );
+    LOG_TRACE_STORAGE("DMA status: 0x%x\n", dmaStatus );
+    LOG_TRACE_STORAGE("Prdt: 0x%x\n", Prdt );
+
+    // set PRDT
+    __outdword(AtaDevice->BusMasterBase + AtaRegisterPrdtAddress - AtaRegisterBusCommand, Prdt);
+
+    _AtaWriteRegister(AtaDevice, AtaRegisterBusStatus, (!WriteOperation * ATA_BUS_CMD_READ_BIT) );
+}
+
+STATUS
+AtaInitialize(
+    IN                              PPCI_DEVICE_DESCRIPTION     PciDevice,
+    IN                              BOOLEAN                     SecondaryChannel,
+    IN                              BOOLEAN                     Slave,
+    IN                              PDEVICE_OBJECT              Device
+    )
+{
+    STATUS status;
+    DWORD baseAddress;
+    DWORD ctrlAddress;
+    DWORD busAddress;
+    BYTE data;
+    DWORD j;
+    ATA_IDENTIFY_RESPONSE identify;
+    PATA_DEVICE pDeviceExtension;
+    IO_INTERRUPT ioInterrupt;
+    BOOLEAN bLegacyDevice;
+
+    LOG_FUNC_START;
+
+    if (NULL == PciDevice)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == Device)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    status = STATUS_SUCCESS;
+    data = 0;
+    pDeviceExtension = NULL;
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    pDeviceExtension = IoGetDeviceExtension(Device);
+    ASSERT(NULL != pDeviceExtension);
+
+    baseAddress = (PciDevice->DeviceData->Header.Device.Bar[2 * BooleanToInteger(SecondaryChannel)].IoSpace.Address) << 2;
+    ctrlAddress = (PciDevice->DeviceData->Header.Device.Bar[2 * BooleanToInteger(SecondaryChannel) + 1].IoSpace.Address) << 2;
+    busAddress = (PciDevice->DeviceData->Header.Device.Bar[4].IoSpace.Address << 2) + (8 * BooleanToInteger(SecondaryChannel));
+
+    ASSERT(baseAddress <= MAX_WORD);
+    ASSERT(ctrlAddress <= MAX_WORD);
+    ASSERT(busAddress <= MAX_WORD);
+
+    LOG_TRACE_STORAGE("Base address: 0x%x\n", baseAddress);
+    LOG_TRACE_STORAGE("Ctrl address: 0x%x\n", ctrlAddress);
+    LOG_TRACE_STORAGE("Bus address: 0x%x\n", busAddress);
+    LOG_TRACE_STORAGE("Bars[4].IoSpace.Address: 0x%x\n", PciDevice->DeviceData->Header.Device.Bar[4].IoSpace.Address << 2);
+    LOG_TRACE_STORAGE("Secondary channel: 0x%x\n", SecondaryChannel);
+    LOG_TRACE_STORAGE("Slave: 0x%x\n", Slave);
+
+    bLegacyDevice = ( 0 == baseAddress ) && ( 0 == ctrlAddress );
+    ASSERT( bLegacyDevice || ( ( 0 != baseAddress ) && ( 0 != ctrlAddress ) ) );
+
+    pDeviceExtension->DeviceRegisters.BaseRegister = (WORD)((0 != baseAddress) ? baseAddress : ATA_FIXED_BASE_ADDRESS[SecondaryChannel]);
+
+    // we subtract 2 from ctrlAddress because BAR gives of address of ctrlRegisters + 2 (dunno why)
+    pDeviceExtension->DeviceRegisters.ControlBase = (WORD)((0 != ctrlAddress) ? (ctrlAddress + 2) : ATA_FIXED_CONTROL_ADDRESS[SecondaryChannel]);
+    pDeviceExtension->DeviceRegisters.BusMasterBase = (WORD) busAddress;
+    pDeviceExtension->DeviceRegisters.NoInterrupt = ATA_DCTRL_REG_NIEN;
+    pDeviceExtension->SecondaryChannel = SecondaryChannel;
+    pDeviceExtension->Slave = Slave;
+
+    LOG_TRACE_STORAGE("Base address: 0x%x\n", pDeviceExtension->DeviceRegisters.BaseRegister);
+    LOG_TRACE_STORAGE("Ctrl address: 0x%x\n", pDeviceExtension->DeviceRegisters.ControlBase);
+
+    // disable interrupts on current drive
+    _AtaWriteRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterDeviceControl, pDeviceExtension->DeviceRegisters.NoInterrupt);
+
+    // select drive
+    _AtaSelectDevice(&pDeviceExtension->DeviceRegisters, Slave);
+
+    // disable interrupts on selected drive
+    _AtaWriteRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterDeviceControl, pDeviceExtension->DeviceRegisters.NoInterrupt);
+
+    LOG_TRACE_STORAGE("Device selected\n");
+
+    /// sleep a little
+    for (j = 0; j < 10; ++j)
+        _AtaReadRegister(&pDeviceExtension->DeviceRegisters,AtaRegisterAlternateStatus);
+
+    LOG_TRACE_STORAGE("About to send identify\n");
+
+    // send identify command
+    _AtaWriteRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterCommand, ATA_CMD_IDENTIFY);
+
+    /// sleep a little
+    for (j = 0; j < 10; ++j)
+        _AtaReadRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterAlternateStatus);
+
+    if (0 == _AtaReadRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterStatus))
+    {
+        // no device
+        status = STATUS_DEVICE_DOES_NOT_EXIST;
+        LOG("Device does not exist\n");
+        return status;
+    }
+
+    LOG_TRACE_STORAGE("Device does exist\n");
+
+    // wait for device to be ready
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        data = _AtaReadRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterStatus);
+        if (IsBooleanFlagOn(data, ATA_SREG_ERR))
+        {
+            LOG("Not ATA, maybe ATAPI\n");
+            status = STATUS_DEVICE_NOT_SUPPORTED;
+            return status;
+        }
+
+        // if device is not busy and it is ready we can continue
+        if ((!IsBooleanFlagOn(data, ATA_SREG_BUSY)) && (IsBooleanFlagOn(data, ATA_SREG_DRQ)))
+        {
+            break;
+        }
+    }
+
+    // specify we do not want interrupts
+    _AtaWriteRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterDeviceControl, pDeviceExtension->DeviceRegisters.NoInterrupt);
+
+    // lets read identify command response
+    _AtaReadBuffer(&pDeviceExtension->DeviceRegisters, (PWORD) &identify, SECTOR_SIZE / sizeof(WORD));
+
+    if (LogIsComponentTraced(LogComponentStorage))
+    {
+        DumpAtaIdentifyCommand(&identify);
+    }
+
+    if (!identify.Features.SupportLba48)
+    {
+        status = STATUS_DEVICE_NOT_SUPPORTED;
+        LOG_WARNING("We do not know how to operate disks without 48-bit address support :(\n");
+        return status;
+    }
+
+    pDeviceExtension->TotalSectors = identify.Address48Bit;
+
+    // initialize current transfer structure
+    _InterlockedExchange(&pDeviceExtension->CurrentTransfer.State, AtaTransferStateFree);
+    status = ExEventInit(&pDeviceExtension->CurrentTransfer.TransferReady, ExEventTypeSynchronization, FALSE );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ExEventInit", status );
+        return status;
+    }
+
+    ioInterrupt.Type = bLegacyDevice ? IoInterruptTypeLegacy : IoInterruptTypePci;
+    ioInterrupt.Irql = IrqlStorageLevel;
+    ioInterrupt.ServiceRoutine = _AtaDmaInterrupt;
+    ioInterrupt.Exclusive = FALSE;
+
+    if (bLegacyDevice)
+    {
+        ioInterrupt.Legacy.Irq = ATA_DEFAULT_IRQ_NO + BooleanToInteger(SecondaryChannel);
+    }
+    else
+    {
+        ioInterrupt.Pci.PciDevice = PciDevice;
+    }
+
+    status = IoRegisterInterrupt( &ioInterrupt, Device );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoRegisterInterrupt", status);
+        return status;
+    }
+
+    // make sure DMA transfer is stopped
+    _AtaWriteRegister(&pDeviceExtension->DeviceRegisters, AtaRegisterBusCommand, 0 );
+
+    pDeviceExtension->Initialized = TRUE;
+
+    return status;
+}
+
+STATUS
+AtaReadWriteSectors(
+    IN                                          PATA_DEVICE     Device,
+    IN                                          QWORD           SectorIndex,
+    IN                                          WORD            SectorCount,
+    _When_(WriteOperation,OUT_WRITES_BYTES(SectorCount*SECTOR_SIZE))
+    _When_(!WriteOperation,IN_READS_BYTES(SectorCount*SECTOR_SIZE))
+                                                PVOID           Buffer,
+    OUT                                         WORD*           SectorsReadWriten,
+    IN                                          BOOLEAN         Asynchronous,
+    IN                                          BOOLEAN         WriteOperation
+    )
+{
+    STATUS status;
+    PATA_DEVICE_REGISTERS pDevRegisters;
+    BYTE ataCmd;
+
+    if (NULL == Device)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (0 == SectorCount)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (NULL == Buffer)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    if (NULL == SectorsReadWriten)
+    {
+        return STATUS_INVALID_PARAMETER5;
+    }
+
+    status = STATUS_SUCCESS;
+    pDevRegisters = &Device->DeviceRegisters;
+
+    // 1. wait for device to become idle
+    _AtaWaitIdle(pDevRegisters);
+
+    LOG_TRACE_STORAGE("Device is idle\n");
+
+    // 2. select device
+    _AtaSelectDevice(pDevRegisters, Device->Slave);
+
+    LOG_TRACE_STORAGE("Device selected\n");
+
+    // 3. wait device to be IDLE and ready
+    _AtaWaitIdle(pDevRegisters);
+
+    LOG_TRACE_STORAGE("Device is idle\n");
+
+    // wait device to be ready
+    _AtaWaitDeviceReady(pDevRegisters);
+
+    LOG_TRACE_STORAGE("Device is ready\n");
+    LOG_TRACE_STORAGE("Asynchronous: 0x%x\n", Asynchronous );
+
+    // we don't want interrupts if we're performing a synchronous transfer
+    pDevRegisters->NoInterrupt = Asynchronous ? 0 : ATA_DCTRL_REG_NIEN;
+
+    // specify if we want interrupts or not
+    _AtaWriteRegister(pDevRegisters, AtaRegisterDeviceControl, pDevRegisters->NoInterrupt);
+
+    if (pDevRegisters->NoInterrupt)
+    {
+        LOG_TRACE_STORAGE("We don't want interrupts\n");
+    }
+    else
+    {
+        LOG_TRACE_STORAGE("We'll use interrupts\n");
+    }
+
+    // 4. write command parameters
+    _AtaWriteIOParameters(pDevRegisters, SectorIndex, SectorCount);
+    LOG_TRACE_STORAGE("IO parameters written\n");
+
+    if (Asynchronous)
+    {
+        // 4.5 write DMA parameters
+
+        // configure bus master register for DMA transfer
+        status = _AtaPrepareDmaTransfer(pDevRegisters, &Device->CurrentTransfer, Buffer, SectorCount, WriteOperation );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_AtaPrepareDmaTransfer", status);
+            return status;
+        }
+
+        LOG_TRACE_STORAGE("DMA parameters written\n");
+    }
+
+    // set command type
+    if (WriteOperation)
+    {
+        ataCmd = Asynchronous ? ATA_CMD_WRITE_DMA_EXT : ATA_CMD_WRITE_SECTORS_EXT;
+    }
+    else
+    {
+        ataCmd = Asynchronous ? ATA_CMD_READ_DMA_EXT : ATA_CMD_READ_SECTORS_EXT;
+    }
+
+    // 5. write command
+    _AtaWriteRegister(pDevRegisters, AtaRegisterCommand, ataCmd);
+
+    if (Asynchronous)
+    {
+        // set direction, it's weird this must be set after the command is written
+        // yeah Read => bit set, Write => bit cleared
+        _AtaWriteRegister(pDevRegisters, AtaRegisterBusCommand, (!WriteOperation * ATA_BUS_CMD_READ_BIT) | ATA_BUS_CMD_START_BIT);
+
+        // wait for DMA transfer to complete
+        ExEventWaitForSignal(&Device->CurrentTransfer.TransferReady);
+
+        // check if transfer actually finished
+        ASSERT( AtaTransferStateFinished == _InterlockedAnd( &Device->CurrentTransfer.State, MAX_DWORD ) );
+        ASSERT( NULL != Device->CurrentTransfer.Prdt );
+
+        LOG_TRACE_STORAGE("About to free PRDT\n");
+        IoFreeContinuousMemory(Device->CurrentTransfer.Prdt );
+        Device->CurrentTransfer.Prdt = NULL;
+
+        LOG_TRACE_STORAGE("DMA transfer complete\n");
+    }
+    else
+    {
+        // read buffer synchronously
+        if (WriteOperation)
+        {
+            _AtaWriteBuffer(pDevRegisters, Buffer, SectorCount * (SECTOR_SIZE / sizeof(WORD)));
+
+            LOG_TRACE_STORAGE("Buffer written\n");
+        }
+        else
+        {
+            _AtaReadBuffer(pDevRegisters, Buffer, SectorCount * (SECTOR_SIZE / sizeof(WORD)));
+
+            LOG_TRACE_STORAGE("Buffer read\n");
+        }
+    }
+
+    *SectorsReadWriten = SectorCount;
+
+    status = STATUS_SUCCESS;
+
+    return status;
+}
+
+BOOLEAN
+(__cdecl _AtaDmaInterrupt)(
+    IN      PDEVICE_OBJECT  Device
+    )
+{
+    PATA_DEVICE pAtaDev;
+    PATA_DEVICE_REGISTERS pDevRegisters;
+    BYTE busStatus;
+    BYTE devStatus;
+
+    LOG_FUNC_START;
+
+    ASSERT( NULL != Device );
+
+    pAtaDev = IoGetDeviceExtension(Device);
+    ASSERT( NULL != pAtaDev );
+
+    pDevRegisters = &pAtaDev->DeviceRegisters;
+
+    _AtaSelectDevice(pDevRegisters, pAtaDev->Slave);
+
+    busStatus = _AtaReadRegister(pDevRegisters, AtaRegisterBusStatus);
+    if (!IsBooleanFlagOn(busStatus, ATA_BUS_DMA_IRQ))
+    {
+        // means other device is interrupting
+        LOGL("This is not the interrupt we're looking for!");
+        return FALSE;
+    }
+
+    devStatus = _AtaReadRegister(pDevRegisters, AtaRegisterStatus);
+    ASSERT(!IsBooleanFlagOn(devStatus, ATA_SREG_DF));
+
+    if (IsBooleanFlagOn(devStatus, ATA_SREG_ERR))
+    {
+        LOG_ERROR("DMA command failed, error register: 0x%x\n", _AtaReadRegister(pDevRegisters, AtaRegisterError ));
+        NOT_REACHED;
+    }
+
+    // must set Stop bit in command register
+    _AtaWriteRegister(pDevRegisters, AtaRegisterBusCommand, 0 );
+
+    ASSERT( AtaTransferStateInProgress == _InterlockedCompareExchange( &pAtaDev->CurrentTransfer.State, AtaTransferStateFinished, AtaTransferStateInProgress ) );
+
+    ExEventSignal(&pAtaDev->CurrentTransfer.TransferReady);
+
+    // clear IRQ bit
+    // apparently this status register is R/W
+    _AtaWriteRegister(&pAtaDev->DeviceRegisters, AtaRegisterBusStatus, ATA_BUS_DMA_IRQ );
+
+    LOG_FUNC_END;
+
+    // we solved the interrupt
+    return TRUE;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/CommonLib.vcxproj b/src_proiect/CommonLib/CommonLib.vcxproj
new file mode 100644
index 0000000..412fd3b
--- /dev/null
+++ b/src_proiect/CommonLib/CommonLib.vcxproj
@@ -0,0 +1,480 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="DebugNoLocks|x64">
+      <Configuration>DebugNoLocks</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="DebugNonNative|x64">
+      <Configuration>DebugNonNative</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseNoLocks|x64">
+      <Configuration>ReleaseNoLocks</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseNonNative|x64">
+      <Configuration>ReleaseNonNative</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\assert.c" />
+    <ClCompile Include="src\bitmap.c" />
+    <ClCompile Include="src\checkin_queue.c" />
+    <ClCompile Include="src\cl_heap.c" />
+    <ClCompile Include="src\common_lib.c" />
+    <ClCompile Include="src\event.c" />
+    <ClCompile Include="src\gs_checks.c" />
+    <ClCompile Include="src\gs_utils.c" />
+    <ClCompile Include="src\hash_table.c" />
+    <ClCompile Include="src\intutils.c" />
+    <ClCompile Include="src\list.c" />
+    <ClCompile Include="src\lock_common.c" />
+    <ClCompile Include="src\cl_memory.c" />
+    <ClCompile Include="src\monlock.c" />
+    <ClCompile Include="src\rec_rw_spinlock.c" />
+    <ClCompile Include="src\ref_cnt.c" />
+    <ClCompile Include="src\rtc_checks.c" />
+    <ClCompile Include="src\rw_spinlock.c" />
+    <ClCompile Include="src\seh.c" />
+    <ClCompile Include="src\spinlock.c" />
+    <ClCompile Include="src\cl_string.c" />
+    <ClCompile Include="src\stack_dynamic.c" />
+    <ClCompile Include="src\stack_interface.c" />
+    <ClCompile Include="src\strutils.c" />
+    <ClCompile Include="src\time.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\seh.h" />
+    <ClInclude Include="headers\stack_dynamic.h" />
+    <ClInclude Include="headers\stack_internal.h" />
+    <ClInclude Include="inc\assert.h" />
+    <ClInclude Include="inc\base.h" />
+    <ClInclude Include="inc\bitmap.h" />
+    <ClInclude Include="inc\checkin_queue.h" />
+    <ClInclude Include="inc\cl_heap.h" />
+    <ClInclude Include="inc\common_lib.h" />
+    <ClInclude Include="inc\data_type.h" />
+    <ClInclude Include="inc\event.h" />
+    <ClInclude Include="inc\gs_utils.h" />
+    <ClInclude Include="inc\hash_table.h" />
+    <ClInclude Include="inc\intutils.h" />
+    <ClInclude Include="inc\list.h" />
+    <ClInclude Include="inc\lock_common.h" />
+    <ClInclude Include="inc\cl_memory.h" />
+    <ClInclude Include="inc\monlock.h" />
+    <ClInclude Include="inc\native\memory.h" />
+    <ClInclude Include="inc\native\string.h" />
+    <ClInclude Include="inc\rec_rw_spinlock.h" />
+    <ClInclude Include="inc\ref_cnt.h" />
+    <ClInclude Include="inc\rw_spinlock.h" />
+    <ClInclude Include="inc\sal_interface.h" />
+    <ClInclude Include="inc\sal_intrinsic.h" />
+    <ClInclude Include="inc\slist.h" />
+    <ClInclude Include="inc\spinlock.h" />
+    <ClInclude Include="inc\stack_interface.h" />
+    <ClInclude Include="inc\status.h" />
+    <ClInclude Include="inc\cl_string.h" />
+    <ClInclude Include="inc\strutils.h" />
+    <ClInclude Include="inc\time.h" />
+    <ClInclude Include="inc\va_list.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_gs_checks.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{CA44C37A-1730-447F-8975-3DF40D559310}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>CommonLib</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;DEBUG;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <OpenMPSupport>false</OpenMPSupport>
+      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
+      <EnablePREfast>true</EnablePREfast>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OmitFramePointers>true</OmitFramePointers>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <SDLCheck>true</SDLCheck>
+      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies />
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+    <YASM>
+      <Debug>true</Debug>
+      <Defines>DEBUG</Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <OpenMPSupport>false</OpenMPSupport>
+      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
+      <EnablePREfast>true</EnablePREfast>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <SDLCheck>true</SDLCheck>
+      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>
+      </WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>
+      </AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+    <YASM>
+      <Debug>true</Debug>
+      <Defines>
+      </Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNonNative|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;CL_NO_RUNTIME_CHECKS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <OpenMPSupport>false</OpenMPSupport>
+      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
+      <EnablePREfast>true</EnablePREfast>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <SDLCheck>true</SDLCheck>
+      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>
+      </WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>
+      </AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+    <YASM>
+      <Debug>true</Debug>
+      <Defines>CL_NO_RUNTIME_CHECKS</Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugNonNative|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;CL_NO_RUNTIME_CHECKS;DEBUG;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <OpenMPSupport>false</OpenMPSupport>
+      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
+      <EnablePREfast>true</EnablePREfast>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OmitFramePointers>true</OmitFramePointers>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <SDLCheck>true</SDLCheck>
+      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>
+      </AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+    <YASM>
+      <Debug>true</Debug>
+      <Defines>DEBUG;CL_NO_RUNTIME_CHECKS</Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugNoLocks|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;DEBUG;_DEBUG;_CONSOLE;_COMMONLIB_NO_LOCKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <OpenMPSupport>false</OpenMPSupport>
+      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
+      <EnablePREfast>true</EnablePREfast>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OmitFramePointers>true</OmitFramePointers>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>
+      </AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseNoLocks|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>COMMONLIB_LIB_IMPL;NDEBUG;_CONSOLE;_COMMONLIB_NO_LOCKS_;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>false</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <OpenMPSupport>false</OpenMPSupport>
+      <AdditionalIncludeDirectories>headers;inc</AdditionalIncludeDirectories>
+      <EnablePREfast>true</EnablePREfast>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization />
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>
+      </AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(ProjectDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.targets" />
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/CommonLib/CommonLib.vcxproj.filters b/src_proiect/CommonLib/CommonLib.vcxproj.filters
new file mode 100644
index 0000000..5398e82
--- /dev/null
+++ b/src_proiect/CommonLib/CommonLib.vcxproj.filters
@@ -0,0 +1,215 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{3749b899-0186-4930-a4bd-a8b4c6b455b6}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\runtime checks">
+      <UniqueIdentifier>{64d245fd-6432-4c5d-9ed6-f474e8239554}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\headers">
+      <UniqueIdentifier>{73a46d7e-cc9a-4a6c-9103-02468143fbc0}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\headers\runtime checks">
+      <UniqueIdentifier>{a14b0037-6d17-433d-bef5-efde9061f28f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\inc\native">
+      <UniqueIdentifier>{16fd42b3-a65e-40e4-893a-6d88facc2eb1}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\ref_cnt.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\strutils.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\list.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\common_lib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\assert.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\spinlock.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\monlock.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\event.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\lock_common.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\bitmap.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\rw_spinlock.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\rec_rw_spinlock.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\time.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\intutils.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\hash_table.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cl_string.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cl_memory.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\gs_checks.c">
+      <Filter>Source Files\runtime checks</Filter>
+    </ClCompile>
+    <ClCompile Include="src\gs_utils.c">
+      <Filter>Source Files\runtime checks</Filter>
+    </ClCompile>
+    <ClCompile Include="src\rtc_checks.c">
+      <Filter>Source Files\runtime checks</Filter>
+    </ClCompile>
+    <ClCompile Include="src\seh.c">
+      <Filter>Source Files\runtime checks</Filter>
+    </ClCompile>
+    <ClCompile Include="src\stack_dynamic.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\stack_interface.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cl_heap.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\checkin_queue.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\va_list.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\assert.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\base.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\common_lib.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\list.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\ref_cnt.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\sal_interface.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\status.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\strutils.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\spinlock.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\monlock.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\lock_common.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\event.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\bitmap.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\rw_spinlock.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\rec_rw_spinlock.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\data_type.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\intutils.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\sal_intrinsic.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\time.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\seh.h">
+      <Filter>Header Files\headers\runtime checks</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\gs_utils.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\hash_table.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\native\memory.h">
+      <Filter>Header Files\inc\native</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\native\string.h">
+      <Filter>Header Files\inc\native</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cl_string.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cl_memory.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\slist.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\stack_dynamic.h">
+      <Filter>Header Files\headers</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\stack_internal.h">
+      <Filter>Header Files\headers</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\stack_interface.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cl_heap.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\checkin_queue.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_gs_checks.yasm">
+      <Filter>Source Files\runtime checks</Filter>
+    </YASM>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/CommonLib/headers/seh.h b/src_proiect/CommonLib/headers/seh.h
new file mode 100644
index 0000000..c6b509a
--- /dev/null
+++ b/src_proiect/CommonLib/headers/seh.h
@@ -0,0 +1,190 @@
+#pragma once
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+typedef unsigned __int64    ULONGLONG, DWORD64;
+typedef __int64             LONGLONG;
+typedef unsigned __int32    ULONG32;
+
+typedef enum _EXCEPTION_DISPOSITION
+{
+    ExceptionContinueExecution,
+    ExceptionContinueSearch,
+    ExceptionNestedException,
+    ExceptionCollidedUnwind
+} EXCEPTION_DISPOSITION;
+
+typedef struct _EXCEPTION_RECORD         // 7 elements, 0x98 bytes (sizeof)
+{
+    /*0x000*/     INT32       ExceptionCode;
+    /*0x004*/     DWORD      ExceptionFlags;
+    /*0x008*/     QWORD       ExceptionRecord;
+    /*0x010*/     QWORD       ExceptionAddress;
+    /*0x018*/     DWORD      NumberParameters;
+    /*0x01C*/     DWORD      __unusedAlignment;
+    /*0x020*/     QWORD       ExceptionInformation[15];
+}EXCEPTION_RECORD, *PEXCEPTION_RECORD;
+
+typedef struct __declspec(align(16)) _M128A
+{
+    ULONGLONG Low;
+    LONGLONG High;
+} M128A, *PM128A;
+
+typedef struct __declspec(align(16)) _XSAVE_FORMAT
+{
+    WORD   ControlWord;
+    WORD   StatusWord;
+    BYTE  TagWord;
+    BYTE  Reserved1;
+    WORD   ErrorOpcode;
+    DWORD ErrorOffset;
+    WORD   ErrorSelector;
+    WORD   Reserved2;
+    DWORD DataOffset;
+    WORD   DataSelector;
+    WORD   Reserved3;
+    DWORD MxCsr;
+    DWORD MxCsr_Mask;
+    M128A FloatRegisters[8];
+    M128A XmmRegisters[16];
+    BYTE  Reserved4[96];
+} XSAVE_FORMAT, *PXSAVE_FORMAT;
+
+
+
+
+
+typedef struct _CONTEXT                    // 64 elements, 0x4D0 bytes (sizeof)
+{
+    /*0x000*/     UINT64       P1Home;
+    /*0x008*/     UINT64       P2Home;
+    /*0x010*/     UINT64       P3Home;
+    /*0x018*/     UINT64       P4Home;
+    /*0x020*/     UINT64       P5Home;
+    /*0x028*/     UINT64       P6Home;
+    /*0x030*/     ULONG32      ContextFlags;
+    /*0x034*/     ULONG32      MxCsr;
+    /*0x038*/     UINT16       SegCs;
+    /*0x03A*/     UINT16       SegDs;
+    /*0x03C*/     UINT16       SegEs;
+    /*0x03E*/     UINT16       SegFs;
+    /*0x040*/     UINT16       SegGs;
+    /*0x042*/     UINT16       SegSs;
+    /*0x044*/     ULONG32      EFlags;
+    /*0x048*/     UINT64       Dr0;
+    /*0x050*/     UINT64       Dr1;
+    /*0x058*/     UINT64       Dr2;
+    /*0x060*/     UINT64       Dr3;
+    /*0x068*/     UINT64       Dr6;
+    /*0x070*/     UINT64       Dr7;
+    /*0x078*/     UINT64       Rax;
+    /*0x080*/     UINT64       Rcx;
+    /*0x088*/     UINT64       Rdx;
+    /*0x090*/     UINT64       Rbx;
+    /*0x098*/     UINT64       Rsp;
+    /*0x0A0*/     UINT64       Rbp;
+    /*0x0A8*/     UINT64       Rsi;
+    /*0x0B0*/     UINT64       Rdi;
+    /*0x0B8*/     UINT64       R8;
+    /*0x0C0*/     UINT64       R9;
+    /*0x0C8*/     UINT64       R10;
+    /*0x0D0*/     UINT64       R11;
+    /*0x0D8*/     UINT64       R12;
+    /*0x0E0*/     UINT64       R13;
+    /*0x0E8*/     UINT64       R14;
+    /*0x0F0*/     UINT64       R15;
+    /*0x0F8*/     UINT64       Rip;
+    union                                  // 2 elements, 0x200 bytes (sizeof)
+    {
+        /*0x100*/         struct _XSAVE_FORMAT FltSave;      // 16 elements, 0x200 bytes (sizeof)
+        struct                             // 18 elements, 0x200 bytes (sizeof)
+        {
+            /*0x100*/             struct _M128A Header[2];
+            /*0x120*/             struct _M128A Legacy[8];
+            /*0x1A0*/             struct _M128A Xmm0;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x1B0*/             struct _M128A Xmm1;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x1C0*/             struct _M128A Xmm2;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x1D0*/             struct _M128A Xmm3;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x1E0*/             struct _M128A Xmm4;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x1F0*/             struct _M128A Xmm5;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x200*/             struct _M128A Xmm6;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x210*/             struct _M128A Xmm7;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x220*/             struct _M128A Xmm8;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x230*/             struct _M128A Xmm9;            // 2 elements, 0x10 bytes (sizeof)
+            /*0x240*/             struct _M128A Xmm10;           // 2 elements, 0x10 bytes (sizeof)
+            /*0x250*/             struct _M128A Xmm11;           // 2 elements, 0x10 bytes (sizeof)
+            /*0x260*/             struct _M128A Xmm12;           // 2 elements, 0x10 bytes (sizeof)
+            /*0x270*/             struct _M128A Xmm13;           // 2 elements, 0x10 bytes (sizeof)
+            /*0x280*/             struct _M128A Xmm14;           // 2 elements, 0x10 bytes (sizeof)
+            /*0x290*/             struct _M128A Xmm15;           // 2 elements, 0x10 bytes (sizeof)
+            /*0x2A0*/             UINT8        _PADDING0_[0x60];
+        };
+    };
+    /*0x300*/     struct _M128A VectorRegister[26];
+    /*0x4A0*/     UINT64       VectorControl;
+    /*0x4A8*/     UINT64       DebugControl;
+    /*0x4B0*/     UINT64       LastBranchToRip;
+    /*0x4B8*/     UINT64       LastBranchFromRip;
+    /*0x4C0*/     UINT64       LastExceptionToRip;
+    /*0x4C8*/     UINT64       LastExceptionFromRip;
+}CONTEXT, *PCONTEXT;
+
+typedef
+EXCEPTION_DISPOSITION
+EXCEPTION_ROUTINE(
+    _Inout_ struct _EXCEPTION_RECORD *ExceptionRecord,
+    _In_ PVOID EstablisherFrame,
+    _Inout_ struct _CONTEXT *ContextRecord,
+    _In_ PVOID DispatcherContext
+);
+
+typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;
+
+typedef struct _RUNTIME_FUNCTION
+{
+    // RVAs
+    DWORD BeginAddress;
+    DWORD EndAddress;
+    DWORD UnwindInfoAddress;
+} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
+
+typedef struct _UNWIND_HISTORY_TABLE_ENTRY
+{
+    DWORD64 ImageBase;
+    PRUNTIME_FUNCTION FunctionEntry;
+} UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;
+
+#define UNWIND_HISTORY_TABLE_SIZE 12
+
+typedef struct _UNWIND_HISTORY_TABLE
+{
+    DWORD Count;
+    BYTE  LocalHint;
+    BYTE  GlobalHint;
+    BYTE  Search;
+    BYTE  Once;
+    DWORD64 LowAddress;
+    DWORD64 HighAddress;
+    UNWIND_HISTORY_TABLE_ENTRY Entry[UNWIND_HISTORY_TABLE_SIZE];
+} UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;
+
+typedef struct _DISPATCHER_CONTEXT
+{
+    DWORD64 ControlPc;
+    DWORD64 ImageBase;
+    PRUNTIME_FUNCTION FunctionEntry;
+    DWORD64 EstablisherFrame;
+    DWORD64 TargetIp;
+    PCONTEXT ContextRecord;
+    PEXCEPTION_ROUTINE LanguageHandler;
+    PVOID HandlerData;
+    PUNWIND_HISTORY_TABLE HistoryTable;
+    DWORD ScopeIndex;
+    DWORD Fill0;
+} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;
+
+#pragma warning(pop)
diff --git a/src_proiect/CommonLib/headers/stack_dynamic.h b/src_proiect/CommonLib/headers/stack_dynamic.h
new file mode 100644
index 0000000..6a457fa
--- /dev/null
+++ b/src_proiect/CommonLib/headers/stack_dynamic.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "stack_interface.h"
+#include "stack_internal.h"
+
+// public
+FUNC_StackPush              StackDynamicPush;
+FUNC_StackPop               StackDynamicPop;
+FUNC_StackPeek              StackDynamicPeek;
+FUNC_StackClear             StackDynamicClear;
+FUNC_StackIsEmpty           StackDynamicIsEmpty;
+FUNC_StackSize              StackDynamicSize;
+
+// private
+FUNC_StackGetRequiredSize   StackDynamicGetRequiredSize;
+FUNC_StackInit              StackDynamicInit;
diff --git a/src_proiect/CommonLib/headers/stack_internal.h b/src_proiect/CommonLib/headers/stack_internal.h
new file mode 100644
index 0000000..fc26e78
--- /dev/null
+++ b/src_proiect/CommonLib/headers/stack_internal.h
@@ -0,0 +1,28 @@
+#pragma once
+
+C_HEADER_START
+typedef struct _STACK* PSTACK;
+
+typedef
+DWORD
+FUNC_StackGetRequiredSize(
+    IN      DWORD                   MaxElements
+    );
+
+typedef FUNC_StackGetRequiredSize* PFUNC_StackGetRequiredSize;
+
+typedef
+STATUS
+FUNC_StackInit(
+    OUT     PSTACK                  Stack
+    );
+
+typedef FUNC_StackInit*             PFUNC_StackInit;
+
+typedef struct _STACK_PRIVATE_INTERFACE_FUNCS
+{
+    PFUNC_StackGetRequiredSize      StackGetRequiredSize;
+
+    PFUNC_StackInit                 StackInit;
+} STACK_PRIVATE_INTERFACE_FUNCS, *PSTACK_PRIVATE_INTERFACE_FUNCS;
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/assert.h b/src_proiect/CommonLib/inc/assert.h
new file mode 100644
index 0000000..68e2d28
--- /dev/null
+++ b/src_proiect/CommonLib/inc/assert.h
@@ -0,0 +1,63 @@
+#pragma once
+
+C_HEADER_START
+
+#include "native/string.h"
+
+//******************************************************************************
+// Function:     FUNC_AssertFunction
+// Description:  Function which is responsible for handling a system assertion
+//               failure.
+// Returns:      void
+// Parameter:    IN_Z            char*           Message
+//******************************************************************************
+typedef
+void
+(__cdecl FUNC_AssertFunction)(
+    IN_Z            char*           Message
+    );
+
+typedef FUNC_AssertFunction*        PFUNC_AssertFunction;
+
+/// These ASSERT* functions cannot be used before
+/// AssertSetFunction is called
+
+// The ASSERT macros validate a specified condition, in case the
+// condition does not hold the registered FUNC_AssertFunction is called
+#ifndef ASSERT
+#define ASSERT(Cond)                ASSERT_INFO((Cond),"")
+#endif // ASSERT
+
+#define ASSERT_INFO(Cond,Msg,...)   if((Cond)){} else                                                                                                    \
+                                    {                                                                                                                    \
+                                        AssertInfo( "[ASSERT][%s][%d]Condition: (" ## #Cond ## ") failed\n" ##Msg, cl_strrchr(__FILE__, '\\') + 1, __LINE__, __VA_ARGS__ );      \
+                                    }
+
+#define NOT_REACHED                 __pragma(warning(suppress: 4127)) ASSERT(FALSE)
+
+void
+AssertInfo(
+    IN_Z            char*       Message,
+    ...
+    );
+
+void
+AssertSetFunction(
+    IN              PFUNC_AssertFunction    AssertFunction
+    );
+
+#ifndef _COMMONLIB_NO_LOCKS_
+REQUIRES_EXCL_LOCK(m_assertLock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_assertLock)
+
+#ifndef COMMONLIB_LIB_IMPL
+// Warning C28285 For function 'AssertFreeLock' 'return' syntax error
+// This is suppressed only for external projects because they have no idea who m_assertLock is
+#pragma warning(suppress: 28285)
+#endif
+void
+AssertFreeLock(
+    void
+    );
+#endif // _COMMONLIB_NO_LOCKS_
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/base.h b/src_proiect/CommonLib/inc/base.h
new file mode 100644
index 0000000..868f9d7
--- /dev/null
+++ b/src_proiect/CommonLib/inc/base.h
@@ -0,0 +1,126 @@
+#pragma once
+
+C_HEADER_START
+#include "data_type.h"
+
+#ifndef UNREFERENCED_PARAMETER
+#define UNREFERENCED_PARAMETER(x)   (x);
+#endif // UNREFERENCED_PARAMETER
+
+#ifndef NOTHING
+#define NOTHING                     ;
+#endif // NOTHING
+
+#define MAX_PATH                    260
+
+#define KB_SIZE                     1024ULL
+#define MB_SIZE                     (1024*KB_SIZE)
+#define GB_SIZE                     (1024*MB_SIZE)
+#define TB_SIZE                     (1024*GB_SIZE)
+
+#define PAGE_SIZE                   0x1000
+
+#ifndef PAGE_SHIFT
+#define PAGE_SHIFT                  12
+#endif // PAGE_SHIFT
+
+#define SHADOW_STACK_SIZE                   0x20
+
+#define BITS_PER_BYTE                       8
+#define BITS_FOR_STRUCTURE(x)               (BITS_PER_BYTE*sizeof(x))
+#define CREATE_BIT_MASK_FOR_N_BITS(n)       (((n) >= 64) ? MAX_QWORD : (((1ULL << (n)) - 1)))
+
+// The difference between these 2 is the following one:
+// IsFlagOn succeeds if at LEAST a flag is set
+// IsBooleanFlagOn succeeds if ALL flags are set
+#define IsFlagOn(x,f)                       (0!=((x)&(f)))
+#define IsBooleanFlagOn(x,f)                ((f)==((x)&(f)))
+
+#define BooleanToInteger(x)                 (!!(x))
+
+// Checks if a bit is set
+#define IsBitSet(x,b)                       ((1<<(b))==((x)&(1<<(b))))
+
+// Sets a bit
+#define SetBit(x,b)                         ((x)|=((x)|(1<<(b))))
+
+// Calculates the difference between 2 pointers
+#define PtrDiff(x,y)                        (((PBYTE)(x))-((PBYTE)(y)))
+#define PtrOffset(x,y)                      (((PBYTE)(x))+((QWORD)(y)))
+
+// E.g: AlignAddressLower(0x1001,0x1000)   = 0x1000
+//      AlignAddressUpper(0x1001,0x1000)   = 0x2000
+#define AlignAddressLower(addr,alig)        ((QWORD)(addr)&~((QWORD)(alig)-1))
+#define AlignAddressUpper(addr,alig)        AlignAddressLower(((QWORD)(addr)+(alig)-1), (alig))
+#define IsAddressAligned(addr,alig)         (0==(((QWORD)(addr))&(((QWORD)(alig))-1)))
+
+#define AddressOffset(addr,alig)            ((QWORD)(addr)&((alig)-1))
+
+// check if a boundary is crossed
+// i.e. addr and addr + size are in different memory regions (alignments)
+#define IsInSameBoundary(addr,size,alig)    (AlignAddressLower((addr),(alig)) == \
+                                             AlignAddressLower((QWORD)(addr)+(size)-1,(alig)))
+
+// Natural alignment <- 2 * sizeof(PVOID)
+// Because we only have x64 configuration => always 0x10
+#define NATURAL_ALIGNMENT                   0x10
+
+// These asserts can be very useful when working with hardware defined
+// registers/structures to validate if the size of the defined C structure
+// matches the hardware specification.
+#define STATIC_ASSERT(Cond)                 STATIC_ASSERT_INFO(Cond,"")
+#define STATIC_ASSERT_INFO(Cond,Msg)        static_assert(Cond,Msg)
+
+// The stack must be aligned at 0x10 bytes - this must be done before
+// the return address is pushed on the stack => the RA is aligned at 0x8 bytes
+//
+// push arg3
+// push arg2
+// push arg1
+// push arg0
+// call func  <-  rsp is 0x10 aligned
+
+// func:
+// mov  edi, edi  <- rsp is 0x8 aligned
+#define IS_STACK_ALIGNED                    IsAddressAligned((PBYTE)_AddressOfReturnAddress()+sizeof(PVOID),NATURAL_ALIGNMENT)
+#define CHECK_STACK_ALIGNMENT               ASSERT_INFO(IS_STACK_ALIGNED, "RSP at 0x%X\n", _AddressOfReturnAddress())
+#define GET_RETURN_ADDRESS                  *((PVOID*)_AddressOfReturnAddress())
+
+#ifndef CONTAINING_RECORD
+#define CONTAINING_RECORD(address, type, field) ((type *)( \
+                                                  (BYTE*)(address) - \
+                                                  (QWORD)(&((type *)0)->field)))
+#endif // CONTAINING_RECORD
+
+#ifndef ARRAYSIZE
+#define ARRAYSIZE(A)                            (sizeof(A)/sizeof((A)[0]))
+#endif // ARRAYSIZE
+
+#ifndef FIELD_OFFSET
+#define FIELD_OFFSET(type, field)               ((QWORD)&(((type *)0)->field))
+#endif // FIELD_OFFSET
+
+#define SECTOR_SIZE                             512
+
+// because endianess this gets 0x55, 0xAA on disk :)
+#define MBR_BOOT_SIGNATURE                      0xAA55
+
+typedef BOOLEAN         INTR_STATE;
+
+#define INTR_OFF        0
+#define INTR_ON         1
+
+// time related defines
+#define SEC_IN_US       (1000*MS_IN_US)
+#define MS_IN_US        1000
+
+#define SEC_IN_NS       (1000*MS_IN_NS)
+#define MS_IN_NS        (1000*US_IN_NS)
+#define US_IN_NS        1000
+
+// Checks if p      in [b, b + s]
+//    and if p + ps in [b, b + s]
+// Because ps and s are positive the actual check done is only for
+// p >= b and p + ps <= b + s
+#define CHECK_BOUNDS(p,ps,b,s)      ((((QWORD)(b) <= (QWORD)(p)) )&& (((QWORD)(p) + (QWORD)(ps) ) <= ((QWORD)(b)+(QWORD)(s))))
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/bitmap.h b/src_proiect/CommonLib/inc/bitmap.h
new file mode 100644
index 0000000..60472df
--- /dev/null
+++ b/src_proiect/CommonLib/inc/bitmap.h
@@ -0,0 +1,130 @@
+#pragma once
+
+C_HEADER_START
+
+#pragma pack(push,16)
+typedef struct _BITMAP
+{
+    // contains the actual bitmap
+    PBYTE                   BitmapBuffer;
+
+    DWORD                   BufferSize;
+    DWORD                   BitCount;
+} BITMAP, *PBITMAP;
+#pragma pack(pop)
+
+//******************************************************************************
+// Function:     BitmapPreinit
+// Description:  
+// Returns:      DWORD - Number of bytes required for the BitmapBuffer
+// Parameter:    OUT PBITMAP Bitmap
+// Parameter:    IN DWORD NumberOfElements
+//******************************************************************************
+DWORD
+BitmapPreinit(
+    OUT         PBITMAP     Bitmap,
+    IN          DWORD       NumberOfElements
+    );
+
+#define BitmapInit(...)     BitmapInitEx(__VA_ARGS__,FALSE)
+
+void
+BitmapInitEx(
+    INOUT       PBITMAP     Bitmap,
+    IN          PBYTE       BitmapBuffer,
+    IN          BOOLEAN     Set
+    );
+
+void
+BitmapUninit(
+    INOUT       PBITMAP     Bitmap
+    );
+
+// Returns the size in elements of the bitmap
+DWORD
+BitmapGetMaxElementCount(
+    IN          PBITMAP     Bitmap
+    );
+
+#define BitmapSetBit(...)       BitmapSetBitValue(__VA_ARGS__,TRUE)
+#define BitmapClearBit(...)     BitmapSetBitValue(__VA_ARGS__,FALSE)
+
+void
+BitmapSetBitValue(
+    INOUT		PBITMAP		Bitmap,
+    IN			DWORD       Index,
+    IN          BOOLEAN     Set
+    );
+
+BOOLEAN
+BitmapGetBitValue(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       Index
+    );
+
+#define BitmapSetBits(...)      BitmapSetBitsValue(__VA_ARGS__,TRUE)
+#define BitmapClearBits(...)    BitmapSetBitsValue(__VA_ARGS__,FALSE)
+
+void
+BitmapSetBitsValue(
+    INOUT		PBITMAP		Bitmap,
+    IN			DWORD       Index,
+    IN          DWORD       Count,
+    IN          BOOLEAN     Set
+    );
+
+SIZE_SUCCESS
+DWORD
+BitmapScan(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    );
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFrom(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    );
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFromTo(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       FirstInvalidBitIndex,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+);
+
+SIZE_SUCCESS
+DWORD
+BitmapScanAndFlip(
+    INOUT       PBITMAP     Bitmap,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    );
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFromAndFlip(
+    INOUT       PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    );
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFromToAndFlip(
+    INOUT       PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       FirstInvalidBitIndex,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+);
+
+C_HEADER_END
\ No newline at end of file
diff --git a/src_proiect/CommonLib/inc/checkin_queue.h b/src_proiect/CommonLib/inc/checkin_queue.h
new file mode 100644
index 0000000..a4dc1b7
--- /dev/null
+++ b/src_proiect/CommonLib/inc/checkin_queue.h
@@ -0,0 +1,90 @@
+#pragma once
+
+C_HEADER_START
+typedef struct _CHECKIN_QUEUE
+{
+    volatile BOOLEAN*       Array;
+
+    DWORD                   NumberOfThreads;
+
+    DWORD                   BufferSize;
+} CHECKIN_QUEUE, * PCHECKIN_QUEUE;
+
+//******************************************************************************
+// Function:     CheckinQueueInit
+// Description:  Pre-Initializes a checkin_queue. No other CheckinQueue* function
+//               can be used before this function is called. The function returns
+//               the needed Buffer size for the internal queue.
+// Returns:      DWORD - The size(in bytes) of the buffer needed for the internal
+//               queue.
+// Parameter:    OUT       PCHECKIN_QUEUE      Queue
+// Parameter:    IN        DWORD               NumberOfThreads
+//******************************************************************************
+DWORD
+CheckinQueuePreInit(
+    OUT       PCHECKIN_QUEUE      Queue,
+    IN        DWORD               NumberOfThreads
+);
+
+//******************************************************************************
+// Function:     CheckinQueueInit
+// Description:  Initializes a checkin_queue.  The checking_queue must be pre-
+//               initialized before by calling CheckinQueuePreInit.
+//               An already allocated array with exactly BufferSize bytes,
+//               returned by the CheckinQueuePreInit function, has to be passed
+//               to this function.
+// Returns:      void
+// Parameter:    INOUT       PCHECKIN_QUEUE      Queue
+// Parameter:    IN          PBYTE               QueueBuffer
+//******************************************************************************
+void
+CheckinQueueInit(
+    INOUT     PCHECKIN_QUEUE      Queue,
+    IN        PBYTE               QueueBuffer
+);
+
+//******************************************************************************
+// Function:     CheckinQueueUninit
+// Description:  Un-initializes the CheckinQueue structure, the memory allocated
+//               for the queue must be de-allocated outside of this function
+//               as from here the reference to the allocated memory zone is lost.
+// Returns:      void
+// Parameter:    INOUT       PCHECKIN_QUEUE      Queue
+//******************************************************************************
+void
+CheckinQueueUninit(
+    INOUT     PCHECKIN_QUEUE      Queue
+);
+
+//******************************************************************************
+// Function:     CheckinQueueMarkPresence
+// Description:  Waits a very little until it can mark a single presence in the
+//               queue. The marking is done atomically.
+// Returns:      void
+// Parameter:    INOUT       PCHECKIN_QUEUE       Queue
+//******************************************************************************
+void
+CheckinQueueMarkPresence(
+    INOUT       PCHECKIN_QUEUE       Queue
+);
+
+//******************************************************************************
+// Function:     CheckinQueueWaitOn
+// Description:  Spins until all threads or CPUs marked there presence inside
+//               the queue or if WaitAll is false, it waits for
+//               NumberOfCheckinsToWait presences. If this number is higher than
+//               the length of the queue, it will wait until the full queue is
+//               marked as present.
+// Returns:      void
+// Parameter:    IN          PCHECKIN_QUEUE      Queue
+// Parameter:    IN          BOOLEAN             WaitAll
+// Parameter:    IN_OPT      DWORD               NumberOfCheckinsToWait
+//******************************************************************************
+void
+CheckinQueueWaitOn(
+    IN          PCHECKIN_QUEUE      Queue,
+    IN          BOOLEAN             WaitAll,
+    IN_OPT      DWORD               NumberOfCheckinsToWait
+);
+
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/cl_heap.h b/src_proiect/CommonLib/inc/cl_heap.h
new file mode 100644
index 0000000..ce490ae
--- /dev/null
+++ b/src_proiect/CommonLib/inc/cl_heap.h
@@ -0,0 +1,79 @@
+#pragma once
+
+C_HEADER_START
+#include "list.h"
+
+// memory alignment in case none is specified by the caller
+#define HEAP_DEFAULT_ALIGNMENT          16
+
+#define PoolAllocateZeroMemory          0x2 // memory allocated will be zeroed
+#define PoolAllocatePanicIfFail         0x4 // system will PANIC in case the allocation will fail
+
+typedef struct _HEAP_HEADER
+{
+    DWORD               Magic;              // used for error checking
+    QWORD               HeapSizeMaximum;    // the maximum size of the HEAP
+    QWORD               HeapSizeRemaining;  // the size remaining to allocated
+    QWORD               BaseAddress;        // heap structure base address
+    QWORD               FreeAddress;        // address from which to start search
+    QWORD               HeapNumberOfAllocations;
+
+    PLIST_ENTRY         EntryToRestartSearch;
+
+    // list of heap allocations
+    // this list is always ordered by address
+    LIST_ENTRY          HeapAllocations;
+} HEAP_HEADER, *PHEAP_HEADER;
+
+//******************************************************************************
+// Function:    HeapInit
+// Description: Initializes the heap system. Needs to be called before any
+//              allocations are made.
+// Returns:     STATUS
+// Parameter:   IN PVOID BaseAddress     - address from which allocations will
+//                                         start
+// Parameter:   IN QWORD MemoryAvailable - bytes available for the heap
+//******************************************************************************
+STATUS
+ClHeapInit(
+    _Notnull_                           PVOID                   BaseAddress,
+    IN                                  QWORD                   MemoryAvailable,
+    OUT_PTR                             PHEAP_HEADER*           HeapHeader
+    );
+
+//******************************************************************************
+// Function:    HeapAllocatePoolWithTag
+// Description: Allocates a number of bytes with a specified tag and returns
+//              the address.
+// Returns:     PVOID - The newly allocated memory region
+// Parameter:   IN DWORD Flags
+// Parameter:   IN DWORD AllocationSize - Number of bytes to allocate
+// Parameter:   IN DWORD Tag
+// Parameter:   IN DWORD AllocationAlignment
+//******************************************************************************
+_Always_(_When_(IsBooleanFlagOn(Flags,PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+ClHeapAllocatePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    );
+
+//******************************************************************************
+// Function:    HeapFreePoolWithTag
+// Description: Frees a previously allocated memory region.
+// Returns:     void
+// Parameter:   IN PVOID MemoryAddress
+// Parameter:   IN DWORD Tag - MUST match tag used for allocation
+//******************************************************************************
+void
+ClHeapFreePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/cl_memory.h b/src_proiect/CommonLib/inc/cl_memory.h
new file mode 100644
index 0000000..9e548f6
--- /dev/null
+++ b/src_proiect/CommonLib/inc/cl_memory.h
@@ -0,0 +1,100 @@
+#pragma once
+
+C_HEADER_START
+//******************************************************************************
+// Function:        memset
+// Description:     Sets bytes in a memory area to a value.
+// Returns:         void
+// Parameter:       OUT PVOID address    - Address at which to set memory
+// Parameter:       IN  BYTE value       - Value which to set
+// Parameter:       IN  DWORD size       - Number of bytes to set
+//******************************************************************************
+_At_buffer_( address, i, size, _Post_satisfies_( ((PBYTE)address)[i] == value ))
+void
+cl_memset(
+    OUT_WRITES_BYTES_ALL(size)  PVOID address,
+    IN                          BYTE value,
+    IN                          DWORD size
+    );
+
+#define cl_memzero(addr,size)      cl_memset((addr),0,(size))
+
+//******************************************************************************
+// Function:     memcpy
+// Description:  This function does not guarantee proper handling of overlapped
+//               memory regions. Use memmove in those cases.
+// Returns:      void
+// Parameter:    OUT PVOID Destination
+// Parameter:    IN PVOID Source
+// Parameter:    IN QWORD Count
+//******************************************************************************
+_At_buffer_(Destination,i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+cl_memcpy(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             void*   Source,
+    IN                          QWORD   Count
+    );
+
+//******************************************************************************
+// Function:     memmove
+// Description:  Executes slower than memcpy but it can be used for overlapped
+//               memory regions.
+// Returns:      void
+// Parameter:    OUT PVOID Destination
+// Parameter:    IN PVOID Source
+// Parameter:    IN QWORD Count
+//******************************************************************************
+_At_buffer_(Destination, i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+cl_memmove(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             void*   Source,
+    IN                          QWORD   Count
+    );
+
+
+//******************************************************************************
+// Function:        memcmp
+// Description:     Compares two memory regions.
+// Returns:         int - 0 if equal, not 0 if different
+// Parameter:       IN PVOID ptr1 - pointer to first memory region
+// Parameter:       IN PVOID ptr2 - pointer to second memory region
+// Parameter:       IN DWORD size - size of region to compare
+//******************************************************************************
+int
+cl_memcmp(
+    IN_READS_BYTES(size)    void* ptr1,
+    IN_READS_BYTES(size)    void* ptr2,
+    IN                      DWORD size
+    );
+
+// Similar to memcmp, however does the comparison in reverse order
+int
+cl_rmemcmp(
+    IN_READS_BYTES(size)    void* ptr1,
+    IN_READS_BYTES(size)    void* ptr2,
+    IN                      DWORD size
+    );
+
+
+//******************************************************************************
+// Function:     memscan
+// Description:  Scans a memory region in search for a different value than the
+//               one received as input.
+// Returns:      int - Index of first byte found different from value. If the
+//               whole buffer contains only value then the return value will be
+//               the size of the buffer.
+// Parameter:    PVOID buffer
+// Parameter:    IN DWORD size
+// Parameter:    IN BYTE value
+//******************************************************************************
+int
+cl_memscan(
+    IN_READS_BYTES(size)    void* buffer,
+    IN                      DWORD size,
+    IN                      BYTE  value
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/cl_string.h b/src_proiect/CommonLib/inc/cl_string.h
new file mode 100644
index 0000000..2e6731e
--- /dev/null
+++ b/src_proiect/CommonLib/inc/cl_string.h
@@ -0,0 +1,159 @@
+#pragma once
+
+C_HEADER_START
+#define INVALID_STRING_SIZE             MAX_DWORD
+
+//******************************************************************************
+// Function:     strcmp
+// Description:  Compares two strings.
+// Returns:      int  0 => strings equal
+//                   +1 => str1 > str2
+//                   -1 => str2 > str1
+// Parameter:    IN_Z char * str1
+// Parameter:    IN_Z char * str2
+//******************************************************************************
+int
+cl_strcmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    );
+
+//******************************************************************************
+// Function:     stricmp
+// Description:  Same as strcmp except its case insensitive.
+// Returns:      int
+// Parameter:    IN_Z char * str1
+// Parameter:    IN_Z char * str2
+//******************************************************************************
+int
+cl_stricmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    );
+
+int
+cl_strncmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    );
+
+int
+cl_strnicmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    );
+
+//******************************************************************************
+// Function:     strchr
+// Description:  Searches a string for the first occurrence of a character.
+// Returns:      const char* - pointer to the first occurence of the character.
+//               If the character is not found the result will point to str.
+// Parameter:    IN_Z char * str
+// Parameter:    IN char c
+//******************************************************************************
+const
+char*
+cl_strchr(
+    IN_Z  char* str,
+    IN  char c
+    );
+
+//******************************************************************************
+// Function:     strrchr
+// Description:  Searches a string for the last occurrence of a character.
+// Returns:      const char* - pointer to the last occurence of the character.
+//               If the character is not found the result will point to str.
+// Parameter:    IN_Z char * str
+// Parameter:    IN char c
+//******************************************************************************
+const
+char*
+cl_strrchr(
+    IN_Z  char* str,
+    IN  char c
+    );
+
+void
+cl_strcpy(
+    OUT_Z char* dst,
+    IN_Z  char* src
+    );
+
+//******************************************************************************
+// Function:     strncpy
+// Description:  Copies the first length characters from src to dst. If the src
+//               string terminates faster the copying will stop. No matter what
+//               the termination reason dst[i+1] will be set to '\0', where i
+//               represents the number of characters copied.
+// Returns:      void
+// Parameter:    char* dst - the size of the dst buffer must be with at laast
+//               1 BYTE greater than length
+// Parameter:    char* src
+// Parameter:    IN DWORD length
+//******************************************************************************
+void
+cl_strncpy(
+    OUT_WRITES(length + 1)  char* dst,
+    IN_READS_Z(length)      char* src,
+    IN                      DWORD length
+    );
+
+SIZE_SUCCESS
+DWORD
+cl_strlen(
+    IN_Z  char* str
+    );
+
+SIZE_SUCCESS
+DWORD
+cl_strlen_s(
+    IN_READS_Z(maxLen)
+                char*   str,
+    IN          DWORD   maxLen
+    );
+
+// buffSize also includes the NULL terminator
+// => only buffSize - 1 will actually be
+// characters
+STATUS
+cl_snprintf(
+    OUT_WRITES(buffSize)    char* outputBuffer,
+    IN                      DWORD buffSize,
+    IN_Z                    char* inputBuffer,
+    ...
+    );
+
+#define cl_sprintf(outBuff,inBuff,...)     cl_snprintf(outBuff,MAX_PATH,inBuff,__VA_ARGS__)
+
+STATUS
+cl_vsnprintf(
+    OUT_WRITES(buffSize)    char*       outputBuffer,
+    IN                      DWORD       buffSize,
+    IN_Z                    char*       inputBuffer,
+    INOUT                   va_list     argptr
+    );
+
+const
+char*
+cl_strtok_s(
+    _When_(*context==NULL,IN_Z)
+    _When_(*context!=NULL,IN_OPT)
+                                char*       strToken,
+    IN_Z                        char*       delimiters,
+    INOUT                       char**      context
+    );
+
+SIZE_SUCCESS
+DWORD
+cl_strcelem(
+    IN_Z                    char*       string,
+    IN                      char        delimiter
+    );
+
+void
+cl_strtrim(
+    INOUT                    char*       string
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/common_lib.h b/src_proiect/CommonLib/inc/common_lib.h
new file mode 100644
index 0000000..939fa47
--- /dev/null
+++ b/src_proiect/CommonLib/inc/common_lib.h
@@ -0,0 +1,53 @@
+#pragma once
+
+#ifdef __cplusplus
+#define C_HEADER_START      extern "C" {
+#else
+#define C_HEADER_START
+#endif
+
+#ifdef __cplusplus
+#define C_HEADER_END        }
+#else
+#define C_HEADER_END
+#endif
+
+
+C_HEADER_START
+
+// basic includes
+#include "base.h"
+#include "sal_interface.h"
+#include "status.h"
+#include "va_list.h"
+#include "intutils.h"
+#include "native/memory.h"
+#include "assert.h"
+
+#pragma pack(push,16)
+typedef struct _COMMON_LIB_INIT
+{
+    // size of the COMMON_LIB_INIT structure
+    // this is used to avoid incompatibilities between
+    // the library and the application using it
+    DWORD                       Size;
+
+    // function to be used for ASSERTs
+    PFUNC_AssertFunction        AssertFunction;
+
+    BOOLEAN                     MonitorSupport;
+} COMMON_LIB_INIT, *PCOMMON_LIB_INIT;
+#pragma pack(pop)
+
+//******************************************************************************
+// Function:     CommonLibInit
+// Description:  Initializes the library.
+// Returns:      STATUS
+// Parameter:    IN PCOMMON_LIB_INIT InitSettings - Initial library settings
+//******************************************************************************
+STATUS
+CommonLibInit(
+    IN      PCOMMON_LIB_INIT        InitSettings
+    );
+
+C_HEADER_END
\ No newline at end of file
diff --git a/src_proiect/CommonLib/inc/data_type.h b/src_proiect/CommonLib/inc/data_type.h
new file mode 100644
index 0000000..56f6100
--- /dev/null
+++ b/src_proiect/CommonLib/inc/data_type.h
@@ -0,0 +1,72 @@
+#pragma once
+
+C_HEADER_START
+
+#pragma warning(push)
+
+// warning C4142: 'DWORD': benign redefinition of type
+#pragma warning(disable:4142)
+
+#ifndef TRUE
+#define TRUE                        ( 1 == 1 )
+#endif
+
+#ifndef FALSE
+#define FALSE                       ( 1 == 0 )
+#endif
+
+#ifndef NULL
+#define NULL                        ( (void*) 0 )
+#endif
+
+#define MAX_NIBBLE                  0xFU
+#define MAX_BYTE                    0xFFU
+#define MAX_WORD                    0xFFFFU
+#define MAX_DWORD                   0xFFFFFFFFUL
+#define MAX_QWORD                   0xFFFFFFFFFFFFFFFFULL
+
+//
+// standard types - define them with explicit length
+//
+typedef unsigned __int8     BYTE, *PBYTE;
+typedef unsigned __int16    WORD, *PWORD;
+typedef unsigned __int32    DWORD, *PDWORD;
+typedef unsigned __int64    QWORD, *PQWORD;
+
+typedef unsigned __int8     UINT8, *PUINT8;
+typedef unsigned __int16    UINT16, *PUINT16;
+typedef unsigned __int32    UINT32, *PUINT32;
+typedef unsigned __int64    UINT64, *PUINT64;
+
+typedef signed __int8       INT8;
+typedef signed __int16      INT16;
+typedef signed __int32      INT32;
+typedef signed __int64      INT64;
+
+// pointer
+typedef void*               PVOID;
+
+// bool
+typedef BYTE                BOOLEAN;
+
+// VMX operation
+typedef BYTE                VMX_RESULT;
+
+#ifndef CL_DO_NOT_DEFINE_PHYSICAL_ADDRESS
+// physical memory address
+typedef PVOID               PHYSICAL_ADDRESS;
+#endif // CL_DO_NOT_DEFINE_PHYSICAL_ADDRESS
+
+typedef volatile BYTE       VOL_BYTE;
+typedef volatile WORD       VOL_WORD;
+typedef volatile DWORD      VOL_DWORD;
+typedef volatile QWORD      VOL_QWORD;
+
+#ifndef _WCHAR_T_DEFINED
+typedef unsigned short WCHAR;
+#define _WCHAR_T_DEFINED
+#endif  /* _WCHAR_T_DEFINED */
+
+#pragma warning(pop)
+
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/event.h b/src_proiect/CommonLib/inc/event.h
new file mode 100644
index 0000000..10e963e
--- /dev/null
+++ b/src_proiect/CommonLib/inc/event.h
@@ -0,0 +1,88 @@
+#pragma once
+
+C_HEADER_START
+typedef enum _EVENT_TYPE
+{
+    EventTypeNotification,
+    EventTypeSynchronization,
+
+    EventTypeReserved
+} EVENT_TYPE, *PEVENT_TYPE;
+
+#pragma warning(push)
+
+// nonstandard extension used : nameless struct/union
+#pragma warning(disable:4201)
+typedef struct _EVENT
+{
+    volatile BYTE       State;
+    EVENT_TYPE          EventType;
+} EVENT, *PEVENT;
+#pragma warning(pop)
+
+//******************************************************************************
+// Function:     EvtInitialize
+// Description:  Creates an EVENT object. The behavior differs depending on the
+//               type of event:
+//               -> EventTypeNotification: Once an event is signaled it remains
+//               signaled until it is manually cleared.
+//               -> EventTypeSynchronization: Once an event is signaled, the
+//               first CPU which will wait detect the signal in EvtWaitForSignal
+//               will also clear it, i.e. a single CPU acknowledges the event,
+//               whereas the notification case all the CPUs acknowledge it.
+// Returns:      STATUS
+// Parameter:    OUT EVENT * Event
+// Parameter:    IN EVENT_TYPE EventType
+// Parameter:    IN BOOLEAN Signaled
+//******************************************************************************
+STATUS
+EvtInitialize(
+    OUT     EVENT*          Event,
+    IN      EVENT_TYPE      EventType,
+    IN      BOOLEAN         Signaled
+    );
+
+//******************************************************************************
+// Function:     EvtSignal
+// Description:  Signals an event.
+// Returns:      void
+// Parameter:    INOUT EVENT * Event
+//******************************************************************************
+void
+EvtSignal(
+    INOUT   EVENT*          Event
+    );
+
+//******************************************************************************
+// Function:     EvtClearSignal
+// Description:  Clears an event signal.
+// Returns:      void
+// Parameter:    INOUT EVENT * Event
+//******************************************************************************
+void
+EvtClearSignal(
+    INOUT   EVENT*          Event
+    );
+
+//******************************************************************************
+// Function:     EvtWaitForSignal
+// Description:  Busy waits until an event is signaled.
+// Returns:      void
+// Parameter:    INOUT EVENT * Event
+//******************************************************************************
+void
+EvtWaitForSignal(
+    INOUT   EVENT*          Event
+    );
+
+//******************************************************************************
+// Function:     EvtIsSignaled
+// Description:  Checks if an event is signaled and returns instantly.
+// Returns:      BOOLEAN - TRUE if the event was signaled, FALSE otherwise.
+// Parameter:    INOUT EVENT * Event
+//******************************************************************************
+BOOLEAN
+EvtIsSignaled(
+    INOUT   EVENT*          Event
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/gs_utils.h b/src_proiect/CommonLib/inc/gs_utils.h
new file mode 100644
index 0000000..6d8b490
--- /dev/null
+++ b/src_proiect/CommonLib/inc/gs_utils.h
@@ -0,0 +1,10 @@
+#pragma once
+
+C_HEADER_START
+void
+GSNotifyStackChange(
+    IN  PVOID       OldStackBase,
+    IN  PVOID       NewStackBase,
+    IN  DWORD       StackSize
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/hash_table.h b/src_proiect/CommonLib/inc/hash_table.h
new file mode 100644
index 0000000..b7b5553
--- /dev/null
+++ b/src_proiect/CommonLib/inc/hash_table.h
@@ -0,0 +1,313 @@
+#pragma once
+//******************************************************************************
+// Hash table
+//
+//
+// The hash table implementation uses a user provided hash function and solves
+// collisions by chaining the elements which hash to the same key. This
+// implementation requires dynamically allocated memory only when initializing
+// the hash table structure, this is because the number of maximum keys in
+// the hash table is determined only when initializing the hash table.
+//
+// However, after the hash table is initialized there is no more need for
+// dynamically allocated memory, the scheme is the same as for LIST_ENTRY,
+// each element to be inserted in the hash contains a HASH_ENTRY field which
+// is used to link all the entries within a single key.
+//
+// The hash function is also provided by the user, also the user must specify
+// the offset difference in the structure between the HASH_ENTRY field and
+// the field which will be used as the key.
+//
+// Lets see a usage example: we have our own structure FOO which has the
+// a WORD element named Id which will be used as the key and it has a
+// HASH_ENTRY element named HashEntry which is used in the hash table.
+//
+// typedef struct _FOO
+// {
+//      DWORD           SomeData;
+//      WORD            Id;
+//      DWORD           MoreData;
+//      HASH_ENTRY      HashEntry;
+// } FOO, *PFOO;
+//
+// We first pre-initialize the hash table by specifying how many keys we
+// want to have (the number of keys does not restrict the maximum number of
+// elements):
+//
+// HASH_TABLE hashTable;
+// PHASH_TABLE_DATA pHashData;
+//
+// DWORD dataSize = HashTablePreInit(&hashTable, 16, sizeof(WORD));
+//
+// Now we need to allocate dataSize bytes and pass the buffer to HashTableInit,
+// we will also pass a hash function (we can select one of the already existent
+// ones) and the offset in bytes between the Id field and the HashEntry field.
+//
+// pHashData = malloc(dataSize);
+//
+// HashTableInit(&hashTable,
+//              pHashData,
+//              HashFuncUniversal,
+//              FIELD_OFFSET(FOO, Id) - FIELD_OFFSET(FOO, HashEntry));
+//
+// Now we can commence operations on the hash table:
+//
+// 1. Insertion
+//
+// PFOO pMyData;
+//
+// HashTableInsert(&hashTable, &pMyData->HashEntry);
+//
+// 2. Lookup
+//
+// PHASH_ENTRY pEntry;
+// WORD idToSearchFor = 0x33;
+//
+// pEntry = HashTableLookup(&hashTable, &idToSearchFor);
+// if (pEntry != NULL)
+// {
+//      PFOO pMyData = CONTAINING_RECORD(pEntry, FOO, HashEntry);
+// }
+//
+// 3. Delete by entry
+//
+// HashTableRemoveEntry(&hashTable, &pMyData->HashEntry);
+//
+// 4. Delete by value
+//
+// WORD idToRemove = 0x33;
+// PHASH_ENTRY pEntry;
+//
+// pEntry = HashTableRemove(&hashTable, &idToRemove);
+//
+// 5. Iteration
+//
+// HASH_TABLE_ITERATOR it;
+// PHASH_ENTRY pEntry;
+//
+// HashTableIteratorInit(&hashTable, &it);
+//
+// while ((pEntry = HashTableIteratorNext(&it)) != NULL)
+// {
+//      // do whatever with the element
+//      // we can safely remove it from the hash table
+// }
+//******************************************************************************
+
+C_HEADER_START
+#include "list.h"
+#include "ref_cnt.h"
+
+typedef struct _HASH_TABLE_DATA*    PHASH_TABLE_DATA;
+typedef struct _HASH_ITERATOR*      PHASH_ITERATOR;
+typedef struct _HASH_KEY*           PHASH_KEY;
+
+typedef LIST_ENTRY                  HASH_ENTRY, *PHASH_ENTRY;
+
+typedef
+QWORD
+(__cdecl FUNC_HashFunction) (
+    IN_READS_BYTES(KeyLength)   PHASH_KEY   Key,
+    IN                          DWORD       KeyLength,
+    IN                          DWORD       MaxKeys
+    );
+
+typedef FUNC_HashFunction *PFUNC_HashFunction;
+
+typedef struct _HASH_TABLE
+{
+    // The universe of keys U = {0, ... MaxKeys - 1}
+    DWORD                       MaxKeys;
+
+    // Size of the key in bytes, maximum is currently 8 bytes
+    DWORD                       KeySize;
+
+    // The number of elements currently found in the hash table
+    DWORD                       NumberOfElements;
+
+    // The offset difference in bytes between the HASH_ENTRY and the key
+    INT32                       OffsetToKey;
+
+    PFUNC_HashFunction          HashFunc;
+
+    // Private data used by the hash table internal implementation
+    PHASH_TABLE_DATA            TableData;
+} HASH_TABLE, *PHASH_TABLE;
+
+typedef struct _HASH_ITERATOR
+{
+    PHASH_TABLE                 HashTable;
+
+    DWORD                       KeyIndex;
+    LIST_ITERATOR               CurrentKeyIterator;
+} HASH_ITERATOR, *PHASH_ITERATOR;
+
+//******************************************************************************
+// Function:     HashTablePreinit
+// Description:  Pre-initializes a hash table with maximum MaxKeys, each key
+//               occupying KeySize bytes.
+// Returns:      DWORD - The number of bytes which need to be allocated for the
+//                       internal TableData structure.
+// Parameter:    OUT PHASH_TABLE HashTable
+// Parameter:    IN DWORD MaxKeys - Maximum number of unique keys
+// Parameter:    IN DWORD KeySize - The length in bytes of a key - required for
+//               the hashing functions
+//******************************************************************************
+DWORD
+HashTablePreinit(
+    OUT     PHASH_TABLE         HashTable,
+    IN      DWORD               MaxKeys,
+    IN      DWORD               KeySize
+    );
+
+//******************************************************************************
+// Function:     HashTableInit
+// Description:  Initializes a pre-initialized hash table, using TableData for
+//               its internal house keeping.
+// Returns:      void
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    IN PHASH_TABLE_DATA TableData
+// Parameter:    IN PFUNC_HashFunction HashFunction - Function which performs
+//                                                    the hash on the key
+// Parameter:    IN INT32 OffsetToKey - Difference in bytes between the offset
+//               of the HASH_ENTRY element and the key. Generically this can be
+//               calculated using the following formula:
+//               FIELD_OFFSET(MY_STRUCT,Key) - FIELD_OFFSET(MY_STRUCT,HashEntry)
+//******************************************************************************
+void
+HashTableInit(
+    INOUT   PHASH_TABLE         HashTable,
+    OUT_WRITES_BYTES(HashTable->MaxKeys * sizeof(HASH_ENTRY))
+            PHASH_TABLE_DATA    TableData,
+    IN      PFUNC_HashFunction  HashFunction,
+    IN      INT32               OffsetToKey
+    );
+
+//******************************************************************************
+// Function:     HashTableClear
+// Description:  Removes all the elements from the hash table, optionally
+//               calling a free function for each element: this function
+//               receives a pointer to the HASH_ENTRY field of the element.
+// Returns:      void
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    IN_OPT PFUNC_FreeFunction FreeFunction
+// Parameter:    IN_OPT PVOID FreeContext
+//******************************************************************************
+void
+HashTableClear(
+    INOUT   PHASH_TABLE         HashTable,
+    IN_OPT  PFUNC_FreeFunction  FreeFunction,
+    IN_OPT  PVOID               FreeContext
+    );
+
+//******************************************************************************
+// Function:     HashTableSize
+// Description:
+// Returns:      DWORD - Number of elements in the hash table
+// Parameter:    IN HASH_TABLE* HashTable
+//******************************************************************************
+DWORD
+HashTableSize(
+    IN      HASH_TABLE*         HashTable
+    );
+
+//******************************************************************************
+// Function:     HashTableInsert
+// Description:  Inserts a new element into the hash table. If a collision
+//               occurs the new element is chained with all the others which
+//               have the same key.
+// Returns:      PHASH_ENTRY - If the Element already exists it returns the
+//                             previous entry, NULL otherwise
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    INOUT PHASH_ENTRY Element
+//******************************************************************************
+PHASH_ENTRY
+HashTableInsert(
+    INOUT   PHASH_TABLE         HashTable,
+    INOUT   PHASH_ENTRY         Element
+    );
+
+//******************************************************************************
+// Function:     HashTableRemove
+// Description:  Removes from the hash table the element with key Key.
+// Returns:      PHASH_ENTRY - Pointer to the HASH_ENTRY field in the found
+//                             element
+//                             NULL if no element with Key present
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    IN PHASH_KEY Key - Key to remove from the hash table.
+//******************************************************************************
+PTR_SUCCESS
+PHASH_ENTRY
+HashTableRemove(
+    INOUT   PHASH_TABLE         HashTable,
+    IN      PHASH_KEY           Key
+    );
+
+//******************************************************************************
+// Function:     HashTableRemoveEntry
+// Description:  Removes an element from the hash table.
+// Returns:      void
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    IN PHASH_ENTRY Element
+//******************************************************************************
+void
+HashTableRemoveEntry(
+    INOUT   PHASH_TABLE         HashTable,
+    IN      PHASH_ENTRY         Element
+    );
+
+//******************************************************************************
+// Function:     HashTableLookup
+// Description:  Searches for the element with key Key in the hash table.
+// Returns:      PHASH_ENTRY - A pointer to the HASH_ENTRY field in the found
+//                             element
+//                             NULL if no element with Key present
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    IN PHASH_KEY Key
+//******************************************************************************
+PTR_SUCCESS
+PHASH_ENTRY
+HashTableLookup(
+    INOUT   PHASH_TABLE         HashTable,
+    IN      PHASH_KEY           Key
+    );
+
+//******************************************************************************
+// Function:     HashTableIteratorInit
+// Description:  Initializes an iterator over the hash table.
+// Returns:      void
+// Parameter:    INOUT PHASH_TABLE HashTable
+// Parameter:    OUT PHASH_ITERATOR HashIterator
+// NOTE:         There is no guarantee regarding the order in which the hash
+//               table is traversed.
+//******************************************************************************
+void
+HashTableIteratorInit(
+    IN      PHASH_TABLE         HashTable,
+    OUT     PHASH_ITERATOR      HashIterator
+    );
+
+//******************************************************************************
+// Function:     HashTableIteratorNext
+// Description:  Returns the next element in the hash table.
+// Returns:      PHASH_ENTRY - A pointer to the HASH_ENTRY field in the found
+//                             element
+//                             NULL if there are no more elements
+// Parameter:    INOUT PHASH_ITERATOR HashIterator
+//******************************************************************************
+PHASH_ENTRY
+HashTableIteratorNext(
+    INOUT   PHASH_ITERATOR      HashIterator
+    );
+
+// Generic Hash functions which you can use for keys of size up to 8 bytes
+
+// 1. HashFuncGenericIncremental: Key % MaxKeys
+// Good for hashes where the keys simply increment by 1: 1, 2, 3, 4, 5 =>
+// these elements will be distributed evenly in each chain
+FUNC_HashFunction               HashFuncGenericIncremental;
+
+// 2. HashFuncUniversal: (((a * Key) + b) % p) % MaxKeys
+// Good for all the other cases.
+FUNC_HashFunction               HashFuncUniversal;
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/intutils.h b/src_proiect/CommonLib/inc/intutils.h
new file mode 100644
index 0000000..f79d99e
--- /dev/null
+++ b/src_proiect/CommonLib/inc/intutils.h
@@ -0,0 +1,50 @@
+#pragma once
+
+C_HEADER_START
+// concatenate two BYTEs to make WORD
+#define BYTES_TO_WORD(x,y)                  ((((WORD)(x))<<8)| \
+                                              ((WORD)(y)))
+
+// concatenate two WORDs to make DWORD
+#define WORDS_TO_DWORD(x,y)                 ((((DWORD)(x))<<16)| \
+                                              ((DWORD)(y)))
+
+// concatenate two DWORDs to make QWORD
+#define DWORDS_TO_QWORD(x,y)                ((((QWORD)(x))<<32)| \
+                                              ((QWORD)(y)))
+
+
+#define WORD_HIGH(x)                        (((WORD)(x))>>8)
+#define WORD_LOW(x)                         (((WORD)(x))&MAX_BYTE)
+
+#define DWORD_HIGH(x)                       (((DWORD)(x))>>16)
+#define DWORD_LOW(x)                        (((DWORD)(x))&MAX_WORD)
+
+#define QWORD_HIGH(x)                       (((QWORD)(x))>>32)
+#define QWORD_LOW(x)                        (((QWORD)(x))&MAX_DWORD)
+
+#ifndef max
+#define max(a,b)                            ((a)>(b)?(a):(b))
+#endif // max
+
+#ifndef min
+#define min(a,b)                            ((a)<(b)?(a):(b))
+#endif // min
+
+#define ntohd(x)    ((DWORD)                            \
+                    ((((x) >> 24) & 0x0000'00FF)    |   \
+                    ( ((x) << 8)  & 0x00FF'0000)    |   \
+                    ( ((x) >> 8)  & 0x0000'FF00)    |   \
+                    ( ((x) << 24) & 0xFF00'0000)))
+
+#define ntohw(x)    ((WORD)(((x) >> 8) | ((x) << 8)))
+
+#define htond(x)    ntohd((x))
+#define htonw(x)    ntohw((x))
+
+QWORD
+CalculatePercentage(
+    IN      QWORD       WholeValue,
+    IN      WORD        HundredsOfPercentage
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/list.h b/src_proiect/CommonLib/inc/list.h
new file mode 100644
index 0000000..109f93d
--- /dev/null
+++ b/src_proiect/CommonLib/inc/list.h
@@ -0,0 +1,294 @@
+#pragma once
+//******************************************************************************
+// Doubly linked list.
+//
+// This implementation of a doubly linked list does not require use of
+// dynamically allocated memory. Instead, each structure that is a potential
+// list element must embed a LIST_ENTRY member. All of the list functions
+// operate on these LIST_ENTRY elements. The CONTAINING_RECORD macro allows
+// conversion from a LIST_ENTRY element back to a structure object that contains
+// it.
+//
+// For example, suppose there is a need for a list of FOO structures. The FOO
+// structure should contain a LIST_ENTRY member, like so:
+//
+// typedef struct _FOO
+// {
+//      DWORD           SomeData;
+//      LIST_ENTRY      Element;
+//      DWORD           MoreData;
+// } FOO, *PFOO;
+//
+// Then a list of FOO structures can be be declared and initialized like so:
+//
+// LIST_ENTRY fooList;
+//
+// InitializeListHead(&fooList);
+//
+// Iteration is a typical situation where it is necessary to convert from a
+// LIST_ENTRY structure back to its enclosing structure. Here's an example
+// where the fooList is iterated and all the elements whose SomeData field
+// equal DataToSearch are deleted:
+//
+// LIST_ITERATOR it;
+// ListIteratorInit(&fooList, &it);
+//
+// PLIST_ENTRY pEntry;
+// while ((pEntry = ListIteratorNext(&it)) != NULL)
+// {
+//      PFOO pFoo = CONTAINING_RECORD(pEntry, FOO, Element);
+//      if (pFoo->SomeData == DataToSearch) RemoveEntryList(pEntry);
+// }
+//
+// The interface for this list is inspired by the LIST_ENTRY implementation
+// from Microsoft. If you're familiar with those LIST_ENTRY structures, you
+// should find this easy to use.
+//******************************************************************************
+
+C_HEADER_START
+
+#define INVALID_LIST_SIZE       MAX_DWORD
+
+#pragma pack(push,16)
+typedef struct _LIST_ENTRY
+{
+    struct _LIST_ENTRY*     Flink;
+    struct _LIST_ENTRY*     Blink;
+} LIST_ENTRY, *PLIST_ENTRY;
+#pragma pack(pop)
+
+typedef struct _LIST_ITERATOR
+{
+    PLIST_ENTRY                 ListHead;
+
+    PLIST_ENTRY                 CurrentEntry;
+} LIST_ITERATOR, *PLIST_ITERATOR;
+
+typedef
+STATUS
+(__cdecl FUNC_ListFunction) (
+    IN      PLIST_ENTRY     ListEntry,
+    IN_OPT  PVOID           FunctionContext
+    );
+
+typedef FUNC_ListFunction*      PFUNC_ListFunction;
+
+//******************************************************************************
+// Function:     FUNC_CompareFunction
+// Description:  Compares two list elements.
+// Returns:      INT64 - Returns a negative value if FirstElem is smaller than
+//               SecondElem, a positive value if FirstElem is greater than
+//               SecondElem and zero otherwise.
+// Parameter:    IN PLIST_ENTRY FirstElem
+// Parameter:    IN PLIST_ENTRY SecondElem
+//******************************************************************************
+typedef
+INT64
+(__cdecl FUNC_CompareFunction) (
+    IN      PLIST_ENTRY     FirstElem,
+    IN      PLIST_ENTRY     SecondElem,
+    IN_OPT  PVOID           Context
+    );
+
+typedef FUNC_CompareFunction*   PFUNC_CompareFunction;
+
+//******************************************************************************
+// Function:     InitializeListHead
+// Description:  Initializes the head of a doubly linked list.
+// Returns:      void
+// Parameter:    OUT PLIST_ENTRY ListHead
+// NOTE:         Must be called before any other operation is performed on the
+//               list.
+//******************************************************************************
+void
+InitializeListHead(
+    OUT     PLIST_ENTRY ListHead
+    );
+
+
+//******************************************************************************
+// Function:     IsListEmpty
+// Description:
+// Returns:      BOOLEAN - TRUE if the list is currently empty, FALSE otherwise.
+// Parameter:    IN PLIST_ENTRY ListHead
+//******************************************************************************
+BOOLEAN
+IsListEmpty(
+    IN      PLIST_ENTRY ListHead
+    );
+
+//******************************************************************************
+// Function:     IsListEmptyDirty
+// Description:  Performs a quick check to see if the list is empty without
+//               validating the list head pointers. Should be used only in
+//               time-critical situations.
+// Returns:      BOOLEAN
+// Parameter:    IN PLIST_ENTRY ListHead
+//******************************************************************************
+__forceinline
+BOOLEAN
+IsListEmptyDirty(
+    IN      PLIST_ENTRY ListHead
+    )
+{
+    return (BOOLEAN)(ListHead->Flink == ListHead);
+}
+
+//******************************************************************************
+// Function:     RemoveEntryList
+// Description:  Removes an entry from the linked list
+// Returns:      BOOLEAN - if TRUE the list is empty after the removal
+// Parameter:    INOUT PLIST_ENTRY Entry
+//******************************************************************************
+BOOLEAN
+RemoveEntryList(
+    INOUT   PLIST_ENTRY Entry
+    );
+
+//******************************************************************************
+// Function:     RemoveHeadList
+// Description:  Removes the head of the linked list
+// Returns:      PLIST_ENTRY - pointer to the entry removed; If the list was
+//               empty it returns a pointer to the list head
+// Parameter:    INOUT PLIST_ENTRY ListHead
+//******************************************************************************
+PLIST_ENTRY
+RemoveHeadList(
+    INOUT   PLIST_ENTRY ListHead
+    );
+
+//******************************************************************************
+// Function:     RemoveTailList
+// Description:  Removes the tail of the linked list
+// Returns:      PLIST_ENTRY - pointer to the entry removed; If the list was
+//               empty it returns a pointer to the list head
+// Parameter:    INOUT PLIST_ENTRY ListHead
+//******************************************************************************
+PLIST_ENTRY
+RemoveTailList(
+    INOUT   PLIST_ENTRY ListHead
+    );
+
+//******************************************************************************
+// Function:     InsertTailList
+// Description:  Inserts an element to the tail of the list.
+// Returns:      void
+// Parameter:    INOUT PLIST_ENTRY ListHead
+// Parameter:    INOUT PLIST_ENTRY Entry
+//******************************************************************************
+void
+InsertTailList(
+    INOUT   PLIST_ENTRY ListHead,
+    INOUT   PLIST_ENTRY Entry
+    );
+
+//******************************************************************************
+// Function:     InsertHeadList
+// Description:  Inserts an element to the head of the list
+// Returns:      void
+// Parameter:    INOUT PLIST_ENTRY ListHead
+// Parameter:    INOUT PLIST_ENTRY Entry
+//******************************************************************************
+void
+InsertHeadList(
+    INOUT   PLIST_ENTRY ListHead,
+    INOUT   PLIST_ENTRY Entry
+    );
+
+//******************************************************************************
+// Function:     InsertOrderedList
+// Description:  Inserts an element into the list following the ordering given
+//               by the CompareFunction function.
+// Returns:      void
+// Parameter:    INOUT PLIST_ENTRY ListHead
+// Parameter:    INOUT PLIST_ENTRY Entry
+// Parameter:    IN PFUNC_CompareFunction CompareFunction
+//******************************************************************************
+void
+InsertOrderedList(
+    INOUT   PLIST_ENTRY             ListHead,
+    INOUT   PLIST_ENTRY             Entry,
+    IN      PFUNC_CompareFunction   CompareFunction,
+    IN_OPT  PVOID                   Context
+    );
+
+//******************************************************************************
+// Function:     GetListElemByIndex
+// Description:  Returns the i-th element from the list.
+// Returns:      PLIST_ENTRY - pointer to the ith element; If the list contains
+//               less than i+1 elements it returns NULL
+// Parameter:    IN PLIST_ENTRY ListHead
+// Parameter:    IN DWORD ListIndex
+//******************************************************************************
+PTR_SUCCESS
+PLIST_ENTRY
+GetListElemByIndex(
+    IN      PLIST_ENTRY ListHead,
+    IN      DWORD       ListIndex
+    );
+
+//******************************************************************************
+// Function:     ListSize
+// Description:  Returns the number of elements in the list.
+// Returns:      DWORD
+// Parameter:    IN PLIST_ENTRY ListHead
+// NOTE:         This function is very slow for large lists due to the fact that
+//               the whole list is traversed to determine the number of
+//               elements.
+//******************************************************************************
+SIZE_SUCCESS
+DWORD
+ListSize(
+    IN      PLIST_ENTRY ListHead
+    );
+
+//******************************************************************************
+// Function:      ForEachElementExecute
+// Description:   Executes a function with each element of the list as argument.
+// Returns:       STATUS
+// Parameter:     IN PLIST_ENTRY ListHead   - List on which to execute function.
+// Parameter:     IN LIST_FUNCTION Function - Function to execute.
+// Parameter:     IN_OPT PVOID Context      - additional context to pass to the
+//                                          function.
+// Parameter:     IN BOOLEAN AllMustSucceed - if TRUE returns SUCCESS only if
+//                                          all function calls succeeded, else
+//                                          it's enough for one to succeed.
+//******************************************************************************
+STATUS
+ForEachElementExecute(
+    IN      PLIST_ENTRY             ListHead,
+    IN      PFUNC_ListFunction      Function,
+    IN_OPT  PVOID                   Context,
+    IN      BOOLEAN                 AllMustSucceed
+    );
+
+//******************************************************************************
+// Function:     ListSearchForElement
+// Description:  Searches for an element in the list using the CompareFunction
+//               function to identify it.
+// Returns:      PLIST_ENTRY
+// Parameter:    IN PLIST_ENTRY ListHead
+// Parameter:    IN PLIST_ENTRY ElementToSearchFor
+// Parameter:    IN PFUNC_CompareFunction CompareFunction
+//******************************************************************************
+PTR_SUCCESS
+PLIST_ENTRY
+ListSearchForElement(
+    IN      PLIST_ENTRY             ListHead,
+    IN      PLIST_ENTRY             ElementToSearchFor,
+    IN      BOOLEAN                 IsListOrdered,
+    IN      PFUNC_CompareFunction   CompareFunction,
+    IN_OPT  PVOID                   Context
+    );
+
+void
+ListIteratorInit(
+    IN      PLIST_ENTRY         List,
+    OUT     PLIST_ITERATOR      ListIterator
+    );
+
+PLIST_ENTRY
+ListIteratorNext(
+    INOUT   PLIST_ITERATOR      ListIterator
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/lock_common.h b/src_proiect/CommonLib/inc/lock_common.h
new file mode 100644
index 0000000..b7f4dea
--- /dev/null
+++ b/src_proiect/CommonLib/inc/lock_common.h
@@ -0,0 +1,118 @@
+#pragma once
+
+C_HEADER_START
+
+#ifndef _COMMONLIB_NO_LOCKS_
+#include "spinlock.h"
+#include "monlock.h"
+#include "rw_spinlock.h"
+#include "rec_rw_spinlock.h"
+
+typedef
+INTR_STATE
+(__cdecl FUNC_IntrDisable)(
+    void
+    );
+
+typedef
+INTR_STATE
+(__cdecl FUNC_IntrEnable)(
+    void
+    );
+
+typedef
+INTR_STATE
+(__cdecl FUNC_IntrGetState)(
+    void
+    );
+
+typedef
+INTR_STATE
+(__cdecl FUNC_IntrSetState)(
+    IN      INTR_STATE      State
+    );
+
+typedef
+PVOID
+(__cdecl FUNC_CpuGetCurrent)(
+    void
+    );
+
+extern FUNC_CpuGetCurrent   CpuGetCurrent;
+extern FUNC_IntrDisable     CpuIntrDisable;
+extern FUNC_IntrEnable      CpuIntrEnable;
+extern FUNC_IntrGetState    CpuIntrGetState;
+extern FUNC_IntrSetState    CpuIntrSetState;
+
+#define LOCK_TAKEN          1
+#define LOCK_FREE           0
+
+typedef union _LOCK
+{
+    SPINLOCK        SpinLock;
+    MONITOR_LOCK    MonitorLock;
+} LOCK, *PLOCK;
+
+typedef
+void
+(__cdecl FUNC_LockInit)(
+    OUT         PLOCK           Lock
+    );
+
+typedef FUNC_LockInit*          PFUNC_LockInit;
+
+typedef
+void
+REQUIRES_NOT_HELD_LOCK(*Lock)
+ACQUIRES_EXCL_AND_NON_REENTRANT_LOCK(*Lock)
+(__cdecl FUNC_LockAcquire)(
+    INOUT       PLOCK           Lock,
+    OUT         INTR_STATE*     IntrState
+    );
+
+typedef FUNC_LockAcquire*       PFUNC_LockAcquire;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_LockTryAcquire)(
+    INOUT       PLOCK           Lock,
+    OUT         INTR_STATE*     IntrState
+    );
+
+typedef FUNC_LockTryAcquire*    PFUNC_LockTryAcquire;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_LockIsOwner)(
+    IN          PLOCK           Lock
+    );
+
+typedef FUNC_LockIsOwner*       PFUNC_LockIsOwner;
+
+typedef
+void
+REQUIRES_EXCL_LOCK(*Lock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(*Lock)
+(__cdecl FUNC_LockRelease)(
+    INOUT       PLOCK           Lock,
+    IN          INTR_STATE      OldIntrState
+    );
+
+typedef FUNC_LockRelease*       PFUNC_LockRelease;
+
+extern PFUNC_LockInit           LockInit;
+
+extern PFUNC_LockAcquire        LockAcquire;
+
+extern PFUNC_LockTryAcquire     LockTryAcquire;
+
+extern PFUNC_LockRelease        LockRelease;
+
+extern PFUNC_LockIsOwner        LockIsOwner;
+
+void
+LockSystemInit(
+    IN      BOOLEAN             MonitorSupport
+    );
+#endif // _COMMONLIB_NO_LOCKS_
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/monlock.h b/src_proiect/CommonLib/inc/monlock.h
new file mode 100644
index 0000000..b871c13
--- /dev/null
+++ b/src_proiect/CommonLib/inc/monlock.h
@@ -0,0 +1,51 @@
+#pragma once
+
+C_HEADER_START
+#define MONITOR_FILTER_SIZE     64
+
+#pragma pack(push,16)
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+typedef struct _MONITOR_LOCK
+{
+    union
+    {
+        SPINLOCK                Lock;
+        volatile BYTE           Reserved[MONITOR_FILTER_SIZE];
+    };
+} MONITOR_LOCK, *PMONITOR_LOCK;
+
+#pragma warning(pop)
+#pragma pack(pop)
+
+void
+MonitorLockInit(
+    OUT         PMONITOR_LOCK       Lock
+    );
+
+void
+MonitorLockAcquire(
+    INOUT       PMONITOR_LOCK       Lock,
+    OUT         INTR_STATE*         IntrState
+    );
+
+BOOL_SUCCESS
+BOOLEAN
+MonitorLockTryAcquire(
+    INOUT       PMONITOR_LOCK       Lock,
+    OUT         INTR_STATE*         IntrState
+    );
+
+BOOLEAN
+MonitorLockIsOwner(
+    IN          PMONITOR_LOCK       Lock
+    );
+
+void
+MonitorLockRelease(
+    INOUT       PMONITOR_LOCK       Lock,
+    IN          INTR_STATE          OldIntrState
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/native/memory.h b/src_proiect/CommonLib/inc/native/memory.h
new file mode 100644
index 0000000..a583cf3
--- /dev/null
+++ b/src_proiect/CommonLib/inc/native/memory.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "cl_memory.h"
+
+#ifndef CL_NON_NATIVE
+
+#define memset              cl_memset
+#define memzero             cl_memzero
+#define memcpy              cl_memcpy
+#define memmove             cl_memmove
+#define memcmp              cl_memcmp
+#define rmemcmp             cl_rmemcmp
+#define memscan             cl_memscan
+#endif // CL_NON_NATIVE
diff --git a/src_proiect/CommonLib/inc/native/string.h b/src_proiect/CommonLib/inc/native/string.h
new file mode 100644
index 0000000..0966fe7
--- /dev/null
+++ b/src_proiect/CommonLib/inc/native/string.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "cl_string.h"
+
+#ifndef CL_NON_NATIVE
+
+#define strcmp                  cl_strcmp
+#define stricmp                 cl_stricmp
+#define strncmp                 cl_strncmp
+#define strchr                  cl_strchr
+#define strrchr                 cl_strrchr
+#define strcpy                  cl_strcpy
+#define strncpy                 cl_strncpy
+#define strlen                  cl_strlen
+#define strlen_s                cl_strlen_s
+#define snprintf                cl_snprintf
+#define sprintf                 cl_sprintf
+#define vsnprintf               cl_vsnprintf
+#define strtok_s                cl_strtok_s
+#define strcelem                cl_strcelem
+#define strtrim                 cl_strtrim
+
+#endif // CL_NON_NATIVE
diff --git a/src_proiect/CommonLib/inc/rec_rw_spinlock.h b/src_proiect/CommonLib/inc/rec_rw_spinlock.h
new file mode 100644
index 0000000..a15df64
--- /dev/null
+++ b/src_proiect/CommonLib/inc/rec_rw_spinlock.h
@@ -0,0 +1,60 @@
+#pragma once
+
+C_HEADER_START
+#include "rw_spinlock.h"
+
+#pragma pack(push,16)
+typedef struct _REC_RW_SPINLOCK
+{
+    RW_SPINLOCK     RwSpinlock;
+
+    // we don't use BYTE because we want to conserve memory,
+    // we use BYTE because there is NO REASON why a lock
+    // should be acquired more than 255 times by the same thread
+    BYTE            CurrentRecursivityDepth;
+    BYTE            MaxRecursivityDepth;
+
+    PVOID           Holder;
+} REC_RW_SPINLOCK, *PREC_RW_SPINLOCK;
+#pragma pack(pop)
+
+
+//******************************************************************************
+// Function:     RecRwSpinlockInit
+// Description:  
+// Returns:      void
+// Parameter:    IN BYTE RecursivityDepth - If parameter is 0 it will default
+//                                          to 2.
+// Parameter:    OUT PREC_RW_SPINLOCK Spinlock
+//******************************************************************************
+void
+RecRwSpinlockInit(
+    IN      BYTE                    RecursivityDepth,
+    OUT     PREC_RW_SPINLOCK        Spinlock
+    );
+
+REQUIRES_NOT_HELD_LOCK(*Spinlock)
+_When_(Exclusive, ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RecRwSpinlockAcquire(
+    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    OUT     INTR_STATE*         IntrState,
+    IN      BOOLEAN             Exclusive
+    );
+
+#define RecRwSpinlockAcquireShared(Lck,Intr)      RecRwSpinlockAcquire((Lck),(Intr),FALSE)
+#define RecRwSpinlockAcquireExclusive(Lck,Intr)   RecRwSpinlockAcquire((Lck),(Intr),TRUE)
+
+_When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RecRwSpinlockRelease(
+    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    IN      INTR_STATE          IntrState,
+    IN      BOOLEAN             Exclusive
+    );
+
+#define RecRwSpinlockReleaseShared(Lck,Intr)      RecRwSpinlockRelease((Lck),(Intr),FALSE)
+#define RecRwSpinlockReleaseExclusive(Lck,Intr)   RecRwSpinlockRelease((Lck),(Intr),TRUE)
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/ref_cnt.h b/src_proiect/CommonLib/inc/ref_cnt.h
new file mode 100644
index 0000000..2ea29e5
--- /dev/null
+++ b/src_proiect/CommonLib/inc/ref_cnt.h
@@ -0,0 +1,73 @@
+#pragma once
+
+C_HEADER_START
+//******************************************************************************
+// Function:     FUNC_FreeFunction
+// Description:  Function called when the ReferenceCount of the object reaches 0
+//               This function should free any allocated resources or handles.
+// Returns:      void
+// Parameter:    _cdecl FUNC_FreeFunction
+//******************************************************************************
+typedef
+void
+(_cdecl FUNC_FreeFunction)(
+    IN      PVOID       Object,
+    IN_OPT  PVOID       Context
+    );
+
+typedef FUNC_FreeFunction*      PFUNC_FreeFunction;
+
+#pragma pack(push,16)
+typedef struct _REF_COUNT
+{
+    volatile DWORD              ReferenceCount;
+    PFUNC_FreeFunction          FreeFunction;
+    PVOID                       Context;
+} REF_COUNT, *PREF_COUNT;
+#pragma pack(pop)
+
+void
+RfcPreInit(
+    OUT     REF_COUNT*              Object
+    );
+
+//******************************************************************************
+// Function:     RfcInit
+// Description:  Initializes a reference counted object.
+// Returns:      STATUS
+// Parameter:    OUT REF_COUNT * Object
+// Parameter:    IN_OPT PFUNC_FreeFunction FreeFunction - Called when reference
+//               count for object reaches 0.
+// Parameter:    IN_OPT PVOID Context - Context to pass to FreeFunction
+//******************************************************************************
+STATUS
+RfcInit(
+    OUT     REF_COUNT*              Object,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   Context
+    );
+
+//******************************************************************************
+// Function:     RfcReference
+// Description:  Increments the reference count of the object
+// Returns:      DWORD - Current reference count of the object
+// Parameter:    INOUT REF_COUNT * Object
+//******************************************************************************
+SIZE_SUCCESS
+DWORD
+RfcReference(
+    INOUT   REF_COUNT*              Object
+    );
+
+//******************************************************************************
+// Function:     RfcReference
+// Description:  Decrements the reference count of the object
+// Returns:      DWORD - Current reference count of the object
+// Parameter:    INOUT REF_COUNT * Object
+//******************************************************************************
+SIZE_SUCCESS
+DWORD
+RfcDereference(
+    INOUT   REF_COUNT*              Object
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/rw_spinlock.h b/src_proiect/CommonLib/inc/rw_spinlock.h
new file mode 100644
index 0000000..caced32
--- /dev/null
+++ b/src_proiect/CommonLib/inc/rw_spinlock.h
@@ -0,0 +1,44 @@
+#pragma once
+
+C_HEADER_START
+#pragma pack(push,16)
+typedef struct _RW_SPINLOCK
+{
+    volatile WORD   WaitingWriters;
+    volatile WORD   ActiveWriter;
+    volatile WORD   ActiveReaders;
+} RW_SPINLOCK, *PRW_SPINLOCK;
+STATIC_ASSERT(FIELD_OFFSET(RW_SPINLOCK,WaitingWriters) + sizeof(WORD) == FIELD_OFFSET(RW_SPINLOCK, ActiveWriter));
+STATIC_ASSERT(FIELD_OFFSET(RW_SPINLOCK,ActiveWriter) + sizeof(WORD) == FIELD_OFFSET(RW_SPINLOCK, ActiveReaders));
+#pragma pack(pop)
+
+void
+RwSpinlockInit(
+    OUT     PRW_SPINLOCK    Spinlock
+    );
+
+REQUIRES_NOT_HELD_LOCK(*Spinlock)
+_When_(Exclusive, ACQUIRES_EXCL_AND_NON_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RwSpinlockAcquire(
+    INOUT   RW_SPINLOCK     *Spinlock,
+    OUT     INTR_STATE*     IntrState,
+    IN      BOOLEAN         Exclusive
+    );
+
+#define RwSpinlockAcquireShared(Lck,Intr)      RwSpinlockAcquire((Lck),(Intr),FALSE)
+#define RwSpinlockAcquireExclusive(Lck,Intr)   RwSpinlockAcquire((Lck),(Intr),TRUE)
+
+_When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_NON_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RwSpinlockRelease(
+    INOUT   RW_SPINLOCK     *Spinlock,
+    IN      INTR_STATE      IntrState,
+    IN      BOOLEAN         Exclusive
+    );
+
+#define RwSpinlockReleaseShared(Lck,Intr)      RwSpinlockRelease((Lck),(Intr),FALSE)
+#define RwSpinlockReleaseExclusive(Lck,Intr)   RwSpinlockRelease((Lck),(Intr),TRUE)
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/sal_interface.h b/src_proiect/CommonLib/inc/sal_interface.h
new file mode 100644
index 0000000..6b39252
--- /dev/null
+++ b/src_proiect/CommonLib/inc/sal_interface.h
@@ -0,0 +1,74 @@
+#pragma once
+
+C_HEADER_START
+#include <sal.h>
+
+#define PTR_SUCCESS                                 _Success_(NULL != return)
+#define SIZE_SUCCESS                                _Success_(MAX_DWORD != return)
+#define BOOL_SUCCESS                                _Success_(TRUE == return)
+
+// The IN arguments must always be constants :)
+#ifndef IN
+#define IN                                          _In_ const
+#endif // IN
+
+#define IN_Z                                        _In_z_ const
+#define IN_OPT                                      _In_opt_ const
+#define IN_OPT_Z                                    _In_opt_z_ const
+#define IN_READS(x)                                 _In_reads_((x)) const
+#define IN_READS_BYTES(x)                           _In_reads_bytes_((x)) const
+#define IN_READS_Z(x)                               _In_reads_or_z_((x)) const
+#define IN_READS_OPT_Z(x)                           _In_reads_opt_z_((x)) const
+#define IN_RANGE(a,b)                               IN _In_range_((a),(b))
+#define IN_RANGE_UPPER(b)                           IN_RANGE(0,(b))
+#define IN_RANGE_LOWER(a)                           IN_RANGE((a),MAX_DWORD)
+#define IN_RANGE_LOWER64(a)                         IN_RANGE((a),MAX_QWORD)
+
+#define INOUT                                       _Inout_
+#define INOUT_OPT                                   _Inout_opt_
+#define INOUT_UPDATES(x)                            _Inout_updates_((x))
+#define INOUT_UPDATES_TO(x,y)                       _Inout_updates_to_((x),(y))
+#define INOUT_UPDATES_ALL(x)                        _Inout_updates_all_((x))
+
+#ifndef OUT
+#define OUT                                         _Out_
+#endif // OUT
+
+#define OUT_Z                                       __out_z
+#define OUT_PTR                                     _Outptr_
+#define OUT_PTR_MAYBE_NULL                          _Outptr_result_maybenull_
+#define OUT_OPT                                     _Out_opt_
+#define OUT_OPT_PTR                                 _Outptr_opt_
+#define OUT_OPT_PTR_MAYBE_NULL                      _Outptr_opt_result_maybenull_
+#define OUT_WRITES(x)                               _Out_writes_((x))
+#define OUT_WRITES_Z(x)                             _Out_writes_z_((x))
+#define OUT_WRITES_OPT(x)                           _Out_writes_opt_((x))
+#define OUT_WRITES_ALL(x)                           _Out_writes_all_((x))
+#define OUT_WRITES_ALL_OPT(x)                       _Out_writes_all_opt_((x))
+#define OUT_WRITES_BYTES(x)                         _Out_writes_bytes_((x))
+#define OUT_WRITES_BYTES_OPT(x)                     _Out_writes_bytes_opt_((x))
+#define OUT_WRITES_BYTES_ALL(x)                     _Out_writes_bytes_all_((x))
+#define OUT_WRITES_BYTES_ALL_OPT(x)                 _Out_writes_bytes_all_opt_((x))
+
+// locking annotations
+#define ACQUIRES_EXCL_AND_NON_REENTRANT_LOCK(x)     _Acquires_exclusive_lock_((x)) \
+                                                    _Acquires_nonreentrant_lock_((x))
+#define ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(x)    _Acquires_shared_lock_((x)) \
+                                                    _Acquires_nonreentrant_lock_((x))
+#define ACQUIRES_EXCL_AND_REENTRANT_LOCK(x)         _Acquires_exclusive_lock_((x))
+
+#define RELEASES_EXCL_AND_NON_REENTRANT_LOCK(x)     _Releases_exclusive_lock_((x)) \
+                                                    _Releases_nonreentrant_lock_((x))
+#define RELEASES_SHARED_AND_NON_REENTRANT_LOCK(x)   _Releases_shared_lock_((x)) \
+                                                    _Releases_nonreentrant_lock_((x))
+#define RELEASES_EXCL_AND_REENTRANT_LOCK(x)         _Releases_exclusive_lock_((x))
+
+#define REQUIRES_EXCL_LOCK(x)                       _Requires_exclusive_lock_held_((x))
+#define REQUIRES_SHARED_LOCK(x)                     _Requires_shared_lock_held_((x))
+#define REQUIRES_NOT_HELD_LOCK(x)                   _Requires_lock_not_held_((x))
+
+// return types
+#define RET_NOT_NULL                                _Ret_notnull_
+
+#include "sal_intrinsic.h"
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/sal_intrinsic.h b/src_proiect/CommonLib/inc/sal_intrinsic.h
new file mode 100644
index 0000000..240db27
--- /dev/null
+++ b/src_proiect/CommonLib/inc/sal_intrinsic.h
@@ -0,0 +1,161 @@
+#pragma once
+
+C_HEADER_START
+#ifndef CL_NON_NATIVE
+#pragma warning(push)
+
+// warning C4391: incorrect return type for intrinsic function
+#pragma warning(disable:4391)
+
+// annotations for some intrinsics
+PVOID
+_AddressOfReturnAddress(
+    void
+    );
+
+void
+__cpuid(
+    OUT_WRITES_ALL(4)    int cpuInfo[4],
+    IN                   int function_id
+    );
+
+void
+__cpuidex(
+    OUT_WRITES_ALL(4)    int cpuInfo[4],
+    IN                   int function_id,
+    IN                   int sub_id
+    );
+
+_Success_(TRUE)
+QWORD
+__readmsr(
+    IN   DWORD   register
+    );
+
+void
+__movsb(
+    OUT_WRITES_BYTES_ALL(Count)                 PVOID   Destination,
+    IN_READS_BYTES(Count)                       PVOID   Source,
+    IN                                          QWORD   Count
+    );
+
+void
+__movsq(
+    OUT_WRITES_BYTES_ALL(Count*sizeof(QWORD))   PVOID   Destination,
+    IN_READS_BYTES(Count*sizeof(QWORD))         PVOID   Source,
+    IN                                          QWORD   Count
+    );
+
+_Success_(return == 0)
+VMX_RESULT
+__vmx_vmread(
+    IN   DWORD  Field,
+    OUT  QWORD* FieldValue
+    );
+
+_Success_(return == 0)
+VMX_RESULT
+__vmx_vmwrite(
+    IN   DWORD  Field,
+    IN   QWORD  FieldValue
+    );
+
+PVOID
+__readcr2(
+    void
+    );
+
+PHYSICAL_ADDRESS
+__readcr3(
+    void
+    );
+
+_Ret_range_(<=, 0xF)
+BYTE
+__readcr8(
+    void
+    );
+
+void
+__writecr8(
+    IN_RANGE_UPPER(0xF) BYTE    Irql
+    );
+
+BYTE
+_InterlockedExchange8(
+    INOUT _Interlocked_operand_
+        BYTE volatile * _Target,
+    IN  BYTE _Value
+    );
+
+DWORD
+_InterlockedIncrement(
+    INOUT _Interlocked_operand_ DWORD volatile * _Addend
+    );
+
+BYTE
+_InterlockedCompareExchange8(
+    INOUT _Interlocked_operand_
+        BYTE volatile * _Destination,
+    IN  BYTE _Exchange,
+    IN  BYTE _Comparand
+    );
+
+WORD
+_InterlockedDecrement16(
+    INOUT _Interlocked_operand_ WORD volatile *Destination
+    );
+
+DWORD _InterlockedCompareExchange(
+    INOUT _Interlocked_operand_
+        DWORD volatile * _Destination,
+    IN  DWORD _Exchange,
+    IN  DWORD _Comparand
+    );
+
+WORD
+_InterlockedCompareExchange16(
+    INOUT _Interlocked_operand_
+        WORD volatile *Destination,
+    IN  WORD ExChange,
+    IN  WORD Comperand
+    );
+
+WORD
+_InterlockedOr16(
+    INOUT _Interlocked_operand_
+        WORD volatile *Destination,
+    IN  WORD Value
+    );
+
+WORD
+_InterlockedIncrement16(
+    INOUT _Interlocked_operand_ WORD volatile *Destination
+    );
+
+DWORD
+_InterlockedDecrement(
+    INOUT _Interlocked_operand_ DWORD volatile * _Addend
+    );
+
+_Success_(return == TRUE)
+BOOLEAN
+_rdrand16_step(
+    OUT WORD*       Value
+    );
+
+_Success_(return == TRUE)
+BOOLEAN
+_rdrand32_step(
+    OUT DWORD*      Value
+    );
+
+_Success_(return == TRUE)
+BOOLEAN
+_rdrand64_step(
+    OUT QWORD*      Value
+    );
+
+#pragma warning(pop)
+#endif // CL_NON_NATIVE
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/slist.h b/src_proiect/CommonLib/inc/slist.h
new file mode 100644
index 0000000..84d9c73
--- /dev/null
+++ b/src_proiect/CommonLib/inc/slist.h
@@ -0,0 +1,46 @@
+#pragma once
+
+C_HEADER_START
+typedef struct _CL_SLIST_ENTRY
+{
+    struct _CL_SLIST_ENTRY*    Next;
+} CL_SLIST_ENTRY, *PCL_SLIST_ENTRY;
+
+__forceinline
+void
+ClInitializeSListHead(
+    OUT     PCL_SLIST_ENTRY ListHead
+    )
+{
+    ListHead->Next = NULL;
+}
+
+__forceinline
+PCL_SLIST_ENTRY
+ClPopEntryList(
+    INOUT PCL_SLIST_ENTRY ListHead
+)
+{
+    PCL_SLIST_ENTRY FirstEntry;
+
+    FirstEntry = ListHead->Next;
+    if (FirstEntry != NULL)
+    {
+        ListHead->Next = FirstEntry->Next;
+    }
+
+    return FirstEntry;
+}
+
+__forceinline
+void
+ClPushEntryList(
+    INOUT PCL_SLIST_ENTRY ListHead,
+    INOUT PCL_SLIST_ENTRY Entry
+)
+{
+    Entry->Next = ListHead->Next;
+    ListHead->Next = Entry;
+    return;
+}
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/spinlock.h b/src_proiect/CommonLib/inc/spinlock.h
new file mode 100644
index 0000000..e7a35e8
--- /dev/null
+++ b/src_proiect/CommonLib/inc/spinlock.h
@@ -0,0 +1,81 @@
+#pragma once
+
+C_HEADER_START
+#pragma pack(push,16)
+typedef struct _SPINLOCK
+{
+    volatile BYTE       State;
+    PVOID               Holder;
+    PVOID               FunctionWhichTookLock;
+} SPINLOCK, *PSPINLOCK;
+#pragma pack(pop)
+
+//******************************************************************************
+// Function:     SpinlockInit
+// Description:  Initializes a spinlock. No other spinlock* function can be used
+//               before this function is called.
+// Returns:      void
+// Parameter:    OUT PSPINLOCK Lock
+//******************************************************************************
+void
+SpinlockInit(
+    OUT         PSPINLOCK       Lock
+    );
+
+//******************************************************************************
+// Function:     SpinlockAcquire
+// Description:  Spins until the Lock is acquired. On return interrupts will be
+//               disabled and IntrState will hold the previous interruptibility
+//               state.
+// Returns:      void
+// Parameter:    INOUT PSPINLOCK Lock
+// Parameter:    OUT INTR_STATE * IntrState
+//******************************************************************************
+void
+SpinlockAcquire(
+    INOUT       PSPINLOCK       Lock,
+    OUT         INTR_STATE*     IntrState
+    );
+
+//******************************************************************************
+// Function:     SpinlockTryAcquire
+// Description:  Attempts to acquire the Lock. If it is free then the function
+//               will take the lock and return with the interrupts disabled and
+//               IntrState will hold the previous interruptibility state.
+// Returns:      BOOLEAN - TRUE if the lock was acquired, FALSE otherwise
+// Parameter:    INOUT PSPINLOCK Lock
+// Parameter:    OUT INTR_STATE * IntrState
+//******************************************************************************
+BOOL_SUCCESS
+BOOLEAN
+SpinlockTryAcquire(
+    INOUT       PSPINLOCK       Lock,
+    OUT         INTR_STATE*     IntrState
+    );
+
+//******************************************************************************
+// Function:     SpinlockIsOwner
+// Description:  Checks if the current CPU is the lock owner.
+// Returns:      BOOLEAN
+// Parameter:    IN PSPINLOCK Lock
+//******************************************************************************
+BOOLEAN
+SpinlockIsOwner(
+    IN          PSPINLOCK       Lock
+    );
+
+//******************************************************************************
+// Function:     SpinlockRelease
+// Description:  Releases a previously acquired Lock. OldIntrState should hold
+//               the value previous returned by SpinlockAcquire or
+//               SpinlockTryAcquire.
+// Returns:      void
+// Parameter:    INOUT PSPINLOCK Lock
+// Parameter:    IN INTR_STATE OldIntrState
+//******************************************************************************
+void
+SpinlockRelease(
+    INOUT       PSPINLOCK       Lock,
+    IN          INTR_STATE      OldIntrState
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/stack_interface.h b/src_proiect/CommonLib/inc/stack_interface.h
new file mode 100644
index 0000000..fa3b837
--- /dev/null
+++ b/src_proiect/CommonLib/inc/stack_interface.h
@@ -0,0 +1,110 @@
+#pragma once
+
+C_HEADER_START
+#include "slist.h"
+#include "ref_cnt.h"
+
+typedef struct _STACK* PSTACK;
+
+typedef struct _STACK_ITEM
+{
+    CL_SLIST_ENTRY     Next;
+} STACK_ITEM, *PSTACK_ITEM;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_StackPush)(
+    INOUT   PSTACK          Stack,
+    IN      PSTACK_ITEM     Item
+    );
+
+typedef FUNC_StackPush*         PFUNC_StackPush;
+
+typedef
+_Must_inspect_result_
+_Success_(return != NULL)
+STACK_ITEM*
+(__cdecl FUNC_StackPop)(
+    INOUT   PSTACK          Stack
+    );
+
+typedef FUNC_StackPop*          PFUNC_StackPop;
+
+typedef
+_Must_inspect_result_
+_Success_(return != NULL)
+STACK_ITEM*
+(__cdecl FUNC_StackPeek)(
+    IN      PSTACK          Stack,
+    IN      DWORD           Index
+    );
+
+typedef FUNC_StackPeek*         PFUNC_StackPeek;
+
+typedef
+void
+(__cdecl FUNC_StackClear)(
+    INOUT   PSTACK              Stack,
+    IN_OPT  PFUNC_FreeFunction  FreeFunction,
+    IN_OPT  PVOID               FreeContext
+    );
+
+typedef FUNC_StackClear*        PFUNC_StackClear;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_StackIsEmpty)(
+        INOUT   PSTACK          Stack
+        );
+
+typedef FUNC_StackIsEmpty*      PFUNC_StackIsEmpty;
+
+typedef
+DWORD
+(__cdecl FUNC_StackSize)(
+    INOUT   PSTACK          Stack
+    );
+
+typedef FUNC_StackSize*         PFUNC_StackSize;
+
+
+typedef struct _STACK_INTERFACE_FUNCS
+{
+    PFUNC_StackPush                 Push;
+    PFUNC_StackPop                  Pop;
+    PFUNC_StackPeek                 Peek;
+    PFUNC_StackClear                Clear;
+
+    PFUNC_StackIsEmpty              IsEmpty;
+    PFUNC_StackSize                 Size;
+} STACK_INTERFACE_FUNCS, *PSTACK_INTERFACE_FUNCS;
+
+typedef struct _STACK_INTERFACE
+{
+    STACK_INTERFACE_FUNCS           Funcs;
+
+    PSTACK                          Stack;
+    DWORD                           MaxElements;
+} STACK_INTERFACE, *PSTACK_INTERFACE;
+
+typedef enum _STACK_TYPE
+{
+    StackTypeDynamic,
+    StackTypeInterlocked,
+
+    StackTypeReserved = StackTypeInterlocked + 1
+} STACK_TYPE;
+
+DWORD
+StackGetRequiredSize(
+    IN      DWORD                   MaxElements,
+    IN      STACK_TYPE              Type
+    );
+
+STATUS
+StackCreate(
+    OUT     PSTACK_INTERFACE        StackInterface,
+    IN      STACK_TYPE              Type,
+    OUT     PSTACK                  Stack
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/status.h b/src_proiect/CommonLib/inc/status.h
new file mode 100644
index 0000000..4d8381a
--- /dev/null
+++ b/src_proiect/CommonLib/inc/status.h
@@ -0,0 +1,366 @@
+#pragma once
+
+C_HEADER_START
+
+// every error/warning status code has the MSB set to 1
+#define FAIL_MASK                                       (1UL << 31)
+
+#define ERROR_MASK                                      (0b11UL << 30)
+#define WARNING_MASK                                    (0b10UL << 30)
+#define INFO_MASK                                       (0b01UL << 30)
+
+#define CUSTOMER_BIT                                    (1UL << 29)
+
+// nothing over (1<<27) should be used
+#define GENERAL_MASK                                    (1UL<<27)
+#define INTRO_MASK                                      (1UL<<26)
+#define VMX_MASK                                        (1UL<<25)
+#define CPU_MASK                                        (1UL<<24)
+#define COMM_MASK                                       (1UL<<23)
+#define TIMER_MASK                                      (1UL<<22)
+#define HEAP_MASK                                       (1UL<<21)
+#define MEMORY_MASK                                     (1UL<<20)
+#define STORAGE_MASK                                    (1UL<<19)
+#define DISK_MASK                                       (1UL<<18)
+#define APIC_MASK                                       (1UL<<17)
+#define DEVICE_MASK                                     (1UL<<16)
+#define RESERVED_MASK                                   (1UL<<16)
+// nothing under (1<<16) should be used
+
+// general errors
+#define CL_STATUS_UNSUPPORTED                              (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0001UL)
+#define CL_STATUS_INTERNAL_ERROR                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0002UL)
+#define CL_STATUS_UNSUCCESSFUL                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0003UL)
+#define CL_STATUS_ELEMENT_NOT_FOUND                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0004UL)
+#define CL_STATUS_ELEMENT_FOUND                            (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0005UL)
+#define CL_STATUS_LIST_EMPTY                               (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0006UL)
+#define CL_STATUS_ALREADY_INITIALIZED                      (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0007UL)
+#define CL_STATUS_ALREADY_INITIALIZED_HINT                 (INFO_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0008UL)
+#define CL_STATUS_INCOMPATIBLE_INTERFACE                   (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0009UL)
+#define CL_STATUS_INVALID_PARAMETER1                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0011UL)
+#define CL_STATUS_INVALID_PARAMETER2                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0012UL)
+#define CL_STATUS_INVALID_PARAMETER3                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0013UL)
+#define CL_STATUS_INVALID_PARAMETER4                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0014UL)
+#define CL_STATUS_INVALID_PARAMETER5                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0015UL)
+#define CL_STATUS_INVALID_PARAMETER6                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0016UL)
+#define CL_STATUS_INVALID_PARAMETER7                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0017UL)
+#define CL_STATUS_INVALID_PARAMETER8                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0018UL)
+#define CL_STATUS_INVALID_FILE_NAME                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0019UL)
+#define CL_STATUS_FILE_NOT_FOUND                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001AUL)
+#define CL_STATUS_FILE_TYPE_INVALID                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001BUL)
+#define CL_STATUS_TIME_INVALID                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001CUL)
+#define CL_STATUS_PATH_NOT_VALID                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001DUL)
+#define CL_STATUS_FILE_ALREADY_EXISTS                      (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001EUL)
+#define CL_STATUS_FILE_NOT_DIRECTORY                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x001FUL)
+#define CL_STATUS_NO_MORE_OBJECTS                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0020UL)
+#define CL_STATUS_PARSE_FAILED                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0021UL)
+#define CL_STATUS_JOB_INTERRUPTED                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0022UL)
+#define CL_STATUS_INVALID_MZ_IMAGE                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0023UL)
+#define CL_STATUS_INVALID_IMAGE_SIZE                       (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0024UL)
+#define CL_STATUS_INVALID_PE_IMAGE                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0025UL)
+#define CL_STATUS_IMAGE_NOT_64_BIT                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0026UL)
+#define CL_STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE               (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0027UL)
+#define CL_STATUS_IMAGE_NOT_FULLY_LOADED                   (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0028UL)
+#define CL_STATUS_IMAGE_HAS_RELOCATIONS                    (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0029UL)
+#define CL_STATUS_NOT_IMPLEMENTED                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002AUL)
+#define CL_STATUS_INVALID_FUNCTION                         (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002BUL)
+#define CL_STATUS_INVALID_BUFFER                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002CUL)
+#define CL_STATUS_NOT_INITIALIZED                          (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002DUL)
+#define CL_STATUS_NO_HANDLING_REQUIRED                     (INFO_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002EUL)
+#define CL_STATUS_CONFLICTING_OPTIONS                      (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x002FUL)
+#define CL_STATUS_ASSERTION_FAILURE                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0030UL)
+#define CL_STATUS_NO_DATA_AVAILABLE                        (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0031UL)
+#define CL_STATUS_LIMIT_REACHED                            (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0032UL)
+#define CL_STATUS_SIZE_INVALID                             (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0033UL)
+#define CL_STATUS_VALUE_MISMATCH                           (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0034UL)
+#define CL_STATUS_OPERATION_REQUIRES_HIGHER_CPL            (ERROR_MASK | CUSTOMER_BIT | GENERAL_MASK | 0x0035UL)
+
+// introspection errors
+#define CL_STATUS_INTRO_INVALID_SYSCALL_HANDLER            (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0001UL )
+#define CL_STATUS_INTRO_KERNEL_BASE_NOT_FOUND              (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0002UL )
+#define CL_STATUS_INTRO_KERNEL_INVALID_IMAGE               (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0003UL )
+#define CL_STATUS_INTRO_EXPORT_NOT_FOUND                   (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0004UL )
+#define CL_STATUS_INTRO_MODULE_LIST_NOT_FOUND              (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0005UL )
+#define CL_STATUS_INTRO_PCR_NOT_AVAILABLE                  (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0006UL )
+#define CL_STATUS_INTRO_KERNEL_ADDRESS_INVALID             (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0007UL )
+#define CL_STATUS_INTRO_VARIABLES_NOT_DEFINED              (INFO_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0008UL )
+#define CL_STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED        (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x0009UL )
+#define CL_STATUS_INTRO_PROCESS_NOT_VALID                  (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000AUL )
+#define CL_STATUS_INTRO_PATTERN_NOT_FOUND                  (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000BUL )
+#define CL_STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED      (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000CUL )
+#define CL_STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND            (ERROR_MASK | CUSTOMER_BIT | INTRO_MASK | 0x000DUL )
+
+// vmx related issues
+#define CL_STATUS_VMX_WRITE_FAILED                         (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0001UL )
+#define CL_STATUS_VMX_READ_FAILED                          (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0002UL )
+#define CL_STATUS_VMX_INVEPT_FAILED                        (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0003UL )
+#define CL_STATUS_VMX_EPT_MAPPING_FAILED                   (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0004UL )
+#define CL_STATUS_VMX_EXIT_NOT_IMPLEMENTED                 (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0005UL )
+#define CL_STATUS_VMX_FEATURE_NOT_SUPPORTED                (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0006UL )
+#define CL_STATUS_VMX_UNEXPECTED_VMCALL                    (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0007UL )
+#define CL_STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED        (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x0008UL )
+#define CL_STATUS_VMX_NO_CALLBACKS                         (WARNING_MASK | CUSTOMER_BIT | VMX_MASK | 0x0009UL )
+#define CL_STATUS_VMX_INCOMPATIBLE_CONFIGURATION           (ERROR_MASK | CUSTOMER_BIT | VMX_MASK | 0x000AUL )
+
+// cpu related errors
+#define CL_STATUS_CPU_UNSUPPORTED_FEATURE                  (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0001UL)
+#define CL_STATUS_CPU_MONITOR_NOT_SUPPORTED                (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0002UL)
+#define CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL        (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0003UL)
+#define CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE        (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0004UL)
+#define CL_STATUS_CPU_NO_MATCHES                           (INFO_MASK | CUSTOMER_BIT | CPU_MASK | 0x0005UL)
+#define CL_STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE        (ERROR_MASK | CUSTOMER_BIT | CPU_MASK | 0x0006UL)
+
+// communication related errors
+#define CL_STATUS_COMM_SERIAL_ALREADY_INITIALIZED          (INFO_MASK | CUSTOMER_BIT | COMM_MASK | 0x0001UL)
+#define CL_STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE           (INFO_MASK | CUSTOMER_BIT | COMM_MASK | 0x0002UL)
+#define CL_STATUS_COMM_SERIAL_NOT_INITIALIZED              (ERROR_MASK | CUSTOMER_BIT | COMM_MASK | 0x0003UL)
+#define CL_STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND          (ERROR_MASK | CUSTOMER_BIT | COMM_MASK | 0x0004UL)
+
+// timer related errors
+#define CL_STATUS_TIMER_INVALID_FREQUENCY                  (ERROR_MASK | CUSTOMER_BIT | TIMER_MASK | 0x0001UL)
+
+// heap related errors
+#define CL_STATUS_HEAP_TOO_SMALL                           (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0001UL)
+#define CL_STATUS_HEAP_ALREADY_INITIALIZED                 (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0002UL)
+#define CL_STATUS_HEAP_NO_MORE_MEMORY                      (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0003UL)
+#define CL_STATUS_HEAP_INSUFFICIENT_RESOURCES              (ERROR_MASK | CUSTOMER_BIT | HEAP_MASK | 0x0004UL)
+
+// memory related errors
+#define CL_STATUS_INVALID_POINTER                          (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0001UL)
+#define CL_STATUS_BUFFER_TOO_SMALL                         (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0002UL)
+#define CL_STATUS_INSUFFICIENT_MEMORY                      (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0003UL)
+#define CL_STATUS_MEMORY_CANNOT_BE_MAPPED                  (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0004UL)
+#define CL_STATUS_PHYSICAL_MEMORY_TOO_SMALL                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0005UL)
+#define CL_STATUS_MEMORY_IS_NOT_RESERVED                   (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0006UL)
+#define CL_STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE            (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0007UL)
+#define CL_STATUS_PAT_LAYOUT_NOT_COMPATIBLE                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0008UL)
+#define CL_STATUS_MEMORY_CANNOT_BE_RESERVED                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0009UL)
+#define CL_STATUS_MEMORY_ACCESS_DENIED                     (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000AUL)
+#define CL_STATUS_MEMORY_CANNOT_BE_COMMITED                (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000BUL)
+#define CL_STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS         (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000CUL)
+#define CL_STATUS_MEMORY_CONFLICTING_CACHEABILITY          (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000DUL)
+#define CL_STATUS_BUFFER_TOO_LARGE                         (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000EUL)
+#define CL_STATUS_MEMORY_ALREADY_RESERVED                  (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x000FUL)
+#define CL_STATUS_MEMORY_IS_NOT_COMMITED                   (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0010UL)
+#define CL_STATUS_MEMORY_PREVENTS_USERMODE_ACCESS          (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0011UL)
+#define CL_STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS        (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0012UL)
+#define CL_STATUS_PHYSICAL_MEMORY_QUOTA_EXCEEDED           (ERROR_MASK | CUSTOMER_BIT | MEMORY_MASK | 0x0013UL)
+
+// disk related errors
+#define CL_STATUS_DISK_MBR_NOT_PRESENT                     (ERROR_MASK | CUSTOMER_BIT | DISK_MASK | 0x0001UL)
+#define CL_STATUS_DISK_FULL                                (ERROR_MASK | CUSTOMER_BIT | DISK_MASK | 0x0002UL)
+
+// APIC errors
+#define CL_STATUS_APIC_NOT_MAPPED                          (ERROR_MASK | CUSTOMER_BIT | APIC_MASK | 0x0001UL)
+#define CL_STATUS_APIC_NOT_INITIALIZED                     (ERROR_MASK | CUSTOMER_BIT | APIC_MASK | 0x0002UL)
+#define CL_STATUS_APIC_NOT_ENABLED                         (ERROR_MASK | CUSTOMER_BIT | APIC_MASK | 0x0003UL)
+
+// device error
+#define CL_STATUS_DEVICE_DOES_NOT_EXIST                    (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0001UL)
+#define CL_STATUS_DEVICE_NO_MORE_DEVICES                   (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0002UL)
+#define CL_STATUS_DEVICE_NOT_SUPPORTED                     (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0003UL)
+#define CL_STATUS_DEVICE_NOT_INITIALIZED                   (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0004UL)
+#define CL_STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED            (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0005UL)
+#define CL_STATUS_DEVICE_SECTOR_COUNT_EXCEEDED             (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0006UL)
+#define CL_STATUS_DEVICE_COULD_NOT_BE_CREATED              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0007UL)
+#define CL_STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED       (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0008UL)
+#define CL_STATUS_DEVICE_INVALID_OPERATION                 (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0009UL)
+#define CL_STATUS_DEVICE_DATA_ALIGNMENT_ERROR              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000AUL)
+#define CL_STATUS_DEVICE_NO_FILESYSTEM_MOUNTED             (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000BUL)
+#define CL_STATUS_DEVICE_FILESYSTEM_UNSUPPORTED            (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000CUL)
+#define CL_STATUS_DEVICE_CLUSTER_INVALID                   (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000DUL)
+#define CL_STATUS_DEVICE_ALIGNMENT_NO_SATISFIED            (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000EUL)
+#define CL_STATUS_DEVICE_DMA_NOT_SUPPORTED                 (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x000FUL)
+#define CL_STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH     (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0010UL)
+#define CL_STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE       (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0011UL)
+#define CL_STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE           (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0012UL)
+#define CL_STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY         (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0013UL)
+#define CL_STATUS_DEVICE_DOES_NOT_EXIST_HINT               (INFO_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0014UL)
+#define CL_STATUS_DEVICE_NOT_READY                         (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0015UL)
+#define CL_STATUS_DEVICE_DISABLED                          (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0016UL)
+#define CL_STATUS_DEVICE_NOT_CONNECTED                     (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0017UL)
+#define CL_STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED          (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0018UL)
+#define CL_STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED        (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x0019UL)
+#define CL_STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST         (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001AUL)
+#define CL_STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED      (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001BUL)
+#define CL_STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE  (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001CUL)
+#define CL_STATUS_DEVICE_SPACE_RANGE_EXCEEDED              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001DUL)
+#define CL_STATUS_DEVICE_TYPE_INVALID                      (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001EUL)
+#define CL_STATUS_DEVICE_BUSY                              (ERROR_MASK | CUSTOMER_BIT | DEVICE_MASK | 0x001FUL)
+
+// success status
+#define CL_STATUS_SUCCESS                                  0UL
+
+// check if a status was successful
+#define SUCCEEDED(x)                                    (0 == ( (x) & FAIL_MASK ) )
+
+typedef _Return_type_success_(SUCCEEDED(return)) DWORD  STATUS;
+
+#ifndef CL_NON_NATIVE
+
+// general errors
+#define STATUS_UNSUPPORTED                              CL_STATUS_UNSUPPORTED
+#define STATUS_INTERNAL_ERROR                           CL_STATUS_INTERNAL_ERROR
+#define STATUS_UNSUCCESSFUL                             CL_STATUS_UNSUCCESSFUL
+#define STATUS_ELEMENT_NOT_FOUND                        CL_STATUS_ELEMENT_NOT_FOUND
+#define STATUS_ELEMENT_FOUND                            CL_STATUS_ELEMENT_FOUND
+#define STATUS_LIST_EMPTY                               CL_STATUS_LIST_EMPTY
+#define STATUS_ALREADY_INITIALIZED                      CL_STATUS_ALREADY_INITIALIZED
+#define STATUS_ALREADY_INITIALIZED_HINT                 CL_STATUS_ALREADY_INITIALIZED_HINT
+#define STATUS_INCOMPATIBLE_INTERFACE                   CL_STATUS_INCOMPATIBLE_INTERFACE
+#define STATUS_INVALID_PARAMETER1                       CL_STATUS_INVALID_PARAMETER1
+#define STATUS_INVALID_PARAMETER2                       CL_STATUS_INVALID_PARAMETER2
+#define STATUS_INVALID_PARAMETER3                       CL_STATUS_INVALID_PARAMETER3
+#define STATUS_INVALID_PARAMETER4                       CL_STATUS_INVALID_PARAMETER4
+#define STATUS_INVALID_PARAMETER5                       CL_STATUS_INVALID_PARAMETER5
+#define STATUS_INVALID_PARAMETER6                       CL_STATUS_INVALID_PARAMETER6
+#define STATUS_INVALID_PARAMETER7                       CL_STATUS_INVALID_PARAMETER7
+#define STATUS_INVALID_PARAMETER8                       CL_STATUS_INVALID_PARAMETER8
+#define STATUS_INVALID_FILE_NAME                        CL_STATUS_INVALID_FILE_NAME
+#define STATUS_FILE_NOT_FOUND                           CL_STATUS_FILE_NOT_FOUND
+#define STATUS_FILE_TYPE_INVALID                        CL_STATUS_FILE_TYPE_INVALID
+#define STATUS_TIME_INVALID                             CL_STATUS_TIME_INVALID
+#define STATUS_PATH_NOT_VALID                           CL_STATUS_PATH_NOT_VALID
+#define STATUS_FILE_ALREADY_EXISTS                      CL_STATUS_FILE_ALREADY_EXISTS
+#define STATUS_FILE_NOT_DIRECTORY                       CL_STATUS_FILE_NOT_DIRECTORY
+#define STATUS_NO_MORE_OBJECTS                          CL_STATUS_NO_MORE_OBJECTS
+#define STATUS_PARSE_FAILED                             CL_STATUS_PARSE_FAILED
+#define STATUS_JOB_INTERRUPTED                          CL_STATUS_JOB_INTERRUPTED
+#define STATUS_INVALID_MZ_IMAGE                         CL_STATUS_INVALID_MZ_IMAGE
+#define STATUS_INVALID_IMAGE_SIZE                       CL_STATUS_INVALID_IMAGE_SIZE
+#define STATUS_INVALID_PE_IMAGE                         CL_STATUS_INVALID_PE_IMAGE
+#define STATUS_IMAGE_NOT_64_BIT                         CL_STATUS_IMAGE_NOT_64_BIT
+#define STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE               CL_STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE
+#define STATUS_IMAGE_NOT_FULLY_LOADED                   CL_STATUS_IMAGE_NOT_FULLY_LOADED
+#define STATUS_IMAGE_HAS_RELOCATIONS                    CL_STATUS_IMAGE_HAS_RELOCATIONS
+#define STATUS_NOT_IMPLEMENTED                          CL_STATUS_NOT_IMPLEMENTED
+#define STATUS_INVALID_FUNCTION                         CL_STATUS_INVALID_FUNCTION
+#define STATUS_INVALID_BUFFER                           CL_STATUS_INVALID_BUFFER
+#define STATUS_NOT_INITIALIZED                          CL_STATUS_NOT_INITIALIZED
+#define STATUS_NO_HANDLING_REQUIRED                     CL_STATUS_NO_HANDLING_REQUIRED
+#define STATUS_CONFLICTING_OPTIONS                      CL_STATUS_CONFLICTING_OPTIONS
+#define STATUS_ASSERTION_FAILURE                        CL_STATUS_ASSERTION_FAILURE
+#define STATUS_NO_DATA_AVAILABLE                        CL_STATUS_NO_DATA_AVAILABLE
+#define STATUS_LIMIT_REACHED                            CL_STATUS_LIMIT_REACHED
+#define STATUS_SIZE_INVALID                             CL_STATUS_SIZE_INVALID
+#define STATUS_VALUE_MISMATCH                           CL_STATUS_VALUE_MISMATCH
+#define STATUS_OPERATION_REQUIRES_HIGHER_CPL            CL_STATUS_OPERATION_REQUIRES_HIGHER_CPL
+
+// introspection errors
+#define STATUS_INTRO_INVALID_SYSCALL_HANDLER            CL_STATUS_INTRO_INVALID_SYSCALL_HANDLER
+#define STATUS_INTRO_KERNEL_BASE_NOT_FOUND              CL_STATUS_INTRO_KERNEL_BASE_NOT_FOUND
+#define STATUS_INTRO_KERNEL_INVALID_IMAGE               CL_STATUS_INTRO_KERNEL_INVALID_IMAGE
+#define STATUS_INTRO_EXPORT_NOT_FOUND                   CL_STATUS_INTRO_EXPORT_NOT_FOUND
+#define STATUS_INTRO_MODULE_LIST_NOT_FOUND              CL_STATUS_INTRO_MODULE_LIST_NOT_FOUND
+#define STATUS_INTRO_PCR_NOT_AVAILABLE                  CL_STATUS_INTRO_PCR_NOT_AVAILABLE
+#define STATUS_INTRO_KERNEL_ADDRESS_INVALID             CL_STATUS_INTRO_KERNEL_ADDRESS_INVALID
+#define STATUS_INTRO_VARIABLES_NOT_DEFINED              CL_STATUS_INTRO_VARIABLES_NOT_DEFINED
+#define STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED        CL_STATUS_INTRO_INTROSPECTION_NOT_SUPPORTED
+#define STATUS_INTRO_PROCESS_NOT_VALID                  CL_STATUS_INTRO_PROCESS_NOT_VALID
+#define STATUS_INTRO_PATTERN_NOT_FOUND                  CL_STATUS_INTRO_PATTERN_NOT_FOUND
+#define STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED      CL_STATUS_INTRO_INTROSPECTION_NOT_INITIALIZED
+#define STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND            CL_STATUS_INTRO_DEBUGGER_DATA_NOT_FOUND
+
+// vmx related issues
+#define STATUS_VMX_WRITE_FAILED                         CL_STATUS_VMX_WRITE_FAILED
+#define STATUS_VMX_READ_FAILED                          CL_STATUS_VMX_READ_FAILED
+#define STATUS_VMX_INVEPT_FAILED                        CL_STATUS_VMX_INVEPT_FAILED
+#define STATUS_VMX_EPT_MAPPING_FAILED                   CL_STATUS_VMX_EPT_MAPPING_FAILED
+#define STATUS_VMX_EXIT_NOT_IMPLEMENTED                 CL_STATUS_VMX_EXIT_NOT_IMPLEMENTED
+#define STATUS_VMX_FEATURE_NOT_SUPPORTED                CL_STATUS_VMX_FEATURE_NOT_SUPPORTED
+#define STATUS_VMX_UNEXPECTED_VMCALL                    CL_STATUS_VMX_UNEXPECTED_VMCALL
+#define STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED        CL_STATUS_VMX_GUEST_MEMORY_CANNOT_BE_MAPPED
+#define STATUS_VMX_NO_CALLBACKS                         CL_STATUS_VMX_NO_CALLBACKS
+#define STATUS_VMX_INCOMPATIBLE_CONFIGURATION           CL_STATUS_VMX_INCOMPATIBLE_CONFIGURATION
+
+// cpu related errors
+#define STATUS_CPU_UNSUPPORTED_FEATURE                  CL_STATUS_CPU_UNSUPPORTED_FEATURE
+#define STATUS_CPU_MONITOR_NOT_SUPPORTED                CL_STATUS_CPU_MONITOR_NOT_SUPPORTED
+#define STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL        CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL
+#define STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE        CL_STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE
+#define STATUS_CPU_NO_MATCHES                           CL_STATUS_CPU_NO_MATCHES
+#define STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE        CL_STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE
+
+// communication related errors
+#define STATUS_COMM_SERIAL_ALREADY_INITIALIZED          CL_STATUS_COMM_SERIAL_ALREADY_INITIALIZED
+#define STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE           CL_STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE
+#define STATUS_COMM_SERIAL_NOT_INITIALIZED              CL_STATUS_COMM_SERIAL_NOT_INITIALIZED
+#define STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND          CL_STATUS_COMM_VMCALL_UNSUPPORTED_COMMAND
+
+// timer related errors
+#define STATUS_TIMER_INVALID_FREQUENCY                  CL_STATUS_TIMER_INVALID_FREQUENCY
+
+// heap related errors
+#define STATUS_HEAP_TOO_SMALL                           CL_STATUS_HEAP_TOO_SMALL
+#define STATUS_HEAP_ALREADY_INITIALIZED                 CL_STATUS_HEAP_ALREADY_INITIALIZED
+#define STATUS_HEAP_NO_MORE_MEMORY                      CL_STATUS_HEAP_NO_MORE_MEMORY
+#define STATUS_HEAP_INSUFFICIENT_RESOURCES              CL_STATUS_HEAP_INSUFFICIENT_RESOURCES
+
+// memory related errors
+#define STATUS_INVALID_POINTER                          CL_STATUS_INVALID_POINTER
+#define STATUS_BUFFER_TOO_SMALL                         CL_STATUS_BUFFER_TOO_SMALL
+#define STATUS_INSUFFICIENT_MEMORY                      CL_STATUS_INSUFFICIENT_MEMORY
+#define STATUS_MEMORY_CANNOT_BE_MAPPED                  CL_STATUS_MEMORY_CANNOT_BE_MAPPED
+#define STATUS_PHYSICAL_MEMORY_TOO_SMALL                CL_STATUS_PHYSICAL_MEMORY_TOO_SMALL
+#define STATUS_MEMORY_IS_NOT_RESERVED                   CL_STATUS_MEMORY_IS_NOT_RESERVED
+#define STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE            CL_STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE
+#define STATUS_PAT_LAYOUT_NOT_COMPATIBLE                CL_STATUS_PAT_LAYOUT_NOT_COMPATIBLE
+#define STATUS_MEMORY_CANNOT_BE_RESERVED                CL_STATUS_MEMORY_CANNOT_BE_RESERVED
+#define STATUS_MEMORY_ACCESS_DENIED                     CL_STATUS_MEMORY_ACCESS_DENIED
+#define STATUS_MEMORY_CANNOT_BE_COMMITED                CL_STATUS_MEMORY_CANNOT_BE_COMMITED
+#define STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS         CL_STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS
+#define STATUS_MEMORY_CONFLICTING_CACHEABILITY          CL_STATUS_MEMORY_CONFLICTING_CACHEABILITY
+#define STATUS_BUFFER_TOO_LARGE                         CL_STATUS_BUFFER_TOO_LARGE
+#define STATUS_MEMORY_ALREADY_RESERVED                  CL_STATUS_MEMORY_ALREADY_RESERVED
+#define STATUS_MEMORY_IS_NOT_COMMITED                   CL_STATUS_MEMORY_IS_NOT_COMMITED
+#define STATUS_MEMORY_PREVENTS_USERMODE_ACCESS          CL_STATUS_MEMORY_PREVENTS_USERMODE_ACCESS
+#define STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS        CL_STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS
+#define STATUS_PHYSICAL_MEMORY_QUOTA_EXCEEDED           CL_STATUS_PHYSICAL_MEMORY_QUOTA_EXCEEDED
+
+// disk related errors
+#define STATUS_DISK_MBR_NOT_PRESENT                     CL_STATUS_DISK_MBR_NOT_PRESENT
+#define STATUS_DISK_FULL                                CL_STATUS_DISK_FULL
+
+// APIC errors
+#define STATUS_APIC_NOT_MAPPED                          CL_STATUS_APIC_NOT_MAPPED
+#define STATUS_APIC_NOT_INITIALIZED                     CL_STATUS_APIC_NOT_INITIALIZED
+#define STATUS_APIC_NOT_ENABLED                         CL_STATUS_APIC_NOT_ENABLED
+
+// device error
+#define STATUS_DEVICE_DOES_NOT_EXIST                    CL_STATUS_DEVICE_DOES_NOT_EXIST
+#define STATUS_DEVICE_NO_MORE_DEVICES                   CL_STATUS_DEVICE_NO_MORE_DEVICES
+#define STATUS_DEVICE_NOT_SUPPORTED                     CL_STATUS_DEVICE_NOT_SUPPORTED
+#define STATUS_DEVICE_NOT_INITIALIZED                   CL_STATUS_DEVICE_NOT_INITIALIZED
+#define STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED            CL_STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED
+#define STATUS_DEVICE_SECTOR_COUNT_EXCEEDED             CL_STATUS_DEVICE_SECTOR_COUNT_EXCEEDED
+#define STATUS_DEVICE_COULD_NOT_BE_CREATED              CL_STATUS_DEVICE_COULD_NOT_BE_CREATED
+#define STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED       CL_STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED
+#define STATUS_DEVICE_INVALID_OPERATION                 CL_STATUS_DEVICE_INVALID_OPERATION
+#define STATUS_DEVICE_DATA_ALIGNMENT_ERROR              CL_STATUS_DEVICE_DATA_ALIGNMENT_ERROR
+#define STATUS_DEVICE_NO_FILESYSTEM_MOUNTED             CL_STATUS_DEVICE_NO_FILESYSTEM_MOUNTED
+#define STATUS_DEVICE_FILESYSTEM_UNSUPPORTED            CL_STATUS_DEVICE_FILESYSTEM_UNSUPPORTED
+#define STATUS_DEVICE_CLUSTER_INVALID                   CL_STATUS_DEVICE_CLUSTER_INVALID
+#define STATUS_DEVICE_ALIGNMENT_NO_SATISFIED            CL_STATUS_DEVICE_ALIGNMENT_NO_SATISFIED
+#define STATUS_DEVICE_DMA_NOT_SUPPORTED                 CL_STATUS_DEVICE_DMA_NOT_SUPPORTED
+#define STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH     CL_STATUS_DEVICE_DMA_PHYSICAL_ADDRESS_TOO_HIGH
+#define STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE       CL_STATUS_DEVICE_DMA_PHYSICAL_SPAN_TOO_LARGE
+#define STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE           CL_STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE
+#define STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY         CL_STATUS_DEVICE_DMA_SPAN_CROSSES_BOUNDARY
+#define STATUS_DEVICE_DOES_NOT_EXIST_HINT               CL_STATUS_DEVICE_DOES_NOT_EXIST_HINT
+#define STATUS_DEVICE_NOT_READY                         CL_STATUS_DEVICE_NOT_READY
+#define STATUS_DEVICE_DISABLED                          CL_STATUS_DEVICE_DISABLED
+#define STATUS_DEVICE_NOT_CONNECTED                     CL_STATUS_DEVICE_NOT_CONNECTED
+#define STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED          CL_STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED
+#define STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED        CL_STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED
+#define STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST         CL_STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST
+#define STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED      CL_STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED
+#define STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE  CL_STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE
+#define STATUS_DEVICE_SPACE_RANGE_EXCEEDED              CL_STATUS_DEVICE_SPACE_RANGE_EXCEEDED
+#define STATUS_DEVICE_TYPE_INVALID                      CL_STATUS_DEVICE_TYPE_INVALID
+#define STATUS_DEVICE_BUSY                              CL_STATUS_DEVICE_BUSY
+
+// success status
+#define STATUS_SUCCESS                                  CL_STATUS_SUCCESS
+#endif // CL_NON_NATIVE
+
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/strutils.h b/src_proiect/CommonLib/inc/strutils.h
new file mode 100644
index 0000000..aff60b2
--- /dev/null
+++ b/src_proiect/CommonLib/inc/strutils.h
@@ -0,0 +1,55 @@
+#pragma once
+
+C_HEADER_START
+// most often used numbering bases
+#define BASE_TWO            2
+#define BASE_TEN            10
+#define BASE_HEXA           16
+
+#define isascii(c)          ( ( 0x1F < (c)) && ((c) < 0x80) )
+#define isupper(c)          ( ( 'A' <= (c)) && ((c) <= 'Z' ) )
+#define islower(c)          ( ( 'a' <= (c)) && ((c) <= 'z'))
+#define tolower(c)          ( (c) | LOWER_UPPER_DIFF)
+#define toupper(c)          ( (c) & (~LOWER_UPPER_DIFF))
+#define isspace(c)          ((' ' == (c)) || ('\t' == (c)) || ('\n' == (c)) || ('\r' == (c)))
+
+#define LOWER_UPPER_DIFF    ('a' - 'A')
+
+//******************************************************************************
+// Function:      itoa
+// Description:   Converts a number into its string representation from the
+//                specified base.
+//                If the number digits occupied by value in base Base is under
+//                MinimumDigits then the rest is completed with leading zeros.
+// Returns:       void
+// Parameter:     IN PVOID valueAddress - Pointer to the number to convert
+// Parameter:     IN BOOLEAN signedValue - If set the value is signed, else unsigned
+// Parameter:     OUT char * buffer - Buffer in which to write the number
+// Parameter:     IN DWORD base - Numeric base of the input value
+// Parameter:     IN DWORD minimumDigits - The minimum number of digits to place
+//                in the buffer
+// Parameter:     IN BOOLEAN is64BitValue - If set the value is treated as a 64bit
+//                value
+//******************************************************************************
+void
+itoa(
+    IN      PVOID       valueAddress,
+    IN      BOOLEAN     signedValue,
+    OUT_Z   char*       buffer,
+    IN      DWORD       base,
+    IN      BOOLEAN     is64BitValue
+    );
+
+void
+atoi(
+    _When_(!is64BitValue, OUT_WRITES_BYTES_ALL(sizeof(DWORD)))
+    _When_(is64BitValue, OUT_WRITES_BYTES_ALL(sizeof(QWORD)))
+            PVOID       valueAddress,
+    IN_Z    char*       buffer,
+    IN      DWORD       base,
+    IN      BOOLEAN     is64BitValue
+    );
+
+#define atoi32(addr,buf,base)       atoi((addr),(buf),(base),FALSE)
+#define atoi64(addr,buf,base)       atoi((addr),(buf),(base),TRUE)
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/time.h b/src_proiect/CommonLib/inc/time.h
new file mode 100644
index 0000000..3a58a83
--- /dev/null
+++ b/src_proiect/CommonLib/inc/time.h
@@ -0,0 +1,33 @@
+#pragma once
+
+C_HEADER_START
+#pragma pack(push,8)
+typedef struct _DATE
+{
+    BYTE			Day;
+    BYTE			Month;
+    WORD			Year;
+} DATE, *PDATE;
+
+typedef struct _TIME
+{
+    BYTE			Second;
+    BYTE			Minute;
+    BYTE			Hour;
+} TIME, *PTIME;
+
+typedef struct _DATETIME
+{
+    DATE			Date;
+    TIME			Time;
+} DATETIME, *PDATETIME;
+STATIC_ASSERT(sizeof(DATETIME) == sizeof(QWORD));
+#pragma pack(pop)
+
+STATUS
+TimeGetStringFormattedBuffer(
+    IN                          DATETIME        DateTime,
+    OUT_WRITES_Z(BufferSize)    char*           Buffer,
+    IN                          DWORD           BufferSize
+    );
+C_HEADER_END
diff --git a/src_proiect/CommonLib/inc/va_list.h b/src_proiect/CommonLib/inc/va_list.h
new file mode 100644
index 0000000..1ccc93b
--- /dev/null
+++ b/src_proiect/CommonLib/inc/va_list.h
@@ -0,0 +1,19 @@
+#pragma once
+
+C_HEADER_START
+#ifndef _VA_LIST_DEFINED
+#define _VA_LIST_DEFINED
+typedef PBYTE               va_list;
+#endif
+
+#define STACKITEM_SIZE      sizeof(PVOID)
+
+// Initializes the va_list
+#define va_start(List,LastArg)     \
+            ((List)=((va_list)&(LastArg) + STACKITEM_SIZE))
+
+// Retrieves the value of the next argument
+// And increases the List pointer
+#define va_arg(List, Type)	\
+	((List) += STACKITEM_SIZE, *((Type *)((List) - STACKITEM_SIZE)))
+C_HEADER_END
diff --git a/src_proiect/CommonLib/src/_gs_checks.yasm b/src_proiect/CommonLib/src/_gs_checks.yasm
new file mode 100644
index 0000000..34c50e6
--- /dev/null
+++ b/src_proiect/CommonLib/src/_gs_checks.yasm
@@ -0,0 +1,28 @@
+%ifdef CL_NO_RUNTIME_CHECKS
+
+%else
+global __security_check_cookie
+
+extern __report_cookie_corruption
+extern __security_cookie
+
+[BITS 64]
+align 0x10, db 0
+__security_check_cookie:
+    ; store rax
+    mov             r11, rax
+    mov             rax, [QWORD __security_cookie]
+
+    cmp             rcx, rax
+
+    je              .end
+
+    jmp             __report_cookie_corruption
+
+    ; we should not return
+    int 3
+
+.end:
+    mov             rax, r11
+    ret
+%endif ; CL_NO_RUNTIME_CHECKS
diff --git a/src_proiect/CommonLib/src/assert.c b/src_proiect/CommonLib/src/assert.c
new file mode 100644
index 0000000..2384ddf
--- /dev/null
+++ b/src_proiect/CommonLib/src/assert.c
@@ -0,0 +1,95 @@
+#include "common_lib.h"
+#include "assert.h"
+#include "lock_common.h"
+
+#define ASSERT_BUFFER_SIZE              512
+
+static char                             m_assertBuffer[ASSERT_BUFFER_SIZE];
+static PFUNC_AssertFunction             m_pAssertFunction = NULL;
+
+#ifndef _COMMONLIB_NO_LOCKS_
+static LOCK                             m_assertLock;
+#endif // _COMMONLIB_NO_LOCKS_
+
+// This function is called in case no assert function is registered
+static FUNC_AssertFunction              _AssertDefaultFunction;
+
+void
+AssertInfo(
+    IN_Z            char*       Message,
+    ...
+    )
+{
+    STATUS status;
+    va_list va;
+#ifndef _COMMONLIB_NO_LOCKS_
+    INTR_STATE oldState;
+#endif // _COMMONLIB_NO_LOCKS_
+
+    status = STATUS_SUCCESS;
+
+    va_start(va, Message);
+
+#ifndef _COMMONLIB_NO_LOCKS_
+    LockAcquire(&m_assertLock, &oldState );
+#endif // _COMMONLIB_NO_LOCKS_
+
+    // we really have to assume the call is successful
+    // because even if it fails we have nothing to do:
+    // 1. If we ASSERT again this function will be called recursively => BAD
+    // 2. If we return from the function => the ASSERT will have no effect => BAD
+    status = vsnprintf(m_assertBuffer, ASSERT_BUFFER_SIZE, Message, va);
+    _Analysis_assume_(SUCCEEDED(status));
+
+    // call the assert function after the string was formated
+
+    // if the AssertFunction is NULL we will use the default assert function
+    if (NULL == m_pAssertFunction)
+    {
+        _AssertDefaultFunction(m_assertBuffer);
+    }
+    else
+    {
+        m_pAssertFunction(m_assertBuffer);
+    }
+
+#ifndef _COMMONLIB_NO_LOCKS_
+    LockRelease(&m_assertLock, oldState );
+#endif // _COMMONLIB_NO_LOCKS_
+}
+
+void
+AssertSetFunction(
+    IN              PFUNC_AssertFunction    AssertFunction
+    )
+{
+    m_pAssertFunction = AssertFunction;
+
+#ifndef _COMMONLIB_NO_LOCKS_
+    LockInit(&m_assertLock);
+#endif // _COMMONLIB_NO_LOCKS_
+}
+
+void
+(__cdecl _AssertDefaultFunction)(
+    IN_Z            char*           Message
+    )
+{
+    UNREFERENCED_PARAMETER(Message);
+
+    __halt();
+}
+
+#ifndef _COMMONLIB_NO_LOCKS_
+REQUIRES_EXCL_LOCK(m_assertLock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_assertLock)
+void
+AssertFreeLock(
+    void
+    )
+{
+    _Analysis_assume_lock_acquired_(m_assertLock);
+
+    LockRelease(&m_assertLock, INTR_OFF );
+}
+#endif // _COMMONLIB_NO_LOCKS_
diff --git a/src_proiect/CommonLib/src/bitmap.c b/src_proiect/CommonLib/src/bitmap.c
new file mode 100644
index 0000000..6aaa4ed
--- /dev/null
+++ b/src_proiect/CommonLib/src/bitmap.c
@@ -0,0 +1,361 @@
+#include "common_lib.h"
+#include "bitmap.h"
+
+// we defined BITMAP_ENTRY_BITS directly to 32 so as not to call
+// BITS_FOR_STRUCTURE for each index calculation
+#define BITMAP_ENTRY_BITS           8
+
+static
+void
+_BitmapChangeBit(
+    INOUT       PBYTE       BitmapBuffer,
+    IN          DWORD       Index,
+    IN          BOOLEAN     Set
+    );
+
+static
+void
+_BitmapChangeBits(
+    INOUT       PBYTE       BitmapBuffer,
+    IN          DWORD       Index,
+    IN          BOOLEAN     Set,
+    IN          DWORD       Count
+    );
+
+static
+BOOLEAN
+_BitmapGetBit(
+    IN          PBYTE       BitmapBuffer,
+    IN          DWORD       Index
+    );
+
+static
+SIZE_SUCCESS
+DWORD
+_BitmapScanInternal(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       StartIndex,
+    IN          DWORD       FirstInvalidBitIndex,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    );
+
+DWORD
+BitmapPreinit(
+    OUT         PBITMAP     Bitmap,
+    IN          DWORD       NumberOfElements
+    )
+{
+    ASSERT( NULL != Bitmap );
+    ASSERT( 0 != NumberOfElements );
+
+    memzero(Bitmap, sizeof(BITMAP));
+
+    Bitmap->BitCount = NumberOfElements;
+    Bitmap->BufferSize = ( AlignAddressUpper(Bitmap->BitCount, BITMAP_ENTRY_BITS) / BITMAP_ENTRY_BITS ) * sizeof(BYTE);
+
+    return Bitmap->BufferSize;
+}
+
+void
+BitmapInitEx(
+    INOUT       PBITMAP     Bitmap,
+    IN          PBYTE       BitmapBuffer,
+    IN          BOOLEAN     Set
+    )
+{
+    ASSERT(NULL != Bitmap);
+    ASSERT(NULL != BitmapBuffer);
+
+    memset(BitmapBuffer,
+           Set ? MAX_BYTE : 0,
+           Bitmap->BufferSize);
+
+    Bitmap->BitmapBuffer = BitmapBuffer;
+}
+
+void
+BitmapUninit(
+    INOUT       PBITMAP     Bitmap
+    )
+{
+    ASSERT( NULL != Bitmap );
+
+    memzero(Bitmap, sizeof(BITMAP));
+}
+
+DWORD
+BitmapGetMaxElementCount(
+    IN          PBITMAP     Bitmap
+    )
+{
+    ASSERT(NULL != Bitmap);
+
+    return Bitmap->BitCount;
+}
+
+void
+BitmapSetBitValue(
+    INOUT		PBITMAP		Bitmap,
+    IN			DWORD       Index,
+    IN          BOOLEAN     Set
+    )
+{
+    ASSERT(NULL != Bitmap);
+    ASSERT(Index < Bitmap->BitCount);
+
+    _BitmapChangeBit(Bitmap->BitmapBuffer, Index, Set);
+}
+
+BOOLEAN
+BitmapGetBitValue(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       Index
+    )
+{
+    ASSERT(NULL != Bitmap);
+    ASSERT(Index < Bitmap->BitCount);
+
+    return _BitmapGetBit(Bitmap->BitmapBuffer, Index );
+}
+
+void
+BitmapSetBitsValue(
+    INOUT		PBITMAP		Bitmap,
+    IN			DWORD       Index,
+    IN          DWORD       Count,
+    IN          BOOLEAN     Set
+    )
+{
+    ASSERT(NULL != Bitmap);
+    ASSERT(Index < Bitmap->BitCount);
+    ASSERT(Bitmap->BitCount - Count >= Index);
+
+    _BitmapChangeBits(Bitmap->BitmapBuffer, Index, Set, Count);
+}
+
+SIZE_SUCCESS
+DWORD
+BitmapScan(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    )
+{
+    return BitmapScanFromTo(Bitmap,0,  Bitmap->BitCount, ConsecutiveBits,Set);
+}
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFrom(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    )
+{
+    return BitmapScanFromTo(Bitmap,Index, Bitmap->BitCount, ConsecutiveBits,Set);
+}
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFromTo(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       FirstInvalidBitIndex,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+)
+{
+    if (NULL == Bitmap)
+    {
+        return MAX_DWORD;
+    }
+
+    if (0 == ConsecutiveBits)
+    {
+        return MAX_DWORD;
+    }
+
+    if( Index > FirstInvalidBitIndex || FirstInvalidBitIndex > Bitmap->BitCount)
+    {
+        return MAX_DWORD;
+    }
+
+    return _BitmapScanInternal(Bitmap, Index, FirstInvalidBitIndex, ConsecutiveBits, Set);
+}
+
+SIZE_SUCCESS
+DWORD
+BitmapScanAndFlip(
+    INOUT       PBITMAP     Bitmap,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    )
+{
+    return BitmapScanFromToAndFlip(Bitmap, 0, Bitmap->BitCount, ConsecutiveBits, Set);
+}
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFromAndFlip(
+    INOUT       PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    )
+{
+    return BitmapScanFromToAndFlip(Bitmap, Index, Bitmap->BitCount, ConsecutiveBits, Set );
+}
+
+SIZE_SUCCESS
+DWORD
+BitmapScanFromToAndFlip(
+    INOUT       PBITMAP     Bitmap,
+    IN          DWORD       Index,
+    IN          DWORD       FirstInvalidBitIndex,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+)
+{
+    DWORD bitmapIndex;
+
+    if (NULL == Bitmap)
+    {
+        return MAX_DWORD;
+    }
+
+    if (0 == ConsecutiveBits)
+    {
+        return MAX_DWORD;
+    }
+
+    if( Index > FirstInvalidBitIndex || FirstInvalidBitIndex > Bitmap->BitCount)
+    {
+        return MAX_DWORD;
+    }
+
+    bitmapIndex = _BitmapScanInternal(Bitmap, Index, FirstInvalidBitIndex, ConsecutiveBits, Set);
+    if (MAX_DWORD == bitmapIndex)
+    {
+        return MAX_DWORD;
+    }
+
+    // let's flip these bits
+    _BitmapChangeBits(Bitmap->BitmapBuffer, bitmapIndex, !Set, ConsecutiveBits);
+
+    return bitmapIndex;
+}
+
+static
+void
+_BitmapChangeBit(
+    INOUT       PBYTE       BitmapBuffer,
+    IN          DWORD       Index,
+    IN          BOOLEAN     Set
+    )
+{
+    DWORD byteIndex;
+    DWORD bitIndex;
+
+    ASSERT( NULL != BitmapBuffer );
+
+    byteIndex = Index / BITMAP_ENTRY_BITS;
+    bitIndex = Index % BITMAP_ENTRY_BITS;
+
+    if (Set)
+    {
+        BitmapBuffer[byteIndex] |= ( 1 << bitIndex );
+    }
+    else
+    {
+        BitmapBuffer[byteIndex] &= ~( 1 << bitIndex );
+    }
+}
+
+static
+void
+_BitmapChangeBits(
+    INOUT       PBYTE       BitmapBuffer,
+    IN          DWORD       Index,
+    IN          BOOLEAN     Set,
+    IN          DWORD       Count
+    )
+{
+    DWORD i;
+
+    for (i = 0; i < Count; ++i)
+    {
+        _BitmapChangeBit(BitmapBuffer, Index + i, Set);
+    }
+}
+
+static
+BOOLEAN
+_BitmapGetBit(
+    IN          PBYTE       BitmapBuffer,
+    IN          DWORD       Index
+    )
+{
+    DWORD byteIndex;
+    DWORD bitIndex;
+
+    ASSERT( NULL != BitmapBuffer);
+
+    byteIndex = Index / BITMAP_ENTRY_BITS;
+    bitIndex = Index % BITMAP_ENTRY_BITS;
+
+    return IsBooleanFlagOn( BitmapBuffer[byteIndex], ( (BYTE) 1 << bitIndex ) );
+}
+
+static
+SIZE_SUCCESS
+DWORD
+_BitmapScanInternal(
+    IN          PBITMAP     Bitmap,
+    IN          DWORD       StartIndex,
+    IN          DWORD       FirstInvalidBitIndex,
+    IN          DWORD       ConsecutiveBits,
+    IN          BOOLEAN     Set
+    )
+{
+    DWORD i, j;
+    DWORD lastIndex;
+    DWORD firstIndex;
+    BOOLEAN found;
+
+    ASSERT( NULL != Bitmap );
+    ASSERT( 0 != ConsecutiveBits );
+    ASSERT( StartIndex <= FirstInvalidBitIndex );
+    ASSERT( FirstInvalidBitIndex <= Bitmap->BitCount );
+
+    if (FirstInvalidBitIndex - StartIndex < ConsecutiveBits)
+    {
+        // we don't have that many bits
+        return MAX_DWORD;
+    }
+
+    lastIndex = FirstInvalidBitIndex - ConsecutiveBits;
+    firstIndex = StartIndex;
+    found = FALSE;
+
+    for (i = firstIndex; i <= lastIndex; ++i)
+    {
+        found = TRUE;
+        for (j = 0; j < ConsecutiveBits; ++j)
+        {
+            if (Set != _BitmapGetBit(Bitmap->BitmapBuffer, i + j))
+            {
+                found = FALSE;
+                break;
+            }
+        }
+
+        if (found)
+        {
+            return i;
+        }
+    }
+
+    return MAX_DWORD;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/checkin_queue.c b/src_proiect/CommonLib/src/checkin_queue.c
new file mode 100644
index 0000000..6d39e96
--- /dev/null
+++ b/src_proiect/CommonLib/src/checkin_queue.c
@@ -0,0 +1,108 @@
+#include "common_lib.h"
+#include "lock_common.h"
+#include "checkin_queue.h"
+
+#ifndef _COMMONLIB_NO_LOCKS_
+
+DWORD
+CheckinQueuePreInit(
+    OUT       PCHECKIN_QUEUE      Queue,
+    IN        DWORD               NumberOfThreads
+)
+{
+    ASSERT(NULL != Queue);
+    ASSERT(0 < NumberOfThreads);
+
+    memzero(Queue, sizeof(CHECKIN_QUEUE));
+
+    Queue->NumberOfThreads = NumberOfThreads;
+
+    Queue->BufferSize = NumberOfThreads * sizeof(BOOLEAN);
+
+    return Queue->BufferSize;
+}
+
+void
+CheckinQueueInit(
+    INOUT     PCHECKIN_QUEUE      Queue,
+    IN        PBYTE               QueueBuffer
+)
+{
+    ASSERT(NULL != Queue);
+    ASSERT(NULL != QueueBuffer);
+    ASSERT(0 < Queue->NumberOfThreads); // a validation in-case PreInit wasn't called
+
+    Queue->Array = QueueBuffer;
+
+    memset((void*)Queue->Array, FALSE, Queue->NumberOfThreads);
+}
+
+void
+CheckinQueueUninit(
+    INOUT     PCHECKIN_QUEUE      Queue
+)
+{
+    ASSERT(NULL != Queue);
+
+    memzero(Queue, sizeof(CHECKIN_QUEUE));
+}
+
+void
+CheckinQueueMarkPresence(
+    INOUT       PCHECKIN_QUEUE       Queue
+)
+{
+    ASSERT(NULL != Queue);
+    ASSERT(0 < Queue->NumberOfThreads);
+
+    // mark here that thread or cpu arrived where it should be after creation
+    // little busy wait here, it should be basically nothing or minimum waiting time (atomic operation)
+    for (DWORD i = 0; i < Queue->NumberOfThreads; i++)
+    {
+        if (!_InterlockedCompareExchange8(&Queue->Array[i], TRUE, FALSE))
+        {
+            // marked my slot, the index of the slot is not an issue
+            break;
+        }
+    }
+}
+
+
+void
+CheckinQueueWaitOn(
+    IN          PCHECKIN_QUEUE      Queue,
+    IN          BOOLEAN             WaitAll,
+    IN_OPT      DWORD               NumberOfCheckinsToWait
+)
+{
+    ASSERT(NULL != Queue);
+    ASSERT(0 < Queue->NumberOfThreads);
+
+    INTR_STATE oldState;
+    BOOLEAN busyWait = TRUE;
+    DWORD numberOfThreads = (WaitAll) ? Queue->NumberOfThreads : NumberOfCheckinsToWait;
+
+    // disable interrupts, as we shouldn't been interrupted.
+    oldState = CpuIntrDisable();
+
+    // don't let the main thread or cpu advance until every thread signaled
+    // that it arrived before the blocking sequence.
+    while (busyWait)
+    {
+        BOOLEAN semaphoreGreen = TRUE;
+        for (DWORD i = 0; i < numberOfThreads; i++)
+        {
+            if (!_InterlockedCompareExchange8(&Queue->Array[i], TRUE, TRUE))
+            {
+                semaphoreGreen = FALSE;
+            }
+            _mm_pause();
+        }
+        if (semaphoreGreen) busyWait = FALSE;
+    }
+
+    // set back the interrupt state
+    CpuIntrSetState(oldState);
+}
+
+#endif // _COMMONLIB_NO_LOCKS_
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/cl_heap.c b/src_proiect/CommonLib/src/cl_heap.c
new file mode 100644
index 0000000..4c0798a
--- /dev/null
+++ b/src_proiect/CommonLib/src/cl_heap.c
@@ -0,0 +1,494 @@
+#include "common_lib.h"
+#include "cl_heap.h"
+
+// 64KB is the minimum heap size required to initialize the system
+#define HEAP_MINIMUM_SIZE               (64*KB_SIZE)
+
+// random HEAP_MAGIC number
+#define HEAP_MAGIC                      0xACE2302E
+
+#define HEAP_FREE_PATTERN               0xAF
+#define HEAP_TAIL_SIZE                  sizeof(DWORD)
+
+typedef struct _HEAP_TAIL
+{
+    DWORD               Magic;
+} HEAP_TAIL, *PHEAP_TAIL;
+STATIC_ASSERT(sizeof(HEAP_TAIL) == HEAP_TAIL_SIZE);
+
+/*
+----------------------------------------------------------------
+-           Magic
+-           Tag
+-           Size
+-           Offset
+-           ListEntry
+-           Data
+
+
+
+
+
+
+-           Magic
+----------------------------------------------------------------
+*/
+typedef
+_Struct_size_bytes_(sizeof(HEAP_ENTRY) + Size + sizeof(HEAP_TAIL))
+struct _HEAP_ENTRY
+{
+    DWORD               Magic;          // 0x0
+    DWORD               Tag;            // 0x4
+    DWORD               Size;           // 0x8  (sizeof actual data allocated(without header) and without MAGIC at the end of the data allocated)
+    DWORD               Offset;         // 0xC  (offset to the data(may depend on the alignment)
+    LIST_ENTRY          ListEntry;      // 0x10
+} HEAP_ENTRY, *PHEAP_ENTRY;             // sizeof(HEAP_ENTRY) = 0x20
+
+//******************************************************************************
+// Function:    InitHeapEntry
+// Description: Initializes the memory area for the new allocation and updates
+//              the global HEAP_HEADER structure.
+// Returns:     QWORD
+// Parameter:   OUT PHEAP_ENTRY * HeapEntry
+// Parameter:   IN DWORD Tag
+// Parameter:   IN DWORD Size
+// Parameter:   IN DWORD Alignment
+// Parameter:   IN BOOLEAN AddToLinkedList
+// Parameter:   IN QWORD SizeAvailable
+//******************************************************************************
+static
+QWORD
+_InitHeapEntry(
+    INOUT    PHEAP_HEADER    HeapHeader,
+    INOUT    PHEAP_ENTRY*    HeapEntry,
+    IN       DWORD           Tag,
+    IN       DWORD           Size,
+    IN       DWORD           Alignment,
+    IN       BOOLEAN         AddToLinkedList,
+    IN       QWORD           SizeAvailable
+    );
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_ValidateHeapEntry(
+    IN      PHEAP_ENTRY     HeapEntry,
+    IN      DWORD           Tag
+    );
+
+STATUS
+ClHeapInit(
+    _Notnull_                           PVOID                   BaseAddress,
+    IN                                  QWORD                   MemoryAvailable,
+    OUT_PTR                             PHEAP_HEADER*           HeapHeader
+    )
+{
+    PHEAP_HEADER pHeapHeader;
+
+    if (BaseAddress == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (MemoryAvailable < HEAP_MINIMUM_SIZE)
+    {
+        return STATUS_HEAP_TOO_SMALL;
+    }
+
+    if (HeapHeader == NULL)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    pHeapHeader = BaseAddress;
+
+    pHeapHeader->Magic = HEAP_MAGIC;
+    pHeapHeader->BaseAddress = ( QWORD ) BaseAddress;
+    pHeapHeader->HeapSizeMaximum = MemoryAvailable;
+    pHeapHeader->HeapSizeRemaining = pHeapHeader->HeapSizeMaximum - sizeof( HEAP_HEADER );
+    pHeapHeader->HeapNumberOfAllocations = 0;
+    pHeapHeader->EntryToRestartSearch = &pHeapHeader->HeapAllocations;
+
+    pHeapHeader->FreeAddress = pHeapHeader->BaseAddress + sizeof( HEAP_HEADER );
+    InitializeListHead( &pHeapHeader->HeapAllocations );
+
+    *HeapHeader = pHeapHeader;
+
+    return STATUS_SUCCESS;
+}
+
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+ClHeapAllocatePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    )
+{
+    STATUS status;
+    INT64 remainingSizeUntilEnd;
+    INT64 remainingSizeBeforeCurrent;
+    QWORD sizeRequired;
+    QWORD startAddress;
+    DWORD alignment;
+    INT64 sizeBetweenEntries;
+    PVOID mappedAddress;
+    HEAP_ENTRY* pNewHeapEntry;
+    BOOLEAN found;
+    QWORD tempAddress;
+
+    LIST_ENTRY* pCurEntry;
+    HEAP_ENTRY* pCurHeapEntry;
+
+    LIST_ENTRY* pPreviousEntry;
+    HEAP_ENTRY* pPreviousHeapEntry;
+
+    ASSERT( NULL != HeapHeader );
+
+    found = FALSE;
+    status = STATUS_SUCCESS;
+    startAddress = 0;
+    pNewHeapEntry = NULL;
+    mappedAddress = NULL;
+
+    tempAddress = 0;
+    sizeBetweenEntries = 0;
+    pCurEntry = NULL;
+    pCurHeapEntry = NULL;
+    pPreviousEntry = NULL;
+    pPreviousHeapEntry = NULL;
+    remainingSizeUntilEnd = 0;
+    remainingSizeBeforeCurrent = 0;
+
+    __try
+    {
+        if (0 == AllocationSize)
+        {
+            status = STATUS_INVALID_PARAMETER2;
+            __leave;
+        }
+
+        if (0 == Tag)
+        {
+            // we need a tag
+            status = STATUS_INVALID_PARAMETER3;
+            __leave;
+        }
+
+        if (0 == AllocationAlignment)
+        {
+            alignment = HEAP_DEFAULT_ALIGNMENT;
+        }
+        else
+        {
+            alignment = AllocationAlignment;
+        }
+
+        sizeRequired = AllocationSize + sizeof(HEAP_ENTRY) + sizeof(HEAP_TAIL);
+
+        if (sizeRequired > HeapHeader->HeapSizeRemaining)
+        {
+            // we clearly have no chance of allocating more space
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            __leave;
+        }
+
+        // this is how much size for data we have available until the end of the heap
+        remainingSizeUntilEnd = HeapHeader->BaseAddress + HeapHeader->HeapSizeMaximum - HeapHeader->FreeAddress - sizeof(HEAP_ENTRY);
+        if ((INT64)sizeRequired <= remainingSizeUntilEnd)
+        {
+            // it's ok we'll place it here, this is the easier case
+            pNewHeapEntry = (HEAP_ENTRY*)HeapHeader->FreeAddress;
+
+            tempAddress = _InitHeapEntry(HeapHeader, &pNewHeapEntry, Tag, AllocationSize, alignment, TRUE, remainingSizeUntilEnd);
+            if (0 != tempAddress)
+            {
+                HeapHeader->FreeAddress = tempAddress;
+                found = TRUE;
+            }
+        }
+
+        if (!found)
+        {
+            // so we don't have space at the end
+            // let's check if there's a chance for us to have space before our current location
+
+            // this is the rest of the space we have
+            remainingSizeBeforeCurrent = HeapHeader->HeapSizeRemaining - remainingSizeUntilEnd - sizeof(HEAP_ENTRY);
+            if ((INT64)sizeRequired > remainingSizeBeforeCurrent)
+            {
+                // we have nowhere to allocate memory
+                status = STATUS_HEAP_NO_MORE_MEMORY;
+                __leave;
+            }
+            else
+            {
+                // we need to go to through the Linked List and find a free spot between 2 entries
+
+
+                // there is no way the list can be empty and we still don't have nay memory remaining
+                ASSERT(!IsListEmpty(&(HeapHeader->HeapAllocations)));
+
+                pPreviousEntry = HeapHeader->EntryToRestartSearch->Flink;
+                pPreviousHeapEntry = CONTAINING_RECORD(pPreviousEntry, HEAP_ENTRY, ListEntry);
+                pCurEntry = pPreviousEntry->Flink;
+
+                while (HeapHeader->EntryToRestartSearch != pCurEntry)
+                {
+                    if ((pCurEntry == &HeapHeader->HeapAllocations) ||
+                        (pPreviousEntry == &HeapHeader->HeapAllocations))
+                    {
+                        goto next_loop;
+                    }
+
+                    ASSERT(NULL != pPreviousHeapEntry);
+
+                    pCurHeapEntry = CONTAINING_RECORD(pCurEntry, HEAP_ENTRY, ListEntry);
+                    startAddress = ((QWORD)pPreviousHeapEntry + sizeof(HEAP_ENTRY) + pPreviousHeapEntry->Size + sizeof(HEAP_TAIL));
+                    sizeBetweenEntries = (INT64)((QWORD)pCurHeapEntry - startAddress);
+
+                    if (sizeBetweenEntries >= (INT64)sizeRequired)
+                    {
+                        // we can squeeze this entry between these 2
+                        pNewHeapEntry = (HEAP_ENTRY*)startAddress;
+
+                        // here we need to add it manually to the linked list
+                        // => FALSE AddToLinkedList parameter, we only need the memory pointer
+                        // and to update the heap structures
+                        tempAddress = _InitHeapEntry(HeapHeader, &pNewHeapEntry, Tag, AllocationSize, alignment, FALSE, sizeBetweenEntries);
+                        if (0 == tempAddress)
+                        {
+                            // _InitHeapEntry also calculates alignment requirements
+                            // => it's possible in this space that we still couldn't fit the data
+                            // but maybe we'll be able to on the next iteration
+                            goto next_loop;
+                        }
+
+                        ASSERT(_ValidateHeapEntry(pPreviousHeapEntry, pPreviousHeapEntry->Tag));
+
+                        // now we insert it in the appropriate position
+                        InsertHeadList(pPreviousEntry, &(pNewHeapEntry->ListEntry));
+
+                        HeapHeader->EntryToRestartSearch = &pNewHeapEntry->ListEntry;
+                        found = TRUE;
+                    }
+
+                    if (found)
+                    {
+                        break;
+                    }
+
+                next_loop:
+                    // we update the pointers
+                    pPreviousEntry = pCurEntry;
+                    pPreviousHeapEntry = pCurHeapEntry;
+                    pCurEntry = pCurEntry->Flink;
+                }
+
+                if (!found)
+                {
+                    status = STATUS_HEAP_NO_MORE_MEMORY;
+                    __leave;
+                }
+            }
+        }
+
+        mappedAddress = ((BYTE*)pNewHeapEntry) + pNewHeapEntry->Offset;
+    }
+    __finally
+    {
+        if (IsFlagOn(Flags, PoolAllocatePanicIfFail))
+        {
+            // we must succeed
+            ASSERT_INFO(SUCCEEDED(status), "Operation failed with status: 0x%x\n", status);
+            ASSERT(NULL != mappedAddress);
+        }
+
+        if (SUCCEEDED(status))
+        {
+            if (IsFlagOn(Flags, PoolAllocateZeroMemory))
+            {
+                memzero(mappedAddress, AllocationSize);
+            }
+        }
+    }
+
+    return mappedAddress;
+}
+
+void
+ClHeapFreePoolWithTag(
+    INOUT   PHEAP_HEADER            HeapHeader,
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    )
+{
+    HEAP_ENTRY* pHeapEntry;
+    LIST_ENTRY* pListEntry;
+    HEAP_ENTRY* pPreviousHeapEntry;
+    QWORD endAddress;
+    QWORD previousAddress;
+    QWORD heapEntrySize;
+
+    ASSERT( NULL != HeapHeader );
+    ASSERT( NULL != MemoryAddress );
+    ASSERT( 0 != Tag );
+
+    pPreviousHeapEntry = NULL;
+    pListEntry = NULL;
+    previousAddress = 0;
+
+    pHeapEntry = ( HEAP_ENTRY* ) ( ( BYTE*) MemoryAddress - sizeof( HEAP_ENTRY ) );
+
+    endAddress = ( QWORD ) MemoryAddress + pHeapEntry->Size + sizeof( HEAP_TAIL );
+
+    // sanity checks
+    ASSERT(_ValidateHeapEntry(pHeapEntry,Tag));
+
+    pListEntry = pHeapEntry->ListEntry.Blink;
+
+    if( &( HeapHeader->HeapAllocations ) == pListEntry )
+    {
+        pListEntry = NULL;
+    }
+
+    if( NULL != pListEntry )
+    {
+        pPreviousHeapEntry = CONTAINING_RECORD( pListEntry, HEAP_ENTRY, ListEntry );
+        previousAddress = ( QWORD) pPreviousHeapEntry + sizeof( HEAP_ENTRY ) + pPreviousHeapEntry->Size + sizeof( HEAP_TAIL );
+    }
+    else
+    {
+        // the list of allocations is empty
+        previousAddress = HeapHeader->BaseAddress + sizeof( HEAP_HEADER );
+    }
+
+    // remove the element from the list of allocations
+    RemoveEntryList( &( pHeapEntry->ListEntry ) );
+    heapEntrySize = pHeapEntry->Size + sizeof(HEAP_ENTRY) + sizeof(HEAP_TAIL);
+
+    // memzero is done only for easier debugging
+    ASSERT( heapEntrySize <= MAX_DWORD );
+    memset( pHeapEntry, HEAP_FREE_PATTERN, (DWORD) heapEntrySize );
+
+    // we should really increment remaining heap size
+    HeapHeader->HeapSizeRemaining = HeapHeader->HeapSizeRemaining + heapEntrySize;
+    HeapHeader->HeapNumberOfAllocations = HeapHeader->HeapNumberOfAllocations - 1;
+
+    if( endAddress == HeapHeader->FreeAddress )
+    {
+        // we were the last ones here => we hand the staff to the previous entry
+        HeapHeader->FreeAddress = previousAddress;
+    }
+}
+
+static
+QWORD
+_InitHeapEntry(
+    INOUT   PHEAP_HEADER    HeapHeader,
+    INOUT   PHEAP_ENTRY*    HeapEntry,
+    IN      DWORD           Tag,
+    IN      DWORD           Size,
+    IN      DWORD           Alignment,
+    IN      BOOLEAN         AddToLinkedList,
+    IN      QWORD           SizeAvailable
+    )
+{
+    QWORD unalignedDataAddress;
+    QWORD dataAddress;
+    PHEAP_TAIL pHeapTail;
+    HEAP_ENTRY* pHeapEntry;
+    DWORD heapEntrySize;
+
+    pHeapTail = NULL;
+    pHeapEntry = *HeapEntry;
+
+    unalignedDataAddress = ( QWORD ) ( ( (BYTE*) pHeapEntry ) + sizeof( HEAP_ENTRY ) );
+
+    // the address needs to be aligned
+    dataAddress = AlignAddressUpper( unalignedDataAddress, Alignment );
+
+    heapEntrySize = Size + sizeof(HEAP_ENTRY) + sizeof(HEAP_TAIL);
+
+    if( SizeAvailable < ( dataAddress - unalignedDataAddress + heapEntrySize ) )
+    {
+        // we don't have enough space to allocate this entry
+        return 0;
+    }
+
+    // we need to remap the HeapEntry to be just before the new address
+    pHeapEntry = ( HEAP_ENTRY* ) ( dataAddress - sizeof( HEAP_ENTRY ) );
+    *HeapEntry = pHeapEntry;
+
+    pHeapEntry->Magic = HEAP_MAGIC;
+    pHeapEntry->Size = Size;
+    pHeapEntry->Tag = Tag;
+
+    // we insert the new element to the list
+    if( AddToLinkedList )
+    {
+        InsertTailList( &( HeapHeader->HeapAllocations ), &(pHeapEntry->ListEntry) );
+    }
+
+
+    pHeapEntry->Offset = ( DWORD ) ( dataAddress - ( QWORD ) pHeapEntry );
+
+    // we also have a magic field to append at the end
+    pHeapTail = ( PHEAP_TAIL )( dataAddress + pHeapEntry->Size );
+
+    // set the magic field
+    pHeapTail->Magic = HEAP_MAGIC;
+
+    HeapHeader->HeapSizeRemaining = HeapHeader->HeapSizeRemaining - heapEntrySize;
+    HeapHeader->HeapNumberOfAllocations = HeapHeader->HeapNumberOfAllocations + 1;
+
+    // has the possibly of becoming the first free entry list
+    return (QWORD) pHeapTail + sizeof(HEAP_TAIL);
+}
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_ValidateHeapEntry(
+    IN      PHEAP_ENTRY     HeapEntry,
+    IN      DWORD           Tag
+    )
+{
+    PHEAP_TAIL pHeapTail;
+    BOOLEAN bResult;
+    DWORD totalSize;
+
+    ASSERT( NULL != HeapEntry );
+    ASSERT( 0 != Tag );
+
+    bResult = TRUE;
+
+    if (HEAP_MAGIC != HeapEntry->Magic)
+    {
+        bResult = FALSE;
+    }
+
+    totalSize = sizeof(HEAP_ENTRY) + HeapEntry->Size + sizeof(HEAP_TAIL);
+    pHeapTail = (PHEAP_TAIL)((PBYTE)HeapEntry + totalSize - sizeof(HEAP_TAIL));
+
+    if (HEAP_MAGIC != pHeapTail->Magic)
+    {
+        bResult = FALSE;
+    }
+
+    if (0 == HeapEntry->Tag)
+    {
+        bResult = FALSE;
+    }
+
+    if (Tag != HeapEntry->Tag)
+    {
+        bResult = FALSE;
+    }
+
+    return bResult;
+}
diff --git a/src_proiect/CommonLib/src/cl_memory.c b/src_proiect/CommonLib/src/cl_memory.c
new file mode 100644
index 0000000..951e7b1
--- /dev/null
+++ b/src_proiect/CommonLib/src/cl_memory.c
@@ -0,0 +1,206 @@
+#include "common_lib.h"
+#include "cl_memory.h"
+
+extern void CpuClearDirectionFlag();
+
+_At_buffer_( address, i, size, _Post_satisfies_( ((PBYTE)address)[i] == value ))
+void
+cl_memset(
+    OUT_WRITES_BYTES_ALL(size)  PVOID address,
+    IN                          BYTE value,
+    IN                          DWORD size
+    )
+{
+    DWORD i;
+
+    // validate parameters
+    // size validation is done implicitly in the for loop
+    if (NULL == address)
+    {
+        return;
+    }
+
+    for (i = 0; i < size; ++i)
+    {
+        ((BYTE*)address)[i] = value;
+    }
+}
+
+_At_buffer_(Destination, i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+cl_memcpy(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             void*   Source,
+    IN                          QWORD   Count
+    )
+{
+    PBYTE dst;
+    PBYTE src;
+    QWORD alignedCount;
+    QWORD unalignedCount;
+
+    if( (NULL == Destination) || (NULL == Source))
+    {
+        return;
+    }
+
+    unalignedCount = Count & 0x7;
+    alignedCount = Count - unalignedCount;
+
+    dst = (PBYTE)Destination;
+    src = (PBYTE)Source;
+
+    if (unalignedCount & 0x4)
+    {
+        *((PDWORD)dst) = *((PDWORD)src);
+        dst = dst + sizeof(DWORD);
+        src = src + sizeof(DWORD);
+    }
+
+    if (unalignedCount & 0x2)
+    {
+        *((PWORD)dst) = *((PWORD)src);
+        dst = dst + sizeof(WORD);
+        src = src + sizeof(WORD);
+    }
+
+    if (unalignedCount & 0x1)
+    {
+        *((PBYTE)dst) = *((PBYTE)src);
+        dst = dst + sizeof(BYTE);
+        src = src + sizeof(BYTE);
+    }
+
+    if (0 != alignedCount)
+    {
+        ASSERT(IsAddressAligned(alignedCount, sizeof(QWORD)));
+
+        dst = (PBYTE)Destination + unalignedCount;
+        src = (PBYTE)Source + unalignedCount;
+
+        CpuClearDirectionFlag();
+
+        __movsq(dst, src, alignedCount / sizeof(QWORD));
+    }
+}
+
+_At_buffer_(Destination, i, Count,
+            _Post_satisfies_(((PBYTE)Destination)[i] == ((PBYTE)Source)[i]))
+void
+cl_memmove(
+    OUT_WRITES_BYTES_ALL(Count) PVOID   Destination,
+    IN_READS(Count)             void*   Source,
+    IN                          QWORD   Count
+    )
+{
+    PBYTE dst;
+    const BYTE* src;
+    QWORD i;
+
+    if ((NULL == Destination) || (NULL == Source))
+    {
+        return;
+    }
+
+    dst = Destination;
+    src = Source;
+
+    for (i = 0; i < Count; ++i)
+    {
+        dst[i] = src[i];
+    }
+}
+
+int
+cl_memcmp(
+    IN_READS_BYTES(size)    void* ptr1,
+    IN_READS_BYTES(size)    void* ptr2,
+    IN                      DWORD size
+    )
+{
+    INT64 i = size;
+    const BYTE* p1;
+    const BYTE* p2;
+
+    if ((NULL == ptr1) || (NULL == ptr2))
+    {
+        // TODO: what is the best result to return?
+        return size;
+    }
+
+
+    p1 = ptr1;
+    p2 = ptr2;
+
+    for (i = 0; i < size; ++i)
+    {
+        if (p1[i] != p2[i])
+        {
+            return p1[i] - p2[i];
+        }
+    }
+
+    return 0;
+}
+
+int
+cl_rmemcmp(
+    IN_READS_BYTES(size)    void* ptr1,
+    IN_READS_BYTES(size)    void* ptr2,
+    IN                      DWORD size
+    )
+{
+    INT64 i = size;
+    const BYTE* p1;
+    const BYTE* p2;
+
+    if ((NULL == ptr1) || (NULL == ptr2))
+    {
+        // TODO: what is the best result to return?
+        return size;
+    }
+
+
+    p1 = ptr1;
+    p2 = ptr2;
+
+    for (i = size - 1; i >= 0; --i)
+    {
+        if (p1[i] != p2[i])
+        {
+            return p1[i] - p2[i];
+        }
+    }
+
+    return 0;
+}
+
+int
+cl_memscan(
+    IN_READS_BYTES(size)    void* buffer,
+    IN                      DWORD size,
+    IN                      BYTE  value
+    )
+{
+    DWORD i;
+    const BYTE* pData;
+
+    if (NULL == buffer)
+    {
+        return 0;
+    }
+
+    pData = buffer;
+
+    for (i = 0; i < size; ++i)
+    {
+        if (pData[i] != value)
+        {
+            // game over
+            return i;
+        }
+    }
+
+    return i;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/cl_string.c b/src_proiect/CommonLib/src/cl_string.c
new file mode 100644
index 0000000..b8933be
--- /dev/null
+++ b/src_proiect/CommonLib/src/cl_string.c
@@ -0,0 +1,714 @@
+#include "common_lib.h"
+#include "cl_string.h"
+#include "strutils.h"
+
+// 64 characters needed in case of %B specifier
+// with NULL terminator => 65 characters are required
+#define VSNPRINTF_BUFFER_SIZE               65
+
+int
+cl_strcmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    i = 0;
+
+    while (('\0' != str1[i]) && ('\0' != str2[i]))
+    {
+        if (str1[i] > str2[i])
+        {
+            return 1;
+        }
+
+        if (str1[i] < str2[i])
+        {
+            return -1;
+        }
+
+        ++i;
+    }
+
+    // it means the second string is over but the first still has
+    // some characters
+    if ('\0' != str1[i])
+    {
+        return 1;
+    }
+
+    if ('\0' != str2[i])
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+int
+cl_stricmp(
+    IN_Z  char* str1,
+    IN_Z  char* str2
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    i = 0;
+
+    while (('\0' != str1[i]) && ('\0' != str2[i]))
+    {
+        char c1 = tolower(str1[i]);
+        char c2 = tolower(str2[i]);
+
+        if (c1 > c2)
+        {
+            return 1;
+        }
+
+        if (c1 < c2)
+        {
+            return -1;
+        }
+
+        ++i;
+    }
+
+    // it means the second string is over but the first still has
+    // some characters
+    if ('\0' != str1[i])
+    {
+        return 1;
+    }
+
+    if ('\0' != str2[i])
+    {
+        return -1;
+    }
+
+    return 0;
+}
+
+int
+cl_strncmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == length)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    i = 0;
+
+    for (i = 0; i < length && '\0' != str1[i] && '\0' != str2[i]; ++i)
+    {
+        if (str1[i] > str2[i])
+        {
+            return 1;
+        }
+
+        if (str1[i] < str2[i])
+        {
+            return -1;
+        }
+    }
+
+    if (i == length)
+    {
+        // they are truly equal
+        return 0;
+    }
+
+    if ('\0' != str1[i])
+    {
+        // string 1 is bigger
+        return 1;
+    }
+
+    // string 2 is bigger
+    return -1;
+}
+
+int
+cl_strnicmp(
+    IN_READS_Z(length)  char* str1,
+    IN_READS_Z(length)  char* str2,
+    IN  DWORD length
+    )
+{
+    DWORD i;
+
+    if (NULL == str1)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == str2)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == length)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    i = 0;
+
+    for (i = 0; i < length && '\0' != str1[i] && '\0' != str2[i]; ++i)
+    {
+        char c1 = tolower(str1[i]);
+        char c2 = tolower(str2[i]);
+
+        if (c1 > c2)
+        {
+            return 1;
+        }
+
+        if (c1 < c2)
+        {
+            return -1;
+        }
+    }
+
+    if (i == length)
+    {
+        // they are truly equal
+        return 0;
+    }
+
+    if ('\0' != str1[i])
+    {
+        // string 1 is bigger
+        return 1;
+    }
+
+    // string 2 is bigger
+    return -1;
+}
+
+const
+char*
+cl_strchr(
+    IN_Z  char* str,
+    IN  char c
+    )
+{
+    DWORD i;
+
+    if (NULL == str)
+    {
+        return NULL;
+    }
+
+    i = 0;
+
+    while ('\0' != str[i])
+    {
+        if (str[i] == c)
+        {
+            return (str + i);
+        }
+        ++i;
+    }
+
+    return str;
+}
+
+const
+char*
+cl_strrchr(
+    IN_Z  char* str,
+    IN  char c
+    )
+{
+    DWORD i;
+    const char* charIndex;
+
+    if (NULL == str)
+    {
+        return NULL;
+    }
+
+    i = 0;
+    charIndex = str;
+
+    while ('\0' != str[i])
+    {
+        if (str[i] == c)
+        {
+            charIndex = (str + i);
+        }
+        ++i;
+    }
+
+    return charIndex;
+}
+
+void
+cl_strcpy(
+    OUT_Z char* dst,
+    IN_Z  char* src
+    )
+{
+    DWORD i;
+
+    ASSERT( NULL != dst );
+    ASSERT( NULL != src );
+
+    i = 0;
+
+    while ('\0' != src[i])
+    {
+        dst[i] = src[i];
+        ++i;
+    }
+
+    dst[i] = '\0';
+}
+
+void
+cl_strncpy(
+    OUT_WRITES(length + 1)  char* dst,
+    IN_READS_Z(length)      char* src,
+    IN                      DWORD length
+    )
+{
+    DWORD i;
+
+    ASSERT( NULL != dst );
+    ASSERT( NULL != src );
+    ASSERT( 0 != length );
+
+    i = 0;
+
+    for (i = 0; i < length && src[i] != '\0'; ++i)
+    {
+        dst[i] = src[i];
+    }
+
+    dst[i] = '\0';
+}
+
+SIZE_SUCCESS
+DWORD
+cl_strlen(
+    IN_Z  char* str
+    )
+{
+    DWORD i;
+
+    if (NULL == str)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    i = 0;
+
+    while ('\0' != str[i])
+    {
+        ++i;
+    }
+
+    return i;
+}
+
+SIZE_SUCCESS
+DWORD
+cl_strlen_s(
+    IN_READS_Z(maxLen)
+                char*   str,
+    IN          DWORD   maxLen
+    )
+{
+    DWORD i;
+
+    if (NULL == str)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    i = 0;
+
+    while (i < maxLen && '\0' != str[i])
+    {
+        ++i;
+    }
+
+    return i;
+}
+
+STATUS
+cl_snprintf(
+    OUT_WRITES(buffSize)    char* outputBuffer,
+    IN                      DWORD buffSize,
+    IN_Z                    char* inputBuffer,
+    ...
+    )
+{
+    va_list va;
+
+    va_start(va, inputBuffer);
+
+    return cl_vsnprintf(outputBuffer, buffSize, inputBuffer, va);
+}
+
+STATUS
+cl_vsnprintf(
+    OUT_WRITES(buffSize)    char*       outputBuffer,
+    IN                      DWORD       buffSize,
+    IN_Z                    char*       inputBuffer,
+    INOUT                   va_list     argptr
+    )
+{
+    char temp[VSNPRINTF_BUFFER_SIZE];        // temporary buffer
+    DWORD index;                // index in Buffer
+    DWORD param_index;            // index which we want to find
+    QWORD temp_value;
+    DWORD outBufferOffset;
+    DWORD temp_len;
+    char* temp_str;
+
+    if (NULL == outputBuffer)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (0 == buffSize)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == inputBuffer)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    index = 0;
+    param_index = 1;
+    temp_value = 0;
+    outBufferOffset = 0;
+    temp_len = 0;
+    temp_str = temp;
+
+    while ('\0' != inputBuffer[index])
+    {
+        if ('%' == inputBuffer[index])
+        {
+            DWORD digits = 0;
+            DWORD fillSpaces = 0;
+            char next = inputBuffer[index + 1];
+            BOOLEAN firstSpecificator = TRUE;
+            char fillChar = ' ';
+            DWORD charsToCopy;
+
+            while (('0' <= next) && (next <= '9'))
+            {
+                if (firstSpecificator)
+                {
+                    firstSpecificator = FALSE;
+
+                    if ('0' == next)
+                    {
+                        fillChar = '0';
+                    }
+                }
+
+                digits = digits * 10 + next - '0';
+                index++;
+                next = inputBuffer[index + 1];
+            }
+
+
+            switch (next)
+            {
+            case 'b':
+                // we have an unsigned 32 bit value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TWO, FALSE);
+                break;
+            case 'B':
+                // we have an unsigned 64 bit value to print
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TWO, TRUE);
+                break;
+            case 'u':
+                // we have an unsigned 32 bit value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TEN, FALSE);
+                break;
+            case 'U':
+                // we have an unsigned 64 bit value to print
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_TEN, TRUE);
+                break;
+            case 'd':
+                // we have a signed 32 bit value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, TRUE, temp_str, BASE_TEN, FALSE);
+                break;
+            case 'D':
+                // we have a signed 64 bit value
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, TRUE, temp_str, BASE_TEN, TRUE);
+                break;
+            case 'x':
+                // we have a 32 bit hexadecimal value to print
+                temp_value = va_arg(argptr, DWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_HEXA, FALSE);
+                break;
+            case 'X':
+                // we have a 64 bit hexadecimal value to print
+                temp_value = va_arg(argptr, QWORD);
+                itoa(&temp_value, FALSE, temp_str, BASE_HEXA, TRUE);
+                break;
+            case 'c':
+                // we have a character value to print
+                temp_value = va_arg(argptr, char);
+                cl_strncpy(temp_str, (char*)&temp_value, sizeof(char));
+                break;
+            case 's':
+            case 'S':
+                // we have a string to print
+                temp_str = va_arg(argptr, char*);
+                break;
+            default:
+                // A parsing error - an incorrect string was supplied =>
+                // return a status error
+                return STATUS_PARSE_FAILED;
+            }
+
+            temp_len = strlen(temp_str);
+            ASSERT(temp_len != INVALID_STRING_SIZE);
+
+            charsToCopy = (next == 'S') ? min(digits, temp_len) : temp_len;
+
+            if (outBufferOffset + temp_len >= buffSize)
+            {
+                // we don't have any more space
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+            // see if we need to pad the string with spaces or with digits
+            fillSpaces = digits > temp_len ? digits - temp_len : 0;
+            if (outBufferOffset + temp_len + fillSpaces >= buffSize)
+            {
+                // we don't have any more space
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+            if (0 != fillSpaces)
+            {
+                // put spaces
+                cl_memset(outputBuffer + outBufferOffset, fillChar, fillSpaces);
+                outBufferOffset = outBufferOffset + fillSpaces;
+            }
+
+            if (charsToCopy != 0)
+            {
+                cl_strncpy(outputBuffer + outBufferOffset, temp_str, charsToCopy);
+            }
+            outBufferOffset = outBufferOffset + charsToCopy;
+
+            param_index++;          // number of parameters parsed
+            index += 2;             // we advance in the format string
+            temp_str = temp;        // we need to reset temp_str to point to temp
+                                    // else, after a string operation it will point to the
+                                    // printed string
+        }
+        else
+        {
+            if (outBufferOffset + 1 >= buffSize)
+            {
+                // we don't have any more space
+                outputBuffer[outBufferOffset] = '\0';
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+
+            outputBuffer[outBufferOffset] = inputBuffer[index];
+
+            outBufferOffset++;
+            index++;
+        }
+
+    }
+
+    outputBuffer[outBufferOffset] = '\0';
+
+    return param_index - 1;
+}
+
+const
+char*
+cl_strtok_s(
+    _When_(*context == NULL, IN_Z)
+    _When_(*context != NULL, IN_OPT)
+                                char*       strToken,
+    IN_Z                        char*       delimiters,
+    INOUT                       char**      context
+    )
+{
+    DWORD i;
+    DWORD j;
+    char* pStr;
+
+    if (NULL == delimiters)
+    {
+        return NULL;
+    }
+
+    if (NULL == context)
+    {
+        return NULL;
+    }
+
+    if ((NULL == *context) && (NULL == strToken) )
+    {
+        return NULL;
+    }
+
+    pStr = (NULL == *context) ? strToken : *context;
+
+    if ('\0' == pStr[0])
+    {
+        // we reached the end of the string
+        return NULL;
+    }
+
+    for (i = 0; pStr[i] != '\0'; ++i)
+    {
+        for (j = 0; delimiters[j] != '\0'; ++j)
+        {
+            if (pStr[i] == delimiters[j])
+            {
+                pStr[i] = '\0';
+                *context = &pStr[i + 1];
+                return pStr;
+            }
+        }
+    }
+
+    // we return the whole string
+    // if we reached the end of the string the context must point to NULL as well
+    // else we go over our string boundary
+    *context = pStr[i] == '\0' ? &pStr[i] : &pStr[i + 1];
+
+    return pStr;
+}
+
+SIZE_SUCCESS
+DWORD
+cl_strcelem(
+    IN_Z                    char*       string,
+    IN                      char        delimiter
+    )
+{
+    DWORD noOfElements;
+    const char* pPrevValue;
+
+    if (string == NULL)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    // If we have n elements we will have n-1 spaces
+    // => start with 1 element
+    noOfElements = 1;
+    pPrevValue = string;
+
+    for (const char* curPosition = cl_strchr(string, delimiter);
+         curPosition != pPrevValue;
+         curPosition = cl_strchr(curPosition, delimiter))
+    {
+        noOfElements++;
+
+        // need to increment by 1 else we'll get stuck in a loop because strchr returns a pointer
+        // to the first occurrence of the character
+        curPosition++;
+        pPrevValue = curPosition;
+    }
+
+    return noOfElements;
+}
+
+void
+cl_strtrim(
+    INOUT                    char*       string
+    )
+{
+    DWORD startIndex = MAX_DWORD;
+
+    ASSERT(NULL != string);
+
+    // find the first non-space character
+    for (DWORD i = 0; string[i] != '\0'; i++)
+    {
+        if (!isspace(string[i]))
+        {
+            startIndex = i;
+            break;
+        }
+    }
+
+    // if only whitespaces were found
+    if (MAX_DWORD == startIndex)
+    {
+        string[0] = '\0';
+        return;
+    }
+
+    DWORD lengthAfterRightTrim = strlen(string);
+
+    // insert '\0' after last non-space character
+    for (DWORD i = strlen(string); i > startIndex; i--)
+    {
+        if (!isspace(string[i - 1]))
+        {
+            string[i] = '\0';
+            lengthAfterRightTrim = i;
+            break;
+        }
+    }
+
+    // if the first non-space character is not at the beginning of the buffer
+    if (0 != startIndex)
+    {
+        ASSERT(lengthAfterRightTrim != 0);
+
+        // shift all characters to the left
+        cl_memmove(string, &string[startIndex], lengthAfterRightTrim);
+    }
+}
diff --git a/src_proiect/CommonLib/src/common_lib.c b/src_proiect/CommonLib/src/common_lib.c
new file mode 100644
index 0000000..aa12334
--- /dev/null
+++ b/src_proiect/CommonLib/src/common_lib.c
@@ -0,0 +1,30 @@
+#include "common_lib.h"
+#include "lock_common.h"
+
+STATUS
+CommonLibInit(
+    IN      PCOMMON_LIB_INIT        InitSettings
+    )
+{
+    STATUS status;
+
+    if (NULL == InitSettings)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (InitSettings->Size != sizeof(COMMON_LIB_INIT))
+    {
+        return STATUS_INCOMPATIBLE_INTERFACE;
+    }
+
+    status = STATUS_SUCCESS;
+
+#ifndef _COMMONLIB_NO_LOCKS_
+    LockSystemInit(InitSettings->MonitorSupport);
+#endif // _COMMONLIB_NO_LOCKS_
+
+    AssertSetFunction(InitSettings->AssertFunction);
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/event.c b/src_proiect/CommonLib/src/event.c
new file mode 100644
index 0000000..04a2f0a
--- /dev/null
+++ b/src_proiect/CommonLib/src/event.c
@@ -0,0 +1,90 @@
+#include "common_lib.h"
+#include "event.h"
+
+#define EVENT_STATE_NOT_SIGNALED        0
+#define EVENT_STATE_SIGNALED            1
+
+STATUS
+EvtInitialize(
+    OUT     EVENT*          Event,
+    IN      EVENT_TYPE      EventType,
+    IN      BOOLEAN         Signaled
+    )
+{
+    BYTE eventState;
+
+    if (NULL == Event)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (EventType >= EventTypeReserved)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    eventState = Signaled ? EVENT_STATE_SIGNALED : EVENT_STATE_NOT_SIGNALED;
+
+    Event->EventType = EventType;
+
+    _InterlockedExchange8(&Event->State, eventState);
+
+    return STATUS_SUCCESS;
+}
+
+void
+EvtSignal(
+    INOUT   EVENT*          Event
+    )
+{
+    ASSERT(NULL != Event);
+
+    _InterlockedExchange8(&Event->State, EVENT_STATE_SIGNALED);
+}
+
+void
+EvtClearSignal(
+    INOUT   EVENT*          Event
+    )
+{
+    ASSERT(NULL != Event);
+
+    _InterlockedExchange8(&Event->State, EVENT_STATE_NOT_SIGNALED);
+}
+
+void
+EvtWaitForSignal(
+    INOUT   EVENT*          Event
+    )
+{
+    BYTE exchangeValue;
+
+    ASSERT(NULL != Event);
+
+    exchangeValue = EventTypeNotification == Event->EventType ? 
+                        EVENT_STATE_SIGNALED : EVENT_STATE_NOT_SIGNALED;
+
+    // wait for the event to be signaled
+    while (EVENT_STATE_SIGNALED != (DWORD)_InterlockedCompareExchange8(&Event->State, exchangeValue, EVENT_STATE_SIGNALED))
+    {
+        _mm_pause();
+    }
+}
+
+BOOLEAN
+EvtIsSignaled(
+    INOUT   EVENT*          Event
+    )
+{
+    BYTE exchangeValue;
+    BYTE initialValue;
+
+    ASSERT( NULL != Event );
+
+    exchangeValue = EventTypeNotification == Event->EventType ? 
+                        EVENT_STATE_SIGNALED : EVENT_STATE_NOT_SIGNALED;
+
+    initialValue = _InterlockedCompareExchange8(&Event->State, exchangeValue, EVENT_STATE_SIGNALED);
+
+    return (initialValue == EVENT_STATE_SIGNALED);
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/gs_checks.c b/src_proiect/CommonLib/src/gs_checks.c
new file mode 100644
index 0000000..098a543
--- /dev/null
+++ b/src_proiect/CommonLib/src/gs_checks.c
@@ -0,0 +1,61 @@
+#ifdef CL_NO_RUNTIME_CHECKS
+
+// warning C4206: nonstandard extension used: translation unit is empty
+#pragma warning(disable:4206)
+#else
+#include "common_lib.h"
+
+#define DEFAULT_SECURITY_COOKIE_VALUE       (QWORD)0xBEEF'0301'2497'EC03ULL
+
+/// TODO: should we initialize the cookie at runtime?
+const UINT64 __security_cookie = DEFAULT_SECURITY_COOKIE_VALUE;
+
+// called when a buffer bound check fails
+// E.g: char buf[10] buf[10] = 'A';
+// From what I've seen in the disassembly no parameters
+// passed => we can only print the location where the
+// instruction occurred
+__declspec(noreturn)
+void
+__report_rangecheckfailure(
+    void
+)
+{
+    // warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+    ASSERT_INFO(FALSE, "RA is 0x%X\n", GET_RETURN_ADDRESS);
+}
+
+// NOT referenced anywhere in code
+__declspec(noreturn)
+void
+__GSHandlerCheck_SEH(
+    void
+)
+{
+    NOT_REACHED;
+}
+
+// NOT referenced anywhere in code
+__declspec(noreturn)
+void
+__GSHandlerCheck(
+    void
+)
+{
+    NOT_REACHED;
+}
+
+// Called for each function which uses a cookie
+__declspec(noreturn)
+void
+__cdecl
+__report_cookie_corruption(
+    IN UINT64 StackCookie
+)
+{
+    ASSERT_INFO(StackCookie == __security_cookie,
+                "Security cookie is 0x%X but should have been 0x%X. RA is 0x%X\n",
+                StackCookie, __security_cookie, GET_RETURN_ADDRESS);
+}
+#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src_proiect/CommonLib/src/gs_utils.c b/src_proiect/CommonLib/src/gs_utils.c
new file mode 100644
index 0000000..b4c03fd
--- /dev/null
+++ b/src_proiect/CommonLib/src/gs_utils.c
@@ -0,0 +1,48 @@
+#ifdef CL_NO_RUNTIME_CHECKS
+// warning C4206: nonstandard extension used: translation unit is empty
+#pragma warning(disable:4206)
+#else
+
+#include "common_lib.h"
+
+extern UINT64 __security_cookie;
+
+void
+GSNotifyStackChange(
+    IN  PVOID       OldStackBase,
+    IN  PVOID       NewStackBase,
+    IN  DWORD       OldStackSize
+    )
+{
+    PDWORD pOldStackCookie;
+    QWORD usedStackSize;
+    PVOID newRsp;
+
+    // our algorithm works only if the stacks are page aligned
+    ASSERT(IsAddressAligned(OldStackBase,PAGE_SIZE));
+    ASSERT(IsAddressAligned(NewStackBase,PAGE_SIZE));
+
+    newRsp = _AddressOfReturnAddress();
+    usedStackSize = min(OldStackSize, PtrDiff(NewStackBase, newRsp));
+
+    // Search [OldRsp, OldStackBase) for cookies
+    for (pOldStackCookie = (PDWORD) PtrDiff(OldStackBase, usedStackSize - sizeof(DWORD));
+         pOldStackCookie < (PDWORD) OldStackBase;
+         pOldStackCookie += 2)
+    {
+        // we assume that if the upper DWORD of the cookie XORed with the upper DWORD of the old RSP
+        // address is equal to the upper DWORD of the __security_cookie that we found a cookie
+        if ((*pOldStackCookie ^ QWORD_HIGH(OldStackBase)) == QWORD_HIGH(__security_cookie))
+        {
+            // PtrDiff(OldStackBase, pCookie - 1) => Offset from stack top to the cookie
+            // PtrDiff(NewStackBase, RES ) => Pointer to cookie on the new stack
+            PQWORD pNewStackCookie = (PQWORD)PtrDiff(NewStackBase, PtrDiff(OldStackBase, pOldStackCookie - 1));
+
+            // offsets within page coincide due to previous assumption (stack addresses are PAGE aligned)
+            QWORD xorResult = AlignAddressLower(pOldStackCookie, PAGE_SIZE) ^ AlignAddressLower(pNewStackCookie, PAGE_SIZE);
+
+            *pNewStackCookie = (*pNewStackCookie ^ xorResult);
+        }
+    }
+}
+#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src_proiect/CommonLib/src/hash_table.c b/src_proiect/CommonLib/src/hash_table.c
new file mode 100644
index 0000000..c507999
--- /dev/null
+++ b/src_proiect/CommonLib/src/hash_table.c
@@ -0,0 +1,374 @@
+#include "common_lib.h"
+#include "hash_table.h"
+
+#pragma warning(push)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+typedef struct _HASH_TABLE_DATA
+{
+    HASH_ENTRY          Entries[0];
+} HASH_TABLE_DATA, *PHASH_TABLE_DATA;
+#pragma warning(pop)
+
+static FUNC_CompareFunction _HashTableSearchElem;
+
+typedef struct _HASH_ELEM_SEARCH_CTX
+{
+    PHASH_TABLE             HashTable;
+
+    PHASH_ENTRY             PlaceholderEntry;
+
+    INT32                   Result;
+} HASH_ELEM_SEARCH_CTX, *PHASH_ELEM_SEARCH_CTX;
+
+static
+__forceinline
+PHASH_KEY
+_HashTableObtainKeyAddress(
+    IN      PHASH_TABLE         HashTable,
+    IN      PHASH_ENTRY         Element
+    )
+{
+    ASSERT(HashTable != NULL);
+    ASSERT(Element != NULL);
+
+    return (PHASH_KEY) ((PBYTE)Element + HashTable->OffsetToKey);
+}
+
+static
+__forceinline
+BOOLEAN
+_HashTableSearchKeyInBucket(
+    IN      PHASH_TABLE         HashTable,
+    IN      PHASH_ENTRY         Bucket,
+    IN      PHASH_KEY           Key,
+    OUT_PTR PHASH_ENTRY*        Placeholder
+    )
+{
+    PHASH_ENTRY pResult;
+    HASH_ELEM_SEARCH_CTX searchCtx = { 0 };
+
+    ASSERT(HashTable != NULL);
+    ASSERT(Bucket != NULL);
+    ASSERT(Key != NULL);
+    ASSERT(Placeholder != NULL);
+
+    searchCtx.HashTable = HashTable;
+    searchCtx.PlaceholderEntry = Bucket;
+    searchCtx.Result = 0;
+
+    // ListSearchForElement takes as the second argument (entry to compare with) a HASH_ENTRY, however because the only
+    // place that parameter is used is in our own _HashTableSearchElem function we do a 'hackish' optimization so as
+    // not to perform two extra operations
+    pResult = ListSearchForElement(Bucket, (PHASH_ENTRY) Key, TRUE, _HashTableSearchElem, &searchCtx);
+    if (pResult != NULL)
+    {
+        ASSERT(pResult == searchCtx.PlaceholderEntry);
+        ASSERT(searchCtx.Result == 0);
+    }
+
+    // If the result > 0 => the element we reached has a higher value than the one which we may want to insert, as a
+    // result the insertion will be done after the Blink pointer
+    *Placeholder = (searchCtx.Result > 0) ? searchCtx.PlaceholderEntry->Blink : searchCtx.PlaceholderEntry;
+
+    return (pResult != NULL);
+}
+
+DWORD
+HashTablePreinit(
+    OUT     PHASH_TABLE         HashTable,
+    IN      DWORD               MaxKeys,
+    IN      DWORD               KeySize
+    )
+{
+    ASSERT(HashTable != NULL);
+    ASSERT(0 < MaxKeys && MaxKeys < MAX_DWORD / sizeof(HASH_ENTRY));
+
+    memzero(HashTable, sizeof(HASH_TABLE));
+
+    HashTable->MaxKeys = MaxKeys;
+    HashTable->KeySize = KeySize;
+
+    return HashTable->MaxKeys * sizeof(HASH_ENTRY);
+}
+
+void
+HashTableInit(
+    INOUT   PHASH_TABLE         HashTable,
+    OUT_WRITES_BYTES(HashTable->MaxKeys * sizeof(HASH_ENTRY))
+            PHASH_TABLE_DATA    TableData,
+    IN      PFUNC_HashFunction  HashFunction,
+    IN      INT32               OffsetToKey
+    )
+{
+    ASSERT(HashTable != NULL);
+    ASSERT(TableData != NULL);
+    ASSERT(HashFunction != NULL);
+
+    HashTable->TableData = TableData;
+    HashTable->HashFunc = HashFunction;
+    HashTable->OffsetToKey = OffsetToKey;
+
+    for (DWORD i = 0; i < HashTable->MaxKeys; ++i)
+    {
+        InitializeListHead(&HashTable->TableData->Entries[i]);
+    }
+}
+
+void
+HashTableClear(
+    INOUT   PHASH_TABLE         HashTable,
+    IN_OPT  PFUNC_FreeFunction  FreeFunction,
+    IN_OPT  PVOID               FreeContext
+    )
+{
+    HASH_ITERATOR it;
+    PHASH_ENTRY pEntry;
+
+    ASSERT(HashTable != NULL);
+
+    HashTableIteratorInit(HashTable, &it);
+
+    while ((pEntry = HashTableIteratorNext(&it)) != NULL)
+    {
+        // remove from hash table
+        HashTableRemoveEntry(HashTable, pEntry);
+
+        // call free function if one was provided
+        if (FreeFunction != NULL)
+        {
+            FreeFunction(pEntry, FreeContext);
+        }
+    }
+}
+
+DWORD
+HashTableSize(
+    IN      HASH_TABLE*         HashTable
+    )
+{
+    ASSERT(HashTable != NULL);
+
+    return HashTable->NumberOfElements;
+}
+
+PHASH_ENTRY
+HashTableInsert(
+    INOUT   PHASH_TABLE         HashTable,
+    INOUT   PHASH_ENTRY         Element
+    )
+{
+    PHASH_ENTRY pPlaceToInsertInBucket;
+    PHASH_KEY pKey;
+    QWORD hIndex;
+
+    ASSERT(HashTable != NULL);
+    ASSERT(Element != NULL);
+
+    pKey = _HashTableObtainKeyAddress(HashTable, Element);
+
+    hIndex = HashTable->HashFunc(pKey,
+                                 HashTable->KeySize,
+                                 HashTable->MaxKeys);
+    ASSERT(hIndex < HashTable->MaxKeys);
+
+    BOOLEAN bElementAlreadyInHash = _HashTableSearchKeyInBucket(
+        HashTable,
+        &HashTable->TableData->Entries[hIndex],
+        pKey,
+        &pPlaceToInsertInBucket);
+
+    InsertHeadList(pPlaceToInsertInBucket, Element);
+
+    if (bElementAlreadyInHash)
+    {
+        RemoveEntryList(pPlaceToInsertInBucket);
+    }
+    else
+    {
+        HashTable->NumberOfElements++;
+    }
+
+    return bElementAlreadyInHash ? pPlaceToInsertInBucket : NULL;
+}
+
+PTR_SUCCESS
+PHASH_ENTRY
+HashTableRemove(
+    INOUT   PHASH_TABLE         HashTable,
+    IN      PHASH_KEY           Key
+    )
+{
+    PHASH_ENTRY pHashEntry;
+
+    ASSERT(HashTable != NULL);
+    ASSERT(Key != NULL);
+
+    pHashEntry = HashTableLookup(HashTable, Key);
+    if (pHashEntry != NULL)
+    {
+        HashTableRemoveEntry(HashTable, pHashEntry);
+    }
+
+    return pHashEntry;
+}
+
+void
+HashTableRemoveEntry(
+    INOUT   PHASH_TABLE         HashTable,
+    IN      PHASH_ENTRY         Element
+    )
+{
+    ASSERT(HashTable != NULL);
+    ASSERT(Element != NULL);
+
+    RemoveEntryList(Element);
+
+    HashTable->NumberOfElements--;
+}
+
+PTR_SUCCESS
+PHASH_ENTRY
+HashTableLookup(
+    INOUT   PHASH_TABLE         HashTable,
+    IN      PHASH_KEY           Key
+    )
+{
+    QWORD hIndex;
+    PHASH_ENTRY pResult;
+
+    ASSERT(HashTable != NULL);
+    ASSERT(Key != NULL);
+
+    hIndex = HashTable->HashFunc(Key,
+                                 HashTable->KeySize,
+                                 HashTable->MaxKeys);
+
+    BOOLEAN bElementInHash = _HashTableSearchKeyInBucket(
+        HashTable,
+        &HashTable->TableData->Entries[hIndex],
+        Key,
+        &pResult);
+
+    return bElementInHash ? pResult : NULL;
+}
+
+void
+HashTableIteratorInit(
+    IN      PHASH_TABLE         HashTable,
+    OUT     PHASH_ITERATOR      HashIterator
+    )
+{
+    ASSERT(HashTable != NULL);
+    ASSERT(HashIterator != NULL);
+
+    HashIterator->HashTable = HashTable;
+    HashIterator->KeyIndex = 0;
+
+    ListIteratorInit(&HashTable->TableData->Entries[0], &HashIterator->CurrentKeyIterator);
+}
+
+PHASH_ENTRY
+HashTableIteratorNext(
+    INOUT   PHASH_ITERATOR      HashIterator
+    )
+{
+    PHASH_ENTRY pResult;
+
+    ASSERT(HashIterator != NULL);
+
+    pResult = NULL;
+
+    while (HashIterator->KeyIndex < HashIterator->HashTable->MaxKeys)
+    {
+        pResult = ListIteratorNext(&HashIterator->CurrentKeyIterator);
+
+        if (pResult) break;
+
+        HashIterator->KeyIndex++;
+        ListIteratorInit(&HashIterator->HashTable->TableData->Entries[HashIterator->KeyIndex], &HashIterator->CurrentKeyIterator);
+    }
+
+    return pResult;
+}
+
+QWORD
+(__cdecl HashFuncGenericIncremental) (
+    IN_READS_BYTES(KeyLength)   PHASH_KEY   Key,
+    IN                          DWORD       KeyLength,
+    IN                          DWORD       MaxKeys
+    )
+{
+    QWORD keyValue;
+
+    ASSERT(Key != NULL);
+    ASSERT(KeyLength <= MAX_QWORD);
+
+    keyValue = 0;
+    cl_memcpy(&keyValue, Key, KeyLength);
+
+    return keyValue % MaxKeys;
+}
+
+#define HASH_UNIVERSAL_A        1701
+#define HASH_UNIVERSAL_B        59
+#define HASH_UNIVERSAL_P        10007
+
+STATIC_ASSERT_INFO(HASH_UNIVERSAL_P <= (MAX_QWORD / HASH_UNIVERSAL_A) - HASH_UNIVERSAL_B,
+    "If hash HASH_UNIVERSAL_P is too big we may have an OF, see assert in HashFuncUniversal");
+
+QWORD
+(__cdecl HashFuncUniversal) (
+    IN_READS_BYTES(KeyLength)   PHASH_KEY   Key,
+    IN                          DWORD       KeyLength,
+    IN                          DWORD       MaxKeys
+    )
+{
+    QWORD keyValue;
+    QWORD result;
+
+    ASSERT(Key != NULL);
+    ASSERT(KeyLength <= MAX_QWORD);
+
+    keyValue = 0;
+    cl_memcpy(&keyValue, Key, KeyLength);
+
+    // perform modulo operation first to make it less likely for
+    // an overflow to happen
+    result = keyValue % HASH_UNIVERSAL_P;
+
+    ASSERT_INFO(result < (MAX_QWORD / HASH_UNIVERSAL_A) - HASH_UNIVERSAL_B,
+        "Check for OF condition!\n");
+
+    return ((HASH_UNIVERSAL_A * result
+                + HASH_UNIVERSAL_B)
+                    % HASH_UNIVERSAL_P)
+                        % MaxKeys;
+}
+
+static
+INT64
+(__cdecl _HashTableSearchElem) (
+    IN      PLIST_ENTRY     FirstElem,
+    IN      PLIST_ENTRY     SecondElem,
+    IN_OPT  PVOID           Context
+    )
+{
+    PHASH_ELEM_SEARCH_CTX pCtx;
+
+    ASSERT(FirstElem != NULL);
+    ASSERT(SecondElem != NULL);
+    ASSERT(Context != NULL);
+
+    pCtx = (PHASH_ELEM_SEARCH_CTX)Context;
+
+    pCtx->PlaceholderEntry = FirstElem;
+
+    pCtx->Result = rmemcmp(
+        _HashTableObtainKeyAddress(pCtx->HashTable, FirstElem),
+        SecondElem, // This is actually a PHASH_KEY
+        pCtx->HashTable->KeySize);
+
+    return pCtx->Result;
+}
diff --git a/src_proiect/CommonLib/src/intutils.c b/src_proiect/CommonLib/src/intutils.c
new file mode 100644
index 0000000..0f01813
--- /dev/null
+++ b/src_proiect/CommonLib/src/intutils.c
@@ -0,0 +1,16 @@
+#include "common_lib.h"
+#include "intutils.h"
+
+QWORD
+CalculatePercentage(
+    IN      QWORD       WholeValue,
+    IN      WORD        HundredsOfPercentage
+    )
+{
+    ASSERT_INFO(HundredsOfPercentage <= 10000, 
+                "This function should only be used for sub-unitary ratios!");
+    ASSERT_INFO((MAX_QWORD / HundredsOfPercentage) >= WholeValue,
+                "The multiplication between WholeValue and HundredsOfPercentage would overflow!");
+
+    return (WholeValue * HundredsOfPercentage ) / 10000;
+}
diff --git a/src_proiect/CommonLib/src/list.c b/src_proiect/CommonLib/src/list.c
new file mode 100644
index 0000000..efaddb2
--- /dev/null
+++ b/src_proiect/CommonLib/src/list.c
@@ -0,0 +1,373 @@
+#include "common_lib.h"
+#include "list.h"
+
+//  Valid list state:
+//  |---------| Flink |---------| Flink |---------|
+//  |         |------>|         |------>|         |
+//  |  Blink  | Blink |  Entry  | Blink |  Flink  |
+//  |         |<------|         |<------|         |
+//  |---------|       |---------|       |---------|
+static
+__forceinline
+BOOLEAN
+_ValidateListEntry(
+    IN  PLIST_ENTRY Entry
+    )
+{
+    // check that the backward element points to this entry
+    if (Entry->Flink->Blink != Entry)
+    {
+        return FALSE;
+    }
+
+    // check that the forward element points to this entry
+    if (Entry->Blink->Flink != Entry)
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+void
+InitializeListHead(
+    OUT PLIST_ENTRY ListHead
+    )
+{
+    ListHead->Flink = ListHead->Blink = ListHead;
+}
+
+
+BOOLEAN
+IsListEmpty(
+    IN  PLIST_ENTRY ListHead
+    )
+{
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    return (BOOLEAN)(ListHead->Flink == ListHead);
+}
+
+BOOLEAN
+RemoveEntryList(
+    INOUT PLIST_ENTRY Entry
+    )
+{
+    PLIST_ENTRY Blink;
+    PLIST_ENTRY Flink;
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(Entry));
+#endif
+
+    Flink = Entry->Flink;
+    Blink = Entry->Blink;
+    Blink->Flink = Flink;
+    Flink->Blink = Blink;
+    return (BOOLEAN)(Flink == Blink);
+}
+
+PLIST_ENTRY
+RemoveHeadList(
+    INOUT PLIST_ENTRY ListHead
+    )
+{
+    PLIST_ENTRY Flink;
+    PLIST_ENTRY Entry;
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    Entry = ListHead->Flink;
+    Flink = Entry->Flink;
+    ListHead->Flink = Flink;
+    Flink->Blink = ListHead;
+    return Entry;
+}
+
+
+
+PLIST_ENTRY
+RemoveTailList(
+    INOUT PLIST_ENTRY ListHead
+    )
+{
+    PLIST_ENTRY Blink;
+    PLIST_ENTRY Entry;
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    Entry = ListHead->Blink;
+    Blink = Entry->Blink;
+    ListHead->Blink = Blink;
+    Blink->Flink = ListHead;
+    return Entry;
+}
+
+
+void
+InsertTailList(
+    INOUT PLIST_ENTRY ListHead,
+    INOUT PLIST_ENTRY Entry
+    )
+{
+    PLIST_ENTRY Blink;
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    Blink = ListHead->Blink;
+    Entry->Flink = ListHead;
+    Entry->Blink = Blink;
+    Blink->Flink = Entry;
+    ListHead->Blink = Entry;
+}
+
+
+void
+InsertHeadList(
+    INOUT PLIST_ENTRY ListHead,
+    INOUT PLIST_ENTRY Entry
+    )
+{
+    PLIST_ENTRY Flink;
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    Flink = ListHead->Flink;
+    Entry->Flink = Flink;
+    Entry->Blink = ListHead;
+    Flink->Blink = Entry;
+    ListHead->Flink = Entry;
+}
+
+void
+InsertOrderedList(
+    INOUT   PLIST_ENTRY             ListHead,
+    INOUT   PLIST_ENTRY             Entry,
+    IN      PFUNC_CompareFunction   CompareFunction,
+    IN_OPT  PVOID                   Context
+    )
+{
+    PLIST_ENTRY pCurrentEntry;
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    for (pCurrentEntry = ListHead->Flink;
+         pCurrentEntry != ListHead;
+         pCurrentEntry = pCurrentEntry->Flink
+         )
+    {
+        if (CompareFunction(Entry, pCurrentEntry, Context) < 0)
+        {
+            // entry to insert is smaller than current entry
+            break;
+        }
+    }
+
+    InsertTailList(pCurrentEntry, Entry);
+}
+
+PTR_SUCCESS
+PLIST_ENTRY
+GetListElemByIndex(
+    IN      PLIST_ENTRY ListHead,
+    IN      DWORD       ListIndex
+    )
+{
+    LIST_ENTRY* pCurEntry;
+    DWORD index;
+
+    if (NULL == ListHead)
+    {
+        return NULL;
+    }
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    pCurEntry = ListHead->Flink;
+
+    index = 0;
+    while (pCurEntry != ListHead)
+    {
+        ASSERT_INFO(NULL != pCurEntry, "ListEntry is NULL\n");
+        if (index == ListIndex)
+        {
+            return pCurEntry;
+        }
+
+        index = index + 1;
+        pCurEntry = pCurEntry->Flink;
+    }
+
+    return NULL;
+}
+
+SIZE_SUCCESS
+DWORD
+ListSize(
+    IN      PLIST_ENTRY ListHead
+    )
+{
+    DWORD count;
+    LIST_ENTRY* pCurEntry;
+
+    if (NULL == ListHead)
+    {
+        return INVALID_LIST_SIZE;
+    }
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    pCurEntry = ListHead->Flink;
+
+    count = 0;
+    while (pCurEntry != ListHead)
+    {
+        ASSERT_INFO(NULL != pCurEntry, "List entry is NULL\n");
+
+        count = count + 1;
+        pCurEntry = pCurEntry->Flink;
+    }
+
+    return count;
+}
+
+STATUS
+ForEachElementExecute(
+    IN      PLIST_ENTRY         ListHead,
+    IN      PFUNC_ListFunction  Function,
+    IN_OPT  PVOID               Context,
+    IN      BOOLEAN             AllMustSucceed
+    )
+{
+    STATUS status;
+    LIST_ENTRY* pCurListEntry;
+
+    if (NULL == ListHead)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == Function)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    status = STATUS_SUCCESS;
+
+    pCurListEntry = ListHead->Flink;
+    while (pCurListEntry != ListHead)
+    {
+        ASSERT_INFO(NULL != pCurListEntry, "List entry is NULL\n");
+        status = Function(pCurListEntry, Context);
+        if (AllMustSucceed)
+        {
+            if (!SUCCEEDED(status))
+            {
+                return status;
+            }
+        }
+        pCurListEntry = pCurListEntry->Flink;
+    }
+
+    return status;
+}
+
+PTR_SUCCESS
+PLIST_ENTRY
+ListSearchForElement(
+    IN      PLIST_ENTRY             ListHead,
+    IN      PLIST_ENTRY             ElementToSearchFor,
+    IN      BOOLEAN                 IsListOrdered,
+    IN      PFUNC_CompareFunction   CompareFunction,
+    IN_OPT  PVOID                   Context
+    )
+{
+    PLIST_ENTRY pCurEntry;
+
+    if (NULL == ListHead)
+    {
+        return NULL;
+    }
+
+    if (NULL == ElementToSearchFor)
+    {
+        return NULL;
+    }
+
+    if (NULL == CompareFunction)
+    {
+        return NULL;
+    }
+
+#ifdef DEBUG
+    ASSERT(_ValidateListEntry(ListHead));
+#endif
+
+    pCurEntry = ListHead->Flink;
+    while (pCurEntry != ListHead)
+    {
+        INT64 cmpResult = CompareFunction(pCurEntry, ElementToSearchFor, Context);
+
+        if (cmpResult == 0) return pCurEntry;
+        if (IsListOrdered && (cmpResult > 0)) return NULL;
+
+        pCurEntry = pCurEntry->Flink;
+    }
+
+    return NULL;
+}
+
+void
+ListIteratorInit(
+    IN      PLIST_ENTRY         List,
+    OUT     PLIST_ITERATOR      ListIterator
+    )
+{
+    ASSERT(List != NULL);
+    ASSERT(ListIterator != NULL);
+
+    ListIterator->ListHead = List;
+    ListIterator->CurrentEntry = List->Flink;
+}
+
+PLIST_ENTRY
+ListIteratorNext(
+    INOUT   PLIST_ITERATOR      ListIterator
+    )
+{
+    PLIST_ENTRY pResult;
+
+    ASSERT(ListIterator != NULL);
+
+    pResult = NULL;
+
+    if (ListIterator->CurrentEntry != ListIterator->ListHead)
+    {
+        pResult = ListIterator->CurrentEntry;
+
+        // advance current entry
+        ListIterator->CurrentEntry = ListIterator->CurrentEntry->Flink;
+    }
+
+    return pResult;
+}
diff --git a/src_proiect/CommonLib/src/lock_common.c b/src_proiect/CommonLib/src/lock_common.c
new file mode 100644
index 0000000..e07c1d6
--- /dev/null
+++ b/src_proiect/CommonLib/src/lock_common.c
@@ -0,0 +1,47 @@
+#include "common_lib.h"
+#include "lock_common.h"
+
+#ifndef _COMMONLIB_NO_LOCKS_
+
+PFUNC_LockInit           LockInit = NULL;
+
+PFUNC_LockAcquire        LockAcquire = NULL;
+
+PFUNC_LockTryAcquire     LockTryAcquire = NULL;
+
+PFUNC_LockRelease        LockRelease = NULL;
+
+PFUNC_LockIsOwner        LockIsOwner = NULL;
+
+#pragma warning(push)
+// warning C4028: formal parameter 1 different from declaration
+#pragma warning(disable:4028)
+
+void
+LockSystemInit(
+    IN      BOOLEAN             MonitorSupport
+    )
+{
+
+    if (MonitorSupport)
+    {
+        // we have monitor support
+        LockInit = MonitorLockInit;
+        LockAcquire = MonitorLockAcquire;
+        LockTryAcquire = MonitorLockTryAcquire;
+        LockIsOwner = MonitorLockIsOwner;
+        LockRelease = MonitorLockRelease;
+    }
+    else
+    {
+        // use classic spinlock
+        LockInit = SpinlockInit;
+        LockAcquire = SpinlockAcquire;
+        LockTryAcquire = SpinlockTryAcquire;
+        LockIsOwner = SpinlockIsOwner;
+        LockRelease = SpinlockRelease;
+    }
+}
+#pragma warning(pop)
+
+#endif // _COMMONLIB_NO_LOCKS_
diff --git a/src_proiect/CommonLib/src/monlock.c b/src_proiect/CommonLib/src/monlock.c
new file mode 100644
index 0000000..2e42c71
--- /dev/null
+++ b/src_proiect/CommonLib/src/monlock.c
@@ -0,0 +1,127 @@
+#include "common_lib.h"
+#include "lock_common.h"
+
+#ifndef _COMMONLIB_NO_LOCKS_
+
+void
+MonitorLockInit(
+    OUT         PMONITOR_LOCK       Lock
+    )
+{
+    ASSERT(NULL != Lock);
+
+    memzero(Lock, sizeof(MONITOR_LOCK));
+
+    _InterlockedExchange8(&Lock->Lock.State, LOCK_FREE);
+}
+
+void
+MonitorLockAcquire(
+    INOUT       PMONITOR_LOCK       Lock,
+    OUT         INTR_STATE*         IntrState
+    )
+{
+    PVOID pCurrentCpu;
+
+    ASSERT(NULL != Lock);
+    ASSERT(NULL != IntrState);
+
+    *IntrState = CpuIntrDisable();
+
+    pCurrentCpu = CpuGetCurrent();
+
+    ASSERT_INFO(pCurrentCpu != Lock->Lock.Holder,
+                "Lock initial taken by function 0x%X, now called by 0x%X\n",
+                Lock->Lock.FunctionWhichTookLock,
+                *((PVOID*)_AddressOfReturnAddress())
+                );
+
+// warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+    while(TRUE)
+    {
+        _mm_monitor(Lock, 0, 0);
+
+        if (LOCK_FREE == _InterlockedCompareExchange8(&Lock->Lock.State, LOCK_TAKEN, LOCK_FREE))
+        {
+            break;
+        }
+
+        _mm_mwait(0, 0);
+    }
+
+    ASSERT(NULL == Lock->Lock.FunctionWhichTookLock);
+    ASSERT(NULL == Lock->Lock.Holder);
+
+    Lock->Lock.Holder = pCurrentCpu;
+    Lock->Lock.FunctionWhichTookLock = *((PVOID*)_AddressOfReturnAddress());
+
+    ASSERT(LOCK_TAKEN == Lock->Lock.State);
+}
+
+BOOL_SUCCESS
+BOOLEAN
+MonitorLockTryAcquire(
+    INOUT       PMONITOR_LOCK       Lock,
+    OUT         INTR_STATE*         IntrState
+    )
+{
+    BOOLEAN acquired;
+
+    PVOID pCurrentCpu;
+
+    ASSERT(NULL != Lock);
+    ASSERT(NULL != IntrState);
+
+    *IntrState = CpuIntrDisable();
+
+    pCurrentCpu = CpuGetCurrent();
+
+    acquired = (LOCK_FREE == _InterlockedCompareExchange8(&Lock->Lock.State, LOCK_TAKEN, LOCK_FREE));
+    if (!acquired)
+    {
+        CpuIntrSetState(*IntrState);
+    }
+    else
+    {
+        ASSERT(NULL == Lock->Lock.FunctionWhichTookLock);
+        ASSERT(NULL == Lock->Lock.Holder);
+
+        Lock->Lock.Holder = pCurrentCpu;
+        Lock->Lock.FunctionWhichTookLock = *((PVOID*)_AddressOfReturnAddress());
+
+        ASSERT(LOCK_TAKEN == Lock->Lock.State);
+    }
+
+    return acquired;
+}
+
+BOOLEAN
+MonitorLockIsOwner(
+    IN          PMONITOR_LOCK       Lock
+    )
+{
+    return CpuGetCurrent() == Lock->Lock.Holder;
+}
+
+void
+MonitorLockRelease(
+    INOUT       PMONITOR_LOCK       Lock,
+    IN          INTR_STATE          OldIntrState
+    )
+{
+    PVOID pCurrentCpu = CpuGetCurrent();
+
+    ASSERT(NULL != Lock);
+    ASSERT(pCurrentCpu == Lock->Lock.Holder);
+    ASSERT(INTR_OFF == CpuIntrGetState());
+
+    Lock->Lock.Holder = NULL;
+    Lock->Lock.FunctionWhichTookLock = NULL;
+
+    _InterlockedExchange8(&Lock->Lock.State, LOCK_FREE);
+
+    CpuIntrSetState(OldIntrState);
+}
+
+#endif // _COMMONLIB_NO_LOCKS_
diff --git a/src_proiect/CommonLib/src/rec_rw_spinlock.c b/src_proiect/CommonLib/src/rec_rw_spinlock.c
new file mode 100644
index 0000000..3fd269d
--- /dev/null
+++ b/src_proiect/CommonLib/src/rec_rw_spinlock.c
@@ -0,0 +1,128 @@
+#include "common_lib.h"
+#include "rec_rw_spinlock.h"
+#include "lock_common.h"
+
+#ifndef _COMMONLIB_NO_LOCKS_
+
+#define RW_DEFAULT_RECURSIVITY_DEPTH_MAX                2
+
+void
+RecRwSpinlockInit(
+    IN      BYTE                    RecursivityDepth,
+    OUT     PREC_RW_SPINLOCK        Spinlock
+    )
+{
+    BYTE recursivityDepth;
+
+    ASSERT(NULL != Spinlock);
+
+    memzero(Spinlock, sizeof(REC_RW_SPINLOCK));
+
+    recursivityDepth = (0 == RecursivityDepth) ? RW_DEFAULT_RECURSIVITY_DEPTH_MAX : RecursivityDepth;
+
+    RwSpinlockInit(&Spinlock->RwSpinlock);
+
+    Spinlock->MaxRecursivityDepth = recursivityDepth;
+}
+
+// warning C26165 : Possibly failing to release lock '* Spinlock' in function 'RecRwSpinlockAcquire'.
+// well we're not actually attempting to release a lock in this function...
+#pragma warning(push)
+#pragma warning(disable:26165)
+
+REQUIRES_NOT_HELD_LOCK(*Spinlock)
+_When_(Exclusive, ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RecRwSpinlockAcquire(
+    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    OUT     INTR_STATE*         IntrState,
+    IN      BOOLEAN             Exclusive
+    )
+{
+    PVOID pCurrentCpu;
+    INTR_STATE dummy;
+
+    ASSERT(NULL != Spinlock);
+    ASSERT(NULL != IntrState);
+
+    *IntrState = CpuIntrDisable();
+    pCurrentCpu = CpuGetCurrent();
+
+    if (Exclusive)
+    {
+        if (Spinlock->Holder == pCurrentCpu)
+        {
+            ASSERT_INFO( Spinlock->CurrentRecursivityDepth < Spinlock->MaxRecursivityDepth,
+                        "Current recursivity depth: %u\nMax recursivity depth: %u\n",
+                        Spinlock->CurrentRecursivityDepth,
+                        Spinlock->MaxRecursivityDepth
+                        );
+
+            _Analysis_assume_lock_acquired_(*Spinlock);
+            Spinlock->CurrentRecursivityDepth++;
+            return;
+        }
+    }
+
+    // if we get here => we need to call RwSpinlockAcquire
+    RwSpinlockAcquire(&Spinlock->RwSpinlock, &dummy, Exclusive );
+
+    ASSERT( NULL == Spinlock->Holder );
+    ASSERT( 0 == Spinlock->CurrentRecursivityDepth );
+
+    if (Exclusive)
+    {
+        Spinlock->CurrentRecursivityDepth = 1;
+        Spinlock->Holder = CpuGetCurrent();
+    }
+}
+#pragma warning(pop)
+
+// warning C26167: Possibly releasing unheld lock '* Spinlock' in function 'RecRwSpinlockRelease'.
+// FALSE, even if we tell SAL we used reentrant locks it's still stupid, and wants a release on
+// each call, so we need to tell him we release the lock in the first branch, and as a result
+// there's a situation in which he thinks we release the lock twice, one on the first branch
+// and second on the RwSpinlockRelease
+#pragma warning(push)
+#pragma warning(disable:26167)
+
+_When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RecRwSpinlockRelease(
+    INOUT   REC_RW_SPINLOCK     *Spinlock,
+    IN      INTR_STATE          IntrState,
+    IN      BOOLEAN             Exclusive
+    )
+{
+    PVOID pCurrentCpu;
+
+    ASSERT( NULL != Spinlock );
+    ASSERT(INTR_OFF == CpuIntrGetState());
+
+    pCurrentCpu = CpuGetCurrent();
+
+    if (Exclusive)
+    {
+        ASSERT(pCurrentCpu == Spinlock->Holder);
+
+        // if we're past the previous assert => lock is held by this CPU, SAL doesn't realize it, so assume it
+        _Analysis_assume_lock_held_(*Spinlock);
+        Spinlock->CurrentRecursivityDepth--;
+        
+        _Analysis_assume_lock_released_(*Spinlock);
+    }
+
+    if (0 == Spinlock->CurrentRecursivityDepth || !Exclusive)
+    {
+        Spinlock->Holder = NULL;
+
+        _Analysis_assume_lock_held_(*Spinlock);
+        RwSpinlockRelease(&Spinlock->RwSpinlock, IntrState, Exclusive );
+    }
+}
+
+#pragma warning(pop)
+
+#endif // _COMMONLIB_NO_LOCKS_
diff --git a/src_proiect/CommonLib/src/ref_cnt.c b/src_proiect/CommonLib/src/ref_cnt.c
new file mode 100644
index 0000000..96def86
--- /dev/null
+++ b/src_proiect/CommonLib/src/ref_cnt.c
@@ -0,0 +1,80 @@
+#include "common_lib.h"
+#include "ref_cnt.h"
+#include "cl_memory.h"
+
+void
+RfcPreInit(
+    OUT     REF_COUNT*              Object
+    )
+{
+    ASSERT(NULL != Object);
+
+    memzero(Object, sizeof(REF_COUNT));
+}
+
+STATUS
+RfcInit(
+    OUT     REF_COUNT*              Object,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   Context
+    )
+{
+    STATUS status;
+
+    if (NULL == Object)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+
+    Object->FreeFunction = FreeFunction;
+    Object->Context = Context;
+    Object->ReferenceCount = 1;
+
+    return status;
+}
+
+SIZE_SUCCESS
+DWORD
+RfcReference(
+    INOUT   REF_COUNT*              Object
+    )
+{
+    DWORD newRefCount;
+
+    ASSERT(NULL != Object);
+
+    newRefCount = (DWORD)_InterlockedIncrement(&Object->ReferenceCount);
+    ASSERT_INFO(MAX_DWORD > newRefCount, "Reached max reference count");
+    ASSERT_INFO( 1 <= newRefCount,
+                "Inexistent object with %u references referenced",
+                newRefCount - 1
+                );
+
+    return newRefCount;
+}
+
+SIZE_SUCCESS
+DWORD
+RfcDereference(
+    INOUT   REF_COUNT*              Object
+    )
+{
+    DWORD newRefCount;
+
+    ASSERT(NULL != Object);
+
+    newRefCount = (DWORD)_InterlockedDecrement(&Object->ReferenceCount);
+    ASSERT_INFO(MAX_DWORD != newRefCount, "Object reference count reached -1");
+
+    if (0 == newRefCount)
+    {
+        if (NULL != Object->FreeFunction)
+        {
+            Object->FreeFunction(Object, Object->Context);
+        }
+    }
+
+    return newRefCount;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/rtc_checks.c b/src_proiect/CommonLib/src/rtc_checks.c
new file mode 100644
index 0000000..37091af
--- /dev/null
+++ b/src_proiect/CommonLib/src/rtc_checks.c
@@ -0,0 +1,84 @@
+#ifdef CL_NO_RUNTIME_CHECKS
+// warning C4206: nonstandard extension used: translation unit is empty
+#pragma warning(disable:4206)
+#else
+
+#include "common_lib.h"
+
+#define UNUSED_PATTERN     (DWORD)0xCC'CC'CC'CCUL
+
+#pragma pack(push,8)
+typedef struct _RTC_vardesc
+{
+    // offsets from ESP
+    DWORD addr;
+    DWORD size;
+    char *name;
+} _RTC_vardesc;
+
+typedef struct _RTC_framedesc
+{
+    DWORD           varCount;
+    DWORD           __alignment;
+    _RTC_vardesc*   variables;
+} _RTC_framedesc;
+#pragma pack(pop)
+
+// NOT referenced anywhere in code
+__declspec(noreturn)
+void
+__cdecl
+_RTC_Shutdown(
+    void
+)
+{
+    NOT_REACHED;
+}
+
+// NOT referenced anywhere in code
+__declspec(noreturn)
+void
+__cdecl
+_RTC_InitBase(
+    void
+)
+{
+    NOT_REACHED;
+}
+
+// we are the ones responsible for checking if any buffer overflow occurred near
+// the protected variables
+void
+__fastcall
+_RTC_CheckStackVars(
+    PVOID           Rsp,
+    _RTC_framedesc *_Fd
+)
+{
+    DWORD i;
+
+    for (i = 0; i < _Fd->varCount; ++i)
+    {
+        DWORD baseValue, endValue;
+
+        PDWORD pBase = (PDWORD)PtrOffset(Rsp, _Fd->variables[i].addr);
+        PDWORD pEnd = (PDWORD)PtrOffset(pBase, _Fd->variables[i].size);
+
+        baseValue = *(pBase - 1);
+        endValue = *pEnd;
+
+        ASSERT_INFO(baseValue == UNUSED_PATTERN && endValue == UNUSED_PATTERN,
+                    "Variable [%s]\n"
+                    "Base value is 0x%x at 0x%X\n"
+                    "End value is 0x%x at 0x%X\n"
+                    "Both values should be 0x%x\n"
+                    "RA at 0x%X\n",
+                    _Fd->variables[i].name,
+                    baseValue, pBase - 1,
+                    endValue, pEnd,
+                    UNUSED_PATTERN,
+                    GET_RETURN_ADDRESS
+        );
+    }
+}
+#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src_proiect/CommonLib/src/rw_spinlock.c b/src_proiect/CommonLib/src/rw_spinlock.c
new file mode 100644
index 0000000..b485d55
--- /dev/null
+++ b/src_proiect/CommonLib/src/rw_spinlock.c
@@ -0,0 +1,103 @@
+#include "common_lib.h"
+#include "lock_common.h"
+
+#ifndef _COMMONLIB_NO_LOCKS_
+
+void
+RwSpinlockInit(
+    OUT     PRW_SPINLOCK    Spinlock
+    )
+{
+    ASSERT( NULL != Spinlock );
+
+    memzero( Spinlock, sizeof(RW_SPINLOCK));
+}
+
+REQUIRES_NOT_HELD_LOCK(*Spinlock)
+_When_(Exclusive, ACQUIRES_EXCL_AND_NON_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, ACQUIRES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RwSpinlockAcquire(
+    INOUT   RW_SPINLOCK     *Spinlock,
+    OUT     INTR_STATE*     IntrState,
+    IN      BOOLEAN         Exclusive
+    )
+{
+    ASSERT( NULL != Spinlock );
+    ASSERT( NULL != IntrState );
+
+    *IntrState = CpuIntrDisable();
+
+    if (Exclusive)
+    {
+        _InterlockedIncrement16(&Spinlock->WaitingWriters);
+
+        // because this is done on DWORD it will affect ActiveWrite and ActiveReaders
+        while (0 != _InterlockedCompareExchange((volatile DWORD*) &Spinlock->ActiveWriter, 1, 0))
+        {
+            _mm_pause();
+        }
+
+        // we're here => we're the active writer
+        // => we're no longer a waiting writer
+        _InterlockedDecrement16(&Spinlock->WaitingWriters);
+        _Analysis_assume_lock_acquired_(*Spinlock);
+    }
+    else
+    {
+        DWORD pseudoActiveWriter = MAX_WORD + 1;
+
+        // shared
+
+        // pretend to take lock exclusively
+        // but instead of checking ActiveWriter and ActiveReaders
+        // check WaitingWriters and ActiveWriter (so writers will have priority)
+        while (0 != _InterlockedCompareExchange((volatile DWORD*) &Spinlock->WaitingWriters, pseudoActiveWriter, 0))
+        {
+            _mm_pause();
+        }
+
+        // we're here => we're an active reader
+        _InterlockedIncrement16(&Spinlock->ActiveReaders);
+
+        ASSERT( 1 == Spinlock->ActiveWriter );
+
+        // let's be honest now and tell the world
+        // we're not a writer
+        _InterlockedDecrement16(&Spinlock->ActiveWriter);
+        _Analysis_assume_lock_acquired_(*Spinlock);
+    }
+}
+
+_When_(Exclusive, REQUIRES_EXCL_LOCK(*Spinlock) RELEASES_EXCL_AND_NON_REENTRANT_LOCK(*Spinlock))
+_When_(!Exclusive, REQUIRES_SHARED_LOCK(*Spinlock) RELEASES_SHARED_AND_NON_REENTRANT_LOCK(*Spinlock))
+void
+RwSpinlockRelease(
+    INOUT   RW_SPINLOCK     *Spinlock,
+    IN      INTR_STATE      IntrState,
+    IN      BOOLEAN         Exclusive
+    )
+{
+    ASSERT( NULL != Spinlock );
+
+    if (Exclusive)
+    {
+        ASSERT( 1 == Spinlock->ActiveWriter );
+
+        _InterlockedDecrement16(&Spinlock->ActiveWriter);
+        _Analysis_assume_lock_released_(*Spinlock);
+    }
+    else
+    {
+        // shared
+
+        // in this case may have 1 pseudo-active writer as well until
+        // the reader 'confesses' to the world it is not a writer
+        _InterlockedDecrement16(&Spinlock->ActiveReaders);
+        _Analysis_assume_lock_released_(*Spinlock);
+    }
+
+    CpuIntrSetState(IntrState);
+}
+
+#endif // _COMMONLIB_NO_LOCKS_
diff --git a/src_proiect/CommonLib/src/seh.c b/src_proiect/CommonLib/src/seh.c
new file mode 100644
index 0000000..a2f3f72
--- /dev/null
+++ b/src_proiect/CommonLib/src/seh.c
@@ -0,0 +1,26 @@
+#ifdef CL_NO_RUNTIME_CHECKS
+// warning C4206: nonstandard extension used: translation unit is empty
+#pragma warning(disable:4206)
+#else
+
+#include "common_lib.h"
+#include "seh.h"
+
+EXCEPTION_DISPOSITION
+__C_specific_handler(
+    _In_    struct _EXCEPTION_RECORD*   ExceptionRecord,
+    _In_    void*                       EstablisherFrame,
+    _Inout_ struct _CONTEXT*            ContextRecord,
+    _Inout_ struct _DISPATCHER_CONTEXT* DispatcherContext
+)
+{
+    UNREFERENCED_PARAMETER(ExceptionRecord);
+    UNREFERENCED_PARAMETER(EstablisherFrame);
+    UNREFERENCED_PARAMETER(ContextRecord);
+    UNREFERENCED_PARAMETER(DispatcherContext);
+
+    NOT_REACHED;
+
+    return ExceptionContinueExecution;
+}
+#endif // CL_NO_RUNTIME_CHECKS
diff --git a/src_proiect/CommonLib/src/spinlock.c b/src_proiect/CommonLib/src/spinlock.c
new file mode 100644
index 0000000..a89f6b2
--- /dev/null
+++ b/src_proiect/CommonLib/src/spinlock.c
@@ -0,0 +1,121 @@
+#include "common_lib.h"
+#include "lock_common.h"
+
+#ifndef _COMMONLIB_NO_LOCKS_
+
+void
+SpinlockInit(
+    OUT         PSPINLOCK       Lock
+    )
+{
+    ASSERT(NULL != Lock);
+
+    memzero(Lock, sizeof(SPINLOCK));
+
+    _InterlockedExchange8(&Lock->State, LOCK_FREE);
+}
+
+void
+SpinlockAcquire(
+    INOUT       PSPINLOCK       Lock,
+    OUT         INTR_STATE*     IntrState
+    )
+{
+    PVOID pCurrentCpu;
+
+    ASSERT(NULL != Lock);
+    ASSERT(NULL != IntrState);
+
+    *IntrState = CpuIntrDisable();
+
+    pCurrentCpu = CpuGetCurrent();
+
+    ASSERT_INFO(pCurrentCpu != Lock->Holder,
+                "Lock initial taken by function 0x%X, now called by 0x%X\n",
+                Lock->FunctionWhichTookLock,
+                *((PVOID*)_AddressOfReturnAddress())
+                );
+
+    while (LOCK_TAKEN == _InterlockedCompareExchange8(&Lock->State, LOCK_TAKEN, LOCK_FREE))
+    {
+        _mm_pause();
+    }
+
+    ASSERT(NULL == Lock->FunctionWhichTookLock);
+    ASSERT(NULL == Lock->Holder);
+
+    Lock->Holder = pCurrentCpu;
+    Lock->FunctionWhichTookLock = *( (PVOID*) _AddressOfReturnAddress() );
+
+    ASSERT(LOCK_TAKEN == Lock->State);
+}
+
+BOOL_SUCCESS
+BOOLEAN
+SpinlockTryAcquire(
+    INOUT       PSPINLOCK       Lock,
+    OUT         INTR_STATE*     IntrState
+    )
+{
+    PVOID pCurrentCpu;
+
+    BOOLEAN acquired;
+
+    ASSERT(NULL != Lock);
+    ASSERT(NULL != IntrState);
+
+    *IntrState = CpuIntrDisable();
+
+    pCurrentCpu = CpuGetCurrent();
+
+    acquired = (LOCK_FREE == _InterlockedCompareExchange8(&Lock->State, LOCK_TAKEN, LOCK_FREE));
+    if (!acquired)
+    {
+        CpuIntrSetState(*IntrState);
+    }
+    else
+    {
+        ASSERT(NULL == Lock->FunctionWhichTookLock);
+        ASSERT(NULL == Lock->Holder);
+
+        Lock->Holder = pCurrentCpu;
+        Lock->FunctionWhichTookLock = *((PVOID*)_AddressOfReturnAddress());
+
+        ASSERT(LOCK_TAKEN == Lock->State);
+    }
+
+    return acquired;
+}
+
+BOOLEAN
+SpinlockIsOwner(
+    IN          PSPINLOCK       Lock
+    )
+{
+    return CpuGetCurrent() == Lock->Holder;
+}
+
+void
+SpinlockRelease(
+    INOUT       PSPINLOCK       Lock,
+    IN          INTR_STATE      OldIntrState
+    )
+{
+    PVOID pCurrentCpu = CpuGetCurrent();
+
+    ASSERT(NULL != Lock);
+    ASSERT_INFO(pCurrentCpu == Lock->Holder,
+                "LockTaken by CPU: 0x%X in function: 0x%X\nNow release by CPU: 0x%X in function: 0x%X\n",
+                Lock->Holder, Lock->FunctionWhichTookLock,
+                pCurrentCpu, *( (PVOID*) _AddressOfReturnAddress() ) );
+    ASSERT(INTR_OFF == CpuIntrGetState());
+
+    Lock->Holder = NULL;
+    Lock->FunctionWhichTookLock = NULL;
+
+    _InterlockedExchange8(&Lock->State, LOCK_FREE);
+
+    CpuIntrSetState(OldIntrState);
+}
+
+#endif // _COMMONLIB_NO_LOCKS_
diff --git a/src_proiect/CommonLib/src/stack_dynamic.c b/src_proiect/CommonLib/src/stack_dynamic.c
new file mode 100644
index 0000000..6184636
--- /dev/null
+++ b/src_proiect/CommonLib/src/stack_dynamic.c
@@ -0,0 +1,140 @@
+#include "common_lib.h"
+#include "stack_dynamic.h"
+
+typedef struct _STACK
+{
+    CL_SLIST_ENTRY             TopOfStack;
+
+    DWORD                   NumberOfElements;
+} STACK, *PSTACK;
+
+BOOLEAN
+(__cdecl StackDynamicPush)(
+    INOUT   PSTACK          Stack,
+    IN      PSTACK_ITEM     Item
+    )
+{
+    ASSERT(Stack != NULL);
+    ASSERT(Item != NULL);
+
+    ClPushEntryList( &Stack->TopOfStack, &Item->Next );
+
+    ASSERT(Stack->NumberOfElements < MAX_DWORD);
+    Stack->NumberOfElements++;
+
+    return TRUE;
+}
+
+_Must_inspect_result_
+_Success_(return != NULL)
+STACK_ITEM*
+(__cdecl StackDynamicPop)(
+    INOUT   PSTACK          Stack
+    )
+{
+    ASSERT(Stack != NULL);
+
+    CL_SLIST_ENTRY *pStackEntry = ClPopEntryList(&Stack->TopOfStack);
+
+    if (pStackEntry == NULL) return NULL;
+
+    ASSERT(Stack->NumberOfElements > 0);
+    Stack->NumberOfElements--;
+
+    return CONTAINING_RECORD(pStackEntry, STACK_ITEM, Next);
+}
+
+_Must_inspect_result_
+_Success_(return != NULL)
+STACK_ITEM*
+(__cdecl StackDynamicPeek)(
+    IN      PSTACK          Stack,
+    IN      DWORD           Index
+    )
+{
+    DWORD currentIndex = 0;
+    PCL_SLIST_ENTRY pItem = NULL;
+
+    ASSERT(Stack != NULL);
+
+    if (Index >= Stack->NumberOfElements)
+    {
+        return NULL;
+    }
+
+    for(pItem = Stack->TopOfStack.Next;
+        pItem != NULL && currentIndex < Index;
+        pItem = pItem->Next )
+    {
+        currentIndex++;
+    }
+
+    ASSERT(pItem != NULL);
+
+    return CONTAINING_RECORD(pItem, STACK_ITEM, Next);
+}
+
+void
+(__cdecl StackDynamicClear)(
+    INOUT   PSTACK              Stack,
+    IN_OPT  PFUNC_FreeFunction  FreeFunction,
+    IN_OPT  PVOID               FreeContext
+    )
+{
+    ASSERT(Stack != NULL);
+
+    while (!StackDynamicIsEmpty(Stack))
+    {
+        PSTACK_ITEM pItem = StackDynamicPop(Stack);
+        ASSERT(pItem != NULL);
+
+        if (FreeFunction != NULL)
+        {
+            FreeFunction(pItem, FreeContext);
+        }
+    }
+}
+
+
+BOOLEAN
+(__cdecl StackDynamicIsEmpty)(
+    INOUT   PSTACK          Stack
+    )
+{
+    ASSERT(Stack != NULL);
+
+    return Stack->TopOfStack.Next == NULL;
+}
+
+DWORD
+(__cdecl StackDynamicSize)(
+    INOUT   PSTACK          Stack
+    )
+{
+    ASSERT(Stack != NULL);
+
+    return Stack->NumberOfElements;
+}
+
+DWORD
+StackDynamicGetRequiredSize(
+    IN      DWORD                   MaxElements
+    )
+{
+    UNREFERENCED_PARAMETER(MaxElements);
+
+    return sizeof(STACK);
+}
+
+STATUS
+StackDynamicInit(
+    OUT     PSTACK                  Stack
+    )
+{
+    cl_memzero(Stack, sizeof(STACK));
+
+    ClInitializeSListHead(&Stack->TopOfStack);
+    Stack->NumberOfElements = 0;
+
+    return STATUS_SUCCESS;
+}
diff --git a/src_proiect/CommonLib/src/stack_interface.c b/src_proiect/CommonLib/src/stack_interface.c
new file mode 100644
index 0000000..6a6a954
--- /dev/null
+++ b/src_proiect/CommonLib/src/stack_interface.c
@@ -0,0 +1,77 @@
+#include "common_lib.h"
+#include "stack_interface.h"
+#include "stack_internal.h"
+
+#include "stack_dynamic.h"
+
+typedef struct _STACK_COMPLETE_FUNCS
+{
+    STACK_INTERFACE_FUNCS           PublicFuncs;
+
+    STACK_PRIVATE_INTERFACE_FUNCS   PrivateFuncs;
+} STACK_COMPLETE_FUNCS, *PSTACK_COMPLETE_FUNCS;
+
+static const STACK_COMPLETE_FUNCS STACK_FUNCS[StackTypeReserved] =
+{
+    {// StackTypeDynamic
+        StackDynamicPush,
+        StackDynamicPop,
+        StackDynamicPeek,
+        StackDynamicClear,
+        StackDynamicIsEmpty,
+        StackDynamicSize,
+        StackDynamicGetRequiredSize,
+        StackDynamicInit
+    },
+
+    { NULL, NULL, NULL, NULL, NULL },       // StackTypeInterlocked
+};
+
+DWORD
+StackGetRequiredSize(
+    IN      DWORD                   MaxElements,
+    IN      STACK_TYPE              Type
+    )
+{
+    ASSERT(MaxElements > 0);
+    ASSERT(Type < StackTypeReserved );
+
+    return STACK_FUNCS[Type].PrivateFuncs.StackGetRequiredSize(MaxElements);
+}
+
+STATUS
+StackCreate(
+    OUT     PSTACK_INTERFACE        StackInterface,
+    IN      STACK_TYPE              Type,
+    OUT     PSTACK                  Stack
+    )
+{
+    STATUS status;
+
+    if (StackInterface == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (Type >= StackTypeReserved)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (Stack == NULL)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    status = STACK_FUNCS[Type].PrivateFuncs.StackInit(Stack);
+    if (!SUCCEEDED(status))
+    {
+        return status;
+    }
+
+    StackInterface->Stack = Stack;
+
+    cl_memcpy(&StackInterface->Funcs, (PVOID) &STACK_FUNCS[Type].PublicFuncs, sizeof(STACK_INTERFACE_FUNCS));
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/strutils.c b/src_proiect/CommonLib/src/strutils.c
new file mode 100644
index 0000000..e7c8241
--- /dev/null
+++ b/src_proiect/CommonLib/src/strutils.c
@@ -0,0 +1,193 @@
+#include "common_lib.h"
+#include "strutils.h"
+
+__forceinline
+void
+swap(
+    INOUT   BYTE* a,
+    INOUT   BYTE* b
+    )
+{
+    *a ^= *b;
+    *b ^= *a;
+    *a ^= *b;
+}
+
+void
+itoa(
+    IN      PVOID       valueAddress,
+    IN      BOOLEAN     signedValue,
+    OUT_Z   char*       buffer,
+    IN      DWORD       base,
+    IN      BOOLEAN     is64BitValue
+    )
+{
+    DWORD index = 0;
+    DWORD i;
+    QWORD value;
+    BOOLEAN negative;
+
+    ASSERT( NULL != valueAddress );
+    ASSERT( NULL != buffer );
+    ASSERT( 0 != base );
+
+    negative = FALSE;
+
+    if (is64BitValue)
+    {
+        if (signedValue)
+        {
+            if (0 > *(INT64*)valueAddress)
+            {
+                negative = TRUE;
+            }
+        }
+
+        if (negative)
+        {
+            value = (-(*(INT64*)valueAddress));
+        }
+        else
+        {
+            value = *(QWORD*)valueAddress;
+        }
+    }
+    else
+    {
+        if (signedValue)
+        {
+            if (0 > *(INT32*)valueAddress)
+            {
+                negative = TRUE;
+            }
+        }
+
+        if (negative)
+        {
+            value = (-(*(INT32*)valueAddress));
+        }
+        else
+        {
+            value = *(DWORD*)valueAddress;
+        }
+    }
+
+
+
+    if (0 == value)
+    {
+        buffer[index] = '0';
+        index++;
+    }
+
+    // we convert the number and get a
+    // reversed ordered string
+    while (0 != value)
+    {
+        // we get the current digit
+        int digit = (value % base);
+
+        // we convert it to an ASCII character
+        if (digit > 9)
+        {
+            buffer[index] = (char)(digit - 10) + 'A';
+        }
+        else
+        {
+            buffer[index] = (char)digit + '0';
+        }
+
+        value = value / base;
+        index++;
+    }
+
+    if (negative)
+    {
+        buffer[index] = '-';
+        index++;
+    }
+
+    // we null terminate the string
+    buffer[index] = '\0';
+
+    for (i = 0; i < index / 2; ++i)
+    {
+        // we reverse the string to have it ordered right
+        swap((BYTE*)&buffer[i], (BYTE*)&buffer[index - i - 1]);
+    }
+}
+
+void
+atoi(
+    _When_(!is64BitValue, OUT_WRITES_BYTES_ALL(sizeof(DWORD)))
+    _When_(is64BitValue, OUT_WRITES_BYTES_ALL(sizeof(QWORD)))
+            PVOID       valueAddress,
+    IN_Z    char*       buffer,
+    IN      DWORD       base,
+    IN      BOOLEAN     is64BitValue
+    )
+{
+    DWORD i;
+    QWORD value;
+    BOOLEAN negative;
+
+    ASSERT( NULL != valueAddress );
+    ASSERT( NULL != buffer );
+    ASSERT( 0 != base );
+
+    i = 0;
+    value = 0;
+    negative = FALSE;
+
+    if ('-' == buffer[0])
+    {
+        negative = TRUE;
+        i = 1;
+    }
+
+    for (; buffer[i] != '\0'; ++i)
+    {
+        char c;
+        BYTE currentCharValue;
+
+        ASSERT(isascii(buffer[i]));
+
+        // it's ok to use tolower even if we have a digit
+        // because they are 0x30 -> 0x39 and an OR with 0x20 leaves
+        // them unmodified
+        c = tolower(buffer[i]);
+
+        if ('0' <= c && c <= '9')
+        {
+            currentCharValue = c - '0';
+        }
+        else if ('a' <= c && c <= 'z')
+        {
+            currentCharValue = c - 'a' + 10;
+        }
+        else
+        {
+            currentCharValue = MAX_BYTE;
+        }
+
+        ASSERT( currentCharValue < base );
+
+        // digit
+        value = value * base + currentCharValue;
+    }
+
+    value = negative ? - (INT64)value : value;
+
+    if (is64BitValue)
+    {
+        *((PQWORD)valueAddress) = value;
+    }
+    else
+    {
+        // we can either have any negative number
+        // or positive numbers smaller or equal to MAX_DWORD
+        ASSERT( negative || (value <= MAX_DWORD) );
+
+        *((PDWORD)valueAddress) = (DWORD) value;
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLib/src/time.c b/src_proiect/CommonLib/src/time.c
new file mode 100644
index 0000000..9493e11
--- /dev/null
+++ b/src_proiect/CommonLib/src/time.c
@@ -0,0 +1,25 @@
+#include "common_lib.h"
+#include "time.h"
+
+STATUS
+TimeGetStringFormattedBuffer(
+    IN                          DATETIME        DateTime,
+    OUT_WRITES_Z(BufferSize)    char*           Buffer,
+    IN                          DWORD           BufferSize
+    )
+{
+    if (NULL == Buffer)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    return snprintf(Buffer, BufferSize,
+                    "%02d/%02d/%04d %02d:%02d:%02d",
+                    DateTime.Date.Day,
+                    DateTime.Date.Month,
+                    DateTime.Date.Year,
+                    DateTime.Time.Hour,
+                    DateTime.Time.Minute,
+                    DateTime.Time.Second
+                    );
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/CommonLibUnitTests.vcxproj b/src_proiect/CommonLibUnitTests/CommonLibUnitTests.vcxproj
new file mode 100644
index 0000000..bff1ac1
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/CommonLibUnitTests.vcxproj
@@ -0,0 +1,133 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{098EB03E-8151-46DB-9052-5136D9BC14EA}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>CommonLibUnitTests</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>CL_NON_NATIVE;USE_SAL;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;../CommonLib/inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnablePREfast>true</EnablePREfast>
+      <ShowIncludes>false</ShowIncludes>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>CommonLib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NonNative\commonlib</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>CL_NON_NATIVE;USE_SAL;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;../CommonLib/inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <EnablePREfast>true</EnablePREfast>
+      <ShowIncludes>false</ShowIncludes>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>CommonLib.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>UseFastLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NonNative\commonlib</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="main.cpp" />
+    <ClCompile Include="src\ut_cl_bitmap.cpp" />
+    <ClCompile Include="src\ut_cl_hash_table.cpp" />
+    <ClCompile Include="src\ut_cl_rng.cpp" />
+    <ClCompile Include="src\ut_cl_stack_dynamic.cpp" />
+    <ClCompile Include="src\ut_cl_string.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\cl_interface.h" />
+    <ClInclude Include="headers\ut_base.h" />
+    <ClInclude Include="headers\ut_cl_bitmap.h" />
+    <ClInclude Include="headers\ut_cl_hash_table.h" />
+    <ClInclude Include="headers\ut_cl_rng.h" />
+    <ClInclude Include="headers\ut_cl_stack_dynamic.h" />
+    <ClInclude Include="headers\ut_cl_string.h" />
+    <ClInclude Include="headers\ut_log.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/CommonLibUnitTests.vcxproj.filters b/src_proiect/CommonLibUnitTests/CommonLibUnitTests.vcxproj.filters
new file mode 100644
index 0000000..2e12e69
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/CommonLibUnitTests.vcxproj.filters
@@ -0,0 +1,75 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\Unit Tests">
+      <UniqueIdentifier>{22c1be61-c180-4ee2-bdbb-ec7a4c81a931}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\Helpers">
+      <UniqueIdentifier>{0f5a37eb-8f7b-4ee0-98c9-f376c3ba09b2}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\Helpers">
+      <UniqueIdentifier>{c6ce04a7-e9e3-4fb1-a742-17a40c08d1a9}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\Unit Tests">
+      <UniqueIdentifier>{a9f59f37-db11-4753-83a4-d159c7f4cbec}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ut_cl_rng.cpp">
+      <Filter>Source Files\Helpers</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ut_cl_bitmap.cpp">
+      <Filter>Source Files\Unit Tests</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ut_cl_stack_dynamic.cpp">
+      <Filter>Source Files\Unit Tests</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ut_cl_string.cpp">
+      <Filter>Source Files\Unit Tests</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ut_cl_hash_table.cpp">
+      <Filter>Source Files\Unit Tests</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\ut_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cl_interface.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ut_log.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ut_cl_bitmap.h">
+      <Filter>Header Files\Unit Tests</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ut_cl_stack_dynamic.h">
+      <Filter>Header Files\Unit Tests</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ut_cl_string.h">
+      <Filter>Header Files\Unit Tests</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ut_cl_rng.h">
+      <Filter>Header Files\Helpers</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ut_cl_hash_table.h">
+      <Filter>Header Files\Unit Tests</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/headers/cl_interface.h b/src_proiect/CommonLibUnitTests/headers/cl_interface.h
new file mode 100644
index 0000000..c7802bd
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/cl_interface.h
@@ -0,0 +1,123 @@
+#pragma once
+
+C_HEADER_START
+
+#include <intrin.h>
+
+#define RFLAGS_DIRECTION_BIT                        ((QWORD)1<<10)
+
+__forceinline
+extern
+void
+CpuClearDirectionFlag(
+    void
+)
+{
+    __writeeflags(__readeflags() & (~RFLAGS_DIRECTION_BIT));
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrGetState(
+    void
+)
+{
+    return INTR_OFF;
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrSetState(
+    const      INTR_STATE         IntrState
+)
+{
+    UNREFERENCED_PARAMETER(IntrState);
+
+    return INTR_OFF;
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrDisable(
+    void
+)
+{
+    return CpuIntrSetState(FALSE);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrEnable(
+    void
+)
+{
+    return CpuIntrSetState(TRUE);
+}
+
+#pragma warning(push)
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// structure retrieved by __cpuid operations
+typedef struct _CPUID_INFO
+{
+    union
+    {
+        int values[4];
+        struct
+        {
+            DWORD eax;
+            DWORD ebx;
+            DWORD ecx;
+            DWORD edx;
+        };
+    };
+} CPUID_INFO, *PCPUID_INFO;
+STATIC_ASSERT(sizeof(CPUID_INFO) == sizeof(DWORD) * 4);
+#pragma warning(pop)
+
+
+__forceinline
+extern
+BYTE
+CpuGetApicId(
+    void
+)
+{
+    CPUID_INFO cpuId;
+
+    __cpuid(cpuId.values, 1);
+
+    return ( cpuId.ebx >> 24 ) & MAX_BYTE;
+}
+
+#define CURRENT_CPU_MASK        0x8000'0000'0000'0000ULL
+
+__forceinline
+extern
+PVOID
+CpuGetCurrent(void)
+{
+    // warning C4306: 'type cast': conversion from 'BYTE' to 'PVOID' of greater size
+#pragma warning(suppress:4306)
+    return (PVOID)(CURRENT_CPU_MASK | CpuGetApicId());
+}
+
+FUNC_AssertFunction                 UtCommonLibAssert;
+
+void
+(__cdecl UtCommonLibAssert)(
+    IN_Z            char*       Message
+    )
+{
+    printf("Assert reached\n");
+    printf("Message is %s\n", Message );
+
+    __debugbreak();
+}
+
+C_HEADER_END
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_base.h b/src_proiect/CommonLibUnitTests/headers/ut_base.h
new file mode 100644
index 0000000..0ee2ed5
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_base.h
@@ -0,0 +1,5 @@
+#pragma once
+
+#include <stdio.h>
+#include "common_lib.h"
+#include "ut_log.h"
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_cl_bitmap.h b/src_proiect/CommonLibUnitTests/headers/ut_cl_bitmap.h
new file mode 100644
index 0000000..216ff96
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_cl_bitmap.h
@@ -0,0 +1,6 @@
+#pragma once
+
+BOOLEAN
+TcBitmapRun(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_cl_hash_table.h b/src_proiect/CommonLibUnitTests/headers/ut_cl_hash_table.h
new file mode 100644
index 0000000..8127bb3
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_cl_hash_table.h
@@ -0,0 +1,4 @@
+#pragma once
+
+STATUS
+UtClHashTable();
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_cl_rng.h b/src_proiect/CommonLibUnitTests/headers/ut_cl_rng.h
new file mode 100644
index 0000000..a480fbd
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_cl_rng.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include <random>
+
+namespace UtCl
+{
+    class RNG
+    {
+    public:
+        RNG(
+            _In_ unsigned int Min = 0,
+            _In_ unsigned int Max = UINT32_MAX
+        );
+
+        unsigned int GetNextRandom();
+
+        static RNG& GetInstance();
+
+
+    private:
+        std::mt19937 m_rng;
+        const std::uniform_int_distribution<std::mt19937::result_type> m_dist;
+
+        static RNG* m_instance;
+
+    };
+}
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_cl_stack_dynamic.h b/src_proiect/CommonLibUnitTests/headers/ut_cl_stack_dynamic.h
new file mode 100644
index 0000000..b380615
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_cl_stack_dynamic.h
@@ -0,0 +1,4 @@
+#pragma once
+
+STATUS
+UtClStackDynamic();
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_cl_string.h b/src_proiect/CommonLibUnitTests/headers/ut_cl_string.h
new file mode 100644
index 0000000..7331cdb
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_cl_string.h
@@ -0,0 +1,6 @@
+#pragma once
+
+STATUS
+UtClStrings(
+    void
+    );
diff --git a/src_proiect/CommonLibUnitTests/headers/ut_log.h b/src_proiect/CommonLibUnitTests/headers/ut_log.h
new file mode 100644
index 0000000..96bb583
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/headers/ut_log.h
@@ -0,0 +1,5 @@
+#pragma once
+
+#define LOG(buf,...)                printf("[%s][%u]"##buf, __FILE__, __LINE__, __VA_ARGS__)
+#define LOG_ERROR(buf, ...)         LOG("[ERROR]"##buf, __VA_ARGS__)
+#define LOG_FUNC_ERROR(func,err)    LOG_ERROR("Function [%s] failed with status 0x%X\n", (func), (err))
diff --git a/src_proiect/CommonLibUnitTests/main.cpp b/src_proiect/CommonLibUnitTests/main.cpp
new file mode 100644
index 0000000..fd82553
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/main.cpp
@@ -0,0 +1,92 @@
+#include "ut_base.h"
+#include <vector>
+#include <string>
+#include <functional>
+#include "cl_interface.h"
+#include "cl_memory.h"
+#include "ut_cl_string.h"
+#include "ut_cl_stack_dynamic.h"
+#include "ut_cl_hash_table.h"
+
+typedef struct _CL_UNIT_TEST
+{
+    const std::string               TestName;
+    const std::function<STATUS()>   TestFunction;
+} CL_UNIT_TEST;
+
+STATUS TstStrings(void)
+{
+    ASSERT(strcmp("Ion", "Ion") == cl_strcmp("Ion", "Ion"));
+
+    return CL_STATUS_SUCCESS;
+}
+
+const CL_UNIT_TEST CL_TESTS[] =
+{
+    {"Strings", UtClStrings},
+    {"Memory", TstStrings},
+    {"DynamicStack", UtClStackDynamic},
+    {"HashTable", UtClHashTable},
+};
+
+static constexpr auto NO_OF_CL_TESTS = ARRAYSIZE(CL_TESTS);
+static constexpr auto DEFAULT_TIMES_TO_RUN = 1;
+
+int main(
+    int argc,
+    char* argv[]
+)
+{
+    DWORD result;
+    STATUS status;
+    COMMON_LIB_INIT init;
+
+    result = 0;
+    cl_memzero(&init, sizeof(COMMON_LIB_INIT));
+
+    init.MonitorSupport = FALSE;
+    init.AssertFunction = UtCommonLibAssert;
+    init.Size = sizeof(COMMON_LIB_INIT);
+
+    status = CommonLibInit(&init);
+    if (!SUCCEEDED(status))
+    {
+        LOG_ERROR("CommonLibInit failed with status: 0x%X\n", status );
+        return status;
+    }
+
+    if (argc < 2)
+    {
+        LOG_ERROR("Usage %s $TEST_CASE [$NO_OF_TIMES]\n", argv[0]);
+        return 1;
+    }
+
+    auto timesToRun = (argc >= 3) ? std::strtol(argv[2], nullptr, 10) : DEFAULT_TIMES_TO_RUN;
+    auto tstToRun = argv[1];
+
+    LOG("Will run testcase [%s] %d times!\n",
+        tstToRun, timesToRun);
+
+    for (const auto& tst : CL_TESTS)
+    {
+        if (tst.TestName == tstToRun)
+        {
+            for (auto i = 0; i < timesToRun; ++i)
+            {
+                status = tst.TestFunction();
+                if (!SUCCEEDED(status))
+                {
+                    LOG_ERROR("Testcase [%s] failed on iteration %d/%d\n",
+                        tstToRun, i + 1, timesToRun);
+                }
+                else
+                {
+                    LOG("Iteration %d/%d of testcase [%s] succeeded!\n",
+                        i + 1, timesToRun, tstToRun);
+                }
+            }
+        }
+    }
+
+    return result;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/src/ut_cl_bitmap.cpp b/src_proiect/CommonLibUnitTests/src/ut_cl_bitmap.cpp
new file mode 100644
index 0000000..1a61d21
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/src/ut_cl_bitmap.cpp
@@ -0,0 +1,17 @@
+#include "ut_base.h"
+#include "ut_cl_bitmap.h"
+#include "bitmap.h"
+
+BOOLEAN
+TcBitmapRun(
+    void
+    )
+{
+    BITMAP bmp;
+
+    printf("Will test BITMAP functions\n");
+
+    BitmapPreinit(&bmp, 10 );
+
+    return TRUE;
+}
\ No newline at end of file
diff --git a/src_proiect/CommonLibUnitTests/src/ut_cl_hash_table.cpp b/src_proiect/CommonLibUnitTests/src/ut_cl_hash_table.cpp
new file mode 100644
index 0000000..323f6ca
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/src/ut_cl_hash_table.cpp
@@ -0,0 +1,533 @@
+#include "ut_base.h"
+#include "ut_cl_hash_table.h"
+#include "hash_table.h"
+#include <unordered_map>
+#include "ut_cl_rng.h"
+
+typedef struct _UT_HASH_ELEM
+{
+    HASH_ENTRY                  HashEntry;
+
+    QWORD                       Value;
+} UT_HASH_ELEM, *PUT_HASH_ELEM;
+
+typedef struct _UT_PHASE
+{
+    DWORD                       ElemsToInsert;
+
+    DWORD                       ElemsToRemoveByKeyLinearly;
+    DWORD                       ElemsToRemoveByKeyLinearlyThroughSkipping;
+    DWORD                       ElemsToRemoveByEntryLinearly;
+    DWORD                       ElemsToRemoveByEntryThroughSkipping;
+} UT_PHASE, *PUT_PHASE;
+
+static constexpr auto NO_OF_PHASES = 2;
+
+typedef struct _STACK_UT_PARAMS
+{
+    const std::string           TestName;
+
+    DWORD                       MaxKeys;
+
+    UT_PHASE                    Phases[NO_OF_PHASES];
+} STACK_UT_PARAMS, *PSTACK_UT_PARAMS;
+
+static const STACK_UT_PARAMS UT_PARAMS[] =
+{
+    {"Empty remove", 16, 0, 25, 25, 25, 25, 0, 25, 25, 25, 25},
+    {"No remove", 16, 10000, 0, 0, 0, 0, 10000, 0, 0, 0, 0},
+    {"Basic test", 16, 1000, 250, 250, 250, 250, 1000, 250, 250, 250, 250},
+    {"Lots of collisions", 4, 10000, 2000, 2000, 2000, 2000, 10000, 2000, 2000, 2000, 2000},
+    {"A lot of buckets", 1024, 10000, 2000, 2000, 2000, 2000, 10000, 2000, 2000, 2000, 2000},
+    {"Single bucket", 1, 1000, 500, 500, 500, 500, 2000, 500, 500, 500, 500},
+    {"Many entries", 4096, 100'000, 50'000, 50'000, 50'000, 50'000, 100'000, 50'000, 50'000, 50'000, 50'000},
+    {"Huge entries", 100'000, 1'000'000, 0, 0, 0, 1'000'000, 1'000'000, 1'000'000, 1'000'000, 1'000'000},
+};
+
+static const PFUNC_HashFunction HASH_FUNCTIONS[] =
+{
+    HashFuncGenericIncremental, HashFuncUniversal
+};
+
+static const DWORD KEY_SIZES[] =
+{
+    1, 2, 3, 4, 5, 6, 7, 8
+};
+
+static
+STATUS
+_HashTableCreate(
+    _In_        DWORD               MaxKeys,
+    _In_        DWORD               KeySize,
+    _In_        PFUNC_HashFunction  HashFunc,
+    _Out_       HASH_TABLE*         HashTable
+    )
+{
+    ASSERT(HashFunc != nullptr);
+    ASSERT(HashTable != nullptr);
+
+    DWORD requiredDataSize = HashTablePreinit(
+        HashTable,
+        MaxKeys,
+        KeySize);
+
+    if (requiredDataSize == 0) return CL_STATUS_SIZE_INVALID;
+
+    PHASH_TABLE_DATA pData = (PHASH_TABLE_DATA) new BYTE[requiredDataSize];
+
+    HashTableInit(
+        HashTable,
+        pData,
+        HashFunc,
+        FIELD_OFFSET(UT_HASH_ELEM, Value) - FIELD_OFFSET(UT_HASH_ELEM, HashEntry));
+
+    return CL_STATUS_SUCCESS;
+}
+
+static
+STATUS
+_HashInsertElements(
+    _Inout_     HASH_TABLE*                         HashTable,
+    _In_        DWORD                               ElementsToInsert,
+    _Outref_    PUT_HASH_ELEM&                      HashElems,
+    _Inout_     std::unordered_map<QWORD,DWORD>&    ShadowHash
+    )
+{
+    STATUS status;
+    UtCl::RNG rngInstance = UtCl::RNG::GetInstance();
+
+    ASSERT(HashTable != nullptr);
+
+    status = CL_STATUS_SUCCESS;
+    PUT_HASH_ELEM pStackElems = new UT_HASH_ELEM[ElementsToInsert];
+
+    for (DWORD i = 0; i < ElementsToInsert; ++i)
+    {
+        pStackElems[i].Value = (rngInstance.GetNextRandom() & CREATE_BIT_MASK_FOR_N_BITS(BITS_PER_BYTE * HashTable->KeySize));
+
+        PHASH_ENTRY pEntry = HashTableLookup(HashTable, (PHASH_KEY) &pStackElems[i].Value);
+        BOOLEAN bFoundInShadowHash = (ShadowHash.find(pStackElems[i].Value) != ShadowHash.end());
+
+        if (pEntry == nullptr)
+        {
+            if (bFoundInShadowHash)
+            {
+                LOG_ERROR("We couldn't find key 0x%I64X in our hash table, however it is present in shadow hash!\n",
+                    pStackElems[i].Value);
+                status = CL_STATUS_ELEMENT_NOT_FOUND;
+            }
+        }
+        else
+        {
+            if (!bFoundInShadowHash)
+            {
+                LOG_ERROR("We couldn't find key 0x%I64X in our shadow hash table, however it is present in our hash!\n",
+                    pStackElems[i].Value);
+                status = CL_STATUS_ELEMENT_FOUND;
+            }
+        }
+
+        if (!SUCCEEDED(status)) break;
+
+        ASSERT(pStackElems[i].Value <= MAX_DWORD);
+        ShadowHash[pStackElems[i].Value] = (DWORD) pStackElems[i].Value;
+        PHASH_ENTRY pPreviousElem = HashTableInsert(HashTable, &pStackElems[i].HashEntry);
+
+        if (pPreviousElem != pEntry)
+        {
+            QWORD entryValue = MAX_QWORD;
+            QWORD prevValue = MAX_QWORD;
+
+            if (pEntry != nullptr)
+            {
+                entryValue = (CONTAINING_RECORD(pEntry, UT_HASH_ELEM, HashEntry))->Value;
+            }
+
+            if (pPreviousElem != nullptr)
+            {
+                prevValue = (CONTAINING_RECORD(pPreviousElem, UT_HASH_ELEM, HashEntry))->Value;
+            }
+
+            LOG_ERROR("When we did a lookup we got the previous element at 0x%p with value 0x%I64X, however now we received element at 0x%p with value 0x%I64X\n",
+                pEntry, entryValue, pPreviousElem, prevValue);
+            status = CL_STATUS_INTERNAL_ERROR;
+            break;
+        }
+    }
+
+    HashElems = pStackElems;
+
+    return status;
+}
+
+static
+STATUS
+_HashRemoveElements(
+    _Inout_     HASH_TABLE*                         HashTable,
+    _In_        DWORD                               ElementsToRemove,
+    _Inout_     std::unordered_map<QWORD, DWORD>&   ShadowHash,
+    _In_        bool                                SkipOne,
+    _In_        bool                                RemoveByEntry
+    )
+{
+    STATUS status;
+    HASH_ITERATOR it;
+
+    ASSERT(HashTable != nullptr);
+
+    status = CL_STATUS_SUCCESS;
+    HashTableIteratorInit(HashTable, &it);
+
+    for (DWORD i = 0; i < ElementsToRemove; ++i)
+    {
+        if (SkipOne && ((i % 2) == 0)) continue;
+
+        PHASH_ENTRY pEntry = HashTableIteratorNext(&it);
+        if (pEntry == nullptr)
+        {
+            if (!ShadowHash.empty())
+            {
+                LOG_ERROR("Our hash table is empty, however shadow hash is not, it has %zu elements!\n",
+                    ShadowHash.size());
+                status = CL_STATUS_ELEMENT_NOT_FOUND;
+            }
+        }
+        else
+        {
+            QWORD keyToDelete = (CONTAINING_RECORD(pEntry, UT_HASH_ELEM, HashEntry))->Value;
+
+            if (ShadowHash.empty())
+            {
+                LOG_ERROR("Shadow hash is empty, however our hash table is not, it has %u elements!\n",
+                    HashTableSize(HashTable));
+                status = CL_STATUS_ELEMENT_FOUND;
+            }
+            else
+            {
+                if (RemoveByEntry)
+                {
+                    HashTableRemoveEntry(HashTable, pEntry);
+                }
+                else
+                {
+                    PHASH_ENTRY pDeletedEntry = HashTableRemove(HashTable, (PHASH_KEY)&keyToDelete);
+                    if (pDeletedEntry != pEntry)
+                    {
+                        LOG_ERROR("Entry received at iterator next differs from that of remove. Entry at iterator is at 0x%p with value 0x%I64X, at delete it is at 0x%p with value 0x%I64X!\n",
+                            pEntry, keyToDelete, pDeletedEntry, pDeletedEntry != nullptr ? (CONTAINING_RECORD(pDeletedEntry, UT_HASH_ELEM, HashEntry))->Value : MAX_QWORD);
+                        status = CL_STATUS_INTERNAL_ERROR;
+                    }
+                }
+
+                ShadowHash.erase(keyToDelete);
+            }
+        }
+
+        if (!SUCCEEDED(status)) break;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_HashCompareSizes(
+    _In_ const HASH_TABLE*                          HashTable,
+    _In_ const std::unordered_map<QWORD, DWORD>&    ShadowHash
+    )
+{
+    DWORD stackSize;
+    size_t shadowStackSize;
+
+    ASSERT(HashTable != nullptr);
+
+    stackSize = HashTableSize(HashTable);
+    shadowStackSize = ShadowHash.size();
+    ASSERT(shadowStackSize <= MAX_DWORD);
+
+    if (stackSize == shadowStackSize) return CL_STATUS_SUCCESS;
+
+    LOG_ERROR("Our reported hash size is %u, while the shadow hash size is %zu\n",
+        stackSize, shadowStackSize);
+
+    return CL_STATUS_SIZE_INVALID;
+}
+
+static
+void
+(_cdecl _HashFreeItem)(
+    IN      PVOID       Object,
+    IN_OPT  PVOID       Context
+    )
+{
+    std::vector<DWORD> *vect = (std::vector<DWORD>*) Context;
+
+    ASSERT(Object != nullptr);
+    ASSERT(Context != nullptr);
+
+    PUT_HASH_ELEM pStackElem = CONTAINING_RECORD(Object, UT_HASH_ELEM , HashEntry);
+
+    ASSERT(pStackElem->Value <= MAX_DWORD);
+    vect->push_back((DWORD)pStackElem->Value);
+}
+
+static
+STATUS
+_HashClear(
+    _Inout_ HASH_TABLE*                          HashTable,
+    _Inout_ std::unordered_map<QWORD, DWORD>&    ShadowHash
+    )
+{
+    STATUS status;
+    std::vector<DWORD> removedElems;
+
+    ASSERT(HashTable != nullptr);
+
+    status = CL_STATUS_SUCCESS;
+
+    HashTableClear(
+        HashTable,
+        _HashFreeItem,
+        &removedElems
+    );
+
+    for (const auto& value : removedElems)
+    {
+        bool bShadowHashEmpty = ShadowHash.empty();
+
+        if (bShadowHashEmpty)
+        {
+            LOG_ERROR("The shadow stack is empty, however we were able to remove element with value %u from stack!\n",
+                value);
+            status = CL_STATUS_ELEMENT_FOUND;
+        }
+        else
+        {
+            bool bFoundElemInShadowHash = (ShadowHash.find(value) != ShadowHash.end());
+
+            if (!bFoundElemInShadowHash)
+            {
+
+                status = CL_STATUS_INTERNAL_ERROR;
+            }
+            else
+            {
+                DWORD shadowHash = ShadowHash[value];
+
+                if (value != shadowHash)
+                {
+                    LOG_ERROR("Values in hashes differ: value is %u while on shadow hash value is %u\n",
+                        value, shadowHash);
+                    status = CL_STATUS_VALUE_MISMATCH;
+                }
+            }
+        }
+
+        if (!SUCCEEDED(status)) break;
+
+        ShadowHash.erase(value);
+    }
+
+    if (SUCCEEDED(status))
+    {
+        if (!ShadowHash.empty())
+        {
+            LOG_ERROR("We have cleared our whole stack, however the shadow stack still has %zu elements!\n",
+                ShadowHash.size());
+            return CL_STATUS_SIZE_INVALID;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+_UtClRunTestcase(
+    _In_ const STACK_UT_PARAMS&             Params,
+    _In_ const PFUNC_HashFunction&          HashFunc,
+    _In_ const DWORD&                       KeySize
+    )
+{
+    STATUS status;
+    HASH_TABLE hashTable;
+    std::unordered_map<QWORD, DWORD> shadowHash;
+    PUT_HASH_ELEM elems[NO_OF_PHASES] = {};
+
+    status = _HashTableCreate(
+        Params.MaxKeys,
+        KeySize,
+        HashFunc,
+        &hashTable);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_HashTableCreate", status);
+        goto cleanup;
+    }
+
+    status = _HashCompareSizes(
+        &hashTable,
+        shadowHash);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_HashCompareSizes", status);
+        goto cleanup;
+    }
+
+    for (auto i = 0; i < NO_OF_PHASES; ++i)
+    {
+        status = _HashInsertElements(
+            &hashTable,
+            Params.Phases[i].ElemsToInsert,
+            elems[i],
+            shadowHash
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashInsertElements", status);
+            goto cleanup;
+        }
+
+        status = _HashCompareSizes(
+            &hashTable,
+            shadowHash);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashCompareSizes", status);
+            goto cleanup;
+        }
+
+        status = _HashRemoveElements(
+            &hashTable,
+            Params.Phases[i].ElemsToRemoveByKeyLinearly,
+            shadowHash,
+            false,
+            false);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashRemoveElements", status);
+            goto cleanup;
+        }
+
+        status = _HashCompareSizes(
+            &hashTable,
+            shadowHash);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashCompareSizes", status);
+            goto cleanup;
+        }
+
+        status = _HashRemoveElements(
+            &hashTable,
+            Params.Phases[i].ElemsToRemoveByKeyLinearlyThroughSkipping,
+            shadowHash,
+            true,
+            false);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashRemoveElements", status);
+            goto cleanup;
+        }
+
+        status = _HashCompareSizes(
+            &hashTable,
+            shadowHash);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashCompareSizes", status);
+            goto cleanup;
+        }
+
+        status = _HashRemoveElements(
+            &hashTable,
+            Params.Phases[i].ElemsToRemoveByEntryLinearly,
+            shadowHash,
+            false,
+            true);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashRemoveElements", status);
+            goto cleanup;
+        }
+
+        status = _HashCompareSizes(
+            &hashTable,
+            shadowHash);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashCompareSizes", status);
+            goto cleanup;
+        }
+
+        status = _HashRemoveElements(
+            &hashTable,
+            Params.Phases[i].ElemsToRemoveByEntryThroughSkipping,
+            shadowHash,
+            true,
+            true);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashRemoveElements", status);
+            goto cleanup;
+        }
+
+        status = _HashCompareSizes(
+            &hashTable,
+            shadowHash);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_HashCompareSizes", status);
+            goto cleanup;
+        }
+    }
+
+    status = _HashClear(
+        &hashTable,
+        shadowHash
+    );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_HashClear", status);
+        goto cleanup;
+    }
+
+cleanup:
+    for (auto i = 0; i < NO_OF_PHASES; ++i)
+    {
+        if (elems[i] != nullptr)
+        {
+            delete[] elems[i];
+            elems[i] = nullptr;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+UtClHashTable()
+{
+    STATUS status = CL_STATUS_SUCCESS;
+
+    for (const auto& keySize : KEY_SIZES)
+    {
+        for (const auto& hashFunc : HASH_FUNCTIONS)
+        {
+            for (const auto& ut : UT_PARAMS)
+            {
+                status = _UtClRunTestcase(
+                    ut,
+                    hashFunc,
+                    keySize);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_ERROR("Failed test [%s] with key size %u and hash func 0x%p with status 0x%X\n",
+                        ut.TestName.c_str(), keySize, hashFunc, status);
+                    break;
+                }
+            }
+        }
+    }
+
+    return status;
+}
diff --git a/src_proiect/CommonLibUnitTests/src/ut_cl_rng.cpp b/src_proiect/CommonLibUnitTests/src/ut_cl_rng.cpp
new file mode 100644
index 0000000..7ae654e
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/src/ut_cl_rng.cpp
@@ -0,0 +1,32 @@
+#include "ut_cl_rng.h"
+
+namespace UtCl
+{
+
+    RNG::RNG(
+        _In_ unsigned int Min,
+        _In_ unsigned int Max
+    ) :
+        m_dist(Min, Max)
+    {
+        m_rng.seed(std::random_device()());
+    }
+
+    unsigned int RNG::GetNextRandom()
+    {
+        return m_dist(m_rng);
+    }
+
+    RNG& RNG::GetInstance()
+    {
+        if (m_instance == NULL)
+        {
+            m_instance = new RNG;
+        }
+
+        return *m_instance;
+    }
+
+    RNG* RNG::m_instance = NULL;
+}
+
diff --git a/src_proiect/CommonLibUnitTests/src/ut_cl_stack_dynamic.cpp b/src_proiect/CommonLibUnitTests/src/ut_cl_stack_dynamic.cpp
new file mode 100644
index 0000000..3e1f00f
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/src/ut_cl_stack_dynamic.cpp
@@ -0,0 +1,349 @@
+#include "ut_base.h"
+#include "ut_cl_stack_dynamic.h"
+#include "stack_interface.h"
+#include <stack>
+#include "ut_cl_rng.h"
+
+typedef struct _UT_STACK_ELEM
+{
+    STACK_ITEM                  Entry;
+
+    DWORD                       Value;
+} UT_STACK_ELEM, *PUT_STACK_ELEM;
+
+typedef struct _UT_PHASE
+{
+    DWORD                       ElemsToInsert;
+    DWORD                       ElemsToPop;
+} UT_PHASE, *PUT_PHASE;
+
+static constexpr auto NO_OF_PHASES = 2;
+
+typedef struct _STACK_UT_PARAMS
+{
+    const std::string           TestName;
+
+    UT_PHASE                    Phases[NO_OF_PHASES];
+} STACK_UT_PARAMS, *PSTACK_UT_PARAMS;
+
+static const STACK_UT_PARAMS UT_PARAMS[] =
+{
+    {"No elems", 0, 0, 0, 0},
+    {"One insert, one pop", 1, 1, 0, 0},
+    {"Two inserts, one pop", 2, 1, 2, 1},
+    {"Inserts with no pops", 100, 0, 100, 0},
+    {"Inserts with not enough pops", 100, 99, 100, 99},
+    {"Many inserts with no pops", 3'000'000, 0, 0, 0},
+    {"Just pops", 0, 1, 0, 10},
+    {"Many Elems", 1'000'000, 900'000, 2'000'000, 2'210'001},
+    {"Huge Elems", 100'000'000, 100'000'010, 200'000'000, 100'000'010},
+};
+
+static
+STATUS
+_StackCreate(
+    _In_    STACK_TYPE          Type,
+    _In_    DWORD               MaxElements,
+    _Out_   STACK_INTERFACE*    StackInterface
+    )
+{
+    DWORD stackSize = StackGetRequiredSize(MaxElements, Type);
+
+    if (stackSize == 0) return CL_STATUS_SIZE_INVALID;
+
+    PSTACK pStack = (PSTACK) new BYTE[stackSize];
+
+    return StackCreate(
+        StackInterface,
+        Type,
+        pStack);
+}
+
+static
+STATUS
+_StackInsertElements(
+    _Inout_     STACK_INTERFACE*    StackInterface,
+    _In_        DWORD               ElementsToInsert,
+    _Outref_    PUT_STACK_ELEM&        StackElems,
+    _Inout_     std::stack<DWORD>&  ShadowStack
+    )
+{
+    BOOLEAN bSuccess = TRUE;
+    UtCl::RNG rngInstance = UtCl::RNG::GetInstance();
+
+    ASSERT(StackInterface != nullptr);
+
+    PUT_STACK_ELEM pStackElems = new UT_STACK_ELEM[ElementsToInsert];
+
+    for (DWORD i = 0; i < ElementsToInsert; ++i)
+    {
+        pStackElems[i].Value = rngInstance.GetNextRandom();
+
+        ShadowStack.push(pStackElems[i].Value);
+        bSuccess = StackInterface->Funcs.Push(StackInterface->Stack, &pStackElems[i].Entry);
+        if (!bSuccess)
+        {
+            LOG_ERROR("Failed to insert element %u/%u. Stack size at this point is %u, shadow stack size is %zu\n",
+                i, ElementsToInsert, StackInterface->Funcs.Size(StackInterface->Stack), ShadowStack.size());
+            break;
+        }
+    }
+
+    StackElems = pStackElems;
+
+    return (bSuccess ? CL_STATUS_SUCCESS : CL_STATUS_LIMIT_REACHED);
+}
+
+static
+STATUS
+_StackPopElements(
+    _Inout_ STACK_INTERFACE*    StackInterface,
+    _In_    DWORD               ElementsToPop,
+    _Inout_ std::stack<DWORD>&  ShadowStack
+    )
+{
+    STATUS status = CL_STATUS_SUCCESS;
+
+    for (DWORD i = 0; i < ElementsToPop; ++i)
+    {
+        PSTACK_ITEM pStackItem = StackInterface->Funcs.Pop(StackInterface->Stack);
+        PUT_STACK_ELEM pStackElem = nullptr;
+
+        bool bShadowStackEmpty = ShadowStack.empty();
+        DWORD value = 0;
+
+        if (pStackItem != nullptr)
+        {
+            pStackElem = CONTAINING_RECORD(pStackItem, UT_STACK_ELEM, Entry);
+            value = pStackElem->Value;
+        }
+
+        if (bShadowStackEmpty)
+        {
+            if (pStackElem != nullptr)
+            {
+                LOG_ERROR("The shadow stack is empty, however we were able to remove element at %p with value %u from stack!\n",
+                    pStackElem, value);
+                status = CL_STATUS_ELEMENT_FOUND;
+            }
+        }
+        else
+        {
+            DWORD shadowStackValue = ShadowStack.top();
+
+            if (pStackElem == nullptr)
+            {
+                LOG_ERROR("The stack is empty, however the shadow stack still has %I64u elements, with the current one being %u!\n",
+                    ShadowStack.size(), shadowStackValue);
+                status = CL_STATUS_LIST_EMPTY;
+            }
+            else if (value != shadowStackValue)
+            {
+                LOG_ERROR("Values at the top of the stack differs for element at %p, value is %u while on shadow stack value is %u\n",
+                    pStackElem, value, shadowStackValue);
+                status = CL_STATUS_VALUE_MISMATCH;
+            }
+
+            ShadowStack.pop();
+        }
+
+        if (!SUCCEEDED(status)) break;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_StackCompareSizes(
+    _In_ const STACK_INTERFACE*    StackInterface,
+    _In_ const std::stack<DWORD>&  ShadowStack
+    )
+{
+    DWORD stackSize;
+    size_t shadowStackSize;
+
+    ASSERT(StackInterface != nullptr);
+
+    stackSize = StackInterface->Funcs.Size(StackInterface->Stack);
+    shadowStackSize = ShadowStack.size();
+    ASSERT(shadowStackSize <= MAX_DWORD);
+
+    if (stackSize == shadowStackSize) return CL_STATUS_SUCCESS;
+
+    LOG_ERROR("Our reported stack size is %u, while the shadow stack size is %zu\n",
+        stackSize, shadowStackSize);
+
+    return CL_STATUS_SIZE_INVALID;
+}
+
+static
+void
+(_cdecl _StackFreeItem)(
+    IN      PVOID       Object,
+    IN_OPT  PVOID       Context
+    )
+{
+    std::vector<DWORD> *vect = (std::vector<DWORD>*) Context;
+
+    ASSERT(Object != nullptr);
+    ASSERT(Context != nullptr);
+
+    PUT_STACK_ELEM pStackElem = CONTAINING_RECORD(Object, UT_STACK_ELEM, Entry);
+
+    vect->push_back(pStackElem->Value);
+}
+
+static
+STATUS
+_StackClear(
+    _Inout_ STACK_INTERFACE*    StackInterface,
+    _Inout_ std::stack<DWORD>&  ShadowStack
+    )
+{
+    STATUS status;
+    std::vector<DWORD> removedElems;
+
+    ASSERT(StackInterface != nullptr);
+
+    status = CL_STATUS_SUCCESS;
+
+    StackInterface->Funcs.Clear(
+        StackInterface->Stack,
+        _StackFreeItem,
+        &removedElems);
+
+    for (const auto& value : removedElems)
+    {
+        bool bShadowStackEmpty = ShadowStack.empty();
+
+        if (bShadowStackEmpty)
+        {
+            LOG_ERROR("The shadow stack is empty, however we were able to remove element with value %u from stack!\n",
+                value);
+            status = CL_STATUS_ELEMENT_FOUND;
+        }
+        else
+        {
+            DWORD shadowStackValue = ShadowStack.top();
+
+            if (value != shadowStackValue)
+            {
+                LOG_ERROR("Values at the top of the stack differ: value is %u while on shadow stack value is %u\n",
+                    value, shadowStackValue);
+                status = CL_STATUS_VALUE_MISMATCH;
+            }
+
+            ShadowStack.pop();
+        }
+
+        if (!SUCCEEDED(status)) break;
+    }
+
+    if (SUCCEEDED(status))
+    {
+        if (!ShadowStack.empty())
+        {
+            LOG_ERROR("We have cleared our whole stack, however the shadow stack still has %zu elements!\n",
+                ShadowStack.size());
+            return CL_STATUS_SIZE_INVALID;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+UtClStackDynamic()
+{
+    STATUS status = CL_STATUS_SUCCESS;
+
+    for (const auto& ut : UT_PARAMS)
+    {
+        STACK_INTERFACE stackInterface;
+        std::stack<DWORD> shadowStack;
+        PUT_STACK_ELEM elems[NO_OF_PHASES] = {};
+
+        status = _StackCreate(
+            StackTypeDynamic,
+            MAX_DWORD,
+            &stackInterface);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_UtClStackCreate", status);
+            goto cleanup;
+        }
+
+        for (auto i = 0; i < NO_OF_PHASES; ++i)
+        {
+            status = _StackInsertElements(
+                &stackInterface,
+                ut.Phases[i].ElemsToInsert,
+                elems[i],
+                shadowStack);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_StackInsertElements", status);
+                goto cleanup;
+            }
+
+            status = _StackCompareSizes(
+                &stackInterface,
+                shadowStack);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_StackCompareSizes", status);
+                goto cleanup;
+            }
+
+            status = _StackPopElements(
+                &stackInterface,
+                ut.Phases[i].ElemsToPop,
+                shadowStack);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_StackInsertElements", status);
+                goto cleanup;
+            }
+
+            status = _StackCompareSizes(
+                &stackInterface,
+                shadowStack);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_StackCompareSizes", status);
+                goto cleanup;
+            }
+        }
+
+        status = _StackClear(
+            &stackInterface,
+            shadowStack
+            );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_StackClear", status);
+            goto cleanup;
+        }
+
+    cleanup:
+        for (auto i = 0; i < NO_OF_PHASES; ++i)
+        {
+            if (elems[i] != nullptr)
+            {
+                delete[] elems[i];
+                elems[i] = nullptr;
+            }
+        }
+
+        if (!SUCCEEDED(status))
+        {
+            LOG_ERROR("Failed test [%s] with status 0x%X\n",
+                ut.TestName.c_str(), status);
+            break;
+        }
+
+    }
+
+    return status;
+}
diff --git a/src_proiect/CommonLibUnitTests/src/ut_cl_string.cpp b/src_proiect/CommonLibUnitTests/src/ut_cl_string.cpp
new file mode 100644
index 0000000..adc6267
--- /dev/null
+++ b/src_proiect/CommonLibUnitTests/src/ut_cl_string.cpp
@@ -0,0 +1,128 @@
+#include "ut_base.h"
+#include "ut_cl_string.h"
+
+#define MAX_STRING_LENGTH           100
+
+typedef enum _UT_STRING_TESTED_FUNCS
+{
+    UtStringTrim = 0,
+
+    UtStringReserved = UtStringTrim + 1
+} UT_STRING_TESTED_FUNCS;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_UtStringTestFunc)(
+    _In_z_  const char*     OriginalString,
+    _In_z_  const char*     ExpectedResult
+    );
+
+typedef FUNC_UtStringTestFunc *PFUNC_UtStringTestFunc;
+
+#pragma warning(push)
+
+// warning C4201 : nonstandard extension used : nameless struct / union
+#pragma warning(disable:4201)
+
+// warning C4200 : nonstandard extension used : zero - sized array in struct / union
+#pragma warning(disable:4200)
+
+typedef struct _UT_SINGLE_STRING_TEST
+{
+    char                        OriginalString[MAX_STRING_LENGTH];
+
+    union
+    {
+        struct
+        {
+            char                ExpectedTrimResult[MAX_STRING_LENGTH];
+        };
+
+        char                    ExpectedResults[UtStringReserved][MAX_STRING_LENGTH];
+    };
+
+} UT_SINGLE_STRING_TEST;
+
+typedef struct _UT_STRING_TC_ARGS
+{
+    PFUNC_UtStringTestFunc      Functions[UtStringReserved];
+    DWORD                       NumberOfFunctions;
+
+    DWORD                       NumberOfStrings;
+
+    const UT_SINGLE_STRING_TEST *Strings;
+} UT_STRING_TC_ARGS;
+#pragma warning(pop)
+
+static FUNC_UtStringTestFunc _UtStringTestTrim;
+
+static const UT_SINGLE_STRING_TEST STR_LIST_TO_TEST[] =
+{
+    {"Test Simplu", "Test Simplu"},
+    {"",  ""},
+    {"\0",  "\0"},
+    {"\03",  "\03"},
+    {"   TEST SIMPLu",  "TEST SIMPLu"},
+    {"           ",  ""},
+    {" AAAAa     ",  "AAAAa"},
+    { "      A",  "A"},
+    {"B      ", "B"}
+};
+
+
+static const UT_STRING_TC_ARGS TC_ARGS =
+{
+    _UtStringTestTrim,
+    UtStringReserved,
+
+    ARRAYSIZE(STR_LIST_TO_TEST),
+    STR_LIST_TO_TEST
+};
+
+
+STATUS
+UtClStrings(
+    void
+    )
+{
+    for (DWORD i = 0; i < TC_ARGS.NumberOfStrings; ++i)
+    {
+        for (DWORD j = 0; j < TC_ARGS.NumberOfFunctions; ++j)
+        {
+            if (!(TC_ARGS.Functions[j])(
+                TC_ARGS.Strings[i].OriginalString,
+                TC_ARGS.Strings[i].ExpectedResults[j]))
+            {
+                LOG_ERROR("String %u [%s] was not processed correctly by function %u!\n",
+                    i, TC_ARGS.Strings[i].OriginalString, j);
+            }
+        }
+
+
+    }
+
+    return CL_STATUS_SUCCESS;
+}
+
+static
+BOOLEAN
+(__cdecl _UtStringTestTrim)(
+    _In_z_  const char*     OriginalString,
+    _In_z_  const char*     ExpectedResult
+    )
+{
+    char tempString[MAX_STRING_LENGTH];
+
+    cl_strcpy(tempString, OriginalString);
+    cl_strtrim(tempString);
+
+    BOOLEAN bSuccess = (cl_strcmp(tempString, ExpectedResult) == 0);
+
+    if (!bSuccess)
+    {
+        LOG_ERROR("Entry was not trimmed correctly. Actual result [%s] vs expected [%s]. Original string was [%s]\n",
+            tempString, ExpectedResult,OriginalString);
+    }
+
+    return bSuccess;
+}
diff --git a/src_proiect/Disk/Disk.vcxproj b/src_proiect/Disk/Disk.vcxproj
new file mode 100644
index 0000000..9a5c1bf
--- /dev/null
+++ b/src_proiect/Disk/Disk.vcxproj
@@ -0,0 +1,135 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\disk_base.h" />
+    <ClInclude Include="headers\disk_dispatch.h" />
+    <ClInclude Include="headers\disk_structures.h" />
+    <ClInclude Include="inc\disk.h" />
+    <ClInclude Include="inc\mbr.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\disk.c" />
+    <ClCompile Include="src\disk_dispatch.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}</ProjectGuid>
+    <RootNamespace>Disk</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>
+      </FunctionLevelLinking>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Disk/Disk.vcxproj.filters b/src_proiect/Disk/Disk.vcxproj.filters
new file mode 100644
index 0000000..9ab2753
--- /dev/null
+++ b/src_proiect/Disk/Disk.vcxproj.filters
@@ -0,0 +1,45 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{7451e92f-6c75-4760-9f36-bf444756d891}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\mbr.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\disk_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\disk.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\disk_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\disk_dispatch.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\disk.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\disk_dispatch.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Disk/headers/disk_base.h b/src_proiect/Disk/headers/disk_base.h
new file mode 100644
index 0000000..544bad7
--- /dev/null
+++ b/src_proiect/Disk/headers/disk_base.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#include "common_lib.h"
+#include "io.h"
+#include "disk_structures.h"
+#include "log.h"
+#include "ex.h"
\ No newline at end of file
diff --git a/src_proiect/Disk/headers/disk_dispatch.h b/src_proiect/Disk/headers/disk_dispatch.h
new file mode 100644
index 0000000..8bd6d07
--- /dev/null
+++ b/src_proiect/Disk/headers/disk_dispatch.h
@@ -0,0 +1,4 @@
+#pragma once
+
+FUNC_DriverDispatch          DiskDispatchReadWrite;
+FUNC_DriverDispatch          DiskDispatchDeviceControl;
\ No newline at end of file
diff --git a/src_proiect/Disk/headers/disk_structures.h b/src_proiect/Disk/headers/disk_structures.h
new file mode 100644
index 0000000..3831644
--- /dev/null
+++ b/src_proiect/Disk/headers/disk_structures.h
@@ -0,0 +1,15 @@
+#pragma once
+
+typedef struct _DISK_OBJECT
+{
+    QWORD                       NumberOfSectors;
+    PDEVICE_OBJECT              DiskDeviceController;
+
+    PDISK_LAYOUT_INFORMATION    DiskLayout;
+} DISK_OBJECT, *PDISK_OBJECT;
+
+typedef struct _VOLUME_LIST_ENTRY
+{
+    LIST_ENTRY              ListEntry;
+    PDEVICE_OBJECT          Volume;
+} VOLUME_LIST_ENTRY, *PVOLUME_LIST_ENTRY;
\ No newline at end of file
diff --git a/src_proiect/Disk/inc/disk.h b/src_proiect/Disk/inc/disk.h
new file mode 100644
index 0000000..d81e8b2
--- /dev/null
+++ b/src_proiect/Disk/inc/disk.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry                    DiskDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/Disk/inc/mbr.h b/src_proiect/Disk/inc/mbr.h
new file mode 100644
index 0000000..98c841e
--- /dev/null
+++ b/src_proiect/Disk/inc/mbr.h
@@ -0,0 +1,58 @@
+#pragma once
+
+#define MBR_PARTITION_ENTRY_SIZE            16
+#define MBR_SIZE                            512
+#define MBR_NO_OF_PARTITIONS                4
+
+#define MBR_EXT_PARTITION_NO_OF_ENTRIES     2
+
+#define CHS_ADDRESS_SIZE                    3
+
+// other values are invalid
+#define MBR_STATUS_ACTIVE                   0x80
+#define MBR_STATUS_INACTIVE                 0x00
+
+// partition types
+#define MBR_PARTITION_EXTENDED_CHS          0x5
+#define MBR_PARTITION_EXTENDED_LBA          0xF
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+typedef struct _CHS_ADDRESS
+{
+    BYTE            Head;
+    BYTE            Sector          : 6;
+    BYTE            CylinderHigh    : 2;
+    BYTE            CylinderLow;
+} CHS_ADDRESS, *PCHS_ADDRESS;
+STATIC_ASSERT(sizeof(CHS_ADDRESS) == CHS_ADDRESS_SIZE);
+
+typedef struct _MBR_PARTITION_ENTRY
+{
+    // 0x80 - active (old MBRs only accept this value as valid)
+    // 0x00 - inactive
+    // 0x1 - 7xF invalid
+    BYTE                    Status;
+    CHS_ADDRESS             FirstSectorCHS;
+    BYTE                    PartitionType;
+    CHS_ADDRESS             LastSectorCHS;
+    DWORD                   FirstSectorLBA;
+    DWORD                   NumberOfSectors;
+} MBR_PARTITION_ENTRY, *PMBR_PARTITION_ENTRY;
+STATIC_ASSERT(sizeof(MBR_PARTITION_ENTRY) == MBR_PARTITION_ENTRY_SIZE);
+
+typedef struct _MBR
+{
+    BYTE                    BootstrapCode[446];
+    MBR_PARTITION_ENTRY     Partitions[MBR_NO_OF_PARTITIONS];
+    WORD                    BootSignature;
+} MBR, *PMBR;
+STATIC_ASSERT(sizeof(MBR) == MBR_SIZE);
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/Disk/src/disk.c b/src_proiect/Disk/src/disk.c
new file mode 100644
index 0000000..2eaea6b
--- /dev/null
+++ b/src_proiect/Disk/src/disk.c
@@ -0,0 +1,483 @@
+#include "disk_base.h"
+#include "disk.h"
+#include "mbr.h"
+#include "disk_dispatch.h"
+
+static
+STATUS
+_DiskInitialize(
+    IN      PDRIVER_OBJECT          DriverObject,
+    IN      PDEVICE_OBJECT          HardDiskControllerDevice
+    );
+
+static
+STATUS
+_DiskRetrievePartitionsFromDisk(
+    INOUT   PDEVICE_OBJECT          DiskDevice
+    );
+
+static
+STATUS
+_DiskRetrievePartitionsFromDiskStartingAtOffset(
+    INOUT   PDEVICE_OBJECT              DiskDevice,
+    IN      DWORD                       DiskOffset,
+    IN      BOOLEAN                     ExtendedPartition,
+    IN      DWORD                       FirstExtendedPartitionLBA,
+    INOUT   DWORD*                      PartitionCount,
+    OUT_OPT PDISK_LAYOUT_INFORMATION    DiskLayoutInformation
+    );
+
+STATUS
+(__cdecl DiskDriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    )
+{
+    STATUS status;
+    DWORD disksFound;
+    PDEVICE_OBJECT* pHardDiskControllerDevices;
+    DWORD numberOfDevices;
+    DWORD i;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DriverObject);
+
+    status = STATUS_SUCCESS;
+    disksFound = 0;
+    pHardDiskControllerDevices = NULL;
+    numberOfDevices = 0;
+
+    DriverObject->DispatchFunctions[IRP_MJ_READ] = DiskDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_WRITE] = DiskDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_DEVICE_CONTROL] = DiskDispatchDeviceControl;
+
+    status = IoGetDevicesByType(DeviceTypeHarddiskController, &pHardDiskControllerDevices, &numberOfDevices);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetDeviceByType", status);
+        return status;
+    }
+    ASSERT(numberOfDevices == 0 || pHardDiskControllerDevices != NULL);
+
+    for (i = 0; i < numberOfDevices; ++i)
+    {
+        ASSERT(pHardDiskControllerDevices[i] != NULL);
+
+        status = _DiskInitialize(DriverObject,
+                                 pHardDiskControllerDevices[i]
+                                 );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_DiskInitialize", status );
+            continue;
+        }
+
+        // this should be done only at the end of the function,
+        // else we may fail and the diskFound would not actually be found :)
+        disksFound = disksFound + 1;
+    }
+
+    if (NULL != pHardDiskControllerDevices)
+    {
+        IoFreeTemporaryData(pHardDiskControllerDevices);
+        pHardDiskControllerDevices = NULL;
+    }
+
+    if( disksFound > 0 )
+    {
+        LOG("Found %d disks\n", disksFound);
+        status = STATUS_SUCCESS;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_DiskInitialize(
+    IN      PDRIVER_OBJECT          DriverObject,
+    IN      PDEVICE_OBJECT          HardDiskControllerDevice
+    )
+{
+    STATUS status;
+    PDEVICE_OBJECT pDiskDevice;
+    PDISK_OBJECT pDiskData;
+    GET_LENGTH_INFORMATION lengthInformation;
+    PIRP pIrp;
+
+    ASSERT(NULL != DriverObject);
+    ASSERT(NULL != HardDiskControllerDevice);
+
+    pDiskDevice = NULL;
+    pDiskData = NULL;
+    memzero(&lengthInformation, sizeof(GET_LENGTH_INFORMATION));
+    pIrp = NULL;
+    status = STATUS_SUCCESS;
+
+    __try
+    {
+        // send an IOCTL to see device description
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_DISK_GET_LENGTH_INFO,
+                                             HardDiskControllerDevice,
+                                             NULL,
+                                             0,
+                                             &lengthInformation,
+                                             sizeof(GET_LENGTH_INFORMATION)
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(HardDiskControllerDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        if (!SUCCEEDED(pIrp->IoStatus.Status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        LOG("Succesfully called device with IOCTL IOCTL_DISK_GET_LENGTH_INFO\n");
+
+        pDiskDevice = IoCreateDevice(DriverObject, sizeof(DISK_OBJECT), DeviceTypeDisk);
+        if (NULL == pDiskDevice)
+        {
+            LOG_FUNC_ERROR_ALLOC("IoCreateDevice", sizeof(DISK_OBJECT));
+            status = STATUS_DEVICE_COULD_NOT_BE_CREATED;
+            __leave;
+        }
+        pDiskDevice->DeviceAlignment = HardDiskControllerDevice->DeviceAlignment;
+
+        pDiskData = IoGetDeviceExtension(pDiskDevice);
+        ASSERT(NULL != pDiskData);
+
+        IoAttachDevice(pDiskDevice, HardDiskControllerDevice);
+
+        pDiskData->NumberOfSectors = lengthInformation.Length / SECTOR_SIZE;
+        pDiskData->DiskDeviceController = HardDiskControllerDevice;
+
+        status = _DiskRetrievePartitionsFromDisk(pDiskDevice);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_DiskRetrievePartitionsFromDisk", status);
+            __leave;
+        }
+        LOGL("_DiskRetrievePartitionsFromDisk succceded\n");
+
+        pDiskDevice = NULL;
+        pDiskData = NULL;
+    }
+    __finally
+    {
+        if (NULL != pDiskDevice)
+        {
+            IoDeleteDevice(pDiskDevice);
+            pDiskDevice = NULL;
+        }
+
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+static
+STATUS
+_DiskRead(
+    IN                                          PDEVICE_OBJECT  DiskDevice,
+    IN                                          QWORD           SectorIndex,
+    IN                                          WORD            SectorCount,
+    OUT_WRITES_BYTES(SectorCount*SECTOR_SIZE)   PVOID           Buffer,
+    OUT                                         WORD*           SectorsRead,
+    IN                                          BOOLEAN         Asynchronous
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PIO_STACK_LOCATION pStackLocation;
+    QWORD byteOffset;
+
+    if (NULL == DiskDevice)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pStackLocation = NULL;
+    byteOffset = 0;
+
+    LOGL("Disk read with sector index 0x%X, sector count 0x%x\n", SectorIndex, SectorCount);
+
+    __try
+    {
+        if (SectorIndex >= MAX_QWORD / SECTOR_SIZE)
+        {
+            status = STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED;
+            __leave;
+        }
+
+        pIrp = IoAllocateIrp(DiskDevice->StackSize);
+        ASSERT(NULL != pIrp);
+
+        // setup next stack location
+        pStackLocation = IoGetNextIrpStackLocation(pIrp);
+
+        pStackLocation->MajorFunction = IRP_MJ_READ;
+        pStackLocation->Parameters.ReadWrite.Length = SectorCount * SECTOR_SIZE;
+
+        pStackLocation->Parameters.ReadWrite.Offset = SectorIndex * SECTOR_SIZE;
+
+        pIrp->Buffer = Buffer;
+        pIrp->Flags.Asynchronous = Asynchronous;
+
+        status = IoCallDriver(DiskDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        *SectorsRead = (WORD)(pIrp->IoStatus.Information / SECTOR_SIZE);
+        status = pIrp->IoStatus.Status;
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_DiskRetrievePartitionsFromDisk(
+    INOUT   PDEVICE_OBJECT          DiskDevice
+    )
+{
+    STATUS status;
+    DWORD partitionCount;
+    PDISK_LAYOUT_INFORMATION pDiskInformation;
+    DWORD structureSize;
+    PDISK_OBJECT pDisk;
+
+    ASSERT(NULL != DiskDevice);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    partitionCount = 0;
+    pDiskInformation = NULL;
+    structureSize = 0;
+    pDisk = IoGetDeviceExtension(DiskDevice);
+
+    ASSERT(NULL != pDisk);
+
+    status = _DiskRetrievePartitionsFromDiskStartingAtOffset(DiskDevice, 0, FALSE, 0, &partitionCount, NULL);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_DiskRetrievePartitionsFromDiskStartingAtOffset", status);
+        return status;
+    }
+
+    // now that we now the partition count we can allocate the structure
+    structureSize = sizeof(DISK_LAYOUT_INFORMATION) + partitionCount * sizeof(PARTITION_INFORMATION);
+
+    LOG("Allocate structure for %d partitions\n", partitionCount);
+
+    pDiskInformation = ExAllocatePoolWithTag(PoolAllocateZeroMemory, structureSize, HEAP_DISK_TAG, 0);
+    if (NULL == pDiskInformation)
+    {
+        status = STATUS_HEAP_NO_MORE_MEMORY;
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", structureSize);
+        return status;
+    }
+
+    partitionCount = 0;
+
+    LOG("Will now call _DiskRetrievePartitionsFromDiskStartingAtOffset to complete pDiskInformation structure\n");
+
+    status = _DiskRetrievePartitionsFromDiskStartingAtOffset(DiskDevice, 0, FALSE, 0, &partitionCount, pDiskInformation);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_DiskRetrievePartitionsFromDiskStartingAtOffset", status);
+        return status;
+    }
+    pDiskInformation->NumberOfPartitions = partitionCount;
+
+    pDisk->DiskLayout = pDiskInformation;
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_DiskRetrievePartitionsFromDiskStartingAtOffset(
+    INOUT   PDEVICE_OBJECT              DiskDevice,
+    IN      DWORD                       DiskOffset,
+    IN      BOOLEAN                     ExtendedPartition,
+    IN      DWORD                       FirstExtendedPartitionLBA,
+    INOUT   DWORD*                      PartitionCount,
+    OUT_OPT PDISK_LAYOUT_INFORMATION    DiskLayoutInformation
+    )
+{
+    STATUS status;
+    PMBR pMbr;
+    WORD sectorsRead;
+    DWORD currentPartition;
+    PMBR_PARTITION_ENTRY pCurPartitionEntry;
+    BOOLEAN extendedPartitionEntry;
+    DWORD entriesToIterateOver;
+    DWORD firstPartitionLBA;
+    PDISK_OBJECT pDiskObject;
+    DWORD partitionCount;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DiskDevice);
+
+    ASSERT_INFO(ExtendedPartition ^ (0 == FirstExtendedPartitionLBA), "If we're in an extended partition the LBA to the first extended partition cannot be 0\n");
+
+    ASSERT(NULL != PartitionCount);
+
+    status = STATUS_SUCCESS;
+    pMbr = NULL;
+    sectorsRead = 0;
+    currentPartition = 0;
+    pCurPartitionEntry = NULL;
+    extendedPartitionEntry = FALSE;
+    entriesToIterateOver = ExtendedPartition ? MBR_EXT_PARTITION_NO_OF_ENTRIES : MBR_NO_OF_PARTITIONS;
+    firstPartitionLBA = 0;
+    partitionCount = *PartitionCount;
+    pDiskObject = IoGetDeviceExtension(DiskDevice);
+    ASSERT(NULL != pDiskObject);
+
+    __try
+    {
+        pMbr = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(MBR), HEAP_TEMP_TAG, 0);
+        if (NULL == pMbr)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(MBR));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        // read the MBR
+        status = _DiskRead(DiskDevice, DiskOffset, 1, pMbr, &sectorsRead, FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("DiskRead", status);
+            __leave;
+        }
+        ASSERT_INFO(1 == sectorsRead, "Number of sectors read: %d\n", sectorsRead);
+
+        // we read the MBR, time to parse it
+        if (MBR_BOOT_SIGNATURE != pMbr->BootSignature)
+        {
+            LOG_WARNING("There is no MBR signature to be found\n");
+            status = STATUS_DISK_MBR_NOT_PRESENT;
+            __leave;
+        }
+
+        for (currentPartition = 0; currentPartition < entriesToIterateOver; ++currentPartition)
+        {
+            pCurPartitionEntry = &pMbr->Partitions[currentPartition];
+
+            if (ExtendedPartition)
+            {
+                // if this entry contains only zero bytes => it was the last entry
+                if (sizeof(MBR_PARTITION_ENTRY) == memscan(pCurPartitionEntry, sizeof(MBR_PARTITION_ENTRY), 0))
+                {
+                    // we finished our iteration
+                    status = STATUS_SUCCESS;
+                    __leave;
+                }
+            }
+
+            if ((MBR_STATUS_ACTIVE != pCurPartitionEntry->Status) &&
+                (MBR_STATUS_INACTIVE != pCurPartitionEntry->Status)
+                )
+            {
+                // this partition is not valid
+                continue;
+            }
+
+            // see if this is an extended partition entry or not
+            extendedPartitionEntry = (MBR_PARTITION_EXTENDED_LBA == pCurPartitionEntry->PartitionType) ||
+                (MBR_PARTITION_EXTENDED_CHS == pCurPartitionEntry->PartitionType);
+
+            if (extendedPartitionEntry)
+            {
+                // we have an extended partition entry
+
+                // partition entry, see what is the offsetToTheFirstPartitionEntry
+                DWORD offsetToFirstExtendedPartition = ExtendedPartition ? FirstExtendedPartitionLBA : pCurPartitionEntry->FirstSectorLBA;
+
+                // the extended entries are relative to the first extended partition
+                firstPartitionLBA = pCurPartitionEntry->FirstSectorLBA + FirstExtendedPartitionLBA;
+
+                // start parsing this extended partition
+                status = _DiskRetrievePartitionsFromDiskStartingAtOffset(DiskDevice, firstPartitionLBA, TRUE, offsetToFirstExtendedPartition, &partitionCount, DiskLayoutInformation);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("_DiskRetrieveVolumesForDiskStartingAtOffset", status);
+                }
+
+                // nothing can be found after an extended entry
+                __leave;
+            }
+            else
+            {
+                // this is not an extended partition entry
+
+                // if we're parsing an extended partition all offsets are relative to this partition
+                firstPartitionLBA = pCurPartitionEntry->FirstSectorLBA + DiskOffset;
+
+                // found another partition
+                if (NULL != DiskLayoutInformation)
+                {
+                    // add partition to list
+
+                    DiskLayoutInformation->Partitions[partitionCount].Bootable = MBR_STATUS_ACTIVE == pCurPartitionEntry->Status;
+                    DiskLayoutInformation->Partitions[partitionCount].OffsetInDisk = firstPartitionLBA;
+                    DiskLayoutInformation->Partitions[partitionCount].PartitionSize = pCurPartitionEntry->NumberOfSectors;
+                    DiskLayoutInformation->Partitions[partitionCount].PartitionType = pCurPartitionEntry->PartitionType;
+                }
+
+                partitionCount = partitionCount + 1;
+            }
+        }
+    }
+    __finally
+    {
+        *PartitionCount = partitionCount;
+
+        if (NULL != pMbr)
+        {
+            ExFreePoolWithTag(pMbr, HEAP_TEMP_TAG);
+            pMbr = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/Disk/src/disk_dispatch.c b/src_proiect/Disk/src/disk_dispatch.c
new file mode 100644
index 0000000..39f1adc
--- /dev/null
+++ b/src_proiect/Disk/src/disk_dispatch.c
@@ -0,0 +1,86 @@
+#include "disk_base.h"
+#include "disk_dispatch.h"
+
+STATUS
+(__cdecl DiskDispatchReadWrite)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PDISK_OBJECT pDiskObject;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    pDiskObject = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pDiskObject);
+
+
+    // copy stack location
+    // this function also advances the current stack location
+    IoCopyCurrentStackLocationToNext(Irp);
+
+    LOG_TRACE_STORAGE("Copied current IRP stack location\n");
+
+    // call lower device object
+    status = IoCallDriver(pDiskObject->DiskDeviceController, Irp);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoCalLDriver", status);
+        return status;
+    }
+    Irp = NULL;
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+(__cdecl DiskDispatchDeviceControl)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PDISK_OBJECT pDiskObject;
+    PIO_STACK_LOCATION pStackLocation;
+    DWORD information;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    pDiskObject = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pDiskObject);
+
+    ASSERT(IRP_MJ_DEVICE_CONTROL == pStackLocation->MajorFunction);
+
+    information = sizeof(DISK_LAYOUT_INFORMATION) + pDiskObject->DiskLayout->NumberOfPartitions * sizeof(PARTITION_INFORMATION);
+
+    switch (pStackLocation->Parameters.DeviceControl.IoControlCode)
+    {
+    case IOCTL_DISK_LAYOUT_INFO:
+        if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+            break;
+        }
+
+        memcpy(pStackLocation->Parameters.DeviceControl.OutputBuffer, pDiskObject->DiskLayout, information);
+        break;
+    default:
+        status = STATUS_UNSUPPORTED;
+    }
+
+    Irp->IoStatus.Information = information;
+    Irp->IoStatus.Status = status;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/Eth_82574L.vcxproj b/src_proiect/Eth_82574L/Eth_82574L.vcxproj
new file mode 100644
index 0000000..49eafc5
--- /dev/null
+++ b/src_proiect/Eth_82574L/Eth_82574L.vcxproj
@@ -0,0 +1,136 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}</ProjectGuid>
+    <RootNamespace>Eth_82574L</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc;..\NetworkPort\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc;..\NetworkPort\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\eth_82574L.c" />
+    <ClCompile Include="src\eth_82574L_operations.c" />
+    <ClCompile Include="src\eth_82574L_structures.c" />
+    <ClCompile Include="src\eth_eeprom.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\eth_82574L_base.h" />
+    <ClInclude Include="headers\eth_82574L_operations.h" />
+    <ClInclude Include="headers\eth_82574L_regs.h" />
+    <ClInclude Include="headers\eth_82574L_structures.h" />
+    <ClInclude Include="headers\eth_eeprom.h" />
+    <ClInclude Include="inc\eth_82574L.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/Eth_82574L.vcxproj.filters b/src_proiect/Eth_82574L/Eth_82574L.vcxproj.filters
new file mode 100644
index 0000000..bf5b109
--- /dev/null
+++ b/src_proiect/Eth_82574L/Eth_82574L.vcxproj.filters
@@ -0,0 +1,54 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{e0692dc1-523d-4d99-84b0-46030c0ebc09}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\eth_82574L.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\eth_82574L_operations.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\eth_eeprom.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\eth_82574L_structures.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\eth_82574L.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\eth_82574L_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\eth_82574L_operations.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\eth_82574L_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\eth_eeprom.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\eth_82574L_regs.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/headers/eth_82574L_base.h b/src_proiect/Eth_82574L/headers/eth_82574L_base.h
new file mode 100644
index 0000000..91ff5fd
--- /dev/null
+++ b/src_proiect/Eth_82574L/headers/eth_82574L_base.h
@@ -0,0 +1,9 @@
+#pragma once
+
+#include "common_lib.h"
+#include "io.h"
+#include "log.h"
+#include "ex.h"
+#include "network.h"
+#include "network_utils.h"
+#include "eth_82574L_structures.h"
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/headers/eth_82574L_operations.h b/src_proiect/Eth_82574L/headers/eth_82574L_operations.h
new file mode 100644
index 0000000..fc5dab5
--- /dev/null
+++ b/src_proiect/Eth_82574L/headers/eth_82574L_operations.h
@@ -0,0 +1,35 @@
+#pragma once
+
+STATUS
+EthInitializeDevice(
+    IN_READS(ETH_NO_OF_BARS_USED)   PPCI_BAR        Bars,
+    INOUT                           PETH_DEVICE     Device
+    );
+
+_No_competing_thread_
+STATUS
+EthReceiveFrame(
+    IN                              PETH_DEVICE     Device,
+    IN_OPT                          WORD            MaximumNumberOfFrames
+    );
+
+_No_competing_thread_
+STATUS
+EthSendFrame(
+    IN                              PETH_DEVICE     Device,
+    IN                              WORD            DescriptorIndex,
+    IN                              WORD            Length
+    );
+
+_No_competing_thread_
+BOOLEAN
+EthHandleInterrupt(
+    IN                              PETH_DEVICE     Device
+    );
+
+_No_competing_thread_
+void
+EthChangeDeviceStatus(
+    IN                              PETH_DEVICE             Device,
+    IN                              PNETWORK_DEVICE_STATUS  DeviceStatus
+    );
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/headers/eth_82574L_regs.h b/src_proiect/Eth_82574L/headers/eth_82574L_regs.h
new file mode 100644
index 0000000..7f8e006
--- /dev/null
+++ b/src_proiect/Eth_82574L/headers/eth_82574L_regs.h
@@ -0,0 +1,727 @@
+#pragma once
+
+#define ETH_INTERNAL_REG_SIZE                   4
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                       General Register Descriptors                      ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+// 0x04 - RW
+typedef union _DEVICE_CONTROL_REGISTER
+{
+    struct
+    {
+        DWORD               FullDuplex                      : 1;
+
+        DWORD               __Reserved0                     : 1;
+
+        DWORD               GIOMasterDisable                : 1;
+
+        DWORD               __Reserved1                     : 2;
+
+        DWORD               AutoSpeedDetectionEnable        : 1;
+
+        DWORD               SetLinkUp                       : 1;
+
+        DWORD               __Reserved2                     : 1;
+
+        DWORD               Speed                           : 2;
+
+        DWORD               __Reserved3                     : 1;
+
+        DWORD               ForceSpeed                      : 1;
+
+        DWORD               ForceDuplex                     : 1;
+
+        DWORD               __Reserved4                     : 7;
+
+        DWORD               __D3ColdWakeupAdEnable          : 1;
+
+        DWORD               __Reserved5                     : 5;
+
+        DWORD               DeviceReset                     : 1;
+
+        DWORD               RxFlowControlEnable             : 1;
+
+        DWORD               TxFlowControlEnable             : 1;
+
+        DWORD               __Reserved6                     : 1;
+
+        DWORD               VlanModeEnable                  : 1;
+
+        DWORD               PhyReset                        : 1;
+    };
+    DWORD                   Raw;
+} DEVICE_CONTROL_REGISTER, *PDEVICE_CONTROL_REGISTER;
+STATIC_ASSERT(sizeof(DEVICE_CONTROL_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x08 - R
+typedef union _DEVICE_STATUS_REGISTER
+{
+    struct
+    {
+        DWORD               FullDuplex                      : 1;
+
+        DWORD               LinkUp                          : 1;
+
+        DWORD               __Reserved0                     : 2;
+
+        DWORD               TxPaused                        : 1;
+
+        DWORD               __Reserved1                     : 1;
+
+        DWORD               Speed                           : 2;
+
+        DWORD               AutoSpeedDetectionValue         : 2;
+
+        DWORD               PhyResetAsserted                : 1;
+
+        DWORD               __Reserved2                     : 8;
+
+        DWORD               GIOMasterEnableStatus           : 1;
+
+        DWORD               __Reserved3                     : 12;
+    };
+    DWORD                   Raw;
+} DEVICE_STATUS_REGISTER, *PDEVICE_STATUS_REGISTER;
+STATIC_ASSERT(sizeof(DEVICE_STATUS_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                      Interrupt Register Descriptors                     ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+// 0xC0 - RC/WC
+typedef union _INT_CAUSE_READ_REGISTER
+{
+    struct
+    {
+        // Set when hardware processes a descriptor with RS set. If using
+        // delayed interrupts(IDE set), the interrupt is delayed until after one of
+        // the delayed - timers(TIDV or TADV) expires.
+        DWORD               TdWrittenBack                   : 1;
+
+        // Set when the last descriptor block for a transmit queue has been
+        // used.When configured to use more than one transmit queue this
+        // interrupt indication is issued if one of the queues is
+        DWORD               TxQueueEmpty                    : 1;
+
+        // This bit is set whenever the link status changes(either from up to
+        // down, or from down to up).This bit is affected by the link indication
+        // from the PHY.
+        DWORD               LinkStatusChange                : 1;
+
+        DWORD               __Reserved0                     : 1;
+
+        // This bit indicates that the number of receive descriptors has reached
+        // the minimum threshold as set in RCTL.RDMTS.This indicates to the
+        // software to load more receive descriptors.
+        DWORD               RdMinimumThresholdHit           : 1;
+
+        DWORD               __Reserved1                     : 1;
+
+        // Set on receive data FIFO overrun.Could be caused either because
+        // there are no available buffers or because PCIe receive bandwidth is
+        // inadequate.
+        DWORD               ReceiverOverrun                 : 1;
+
+        DWORD               ReceiverTimerInterrupt          : 1;
+
+        DWORD               __Reserved2                     : 1;
+
+        DWORD               __Reserved3                     : 22;
+
+        // This bit is set when the LAN port has a pending interrupt.If the
+        // interrupt is enabled in the PCI configuration space, an interrupt is
+        // asserted.
+        DWORD               IntAsserted                     : 1;
+    };
+    DWORD                   Raw;
+} INT_CAUSE_READ_REGISTER, *PINT_CAUSE_READ_REGISTER;
+STATIC_ASSERT(sizeof(INT_CAUSE_READ_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+// 0xD0 - RW
+typedef union _INT_MASK_SET_REGISTER
+{
+    struct
+    {
+        // Sets the mask for transmit descriptor written back.
+        DWORD               TdWrittenBack                   : 1;
+
+        // Sets the mask for transmit queue empty.
+        DWORD               TxQueueEmpty                    : 1;
+
+        // Sets the mask for link status change.
+        DWORD               LinkStatusChange                : 1;
+
+        DWORD               __Reserved0                     : 1;
+
+        // Sets the mask for receive descriptor minimum threshold hit.
+        DWORD               RdMinimumThresholdHit           : 1;
+
+        DWORD               __Reserved1                     : 1;
+
+        // Sets mask for receiver overrun. Set on receive data FIFO overrun.
+        DWORD               ReceiverOverrun                 : 1;
+
+        // Sets mask for receiver timer interrupt.
+        DWORD               ReceiverTimerInterrupt          : 1;
+
+        DWORD               __Reserved2                     : 1;
+
+        // Sets mask for MDIO access complete interrupt.
+        DWORD               MdioAccessComplete              : 1;
+
+        DWORD               __Reserved3                     : 5;
+
+        // Sets the mask for transmit descriptor low threshold hit.
+        DWORD               TdLowThresholdHit               : 1;
+
+        // Sets the mask for small receive packet detection.
+        DWORD               SmallReceivePacketDetection     : 1;
+
+        // Sets the mask for receive ACK frame detection.
+        DWORD               AckFrameDetection               : 1;
+
+        // Sets a manageability event.
+        DWORD               ManageabilityEvent              : 1;
+
+        DWORD               __Reserved4                     : 1;
+
+        // Sets the mask for receive queue 0 interrupt.
+        DWORD               RxQueue0                        : 1;
+
+        // Sets the mask for receive queue 1 interrupt.
+        DWORD               RxQueue1                        : 1;
+
+        // Sets the mask for transmit queue 0 interrupt.
+        DWORD               TxQueue0                        : 1;
+
+        // Sets the mask for transmit queue 1 interrupt.
+        DWORD               TxQueue1                        : 1;
+
+        // Sets the mask for other interrupt.
+        DWORD               OtherInterrupt                  : 1;
+
+        DWORD               __Reserved5                     : 7;
+    };
+    DWORD                   Raw;
+} INT_MASK_SET_REGISTER, *PINT_MASK_SET_REGISTER;
+STATIC_ASSERT(sizeof(INT_MASK_SET_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+// 0xD8 - W
+typedef union _INT_MASK_CLEAR_REGISTER
+{
+    struct
+    {
+        // Clears the mask for transmit descriptor written back.
+        DWORD               TdWrittenBack                   : 1;
+
+        // Clears the mask for transmit queue empty.
+        DWORD               TxQueueEmpty                    : 1;
+
+        // Clears the mask for link status change.
+        DWORD               LinkStatusChange                : 1;
+
+        DWORD               __Reserved0                     : 1;
+
+        // Clears the mask for receive descriptor minimum threshold hit.
+        DWORD               RdMinimumThresholdHit           : 1;
+
+        DWORD               __Reserved1                     : 1;
+
+        // Clears mask for receiver overrun. Set on receive data FIFO overrun.
+        DWORD               ReceiverOverrun                 : 1;
+
+        // Clears mask for receiver timer interrupt.
+        DWORD               ReceiverTimerInterrupt          : 1;
+
+        DWORD               __Reserved2                     : 1;
+
+        // Clears mask for MDIO access complete interrupt.
+        DWORD               MdioAccessComplete              : 1;
+
+        DWORD               __Reserved3                     : 5;
+
+        // Clears the mask for transmit descriptor low threshold hit.
+        DWORD               TdLowThresholdHit               : 1;
+
+        // Clears the mask for small receive packet detection.
+        DWORD               SmallReceivePacketDetection     : 1;
+
+        // Clears the mask for receive ACK frame detection.
+        DWORD               AckFrameDetection               : 1;
+
+        // Clears a manageability event.
+        DWORD               ManageabilityEvent              : 1;
+
+        DWORD               __Reserved4                     : 1;
+
+        // Clears the mask for receive queue 0 interrupt.
+        DWORD               RxQueue0                        : 1;
+
+        // Clears the mask for receive queue 1 interrupt.
+        DWORD               RxQueue1                        : 1;
+
+        // Clears the mask for transmit queue 0 interrupt.
+        DWORD               TxQueue0                        : 1;
+
+        // Clears the mask for transmit queue 1 interrupt.
+        DWORD               TxQueue1                        : 1;
+
+        // Clears the mask for other interrupt.
+        DWORD               OtherInterrupt                  : 1;
+
+        DWORD               __Reserved5                     : 7;
+    };
+    DWORD                   Raw;
+} INT_MASK_CLEAR_REGISTER, *PINT_MASK_CLEAR_REGISTER;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                      Receive Register Descriptors                       ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+#define RDMTS_HALF                  0b00
+#define RDMTS_QUARTER               0b01
+#define RDMTS_HALF_QUARTER          0b10
+
+// 0x100 - RW
+typedef union _RECEIVE_CONTROL_REGISTER
+{
+    struct
+    {
+        DWORD               __Reserved0                     : 1;
+
+        // The receiver is enabled when this bit is set to 1b. Writing this bit to
+        // 0b, stops reception after receipt of any in progress packet.All
+        // subsequent packets are then immediately dropped until this bit is set to 1b.
+        DWORD               Enable                          : 1;
+
+        DWORD               StoreBadPackets                 : 1;
+
+        DWORD               UnicastPromiscuousEnable        : 1;
+
+        DWORD               MulticastPromiscuousEnable      : 1;
+
+        DWORD               LongPacketEnable                : 1;
+
+        // Should always be set to 00b
+        DWORD               LoopbackMode                    : 2;
+
+        // The corresponding interrupt is set whenever the fractional number of
+        // free descriptors becomes equal to RDMTS.
+        //     00b 1 / 2
+        //     01b 1 / 4
+        //     10b 1 / 8
+        //     11b RESERVED
+        DWORD               ReceiveDescriptorMinThSize      : 2;
+
+        // 00b = Legacy descriptor type.
+        // 01b = Packet split descriptor type.
+        // 10b, 11b = Reserved.
+        DWORD               DescriptorType                  : 2;
+
+        DWORD               MulticastOffset                 : 2;
+
+        DWORD               __Reserved1                     : 1;
+
+        DWORD               BroadcastAcceptMode             : 1;
+
+        //  If RCTL.BSEX = 0b:
+        //     00b = 2048 bytes.
+        //     01b = 1024 bytes.
+        //     10b = 512 bytes.
+        //     11b = 256 bytes.
+        //  If RCTL.BSEX = 1b :
+        //     00b = reserved; software should not set to this value.
+        //     01b = 16384 bytes.
+        //     10b = 8192 bytes.
+        //     11b = 4096 bytes.
+        //  BSIZE is only used when DTYP = 00b.When DTYP = 01b, the buffer
+        //  sizes for the descriptor are controlled by fields in the PSRCTL register.
+        //  BSIZE is not relevant when FLXBUF is different from 0x0, in that case,
+        //  FLXBUF determines the buffer size.
+        DWORD               ReceiveBufferSize               : 2;
+
+        DWORD               VlanFilterEnable                : 1;
+
+        DWORD               CanonicalFormIndicatorEnable    : 1;
+
+        DWORD               CanonicalFormIndiicatorValue    : 1;
+
+        DWORD               __Reserved2                     : 1;
+
+        DWORD               DiscardPauseFrames              : 1;
+
+        DWORD               PassMacControlFrames            : 1;
+
+        DWORD               __Reserved3                     : 1;
+
+        // Modifies the buffer size indication(BSIZE).When set to 1b, the
+        // original BSIZE values are multiplied by 16.
+        DWORD               BufferSizeExtension             : 1;
+
+        DWORD               StripEthCRC                     : 1;
+
+        // Determines a flexible buffer size.When this field is 0x0000, the buffer
+        // size is determined by BSIZE.If this field is different from 0x0000, the
+        // receive buffer size is the number represented in KB.For example,
+        // 0x0001 = 1 KB(1024 bytes).
+        DWORD               FlexibleBufferSize              : 4;
+
+        DWORD               __Reserved4                     : 1;
+    };
+    DWORD                   Raw;
+} RECEIVE_CONTROL_REGISTER, *PRECEIVE_CONTROL_REGISTER;
+STATIC_ASSERT(sizeof(RECEIVE_CONTROL_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x2800 - RW
+typedef union _RD_BASE_ADDRESS_LOW
+{
+    struct
+    {
+        DWORD                   __Ignored0                      :  4;
+
+        DWORD                   BaseAddressLow                  : 28;
+    };
+    DWORD                       Raw;
+} RD_BASE_ADDRESS_LOW, *PRD_BASE_ADDRESS_LOW;
+STATIC_ASSERT(sizeof(RD_BASE_ADDRESS_LOW) == ETH_INTERNAL_REG_SIZE);
+
+// 0x2804 - RW
+typedef union _RD_BASE_ADDRESS_HIGH
+{
+    DWORD                   BaseAddressHigh;
+    DWORD                   Raw;
+} RD_BASE_ADDRESS_HIGH, *PRD_BASE_ADDRESS_HIGH;
+STATIC_ASSERT(sizeof(RD_BASE_ADDRESS_HIGH) == ETH_INTERNAL_REG_SIZE);
+
+// 0x2808 - RW
+typedef union _RD_LENGTH
+{
+    struct
+    {
+        // Number of bytes allocated for descriptors in the circular descriptor
+        // buffer.It must be 128 - byte aligned.
+        DWORD                   Length                          : 20;
+
+        DWORD                   __Reserved0                     : 12;
+    };
+    DWORD                       Raw;
+} RD_LENGTH, *PRD_LENGTH;
+STATIC_ASSERT(sizeof(RD_LENGTH) == ETH_INTERNAL_REG_SIZE);
+
+// 0x2810 - RW
+typedef union _RD_HEAD
+{
+    struct
+    {
+        // This register contains the head pointer for the receive descriptor buffer.The register
+        // points to a 16 - byte datum.Hardware controls the pointer.The only time that software
+        // should write to this register is after a reset(hardware reset or CTRL.RST) and before
+        // enabling the receive function(RCTL.EN).
+        /// ATTENTION: If software were to write to this register while the receive function was
+        /// enabled, the on - chip descriptor buffers might be invalidated and the hardware
+        /// could be become unstable.
+        WORD                    Head;
+
+        WORD                    __Reserved0;
+    };
+    DWORD                       Raw;
+} RD_HEAD, *PRD_HEAD;
+STATIC_ASSERT(sizeof(RD_HEAD) == ETH_INTERNAL_REG_SIZE);
+
+// 0x2818 - RW
+typedef union _RD_TAIL
+{
+    struct
+    {
+        // This register contains the tail pointers for the receive descriptor buffer.The register
+        // points to a 16 - byte datum.Software writes the tail register to add receive descriptors
+        // to the hardware free list for the ring.
+        WORD                   Tail;
+
+        WORD                   __Reserved0;
+    };
+    DWORD                       Raw;
+} RD_TAIL, *PRD_TAIL;
+STATIC_ASSERT(sizeof(RD_TAIL) == ETH_INTERNAL_REG_SIZE);
+
+// 0x2820 - RW
+typedef union _RECEIVE_INTERRUPT_RELATIVE_DELAY_TIMER
+{
+    struct
+    {
+        // Receive packet delay timer measured in increments of 1.024 in us
+        WORD                    Delay;
+
+        WORD                    __Reserved                      : 15;
+
+        // When set to 1b, flushes the partial descriptor block; ignored
+        // otherwise.Reads 0b.
+        WORD                    FlushPartialDescriptorBlock     :  1;
+    };
+    DWORD                       Raw;
+} RECEIVE_INTERRUPT_RELATIVE_DELAY_TIMER, *PRECEIVE_INTERRUPT_RELATIVE_DELAY_TIMER;
+STATIC_ASSERT(sizeof(RECEIVE_INTERRUPT_RELATIVE_DELAY_TIMER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x282C - RW
+typedef union _RECEIVE_INTERRUPT_ABSOLUTE_DELAY_TIMER
+{
+    struct
+    {
+        // Receive absolute delay timer measured in increments of 1.024 in us (0=
+        // disabled).
+        WORD                    Delay;
+
+        WORD                    __Reserved;
+    };
+    DWORD                       Raw;
+} RECEIVE_INTERRUPT_ABSOLUTE_DELAY_TIMER, *PRECEIVE_INTERRUPT_ABSOLUTE_DELAY_TIMER;
+STATIC_ASSERT(sizeof(RECEIVE_INTERRUPT_ABSOLUTE_DELAY_TIMER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x3820 - RW
+typedef union _TRANSMIT_INTERRUPT_RELATIVE_DELAY_TIMER
+{
+    struct
+    {
+        // Counts in units of 1.024 microseconds. A value of 0 is not allowed.
+        WORD                    Delay;
+
+        WORD                    __Reserved                      : 15;
+
+        // Flush Partial Descriptor Block
+        WORD                    FlushPartialDescriptorBlock     :  1;
+    };
+    DWORD                       Raw;
+} TRANSMIT_INTERRUPT_RELATIVE_DELAY_TIMER, *PTRANSMIT_INTERRUPT_RELATIVE_DELAY_TIMER;
+STATIC_ASSERT(sizeof(TRANSMIT_INTERRUPT_RELATIVE_DELAY_TIMER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x382C - RW
+typedef union _TRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER
+{
+    struct
+    {
+        // Counts in units of 1.024 microseconds. (0b = disabled).
+        WORD                    Delay;
+
+        WORD                    __Reserved;
+    };
+    DWORD                       Raw;
+} TRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER, *PTRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER;
+STATIC_ASSERT(sizeof(TRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x5008 - RW
+typedef union _RECEIVE_FILTER_CONTROL_REGISTER
+{
+    struct
+    {
+        // Disable the iSCSI filtering.
+        DWORD                   IScsiDisable                    :  1;
+
+        // This field indicates the Dword count of the iSCSI header, which is used
+        // for packet split mechanism.
+        DWORD                   IScsiDwordCount                 :  5;
+
+        // Disable filtering of NFS write request headers.
+        DWORD                   NfsWriteDisable                 :  1;
+
+        // Disable filtering of NFS read reply headers.
+        DWORD                   NfsReadDisable                  :  1;
+
+        // 00b = NFS version 2.
+        // 01b = NFS version 3.
+        // 10b = NFS version 4.
+        // 11b = Reserved for future use.
+        DWORD                   NfsVersion                      :  2;
+
+        // Disable IPv6 packet filtering.
+        DWORD                   Ipv6Disable                     :  1;
+
+        // Disable XSUM on IPv6 packets.
+        DWORD                   Ipv6XSumDisable                 :  1;
+
+        // When this bit is set, the 82574 does not accelerate interrupt on TCP
+        // ACK packets
+        DWORD                   TcpAckAccelerateDisable         :  1;
+
+        // 1b = The 82574L recognizes ACK packets according to the ACK bit in
+        // the TCP header + No CP data
+        // 0b = The 82574L recognizes ACK packets according to the ACK bit
+        // only.
+        // This bit is relevant only if the ACKDIS bit is not set.
+        DWORD                   TcpAckDataDisable               :  1;
+
+        // When this bit is set, the header of IP fragmented packets are not set.
+        DWORD                   IpFragmentSplitDisable          :  1;
+
+        // When the EXSTEN bit is set or when the packet split receive
+        // descriptor is used, the 82574 writes the extended status to the Rx
+        // descriptor.
+        DWORD                   ExtendedStatusEnable            :  1;
+
+        DWORD                   __Reserved1                     : 16;
+    };
+    DWORD                       Raw;
+} RECEIVE_FILTER_CONTROL_REGISTER, *PRECEIVE_FILTER_CONTROL_REGISTER;
+STATIC_ASSERT(sizeof(RECEIVE_FILTER_CONTROL_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                      Transmit Register Descriptors                      ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+// 0x400 - RW
+typedef union _TRANSMIT_CONTROL_REGISTER
+{
+    struct
+    {
+        DWORD               __Reserved0                     :  1;
+
+        // The transmitter is enabled when this bit is set to 1b. Writing this bit to
+        // 0b stops transmission after any in progress packets are sent.Data
+        // remains in the transmit FIFO until the device is re - enabled.Software
+        // should combine this with a reset if the packets in the FIFO need to be
+        // flushed.
+        DWORD               Enable                          :  1;
+
+        DWORD               __Reserved1                     :  1;
+
+        // Padding makes the packet 64 bytes.This is not the same as the
+        // minimum collision distance.
+        // If padding of short packet is allowed, the value in TX descriptor length
+        // field should be not less than 17 bytes.
+        DWORD               PadShortPackets                 :  1;
+
+        // This determines the number of attempts at re - transmission prior to
+        // giving up on the packet(not including the first transmission attempt).
+        // While this can be varied, it should be set to a value of 15 in order to
+        // comply with the IEEE specification requiring a total of 16 attempts.
+        // The Ethernet back - off algorithm is implemented and clamps to the
+        // maximum number of slot times after 10 retries.This field only has
+        // meaning while in half - duplex operation.
+        DWORD               CollisionThreshold              :  8;
+
+        // Specifies the minimum number of byte times that must elapse for
+        // proper CSMA / CD operation.Packets are padded with special symbols,
+        // not valid data bytes.Hardware checks and pads to this value plus one
+        // byte even in full - duplex operation.
+        DWORD               CollisionDistance               : 10;
+
+        // When set to 1b, the device schedules the transmission of an XOFF
+        // (PAUSE) frame using the current value of the pause timer.This bit self
+        // clears upon transmission of the XOFF frame.
+        DWORD               SoftwareXoffTransmission        :  1;
+
+        DWORD               __Reserved2                     :  1;
+
+        DWORD               __Ignored0                      :  1;
+
+        DWORD               UnderRunNoRetransmit            :  1;
+
+        DWORD               TxDescriptorMinimumThreshold    :  2;
+
+        // This bit defines the number of read requests the 82574 issues for
+        // transmit data.When set to 0b, the 82574 submits only one request at
+        // a time, When set to 1b, the 82574 might submit up to four concurrent
+        // requests.The software device driver must not modify this register
+        // when the Tx head register is not equal to the tail register.
+        // This bit is loaded from the NVM word 0x24 / 0x14.
+        DWORD               MultipleRequestSupport          :  1;
+
+        // These bits define the threshold size for the intermediate buffer to
+        // determine when to send the read command to the packet buffer.
+        // Threshold is defined as follows :
+        //  RRTHRESH = 00b threshold = 2 lines of 16 bytes
+        //  RRTHRESH = 01b threshold = 4 lines of 16 bytes
+        //  RRTHRESH = 10b threshold = 8 lines of 16 bytes
+        //  RRTHRESH = 11b threshold = No threshold(transfer data after all of
+        //                                          the request is in the RFIFO)
+        DWORD               ReadRequestThreashold           :  2;
+
+        DWORD               __Reserved3                     :  1;
+    };
+    DWORD                   Raw;
+} TRANSMIT_CONTROL_REGISTER, *PTRANSMIT_CONTROL_REGISTER;
+STATIC_ASSERT(sizeof(TRANSMIT_CONTROL_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+// 0x3800 - RW
+typedef union _TD_BASE_ADDRESS_LOW
+{
+    struct
+    {
+        DWORD                   __Ignored0                      :  4;
+
+        DWORD                   BaseAddressLow                  : 28;
+    };
+    DWORD                       Raw;
+} TD_BASE_ADDRESS_LOW, *PTD_BASE_ADDRESS_LOW;
+STATIC_ASSERT(sizeof(TD_BASE_ADDRESS_LOW) == ETH_INTERNAL_REG_SIZE);
+
+// 0x3804 - RW
+typedef union _TD_BASE_ADDRESS_HIGH
+{
+    DWORD                   BaseAddressHigh;
+    DWORD                   Raw;
+} TD_BASE_ADDRESS_HIGH, *PTD_BASE_ADDRESS_HIGH;
+STATIC_ASSERT(sizeof(TD_BASE_ADDRESS_HIGH) == ETH_INTERNAL_REG_SIZE);
+
+// 0x3808 - RW
+typedef union _TD_LENGTH
+{
+    struct
+    {
+        // Number of bytes allocated for descriptors in the circular descriptor
+        // buffer.It must be 128 - byte aligned.
+        DWORD                   Length                          : 20;
+
+        DWORD                   __Reserved0                     : 12;
+    };
+    DWORD                       Raw;
+} TD_LENGTH, *PTD_LENGTH;
+STATIC_ASSERT(sizeof(TD_LENGTH) == ETH_INTERNAL_REG_SIZE);
+
+// 0x3810 - RW
+typedef union _TD_HEAD
+{
+    struct
+    {
+        // This register contains the head pointer for the transmit descriptor ring.It points to a
+        // 16 - byte datum.Hardware controls this pointer.The only time that software should
+        // write to this register is after a reset(hardware reset or CTRL.RST) and before enabling
+        // the transmit function(TCTL.EN).
+        WORD                    Head;
+
+        WORD                    __Reserved0;
+    };
+    DWORD                       Raw;
+} TD_HEAD, *PTD_HEAD;
+STATIC_ASSERT(sizeof(TD_HEAD) == ETH_INTERNAL_REG_SIZE);
+
+// 0x3818 - RW
+typedef union _TD_TAIL
+{
+    struct
+    {
+        // This register contains the tail pointer for the transmit descriptor ring.It points to a 16 -
+        // byte datum.Software writes the tail pointer to add more descriptors to the transmit
+        // ready queue.Hardware attempts to transmit all packets referenced by descriptors
+        // between head and tail.
+        WORD                        Tail;
+
+        WORD                        __Reserved0;
+    };
+    DWORD                           Raw;
+} TD_TAIL, *PTD_TAIL;
+STATIC_ASSERT(sizeof(TD_TAIL) == ETH_INTERNAL_REG_SIZE);
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/Eth_82574L/headers/eth_82574L_structures.h b/src_proiect/Eth_82574L/headers/eth_82574L_structures.h
new file mode 100644
index 0000000..5464a8c
--- /dev/null
+++ b/src_proiect/Eth_82574L/headers/eth_82574L_structures.h
@@ -0,0 +1,521 @@
+#pragma once
+
+#include "eth_82574L_regs.h"
+#include "lock_common.h"
+
+#define INTEL_82574L_DEV_ID                     0x10D3
+
+#define ETH_NO_OF_BARS_USED                     4
+
+// actual size is 128 * KB_SIZE but we don't want to map it all
+#define ETH_INTERNAL_REGISTER_SIZE              (32*KB_SIZE)
+
+// actual size is between 64 KB and 16MB
+#define ETH_FLASH_SIZE                          (4*KB_SIZE)
+#define ETH_MSI_X_TABLES_SIZE                   (16*KB_SIZE)
+
+#define ETH_OFFSET_ICR                          0x00C0
+#define ETH_OFFSET_IMS                          0x00D0
+#define ETH_OFFSET_RCTL                         0x0100
+#define ETH_OFFSET_TCTL                         0x0400
+#define ETH_OFFSET_RDBAL                        0x2800
+#define ETH_OFFSET_TDBAL                        0x3800
+#define ETH_OFFSET_RFCTL                        0x5008
+#define ETH_OFFSET_TO_IP_ADDRESS_VALID          0x5838
+
+#define ETH_DESCRIPTOR_SIZE                     16
+
+#define ETH_DESCRIPTOR_BUFFER_ALIGNMENT         128
+#define ETH_DATA_BUFFER_ALIGNMENT               4
+
+#define ETH_NO_OF_RX_DESCS                      32
+#define ETH_NO_OF_TX_DESCS                      32
+
+#define ETH_BUFFER_SIZE                         4*KB_SIZE
+
+#define ETH_BSIZE_4KB_SEX                       0b11
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+typedef union _EERD_REGISTER
+{
+    struct
+    {
+        WORD        Start                       :   1;
+        WORD        Done                        :   1;
+
+        // address in words
+        WORD        Address                     :  14;
+        WORD        Data;
+    };
+    DWORD           Raw;
+} EERD_REGISTER, *PEERD_REGISTER;
+STATIC_ASSERT(sizeof(EERD_REGISTER) == ETH_INTERNAL_REG_SIZE);
+
+typedef struct _ETH_INTERNAL_REGS
+{
+    // 0x0 - 0x4 - RW
+    VOL_DWORD                               DeviceControlRegister[2];
+
+    // 0x8 - R
+    VOL_DWORD                               DeviceStatusRegister;
+
+    // 0xC
+    VOL_DWORD                               __Reserved0;
+
+    // 0x10 - RW/R0
+    VOL_DWORD                               EepromFlashControlRegister;
+
+    // 0x14 - RW
+    VOL_DWORD                               EepromReadRegister;
+
+    BYTE                                    __Reserved1[0xA8];
+
+    // 0xC0 - RC/WC
+    VOL_DWORD                               InterruptCauseReadRegister;
+
+    BYTE                                    __Reserved99[0xC];
+
+    // 0xD0 - RW
+    VOL_DWORD                               InterruptMaskSetRegister;
+
+    VOL_DWORD                               __Reserved98;
+
+    // 0xD8 - W
+    VOL_DWORD                               InterruptMaskClearRegister;
+
+    BYTE                                    __Reserved2[0x24];
+
+    // 0x100 - RW
+    VOL_DWORD                               ReceiveControlRegister;
+
+    BYTE                                    __Reserved3[0x2FC];
+
+    // 0x400 - RW
+    VOL_DWORD                               TransmitControlRegister;
+
+    BYTE                                    __Reserved4[0x23FC];
+
+    // 0x2800 - RW
+    VOL_DWORD                               ReceiveDescriptorAddressLow;
+
+    // 0x2804 - RW
+    VOL_DWORD                               ReceiveDescriptorAddressHigh;
+
+    // 0x2808 - RW
+    VOL_DWORD                               ReceiveDescriptorLength;
+
+    VOL_DWORD                               __Reserved5;
+
+    // 0x2810 - RW
+    VOL_DWORD                               ReceiveDescriptorHead;
+
+    VOL_DWORD                               __Reserved6;
+
+    // 0x2818 - RW
+    VOL_DWORD                               ReceiveDescriptorTail;
+
+    VOL_DWORD                               __Reserved7;
+
+    // 0x2820 - RW
+    VOL_DWORD                               ReceiveInterruptRelativeDelayTimer;
+
+    VOL_DWORD                               __Reserved8;
+
+    VOL_DWORD                               __Reserved9;
+
+    // 0x282C - RW
+    VOL_DWORD                               ReceiveInterruptAbsoluteDelayTimer;
+
+    BYTE                                    __Reserved10[0xFD0];
+
+    // 0x3800 - RW
+    VOL_DWORD                               TransmitDescriptorAddressLow;
+
+    // 0x3804 - RW
+    VOL_DWORD                               TransmitDescriptorAddressHigh;
+
+    // 0x3808 - RW
+    VOL_DWORD                               TransmitDescriptorLength;
+
+    VOL_DWORD                               __Reserved11;
+
+    // 0x3810 - RW
+    VOL_DWORD                               TransmitDescriptorHead;
+
+    VOL_DWORD                               __Reserved12;
+
+    // 0x3818 - RW
+    VOL_DWORD                               TransmitDescriptorTail;
+
+    VOL_DWORD                               __Reserved13;
+
+    // 0x3820 - RW
+    VOL_DWORD                               TransmitInterruptRelativeDelayTimer;
+
+    VOL_DWORD                               __Reserved14[2];
+
+    // 0x382C - RW
+    VOL_DWORD                               TransmitInterruptAbsoluteDelayTimer;
+
+    BYTE                                    __Reserved15[0x17D8];
+
+    // 0x5008 - RW
+    VOL_DWORD                               ReceiveFilterControlRegister;
+
+    BYTE                                    __Reserved16[0x82C];
+
+    // 0x5838 - RW
+    VOL_DWORD                               IpAddressValid;
+
+    // 0x583C
+    VOL_DWORD                               __Reserved17;
+
+    // 0x5840
+    VOL_DWORD                               IpAddress0;
+} ETH_INTERNAL_REGS, *PETH_INTERNAL_REGS;
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,InterruptCauseReadRegister) == ETH_OFFSET_ICR);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,InterruptMaskSetRegister) == ETH_OFFSET_IMS);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,ReceiveControlRegister) == ETH_OFFSET_RCTL);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,TransmitControlRegister) == ETH_OFFSET_TCTL);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,ReceiveDescriptorAddressLow) == ETH_OFFSET_RDBAL);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,TransmitDescriptorAddressLow) == ETH_OFFSET_TDBAL);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,ReceiveFilterControlRegister) == ETH_OFFSET_RFCTL);
+STATIC_ASSERT(FIELD_OFFSET(ETH_INTERNAL_REGS,IpAddressValid) == ETH_OFFSET_TO_IP_ADDRESS_VALID );
+STATIC_ASSERT(sizeof(ETH_INTERNAL_REGS) <= ETH_INTERNAL_REGISTER_SIZE);
+
+typedef struct _RECEIVE_DESCRIPTOR_SHADOW
+{
+    PHYSICAL_ADDRESS                        BufferAddress;
+    WORD                                    Length;
+    WORD                                    Checksum;
+    union
+    {
+        struct
+        {
+            BYTE                            DescriptorDone      : 1;
+            BYTE                            EOP                 : 1;
+            BYTE                            __Reserved0         : 1;
+
+            // Packet is 802.1q (matched VET)
+            BYTE                            VP                  : 1;
+
+            // UDP checksum calculated on packet
+            BYTE                            UDPCS               : 1;
+
+            // TCP checksum calculated on packet
+            BYTE                            TCPCS               : 1;
+
+            // IPv4 checksum calculated on packet
+            BYTE                            IPCS                : 1;
+            BYTE                            __Reserved1         : 1;
+        };
+        BYTE                                Raw;
+    } Status;
+    BYTE                                    Errors;
+    WORD                                    VlanTag;
+} RECEIVE_DESCRIPTOR_SHADOW, *PRECEIVE_DESCRIPTOR_SHADOW;
+typedef volatile RECEIVE_DESCRIPTOR_SHADOW RECEIVE_DESCRIPTOR, *PRECEIVE_DESCRIPTOR;
+STATIC_ASSERT(sizeof(RECEIVE_DESCRIPTOR_SHADOW) == ETH_DESCRIPTOR_SIZE);
+
+typedef struct _TRANSMIT_DESCRIPTOR_SHADOW
+{
+    PHYSICAL_ADDRESS                        BufferAddress;
+    WORD                                    Length;
+    BYTE                                    ChecksumOffset;
+    struct
+    {
+        // EOP stands for end - of - packet and when set, indicates the last descriptor making up the
+        // packet.
+        BYTE                                EOP                 : 1;
+
+        // When IFCS is set, hardware appends the MAC FCS at the end of the packet.When
+        // cleared, software should calculate the FCS for proper CRC check.The software must set
+        // IFCS in the following instances :
+        //   Transmission of short packets while padding is enabled by the TCTL.PSP bit
+        //   Checksum offload is enabled by the IC bit in the TDESC.CMD
+        //   VLAN header insertion enabled by the VLE bit in the TDESC.CMD
+        //   Large send or TCP / IP checksum offload using context descriptor
+        BYTE                                IFCS                : 1;
+
+        // When IC is set, hardware inserts a checksum value calculated from the CSS bit value to
+        // the CSE bit value, or to the end of packet.The checksum value is inserted in the header
+        // at the CSO bit value location.One or many descriptors can be used to form a packet.
+        // Checksum calculations are for the entire packet starting at the byte indicated by the
+        // CSS field.A value of zero for CSS corresponds to the first byte in the packet.CSS must
+        // be set in the first descriptor for a packet.In addition, IC is ignored if CSO or CSS are
+        // out of range.This occurs if () or ().
+        BYTE                                IC                  : 1;
+
+        // When the RS bit is set, hardware writes back the DD bit once the DMA fetch completes.
+        BYTE                                RS                  : 1;
+
+        BYTE                                __Reserved0         : 1;
+
+        // The DEXT bit identifies this descriptor as either a legacy or an extended descriptor type
+        // and must be set to 0b to indicate legacy descriptor.
+        BYTE                                DEXT                : 1;
+
+        // VLE indicates that the packet is a VLAN packet(for example, that the hardware should
+        // add the VLAN Ether type and an 802.1q VLAN tag to the packet)
+        BYTE                                VLE                 : 1;
+
+        // IDE activates a transmit interrupt delay timer.Hardware loads a countdown register
+        // when it writes back a transmit descriptor that has RS and IDE set.The value loaded
+        // comes from the IDV field of the Interrupt Delay(TIDV) register.When the count
+        // reaches zero, a transmit interrupt occurs if transmit descriptor write - back interrupts
+        // (TXDW) are enabled.Hardware always loads the transmit interrupt counter whenever it
+        // processes a descriptor with IDE set even if it is already counting down due to a
+        // previous descriptor.If hardware encounters a descriptor that has RS set, but not IDE, it
+        // generates an interrupt immediately after writing back the descriptor and clears the
+        // interrupt delay timer.Setting the IDE bit has no meaning without setting the RS bit.
+        BYTE                                IDE                 : 1;
+    } Command;
+    struct
+    {
+        // DD indicates that the descriptor is done and is written back after the descriptor has
+        // been processed(assuming the RS bit was set).The DD bit can be used as an indicator
+        // to the software that all descriptors, in the memory descriptor ring, up to and including
+        // the descriptor with the DD bit set are again available to the software.
+        BYTE                                DescriptorDone      : 1;
+
+        BYTE                                __Reserved0         : 3;
+
+        BYTE                                TS                  : 1;
+
+        // The TS bit indicates to the 82574 to put a time stamp on the packet designated by the
+        // descriptor.
+        BYTE                                __Reserved1         : 3;
+    };
+    BYTE                                    ChecksumStart;
+    WORD                                    VLAN;
+} TRANSMIT_DESCRIPTOR_SHADOW, *PTRANSMIT_DESCRIPTOR_SHADOW;
+typedef volatile TRANSMIT_DESCRIPTOR_SHADOW TRANSMIT_DESCRIPTOR, *PTRANSMIT_DESCRIPTOR;
+STATIC_ASSERT(sizeof(TRANSMIT_DESCRIPTOR_SHADOW) == ETH_DESCRIPTOR_SIZE);
+
+#pragma pack(pop)
+
+typedef struct _ETH_BUFFERS
+{
+    WORD                                    NumberOfDescriptors;
+    WORD                                    CurrentDescriptor;
+    WORD                                    BufferSize;
+} ETH_BUFFERS, *PETH_BUFFERS;
+
+typedef struct _RX_DATA
+{
+    PRECEIVE_DESCRIPTOR                     ReceiveBuffer;
+    ETH_BUFFERS                             Buffers;
+} RX_DATA, *PRX_DATA;
+
+typedef struct _TX_DATA
+{
+    PTRANSMIT_DESCRIPTOR                    TransmitBuffer;
+    ETH_BUFFERS                             Buffers;
+    LOCK                                    TxInterruptLock;
+} TX_DATA, *PTX_DATA;
+
+#pragma warning(pop)
+
+typedef struct _ETH_DEVICE
+{
+    struct _MINIPORT_DEVICE*                MiniportDevice;
+
+    PETH_INTERNAL_REGS                      InternalRegisters;
+    volatile DWORD*                         Flash;
+    volatile DWORD*                         MsiX;
+
+    RX_DATA                                 RxData;
+    TX_DATA                                 TxData;
+} ETH_DEVICE, *PETH_DEVICE;
+
+// General
+DEVICE_CONTROL_REGISTER
+EthGetDeviceControlRegister(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetDeviceControlRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      DEVICE_CONTROL_REGISTER     ControlRegister
+    );
+
+DEVICE_STATUS_REGISTER
+EthGetDeviceStatusRegister(
+    IN      PETH_DEVICE         Device
+    );
+
+// Interrupt
+INT_CAUSE_READ_REGISTER
+EthGetInterruptReason(
+    IN      PETH_DEVICE         Device
+    );
+
+INT_MASK_SET_REGISTER
+EthGetInterruptMaskRegister(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetInterruptMaskSetRegister(
+    IN      PETH_DEVICE             Device,
+    IN      INT_MASK_SET_REGISTER   Mask
+    );
+
+void
+EthSetInterruptMaskClearRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      INT_MASK_CLEAR_REGISTER     Mask
+    );
+
+// Receive
+DWORD
+EthGetRxControlRegister(
+    IN      PETH_DEVICE                 Device
+    );
+
+void
+EthSetRxControlRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      RECEIVE_CONTROL_REGISTER    ControlRegister
+    );
+
+void
+EthSetRxFilterControlRegister(
+    IN      PETH_DEVICE                         Device,
+    IN      RECEIVE_FILTER_CONTROL_REGISTER     FilterRegister
+    );
+
+void
+EthSetRxRingBufferAddress(
+    IN      PETH_DEVICE         Device,
+    IN      PHYSICAL_ADDRESS    Address
+    );
+
+void
+EthSetRxRingBufferSize(
+    IN      PETH_DEVICE         Device,
+    IN      DWORD               Size
+    );
+
+WORD
+EthGetRxHead(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetRxHead(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    );
+
+WORD
+EthGetRxTail(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetRxTail(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    );
+
+WORD
+EthGetRxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetRxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    );
+
+WORD
+EthGetRxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetRxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    );
+
+
+// Transmit
+DWORD
+EthGetTxControlRegister(
+    IN      PETH_DEVICE                 Device
+    );
+
+void
+EthSetTxControlRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      TRANSMIT_CONTROL_REGISTER   ControlRegister
+    );
+
+void
+EthSetTxRingBufferAddress(
+    IN      PETH_DEVICE         Device,
+    IN      PHYSICAL_ADDRESS    Address
+    );
+
+void
+EthSetTxRingBufferSize(
+    IN      PETH_DEVICE         Device,
+    IN      DWORD               Size
+    );
+
+WORD
+EthGetTxHead(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetTxHead(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    );
+
+WORD
+EthGetTxTail(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetTxTail(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    );
+
+WORD
+EthGetTxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetTxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    );
+
+WORD
+EthGetTxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device
+    );
+
+void
+EthSetTxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    );
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/headers/eth_eeprom.h b/src_proiect/Eth_82574L/headers/eth_eeprom.h
new file mode 100644
index 0000000..4846b43
--- /dev/null
+++ b/src_proiect/Eth_82574L/headers/eth_eeprom.h
@@ -0,0 +1,7 @@
+#pragma once
+
+WORD
+EthEepromReadWord(
+    IN      PETH_INTERNAL_REGS      EthRegs,
+    IN      WORD                    Address
+    );
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/inc/eth_82574L.h b/src_proiect/Eth_82574L/inc/eth_82574L.h
new file mode 100644
index 0000000..51cfdbf
--- /dev/null
+++ b/src_proiect/Eth_82574L/inc/eth_82574L.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry        Eth82574LDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/src/eth_82574L.c b/src_proiect/Eth_82574L/src/eth_82574L.c
new file mode 100644
index 0000000..3fdf877
--- /dev/null
+++ b/src_proiect/Eth_82574L/src/eth_82574L.c
@@ -0,0 +1,209 @@
+#include "eth_82574L_base.h"
+#include "eth_82574L.h"
+#include "eth_82574L_operations.h"
+#include "network_port.h"
+
+static FUNC_NetworkMiniportInitializeDevice     _Eth82574LInitializeMiniport;
+static FUNC_NetworkMiniportSendBuffer           _Eth82574LSendBuffer;
+static FUNC_NetworkMiniportInterruptHandler     _Eth82574LReceiveInterrupt;
+static FUNC_NetworkMiniportChangeDeviceStatus   _Eth82574LChangeDeviceStatus;
+
+__forceinline
+void
+_EthInitializeBuffers(
+    IN          PMINIPORT_BUFFER_INITIALIZATION     BufferInit,
+    OUT         PETH_BUFFERS                        Buffers,
+    IN          BOOLEAN                             TransmitBuffers
+    )
+{
+    DWORD i;
+
+    ASSERT( NULL != BufferInit );
+    ASSERT( NULL != Buffers );
+
+    i = 0;
+
+    ASSERT( BufferInit->NumberOfBuffers <= MAX_WORD );
+    Buffers->NumberOfDescriptors = (WORD) BufferInit->NumberOfBuffers;
+
+    memzero(BufferInit->RingBuffer,
+            Buffers->NumberOfDescriptors * ( TransmitBuffers ? sizeof(TRANSMIT_DESCRIPTOR_SHADOW) : sizeof(RECEIVE_DESCRIPTOR_SHADOW) ) );
+    for (i = 0; i < BufferInit->NumberOfBuffers; ++i)
+    {
+        if (TransmitBuffers)
+        {
+            PTRANSMIT_DESCRIPTOR pTxBuffer = BufferInit->RingBuffer;
+
+            pTxBuffer[i].BufferAddress = BufferInit->Buffers[i];
+
+            // set DescriptorDone so that we will know that descriptor is available for software
+            pTxBuffer[i].DescriptorDone = 1;
+        }
+        else
+        {
+            PRECEIVE_DESCRIPTOR pRxBuffer = BufferInit->RingBuffer;
+
+            pRxBuffer[i].BufferAddress = BufferInit->Buffers[i];
+        }
+    }
+    Buffers->CurrentDescriptor = 0;
+    Buffers->BufferSize = BufferInit->BufferSize;
+}
+
+STATUS
+(__cdecl Eth82574LDriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    )
+{
+    STATUS status;
+    MINIPORT_REGISTRATION registration;
+
+    ASSERT( NULL != DriverObject );
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    memzero(&registration, sizeof(MINIPORT_REGISTRATION));
+
+    registration.DeviceContextSize = sizeof(ETH_DEVICE);
+
+    registration.RxBuffers.BufferSize = ETH_BUFFER_SIZE;
+    registration.RxBuffers.DescriptorSize = ETH_DESCRIPTOR_SIZE;
+    registration.RxBuffers.NumberOfBuffers = ETH_NO_OF_RX_DESCS;
+
+    registration.Specification.MatchVendor = TRUE;
+    registration.Specification.MatchDevice = TRUE;
+    registration.Specification.Description.VendorId = PciVendorIdIntel;
+    registration.Specification.Description.DeviceId = INTEL_82574L_DEV_ID;
+
+    registration.TxBuffers.BufferSize = ETH_BUFFER_SIZE;
+    registration.TxBuffers.DescriptorSize = ETH_DESCRIPTOR_SIZE;
+    registration.TxBuffers.NumberOfBuffers = ETH_NO_OF_TX_DESCS;
+
+    registration.MiniportFunctions.MiniportInitializeDevice = _Eth82574LInitializeMiniport;
+    registration.MiniportFunctions.MiniportUninitializeDevice = NULL;
+    registration.MiniportFunctions.MiniportSendBuffer = _Eth82574LSendBuffer;
+    registration.MiniportFunctions.MiniportInterruptHandler = _Eth82574LReceiveInterrupt;
+    registration.MiniportFunctions.MiniportChangeDeviceStatus = _Eth82574LChangeDeviceStatus;
+
+    // if we don't have any devices or we haven't managed to actually initialize
+    // any device there is no reason for the driver to remain 'loaded' =>
+    // NetworkPortRegisterMiniportDriver will fail
+    status = NetworkPortRegisterMiniportDriver(DriverObject,
+                                               &registration
+                                               );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NetworkPortRegisterMiniportDriver", status );
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+(__cdecl _Eth82574LInitializeMiniport)(
+    INOUT                           PMINIPORT_DEVICE                    MiniportDevice,
+    IN                              PMINIPORT_DEVICE_INITIALIZATION     MiniportInitialization
+    )
+{
+    STATUS status;
+    PETH_DEVICE pEthDevice;
+
+    ASSERT( NULL != MiniportDevice );
+    ASSERT( NULL != MiniportInitialization );
+    ASSERT( NULL != MiniportInitialization->PciBar );
+
+    ASSERT( ETH_NO_OF_RX_DESCS == MiniportInitialization->RxBuffers.NumberOfBuffers );
+    ASSERT( NULL != MiniportInitialization->RxBuffers.Buffers );
+    ASSERT( NULL != MiniportInitialization->RxBuffers.RingBuffer );
+    ASSERT( ETH_BUFFER_SIZE == MiniportInitialization->RxBuffers.BufferSize );
+
+    ASSERT(ETH_NO_OF_TX_DESCS == MiniportInitialization->TxBuffers.NumberOfBuffers);
+    ASSERT(NULL != MiniportInitialization->TxBuffers.Buffers);
+    ASSERT(NULL != MiniportInitialization->TxBuffers.RingBuffer);
+    ASSERT( ETH_BUFFER_SIZE == MiniportInitialization->TxBuffers.BufferSize );
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pEthDevice = NULL;
+
+    pEthDevice = NetworkPortGetMiniportExtension(MiniportDevice);
+    ASSERT( NULL != pEthDevice );
+
+    _EthInitializeBuffers(&MiniportInitialization->RxBuffers, &pEthDevice->RxData.Buffers, FALSE );
+    pEthDevice->RxData.ReceiveBuffer = MiniportInitialization->RxBuffers.RingBuffer;
+
+    _EthInitializeBuffers(&MiniportInitialization->TxBuffers, &pEthDevice->TxData.Buffers, TRUE );
+    pEthDevice->TxData.TransmitBuffer = MiniportInitialization->TxBuffers.RingBuffer;
+
+    pEthDevice->MiniportDevice = MiniportDevice;
+
+    status = EthInitializeDevice( MiniportInitialization->PciBar, pEthDevice );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("EthInitializeDevice", status );
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+(__cdecl _Eth82574LSendBuffer)(
+    IN  PMINIPORT_DEVICE            MiniportDevice,
+    IN  WORD                        DescriptorIndex,
+    IN  WORD                        Length
+    )
+{
+    PETH_DEVICE pEthDevice;
+
+    ASSERT(NULL != MiniportDevice);
+
+    pEthDevice = NetworkPortGetMiniportExtension(MiniportDevice);
+    ASSERT(NULL != pEthDevice);
+
+    return EthSendFrame(pEthDevice, DescriptorIndex, Length);
+}
+
+static
+BOOLEAN
+(__cdecl _Eth82574LReceiveInterrupt)(
+    IN  PMINIPORT_DEVICE            MiniportDevice
+    )
+{
+    PETH_DEVICE pEthDevice;
+
+    ASSERT( NULL != MiniportDevice );
+
+    pEthDevice = NetworkPortGetMiniportExtension(MiniportDevice);
+    ASSERT( NULL != pEthDevice );
+
+    return EthHandleInterrupt(pEthDevice);
+}
+
+static
+void
+(__cdecl _Eth82574LChangeDeviceStatus)(
+    IN  PMINIPORT_DEVICE            MiniportDevice,
+    IN  PNETWORK_DEVICE_STATUS      DeviceStatus
+    )
+{
+    PETH_DEVICE pEthDevice;
+
+    ASSERT( NULL != MiniportDevice );
+    ASSERT( NULL != DeviceStatus );
+
+    pEthDevice = NetworkPortGetMiniportExtension(MiniportDevice);
+    ASSERT(NULL != pEthDevice);
+
+    EthChangeDeviceStatus(pEthDevice, DeviceStatus );
+}
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/src/eth_82574L_operations.c b/src_proiect/Eth_82574L/src/eth_82574L_operations.c
new file mode 100644
index 0000000..c234f5a
--- /dev/null
+++ b/src_proiect/Eth_82574L/src/eth_82574L_operations.c
@@ -0,0 +1,682 @@
+#include "eth_82574L_base.h"
+#include "eth_82574L_operations.h"
+#include "eth_eeprom.h"
+#include "network_port.h"
+
+__forceinline
+static
+void
+_EthChangeRxStatus(
+    IN      PETH_DEVICE         Device,
+    IN      BOOLEAN             NewStatus
+    )
+{
+    RECEIVE_CONTROL_REGISTER ctrlRegister;
+
+    ASSERT( NULL != Device );
+
+    ctrlRegister.Raw = EthGetRxControlRegister(Device);
+    ctrlRegister.Enable = NewStatus;
+    EthSetRxControlRegister(Device, ctrlRegister);
+}
+
+__forceinline
+static
+void
+_EthChangeTxStatus(
+    IN      PETH_DEVICE         Device,
+    IN      BOOLEAN             NewStatus
+    )
+{
+    TRANSMIT_CONTROL_REGISTER ctrlRegister;
+
+    ASSERT(NULL != Device);
+
+    ctrlRegister.Raw = EthGetTxControlRegister(Device);
+    ctrlRegister.Enable = NewStatus;
+    EthSetTxControlRegister(Device, ctrlRegister);
+}
+
+static
+PTR_SUCCESS
+PVOID
+_EthMapMemoryMappedBar(
+    IN      PPCI_BAR            Bar,
+    IN      DWORD               BytesToMap
+    );
+
+static
+void
+_EthRetrieveMacAddress(
+    IN      PETH_INTERNAL_REGS  EthRegisters,
+    OUT     PMAC_ADDRESS        MacAddress
+    );
+
+static
+STATUS
+_EthRxInit(
+    IN      PETH_DEVICE         Device
+    );
+
+static
+STATUS
+_EthTxInit(
+    IN      PETH_DEVICE         Device
+    );
+
+static
+STATUS
+_EthInterruptInit(
+    IN      PETH_DEVICE         Device
+    );
+
+static
+void
+_EthDeviceControlsInit(
+    IN      PETH_DEVICE         Device
+    );
+
+static
+void
+_EthSignalTxQueueFullIfNecessary(
+    IN      PETH_DEVICE         Device
+    );
+
+STATUS
+EthInitializeDevice(
+    IN_READS(ETH_NO_OF_BARS_USED)   PPCI_BAR        Bars,
+    INOUT                           PETH_DEVICE     Device
+    )
+{
+    STATUS status;
+    PETH_INTERNAL_REGS pInternalRegs;
+    PVOID pFlash;
+    PVOID pMsiXTables;
+
+    ASSERT( NULL != Bars );
+    ASSERT( NULL != Device );
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pInternalRegs = NULL;
+    pFlash = NULL;
+    pMsiXTables = NULL;
+
+    __try
+    {
+        pInternalRegs = _EthMapMemoryMappedBar(&Bars[0], ETH_INTERNAL_REGISTER_SIZE);
+        if (NULL == pInternalRegs)
+        {
+            LOG_ERROR("_EthMapMemoryMappedBar could not map internal registers\n");
+            status = STATUS_MEMORY_CANNOT_BE_MAPPED;
+            __leave;
+        }
+        LOG_TRACE_NETWORK("Internal registers successfully mapped!\n");
+
+        Device->InternalRegisters = pInternalRegs;
+
+        pFlash = _EthMapMemoryMappedBar(&Bars[1], ETH_FLASH_SIZE);
+        if (NULL == pFlash)
+        {
+            LOG_WARNING("Flash memory could not be mapped\n");
+        }
+        else
+        {
+            Device->Flash = pFlash;
+            LOG_TRACE_NETWORK("Flash successfully mapped!\n");
+        }
+
+        pMsiXTables = _EthMapMemoryMappedBar(&Bars[3], ETH_MSI_X_TABLES_SIZE);
+        if (NULL == pMsiXTables)
+        {
+            LOG_WARNING("Msi-X tables could not be mapped\n");
+        }
+        else
+        {
+            Device->MsiX = pMsiXTables;
+            LOG_TRACE_NETWORK("Msi-X tables successfully mapped!\n");
+        }
+
+        _EthRetrieveMacAddress(pInternalRegs, &Device->MiniportDevice->PhysicalAddress);
+
+        LOG("Ip address valid: 0x%x\n", pInternalRegs->IpAddressValid);
+        LOG("Ip address 0: 0x%x\n", pInternalRegs->IpAddress0);
+
+        status = _EthRxInit(Device);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_EthRxInit", status);
+            __leave;
+        }
+        LOG_TRACE_NETWORK("_EthRxInit succeeded\n");
+        Device->MiniportDevice->DeviceStatus.RxEnabled = TRUE;
+
+        status = _EthTxInit(Device);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_EthTxInit", status);
+            __leave;
+        }
+        LOG_TRACE_NETWORK("_EthTxInit succeeded\n");
+        Device->MiniportDevice->DeviceStatus.TxEnabled = TRUE;
+
+        status = _EthInterruptInit(Device);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_EthInterruptInit", status);
+            __leave;
+        }
+        LOG_TRACE_NETWORK("_EthInterruptInit succeeded\n");
+
+        _EthDeviceControlsInit(Device);
+        LOG_TRACE_NETWORK("_EthDeviceControlsInit succeeded\n");
+
+        Device->MiniportDevice->LinkUp = (BOOLEAN)(EthGetDeviceStatusRegister(Device).LinkUp);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pMsiXTables)
+            {
+                IoUnmapMemory(pMsiXTables, ETH_MSI_X_TABLES_SIZE);
+                pMsiXTables = NULL;
+            }
+
+            if (NULL != pFlash)
+            {
+                IoUnmapMemory(pFlash, ETH_FLASH_SIZE);
+                pFlash = NULL;
+            }
+
+            if (NULL != pInternalRegs)
+            {
+                IoUnmapMemory(pInternalRegs, ETH_INTERNAL_REGISTER_SIZE);
+                pInternalRegs = NULL;
+            }
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+_No_competing_thread_
+STATUS
+EthReceiveFrame(
+    IN                              PETH_DEVICE     Device,
+    IN_OPT                          WORD            MaximumNumberOfFrames
+    )
+{
+    STATUS status;
+    WORD curRxIndex;
+    WORD prevRxIndex;
+    WORD noOfFramesReceived;
+
+    ASSERT( NULL != Device );
+
+    status = STATUS_SUCCESS;
+    curRxIndex = Device->RxData.Buffers.CurrentDescriptor;
+    ASSERT( curRxIndex < Device->RxData.Buffers.NumberOfDescriptors );
+
+    noOfFramesReceived = 0;
+
+    while (Device->RxData.ReceiveBuffer[curRxIndex].Status.DescriptorDone)
+    {
+        WORD len = Device->RxData.ReceiveBuffer[curRxIndex].Length;
+
+        ASSERT( len <= Device->RxData.Buffers.BufferSize );
+        ASSERT( 1 == Device->RxData.ReceiveBuffer[curRxIndex].Status.EOP );
+
+        status = NetworkPortNotifyReceiveBuffer(Device->MiniportDevice, curRxIndex, len );
+        ASSERT( SUCCEEDED(status));
+
+        Device->RxData.ReceiveBuffer[curRxIndex].Status.DescriptorDone = 0;
+        prevRxIndex = curRxIndex;
+        curRxIndex = (curRxIndex + 1) % Device->RxData.Buffers.NumberOfDescriptors;
+        EthSetRxTail(Device, prevRxIndex);
+
+        noOfFramesReceived = noOfFramesReceived + 1;
+
+        if (noOfFramesReceived == MaximumNumberOfFrames)
+        {
+            break;
+        }
+    }
+
+    Device->RxData.Buffers.CurrentDescriptor = curRxIndex;
+
+    return status;
+}
+
+_No_competing_thread_
+STATUS
+EthSendFrame(
+    IN                              PETH_DEVICE     Device,
+    IN                              WORD            DescriptorIndex,
+    IN                              WORD            Length
+    )
+{
+    WORD curTxIndex;
+    PTRANSMIT_DESCRIPTOR pDescriptor;
+
+    ASSERT( NULL != Device );
+    ASSERT( Length <= Device->TxData.Buffers.BufferSize );
+
+    curTxIndex = DescriptorIndex;
+    ASSERT( curTxIndex == Device->TxData.Buffers.CurrentDescriptor );
+    ASSERT( curTxIndex < Device->TxData.Buffers.NumberOfDescriptors );
+    pDescriptor = &Device->TxData.TransmitBuffer[curTxIndex];
+    ASSERT(pDescriptor->DescriptorDone);
+
+    pDescriptor->Command.DEXT = FALSE;
+    pDescriptor->Command.IC = FALSE;
+    pDescriptor->Command.IFCS = TRUE;
+    pDescriptor->Command.EOP = TRUE;
+    pDescriptor->Command.IDE = TRUE;
+    pDescriptor->Command.RS = TRUE;
+    pDescriptor->Command.VLE = FALSE;
+
+    pDescriptor->DescriptorDone = 0;
+    pDescriptor->Length = Length;
+
+    curTxIndex = (curTxIndex + 1) % Device->TxData.Buffers.NumberOfDescriptors;
+    Device->TxData.Buffers.CurrentDescriptor = curTxIndex;
+
+    _EthSignalTxQueueFullIfNecessary(Device);
+
+    EthSetTxTail(Device, curTxIndex);
+
+    return STATUS_SUCCESS;
+}
+
+_No_competing_thread_
+BOOLEAN
+EthHandleInterrupt(
+    IN                              PETH_DEVICE     Device
+    )
+{
+    INT_CAUSE_READ_REGISTER intReason;
+    STATUS status;
+    BOOLEAN bSolvedInterrupt;
+
+    ASSERT( NULL != Device );
+
+    status = STATUS_SUCCESS;
+    bSolvedInterrupt = FALSE;
+
+    intReason = EthGetInterruptReason(Device);
+    LOG_TRACE_COMP(LogComponentNetwork | LogComponentInterrupt,
+                   "intReason: 0x%x on device 0x%X\n", intReason.Raw, Device);
+
+    // not our interrupt, sorry
+    if (!intReason.IntAsserted)
+    {
+        return FALSE;
+    }
+
+    if (intReason.RdMinimumThresholdHit || intReason.ReceiverTimerInterrupt)
+    {
+        status = EthReceiveFrame(Device, 0);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("EthReceiveFrame", status);
+            return FALSE;
+        }
+        bSolvedInterrupt = TRUE;
+    }
+
+    if (intReason.TdWrittenBack || intReason.TxQueueEmpty)
+    {
+        INTR_STATE dummyState;
+
+        LockAcquire(&Device->TxData.TxInterruptLock, &dummyState );
+
+        // notify port driver we have free descriptors
+        NetworkPortNotifyTxDescriptorAvailable(Device->MiniportDevice);
+
+        LockRelease(&Device->TxData.TxInterruptLock, INTR_OFF );
+
+        bSolvedInterrupt = TRUE;
+    }
+
+    if (intReason.LinkStatusChange)
+    {
+        DEVICE_STATUS_REGISTER devStatus = EthGetDeviceStatusRegister(Device);
+
+        LOG("Link status is [%s]\n", devStatus.LinkUp ? "UP" : "DOWN" );
+
+        NetworkPortNotifyLinkStatusChange(Device->MiniportDevice,
+                                          (BOOLEAN) devStatus.LinkUp
+                                          );
+
+        bSolvedInterrupt = TRUE;
+    }
+
+    return bSolvedInterrupt;
+}
+
+_No_competing_thread_
+void
+EthChangeDeviceStatus(
+    IN                              PETH_DEVICE             Device,
+    IN                              PNETWORK_DEVICE_STATUS  DeviceStatus
+    )
+{
+    BOOLEAN newRxStatus;
+    BOOLEAN newTxStatus;
+
+    ASSERT( NULL != Device );
+    ASSERT( NULL != DeviceStatus );
+
+    LOG_FUNC_START;
+
+    newRxStatus = DeviceStatus->RxEnabled;
+    newTxStatus = DeviceStatus->TxEnabled;
+
+    if (newRxStatus ^ Device->MiniportDevice->DeviceStatus.RxEnabled)
+    {
+        // change RX status
+        LOG("Will change RX status %u -> %u\n",
+             Device->MiniportDevice->DeviceStatus.RxEnabled,
+             newRxStatus
+             );
+        _EthChangeRxStatus(Device, newRxStatus);
+    }
+
+    if (newTxStatus ^ Device->MiniportDevice->DeviceStatus.TxEnabled)
+    {
+        // change TX status
+        LOG("Will change TX status %u -> %u\n",
+             Device->MiniportDevice->DeviceStatus.TxEnabled,
+             newTxStatus
+             );
+        _EthChangeTxStatus(Device, newRxStatus);
+    }
+
+    LOG_FUNC_END;
+}
+
+static
+PTR_SUCCESS
+PVOID
+_EthMapMemoryMappedBar(
+    IN              PPCI_BAR            Bar,
+    IN              DWORD               BytesToMap
+    )
+{
+    PHYSICAL_ADDRESS tempPa;
+    PVOID pResult;
+
+    ASSERT( NULL != Bar );
+    ASSERT( 0 != BytesToMap );
+
+    ASSERT(0 == Bar->MemorySpace.Zero);
+    ASSERT(PCI_MEM_SPACE_32_BIT == Bar->MemorySpace.Type);
+
+    pResult = NULL;
+    tempPa = PCI_GET_PA_FROM_MEM_ADDR(Bar);
+
+    LOG_TRACE_NETWORK("BAR PA at 0x%X\n", tempPa);
+
+    if( NULL == tempPa )
+    {
+        return NULL;
+    }
+
+    pResult = IoMapMemory(tempPa, BytesToMap, PAGE_RIGHTS_READWRITE);
+    if (NULL == pResult)
+    {
+        LOG_ERROR("IoMapMemory could not map PA 0x%X\n", tempPa);
+        return NULL;
+    }
+
+    return pResult;
+}
+
+static
+void
+_EthRetrieveMacAddress(
+    IN              PETH_INTERNAL_REGS  EthRegisters,
+    OUT             PMAC_ADDRESS        MacAddress
+    )
+{
+    WORD tmp;
+
+    ASSERT(NULL != EthRegisters);
+    ASSERT(NULL != MacAddress);
+
+    tmp = EthEepromReadWord(EthRegisters, 0x0);
+    memcpy(&MacAddress->Value[0], &tmp, sizeof(WORD));
+
+    tmp = EthEepromReadWord(EthRegisters, 0x1);
+    memcpy(&MacAddress->Value[2], &tmp, sizeof(WORD));
+
+    tmp = EthEepromReadWord(EthRegisters, 0x2);
+    memcpy(&MacAddress->Value[4], &tmp, sizeof(WORD));
+}
+
+static
+STATUS
+_EthRxInit(
+    IN      PETH_DEVICE         Device
+    )
+{
+    STATUS status;
+    PHYSICAL_ADDRESS ringBufferPa;
+    RECEIVE_CONTROL_REGISTER ctrlRegister;
+    RECEIVE_FILTER_CONTROL_REGISTER filterRegister;
+
+    ASSERT(NULL != Device);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    ringBufferPa = NULL;
+    ctrlRegister.Raw = 0;
+    filterRegister.Raw = 0;
+
+    ringBufferPa = IoGetPhysicalAddress((PVOID)Device->RxData.ReceiveBuffer);
+    if (NULL == ringBufferPa)
+    {
+        LOG_ERROR("IoGetPhysicalAddress cannot map VA 0x%X\n", Device->RxData.ReceiveBuffer);
+        return STATUS_MEMORY_CANNOT_BE_MAPPED;
+    }
+
+    LOG_TRACE_NETWORK("Ring buffer PA: 0x%X\n", ringBufferPa );
+
+    EthSetRxRingBufferAddress(Device, ringBufferPa);
+
+    EthSetRxRingBufferSize(Device, Device->RxData.Buffers.NumberOfDescriptors * ETH_DESCRIPTOR_SIZE );
+
+    EthSetRxHead(Device, 0 );
+
+    // this is a HACK to simplify LIFE
+    // simply state that the last descriptor is not available
+    // and make it available only after the first packet is processed
+    EthSetRxTail(Device, Device->RxData.Buffers.NumberOfDescriptors - 1);
+
+    // Enable RX
+    ctrlRegister.Enable = TRUE;
+
+    // promiscuous mode
+    ctrlRegister.UnicastPromiscuousEnable = TRUE;
+    ctrlRegister.MulticastPromiscuousEnable = TRUE;
+
+    // when half our descriptors are full maybe we ought to
+    // interrupt
+    ctrlRegister.ReceiveDescriptorMinThSize = RDMTS_HALF;
+
+    // accept broadcast, why not
+    ctrlRegister.BroadcastAcceptMode = TRUE;
+
+    ctrlRegister.BufferSizeExtension = TRUE;
+    ctrlRegister.ReceiveBufferSize = ETH_BSIZE_4KB_SEX;
+    ctrlRegister.StoreBadPackets = TRUE;
+    ctrlRegister.StripEthCRC = TRUE;
+
+    EthSetRxControlRegister(Device, ctrlRegister );
+
+    EthSetRxFilterControlRegister( Device, filterRegister );
+
+    EthSetRxInterruptRelativeDelay( Device, 10 * MS_IN_US );
+    EthSetRxInterruptAbsoluteDelay( Device, 64 * MS_IN_US );
+
+    LOG_TRACE_NETWORK("Relative delay: %u, absolute delay: %u\n",
+         EthGetRxInterruptRelativeDelay(Device),
+         EthGetRxInterruptAbsoluteDelay(Device));
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_EthTxInit(
+    IN      PETH_DEVICE         Device
+    )
+{
+    STATUS status;
+    PHYSICAL_ADDRESS ringBufferPa;
+    TRANSMIT_CONTROL_REGISTER ctrlRegister;
+
+    ASSERT( NULL != Device );
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    ctrlRegister.Raw = 0;
+    ringBufferPa = NULL;
+
+    ringBufferPa = IoGetPhysicalAddress((PVOID)Device->TxData.TransmitBuffer);
+    if (NULL == ringBufferPa)
+    {
+        LOG_ERROR("IoGetPhysicalAddress cannot map VA 0x%X\n", Device->TxData.TransmitBuffer);
+        return STATUS_MEMORY_CANNOT_BE_MAPPED;
+    }
+
+    LOG_TRACE_NETWORK("Ring buffer PA: 0x%X\n", ringBufferPa);
+
+    EthSetTxRingBufferAddress(Device, ringBufferPa);
+
+    EthSetTxRingBufferSize(Device, Device->TxData.Buffers.NumberOfDescriptors * ETH_DESCRIPTOR_SIZE);
+
+    EthSetTxHead(Device, 0);
+
+    EthSetTxTail(Device, 0);
+
+    // enable TX
+    ctrlRegister.Enable = TRUE;
+
+    ctrlRegister.PadShortPackets = TRUE;
+    ctrlRegister.CollisionDistance = IEEE_802_3_MINIMUM_FRAME_SIZE;
+
+    EthSetTxControlRegister(Device, ctrlRegister );
+
+    EthSetTxInterruptRelativeDelay(Device, 10 * MS_IN_US);
+    EthSetTxInterruptAbsoluteDelay(Device, 64 * MS_IN_US);
+
+    LOG_TRACE_NETWORK("Relative delay: %u, absolute delay: %u\n",
+         EthGetTxInterruptRelativeDelay(Device),
+         EthGetTxInterruptAbsoluteDelay(Device));
+
+    LockInit(&Device->TxData.TxInterruptLock);
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_EthInterruptInit(
+    IN      PETH_DEVICE         Device
+    )
+{
+    STATUS status;
+    INT_MASK_SET_REGISTER intSetMaskReg;
+    INT_MASK_CLEAR_REGISTER intClearMaskReg;
+
+    ASSERT( NULL != Device );
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    intSetMaskReg.Raw = 0;
+    intClearMaskReg.Raw = MAX_DWORD;
+
+    intClearMaskReg.__Reserved0 = 0;
+    intClearMaskReg.__Reserved1 = 0;
+    intClearMaskReg.__Reserved2 = 0;
+    intClearMaskReg.__Reserved3 = 0;
+    intClearMaskReg.__Reserved4 = 0;
+    intClearMaskReg.__Reserved5 = 0;
+
+    // clear all interrupts then set those which we want to intercept
+
+    intSetMaskReg.RdMinimumThresholdHit = TRUE;
+    intSetMaskReg.ReceiverOverrun = TRUE;
+    intSetMaskReg.ReceiverTimerInterrupt = TRUE;
+    intSetMaskReg.TdWrittenBack = TRUE;
+    intSetMaskReg.LinkStatusChange = TRUE;
+
+    EthSetInterruptMaskClearRegister(Device, intClearMaskReg);
+    EthSetInterruptMaskSetRegister(Device, intSetMaskReg);
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+void
+_EthDeviceControlsInit(
+    IN      PETH_DEVICE         Device
+    )
+{
+    DEVICE_CONTROL_REGISTER devCtrl;
+
+    ASSERT(NULL != Device);
+
+    devCtrl = EthGetDeviceControlRegister(Device);
+
+    // make sure set link up is set
+    devCtrl.SetLinkUp = TRUE;
+
+    // disable VLAN
+    devCtrl.VlanModeEnable = FALSE;
+
+    EthSetDeviceControlRegister(Device, devCtrl );
+}
+
+static
+void
+_EthSignalTxQueueFullIfNecessary(
+    IN      PETH_DEVICE         Device
+    )
+{
+    WORD nextTxIndex;
+    INTR_STATE intrState;
+
+    ASSERT( NULL != Device );
+
+    nextTxIndex = ( Device->TxData.Buffers.CurrentDescriptor + 1 ) % Device->TxData.Buffers.NumberOfDescriptors;
+
+    // the check is done twice because we don't want each time we send a packet to take the interrupt
+    // lock => in most cases the validation will be quick
+    if (nextTxIndex == EthGetTxHead(Device))
+    {
+        LockAcquire(&Device->TxData.TxInterruptLock, &intrState);
+
+        if (nextTxIndex == EthGetTxHead(Device))
+        {
+            LOGL("Queue is full\n");
+            NetworkPortNotifyTxQueueFull(Device->MiniportDevice);
+        }
+
+        LockRelease(&Device->TxData.TxInterruptLock, intrState);
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/src/eth_82574L_structures.c b/src_proiect/Eth_82574L/src/eth_82574L_structures.c
new file mode 100644
index 0000000..70c4743
--- /dev/null
+++ b/src_proiect/Eth_82574L/src/eth_82574L_structures.c
@@ -0,0 +1,512 @@
+#include "eth_82574L_base.h"
+
+__forceinline
+WORD
+_EthTransformMicrosecondsTo1Dot024(
+    IN      WORD                Microseconds
+    )
+{
+    DWORD result;
+
+    result = ( (DWORD) Microseconds * 1000 + 1023 ) / 1024;
+
+    ASSERT( result <= MAX_WORD );
+
+    return (WORD) result;
+}
+
+__forceinline
+WORD
+_EthTransform1Dot024ToMicroseconds(
+    IN      WORD                DotResult
+    )
+{
+    DWORD result;
+
+    /// Unfortunately, I can't come up with a formula which will give
+    /// the correct result for 0 :( => special case
+    if (0 == DotResult)
+    {
+        return 0;
+    }
+
+    result = ((DWORD) DotResult * 1024 - 24 ) / 1000;
+
+    ASSERT( result <= MAX_WORD );
+
+    return (WORD) result;
+}
+
+DEVICE_CONTROL_REGISTER
+EthGetDeviceControlRegister(
+    IN      PETH_DEVICE         Device
+    )
+{
+    DEVICE_CONTROL_REGISTER result;
+
+    ASSERT( NULL != Device );
+
+    result.Raw = Device->InternalRegisters->DeviceControlRegister[0];
+
+    return result;
+}
+
+void
+EthSetDeviceControlRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      DEVICE_CONTROL_REGISTER     ControlRegister
+    )
+{
+    ASSERT( NULL != Device );
+
+    Device->InternalRegisters->DeviceControlRegister[0] = ControlRegister.Raw;
+}
+
+DEVICE_STATUS_REGISTER
+EthGetDeviceStatusRegister(
+    IN      PETH_DEVICE         Device
+    )
+{
+    DEVICE_STATUS_REGISTER result;
+
+    ASSERT( NULL != Device );
+
+    result.Raw = Device->InternalRegisters->DeviceStatusRegister;
+
+    return result;
+}
+
+INT_CAUSE_READ_REGISTER
+EthGetInterruptReason(
+    IN      PETH_DEVICE         Device
+    )
+{
+    INT_CAUSE_READ_REGISTER result;
+
+    ASSERT(NULL != Device);
+
+    result.Raw = Device->InternalRegisters->InterruptCauseReadRegister;
+
+    return result;
+}
+
+INT_MASK_SET_REGISTER
+EthGetInterruptMaskRegister(
+    IN      PETH_DEVICE         Device
+    )
+{
+    INT_MASK_SET_REGISTER result;
+
+    ASSERT( NULL != Device );
+
+    result.Raw = Device->InternalRegisters->InterruptMaskSetRegister;
+
+    return result;
+}
+
+void
+EthSetInterruptMaskSetRegister(
+    IN      PETH_DEVICE             Device,
+    IN      INT_MASK_SET_REGISTER   Mask
+    )
+{
+    ASSERT( NULL != Device );
+
+    Device->InternalRegisters->InterruptMaskSetRegister = Mask.Raw;
+}
+
+void
+EthSetInterruptMaskClearRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      INT_MASK_CLEAR_REGISTER     Mask
+    )
+{
+    ASSERT(NULL != Device);
+
+    Device->InternalRegisters->InterruptMaskClearRegister = Mask.Raw;
+}
+
+DWORD
+EthGetRxControlRegister(
+    IN      PETH_DEVICE                 Device
+    )
+{
+    ASSERT(NULL != Device);
+
+    return Device->InternalRegisters->ReceiveControlRegister;
+}
+
+void
+EthSetRxControlRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      RECEIVE_CONTROL_REGISTER    ControlRegister
+    )
+{
+    ASSERT(NULL != Device);
+
+    Device->InternalRegisters->ReceiveControlRegister = ControlRegister.Raw;
+}
+
+void
+EthSetRxFilterControlRegister(
+    IN      PETH_DEVICE                         Device,
+    IN      RECEIVE_FILTER_CONTROL_REGISTER     FilterRegister
+    )
+{
+    ASSERT(NULL != Device);
+
+    Device->InternalRegisters->ReceiveFilterControlRegister = FilterRegister.Raw;
+}
+
+void
+EthSetRxRingBufferAddress(
+    IN      PETH_DEVICE         Device,
+    IN      PHYSICAL_ADDRESS    Address
+    )
+{
+    DWORD ringBufferLow;
+    DWORD ringBufferHigh;
+    RD_BASE_ADDRESS_LOW rdBal;
+    RD_BASE_ADDRESS_HIGH rdBah;
+
+    ASSERT(NULL != Device);
+    ASSERT(NULL != Address);
+
+    rdBal.Raw = 0;
+    rdBah.Raw = 0;
+    ringBufferHigh = QWORD_HIGH(Address);
+    ringBufferLow = QWORD_LOW(Address);
+
+    // Configure ring buffer address
+    ASSERT(IsAddressAligned(ringBufferLow, ETH_DESCRIPTOR_BUFFER_ALIGNMENT));
+    rdBal.Raw = ringBufferLow;
+    rdBah.BaseAddressHigh = ringBufferHigh;
+
+    Device->InternalRegisters->ReceiveDescriptorAddressLow = rdBal.Raw;
+    Device->InternalRegisters->ReceiveDescriptorAddressHigh = rdBah.Raw;
+}
+
+void
+EthSetRxRingBufferSize(
+    IN      PETH_DEVICE         Device,
+    IN      DWORD               Size
+    )
+{
+    RD_LENGTH rdLen;
+
+    ASSERT( NULL != Device );
+
+    rdLen.Raw = 0;
+
+    // Set descriptor length
+    rdLen.Length = Size;
+
+    Device->InternalRegisters->ReceiveDescriptorLength = rdLen.Raw;
+}
+
+WORD
+EthGetRxHead(
+    IN      PETH_DEVICE         Device
+    )
+{
+    RD_HEAD rdHead;
+
+    ASSERT(NULL != Device);
+
+    rdHead.Raw = Device->InternalRegisters->ReceiveDescriptorHead;
+
+    return rdHead.Head;
+}
+
+void
+EthSetRxHead(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    )
+{
+    RD_HEAD rdHead;
+
+    ASSERT(NULL != Device);
+
+    rdHead.Raw = 0;
+    rdHead.Head = Index;
+
+    Device->InternalRegisters->ReceiveDescriptorHead = rdHead.Raw;
+}
+
+WORD
+EthGetRxTail(
+    IN      PETH_DEVICE         Device
+    )
+{
+    RD_TAIL rdTail;
+
+    ASSERT(NULL != Device);
+
+    rdTail.Raw = Device->InternalRegisters->ReceiveDescriptorTail;
+
+    return rdTail.Tail;
+}
+
+void
+EthSetRxTail(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    )
+{
+    RD_TAIL rdTail;
+
+    ASSERT(NULL != Device);
+
+    rdTail.Raw = 0;
+    rdTail.Tail = Index;
+
+    Device->InternalRegisters->ReceiveDescriptorTail = rdTail.Raw;
+}
+
+WORD
+EthGetRxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device
+    )
+{
+    RECEIVE_INTERRUPT_RELATIVE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = Device->InternalRegisters->ReceiveInterruptRelativeDelayTimer;
+
+    return _EthTransform1Dot024ToMicroseconds( timer.Delay );
+}
+
+void
+EthSetRxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    )
+{
+    RECEIVE_INTERRUPT_RELATIVE_DELAY_TIMER timer;
+
+    ASSERT( NULL != Device );
+
+    timer.Raw = 0;
+    timer.Delay = _EthTransformMicrosecondsTo1Dot024(Microseconds);
+
+    Device->InternalRegisters->ReceiveInterruptRelativeDelayTimer = timer.Raw;
+}
+
+WORD
+EthGetRxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device
+    )
+{
+    RECEIVE_INTERRUPT_ABSOLUTE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = Device->InternalRegisters->ReceiveInterruptAbsoluteDelayTimer;
+
+    return _EthTransform1Dot024ToMicroseconds( timer.Delay );
+}
+
+void
+EthSetRxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    )
+{
+    RECEIVE_INTERRUPT_ABSOLUTE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = 0;
+    timer.Delay = _EthTransformMicrosecondsTo1Dot024(Microseconds);
+
+    Device->InternalRegisters->ReceiveInterruptAbsoluteDelayTimer = timer.Raw;
+}
+
+DWORD
+EthGetTxControlRegister(
+    IN      PETH_DEVICE                 Device
+    )
+{
+    ASSERT(NULL != Device);
+
+    return Device->InternalRegisters->TransmitControlRegister;
+}
+
+void
+EthSetTxControlRegister(
+    IN      PETH_DEVICE                 Device,
+    IN      TRANSMIT_CONTROL_REGISTER   ControlRegister
+    )
+{
+    ASSERT(NULL != Device);
+
+    Device->InternalRegisters->TransmitControlRegister = ControlRegister.Raw;
+}
+
+void
+EthSetTxRingBufferAddress(
+    IN      PETH_DEVICE         Device,
+    IN      PHYSICAL_ADDRESS    Address
+    )
+{
+    DWORD ringBufferLow;
+    DWORD ringBufferHigh;
+    TD_BASE_ADDRESS_LOW tdBal;
+    TD_BASE_ADDRESS_HIGH tdBah;
+
+    ASSERT(NULL != Device);
+    ASSERT(NULL != Address);
+
+    tdBal.Raw = 0;
+    tdBah.Raw = 0;
+    ringBufferHigh = QWORD_HIGH(Address);
+    ringBufferLow = QWORD_LOW(Address);
+
+    // Configure ring buffer address
+    ASSERT(IsAddressAligned(ringBufferLow, ETH_DESCRIPTOR_BUFFER_ALIGNMENT));
+    tdBal.Raw = ringBufferLow;
+    tdBah.BaseAddressHigh = ringBufferHigh;
+
+    Device->InternalRegisters->TransmitDescriptorAddressLow = tdBal.Raw;
+    Device->InternalRegisters->TransmitDescriptorAddressHigh = tdBah.Raw;
+}
+
+void
+EthSetTxRingBufferSize(
+    IN      PETH_DEVICE         Device,
+    IN      DWORD               Size
+    )
+{
+    TD_LENGTH tdLen;
+
+    ASSERT(NULL != Device);
+
+    tdLen.Raw = 0;
+
+    // Set descriptor length
+    tdLen.Length = Size;
+
+    Device->InternalRegisters->TransmitDescriptorLength = tdLen.Raw;
+}
+
+WORD
+EthGetTxHead(
+    IN      PETH_DEVICE         Device
+    )
+{
+    TD_HEAD tdHead;
+
+    ASSERT(NULL != Device);
+
+    tdHead.Raw = Device->InternalRegisters->TransmitDescriptorHead;
+
+    return tdHead.Head;
+}
+
+void
+EthSetTxHead(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    )
+{
+    TD_HEAD tdHead;
+
+    ASSERT(NULL != Device);
+
+    tdHead.Raw = 0;
+    tdHead.Head = Index;
+
+    Device->InternalRegisters->TransmitDescriptorHead = tdHead.Raw;
+}
+
+WORD
+EthGetTxTail(
+    IN      PETH_DEVICE         Device
+    )
+{
+    TD_TAIL tdTail;
+
+    ASSERT(NULL != Device);
+
+    tdTail.Raw = Device->InternalRegisters->TransmitDescriptorTail;
+
+    return tdTail.Tail;
+}
+
+void
+EthSetTxTail(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Index
+    )
+{
+    TD_TAIL tdTail;
+
+    ASSERT(NULL != Device);
+
+    tdTail.Raw = 0;
+    tdTail.Tail = Index;
+
+    Device->InternalRegisters->TransmitDescriptorTail = tdTail.Raw;
+}
+
+WORD
+EthGetTxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device
+    )
+{
+    TRANSMIT_INTERRUPT_RELATIVE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = Device->InternalRegisters->TransmitInterruptRelativeDelayTimer;
+
+    return _EthTransform1Dot024ToMicroseconds(timer.Delay);
+}
+
+void
+EthSetTxInterruptRelativeDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    )
+{
+    TRANSMIT_INTERRUPT_RELATIVE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = 0;
+    timer.Delay = _EthTransformMicrosecondsTo1Dot024(Microseconds);
+
+    Device->InternalRegisters->TransmitInterruptRelativeDelayTimer = timer.Raw;
+}
+
+WORD
+EthGetTxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device
+    )
+{
+    TRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = Device->InternalRegisters->TransmitInterruptAbsoluteDelayTimer;
+
+    return _EthTransform1Dot024ToMicroseconds(timer.Delay);
+}
+
+void
+EthSetTxInterruptAbsoluteDelay(
+    IN      PETH_DEVICE         Device,
+    IN      WORD                Microseconds
+    )
+{
+    TRANSMIT_INTERRUPT_ABSOLUTE_DELAY_TIMER timer;
+
+    ASSERT(NULL != Device);
+
+    timer.Raw = 0;
+    timer.Delay = _EthTransformMicrosecondsTo1Dot024(Microseconds);
+
+    Device->InternalRegisters->TransmitInterruptAbsoluteDelayTimer = timer.Raw;
+}
\ No newline at end of file
diff --git a/src_proiect/Eth_82574L/src/eth_eeprom.c b/src_proiect/Eth_82574L/src/eth_eeprom.c
new file mode 100644
index 0000000..8b4da75
--- /dev/null
+++ b/src_proiect/Eth_82574L/src/eth_eeprom.c
@@ -0,0 +1,24 @@
+#include "eth_82574L_base.h"
+#include "eth_eeprom.h"
+
+WORD
+EthEepromReadWord(
+    IN      PETH_INTERNAL_REGS      EthRegs,
+    IN      WORD                    Address
+    )
+{
+    EERD_REGISTER reg;
+
+    ASSERT( NULL != EthRegs );
+
+    reg.Raw = 0;
+    reg.Address = Address;
+    reg.Start = 1;
+
+    EthRegs->EepromReadRegister = reg.Raw;
+
+    reg.Raw = EthRegs->EepromReadRegister;
+    ASSERT( !reg.Start && reg.Done );
+
+    return reg.Data;
+}
\ No newline at end of file
diff --git a/src_proiect/FAT32/FAT32.vcxproj b/src_proiect/FAT32/FAT32.vcxproj
new file mode 100644
index 0000000..c6f642e
--- /dev/null
+++ b/src_proiect/FAT32/FAT32.vcxproj
@@ -0,0 +1,149 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>FAT32</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\fat32_base.h" />
+    <ClInclude Include="headers\fat_structures.h" />
+    <ClInclude Include="headers\fat_utils.h" />
+    <ClInclude Include="headers\fat_operations.h" />
+    <ClInclude Include="inc\fat32.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\fat32.c" />
+    <ClCompile Include="src\fat_utils.c" />
+    <ClCompile Include="src\fat_operations.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/FAT32/FAT32.vcxproj.filters b/src_proiect/FAT32/FAT32.vcxproj.filters
new file mode 100644
index 0000000..e9dc3e5
--- /dev/null
+++ b/src_proiect/FAT32/FAT32.vcxproj.filters
@@ -0,0 +1,48 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{f735dabe-8a20-4d41-a2c8-979f8b3b714a}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\fat32.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\fat_utils.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\fat_operations.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\fat32.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\fat32_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\fat_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\fat_utils.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\fat_operations.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/FAT32/headers/fat32_base.h b/src_proiect/FAT32/headers/fat32_base.h
new file mode 100644
index 0000000..dc9c5b0
--- /dev/null
+++ b/src_proiect/FAT32/headers/fat32_base.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#include "common_lib.h"
+#include "io.h"
+#include "log.h"
+#include "fat_structures.h"
+#include "ex.h"
\ No newline at end of file
diff --git a/src_proiect/FAT32/headers/fat_operations.h b/src_proiect/FAT32/headers/fat_operations.h
new file mode 100644
index 0000000..7d8ca20
--- /dev/null
+++ b/src_proiect/FAT32/headers/fat_operations.h
@@ -0,0 +1,103 @@
+#pragma once
+
+// Structure containing information about the
+// FAT32 partition
+typedef struct _FAT_DATA
+{
+    PDEVICE_OBJECT      VolumeDevice;
+
+    DWORD               CountOfClusters;            // = DataSectors / SectorsPerCluster
+
+    QWORD               RootDirectoryStartSector;   // Sector where root directory starts
+
+    DWORD               ReservedSectors;            // Number of reserved sectors
+
+    DWORD               FirstDataSector;            // First Sector where the Data Region starts
+    DWORD               SectorsPerCluster;          // Number of sectors / cluster
+
+    DWORD               BytesPerSector;             // Number of bytes / sector
+    DWORD               EntriesPerSector;           // Directory entries / sector
+
+    DWORD               AllocationSize;
+} FAT_DATA, *PFAT_DATA;
+
+ typedef
+STATUS
+(__cdecl FUNC_FatReadWriteFile)(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       BaseFileSector,
+    IN      QWORD       SectorOffset,
+    IN      QWORD       DirEntrySector,
+    IN      PVOID       Buffer,
+    IN      QWORD       SectorsToReadOrWrite,
+    OUT     QWORD*      SectorsReadOrWritten,
+    IN      BOOLEAN     Asynchronous
+    );
+
+typedef FUNC_FatReadWriteFile *PFUNC_FatReadWriteFile;
+
+STATUS
+FatInitVolume(
+    INOUT          PFAT_DATA           FatData
+    );
+
+STATUS
+FatSearch(
+    IN      PFAT_DATA               FatData,
+    IN_Z    char*                   Name,
+    OUT     QWORD*                  DirectorySector,
+    IN      BYTE                    SearchType,
+    OUT_OPT PFILE_INFORMATION       FileInformation,
+    OUT     QWORD*                  ParentSector
+    );
+
+STATUS
+FatSearchDirectoryEntry(
+    IN      PFAT_DATA               FatData,
+    IN      QWORD                   SectorToSearch,
+    IN_Z    char*                   Name,
+    IN      BYTE                    SearchType,
+    OUT     QWORD*                  SearchResult,
+    OUT_OPT PFILE_INFORMATION       FileInformation,
+    OUT     QWORD*                  ParentSector
+    );
+
+STATUS
+FatReadFile(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       BaseFileSector,
+    IN      QWORD       SectorOffset,
+    IN      QWORD       DirEntrySector,
+    IN      PVOID       Buffer,
+    IN      QWORD       SectorsToRead,
+    OUT     QWORD*      SectorsRead,
+    IN      BOOLEAN     Asynchronous
+    );
+
+STATUS
+FatWriteFile(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       BaseFileSector,
+    IN      QWORD       SectorOffset,
+    IN      QWORD       DirEntrySector,
+    IN      PVOID       Buffer,
+    IN      QWORD       SectorsToWrite,
+    OUT     QWORD*      SectorsWritten,
+    IN      BOOLEAN     Asynchronous
+);
+
+STATUS
+FatCreateDirectoryEntry(
+    IN      PFAT_DATA       FatData,
+    IN_Z    char*           Name,
+    IN      BYTE            FileAttributes
+    );
+
+STATUS
+FatQueryDirectory(
+    IN                                              PFAT_DATA                       FatData,
+    IN                                              QWORD                           DirectorySector,
+    IN                                              DWORD                           DirectoryInformationSize,
+    OUT_WRITES_BYTES(DirectoryInformationSize)      FILE_DIRECTORY_INFORMATION      *DirectoryInformation,
+    OUT                                             DWORD*                          RequiredDirectionInformationSize
+    );
\ No newline at end of file
diff --git a/src_proiect/FAT32/headers/fat_structures.h b/src_proiect/FAT32/headers/fat_structures.h
new file mode 100644
index 0000000..10342bc
--- /dev/null
+++ b/src_proiect/FAT32/headers/fat_structures.h
@@ -0,0 +1,252 @@
+#pragma once
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                                    DEFINES                                    /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+// FAT Directory Entry Attributes
+#define        ATTR_NORMAL                  0x00
+#define        ATTR_READ_ONLY               0x01
+#define        ATTR_HIDDEN                  0x02
+#define        ATTR_SYSTEM                  0x04
+#define        ATTR_VOLUME_ID               0x08
+#define        ATTR_DIRECTORY               0x10
+#define        ATTR_ARCHIVE                 0x20
+
+#define        ATTR_LONG_NAME               (ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID)
+#define        ATTR_LONG_NAME_MASK          (ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID|ATTR_DIRECTORY|ATTR_ARCHIVE)
+
+// Short Directory entry name length
+#define        SHORT_NAME_NAME              8
+#define        SHORT_NAME_EXT               3
+#define        SHORT_NAME_CHARS             11
+
+// Long Directory Entries char lengths
+#define        LONG_NAME1_CHARS             5
+#define        LONG_NAME2_CHARS             6
+#define        LONG_NAME3_CHARS             2
+#define        LONG_NAME_TOTAL_CHARS        (LONG_NAME1_CHARS+LONG_NAME2_CHARS+LONG_NAME3_CHARS)
+
+#define        LONG_NAME_MAX_CHARS          255
+
+#define        MAX_SECTORS_FOR_LONG_ENTRY    3
+
+// Values in DIR_Name[0] to check to see if entry
+// is a valid directory entry
+#define        FREE_ENTRY                   0xE5
+#define        FREE_ALL                     0x00
+#define        FREE_JAP_ENTRY               0x05
+
+#define        LONG_NAME_ORD_END_MASK       0x40
+
+// FAT Date format values
+#define        FAT_DAY_BITS                 5
+#define        FAT_MONTH_BITS               4
+#define        FAT_YEAR_BITS                7
+
+#define        FAT_DAY_RANGE_MIN            1
+#define        FAT_DAY_RANGE_MAX            31
+
+#define        FAT_MONTH_RANGE_MIN          1
+#define        FAT_MONTH_RANGE_MAX          12
+
+#define        FAT_START_YEAR               1980
+
+// FAT Time format values
+#define        FAT_SECOND_BITS              5
+#define        FAT_MINUTE_BITS              6
+#define        FAT_HOUR_BITS                5
+
+#define        FAT_SECOND_RANGE_MIN         0
+#define        FAT_SECOND_RANGE_MAX         29
+
+#define        FAT_MINUTE_RANGE_MIN         0
+#define        FAT_MINUTE_RANGE_MAX         59
+
+#define        FAT_HOUR_RANGE_MIN           0
+#define        FAT_HOUR_RANGE_MAX           23
+
+// Path delimiter
+#define        FAT_DELIMITER                '\\'
+
+// Refers to dot and dotdot entries
+#define        FAT_DIR_NO_DEFAULT_ENTRIES   2
+
+// Refers to the index in the DIR_ENTRY array
+// of the dot and dotdot entries
+#define        DOT_ENTRY_INDEX              0
+#define        DOT_DOT_ENTRY_INDEX          1
+
+// Dot and dotdot entries
+#define        DOT_ENTRY_NAME               ".          "
+#define        DOT_DOT_ENTRY_NAME           "..         "
+
+// Mask to apply when reading cluster values
+#define        FAT32_CLUSTER_MASK           0x0FFFFFFF
+
+// End of clusterchain mark
+#define        FAT32_EOC_MARK               0x0FFFFFFF
+
+// Bad cluster value
+#define        FAT32_BAD_CLUSTER            0x0FFFFFF7
+
+// Checks if cluster number marks the end of the cluster chain
+#define        FAT32_EOC(cluster)           ((cluster) > FAT32_BAD_CLUSTER)
+
+#define        FAT32_UNKNOWN                0xFFFFFFFF
+
+// Maximum number of clusters per FAT type
+#define        FAT12_MAX_CLUSTERS           4085
+#define        FAT16_MAX_CLUSTERS           65525
+
+//typedef     WORD    FAT16_ENTRY;
+typedef     DWORD   FAT32_ENTRY;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                                    STRUCTURES                                 /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+// Directory entry structure
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+//warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+typedef struct _FATDATE
+{
+    // 1 -> 31
+    WORD        Day     : 5;
+    WORD        Month   : 4;
+
+    // this value must be incremented
+    // by 1980
+    WORD        Year    : 7;
+} FATDATE, *PFATDATE;
+STATIC_ASSERT(sizeof(FATDATE) == sizeof(WORD));
+
+typedef struct _FATTIME
+{
+    // Multiply by 2 to get second count
+    WORD        Second  : 5;
+    WORD        Minute  : 6;
+    WORD        Hour    : 5;
+} FATTIME, *PFATTIME;
+STATIC_ASSERT(sizeof(FATTIME) == sizeof(WORD));
+#pragma warning(pop)
+
+typedef struct _DIR_ENTRY
+{
+    BYTE            DIR_Name[11];       // 0x0  Name
+    BYTE            DIR_Attr;           // 0xB  Attributes
+    BYTE            DIR_NTRes;          // 0xC  Reserved
+
+    // Creation Time and Date
+    BYTE            DIR_CrtTimeTenth;   // 0xD
+    FATTIME         DIR_CrtTime;        // 0xE
+    FATDATE         DIR_CrtDate;        // 0x10
+
+    // Last Access Date
+    FATDATE         DIR_LstAccDate;     // 0x12
+
+    // Directory Entry Cluster High
+    WORD            DIR_FstClusHI;      // 0x14
+
+    // Write Time and Date
+    FATTIME         DIR_WrtTime;        // 0x16
+    FATDATE         DIR_WrtDate;        // 0x18
+
+    // Directory Entry Cluster Low
+    WORD            DIR_FstClusLO;      // 0x1A
+
+    // File Size( 0 for directories )
+    DWORD           DIR_FileSize;       // 0x1C
+} DIR_ENTRY, *PDIR_ENTRY;
+
+
+// Long directory entry structure
+typedef struct _LONG_DIR_ENTRY
+{
+    // If Handled properly indicates the index of this entry in a long entry list
+    BYTE            LDIR_Ord;
+
+    // Characters 1-5 of name
+    BYTE            LDIR_Name1[10];
+
+    // File attributes
+    BYTE            LDIR_Attr;
+
+    BYTE            LDIR_Type;
+    BYTE            LDIR_Chksum;
+
+    // Characters 6-11 of name
+    BYTE            LDIR_Name2[12];
+    WORD            LDIR_FstClusLO;     // Must be 0 ( ZERO )
+
+                                        // Characters 12-13 of name
+    BYTE            LDIR_Name3[4];
+} LONG_DIR_ENTRY, *PLONG_DIR_ENTRY;
+
+// Found in sector 1 of the partition
+typedef struct _FSINFO
+{
+    DWORD           FSI_LeadSig;
+    BYTE            FSI_Reserved1[480];
+    DWORD           FSI_StrucSig;
+    DWORD           FSI_Free_Count;      // number of free clusters remaining
+    DWORD           FSI_Nxt_Free;        // next free cluster
+    BYTE            FSI_Reserved2[12];
+    DWORD           FSI_TrailSig;
+} FSINFO, *PFSINFO;
+
+// Found in sector 0 of the partition
+typedef struct _FAT_BPB
+{
+    BYTE            BS_jmpBoot[3];      // jump instruction
+    char            BS_OEMName[8];
+    WORD            BPB_BytsPerSec;     // bytes per sector
+    BYTE            BPB_SecPerClus;     // number of sectors / cluster
+    WORD            BPB_RsvdSecCnt;     // number of reserved sectors
+    BYTE            BPB_NumFATs;        // number of FATS
+    WORD            BPB_RootEntCnt;     // 0 for FAT32
+    WORD            BPB_TotSec16;       // 0 for FAT32
+    BYTE            BPB_Media;
+    WORD            BPB_FATSz16;        // 0 for FAT32
+    WORD            BPB_SecPerTrk;
+    WORD            BPB_NumHeads;
+    DWORD           BPB_HiddSec;
+    DWORD           BPB_TotSec32;       // Number of sectors on volume
+    union {
+        struct
+        {
+            BYTE    BS_DrvNum;
+            BYTE    BS_Reserved1;
+            BYTE    BS_BootSig;
+            DWORD   BS_VolID;
+            BYTE    BS_VolLab[11];
+            BYTE    BS_FilSysType[8];
+        } FAT12_16_BPB;
+
+        struct
+        {
+            DWORD   BPB_FATSz32;        // Number of Sectors occupied by a FAT32
+            WORD    BPB_ExtFlags;
+            WORD    BPB_FSVer;
+            DWORD   BPB_RootClus;
+            WORD    BPB_FSInfo;
+            WORD    BPB_BkBootSec;
+            BYTE    BPB_Reserved[12];
+            BYTE    BS_DrvNum;
+            BYTE    BS_Reserved1;
+            BYTE    BS_BootSig;
+            DWORD   BS_VolID;
+            BYTE    BS_VolLab[11];
+            BYTE    BS_FilSysType[8];   // should be set to "FAT32   " else it's bad :(
+        } FAT32_BPB;
+    } DiffOffset;
+    BYTE            Reserved[420];
+    WORD            Signature;
+} FAT_BPB, *PFAT_BPB;
+STATIC_ASSERT(sizeof(FAT_BPB) == SECTOR_SIZE);
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src_proiect/FAT32/headers/fat_utils.h b/src_proiect/FAT32/headers/fat_utils.h
new file mode 100644
index 0000000..11786d2
--- /dev/null
+++ b/src_proiect/FAT32/headers/fat_utils.h
@@ -0,0 +1,76 @@
+#pragma once
+
+STATUS
+NextSectorInClusterChain(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           CurrentSector,
+    OUT     QWORD*          NextSector,
+    IN      BOOLEAN         ExtendChain
+);
+
+STATUS
+NextClusterInChain(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           CurrentCluster,
+    OUT     QWORD*          Result
+);
+
+STATUS
+FirstSectorOfCluster(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       Cluster,
+    OUT     QWORD*      Result
+);
+
+STATUS
+ClusterOfSector(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       Sector,
+    OUT     QWORD*      Result
+);
+
+STATUS
+GetDirEntryFromSector(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       EntrySector,
+    IN      QWORD       DirFirstSector, // search criterion
+    OUT     QWORD*      EntryIndex,
+    OUT     DIR_ENTRY*  DirEntry
+);
+
+STATUS
+WriteDirEntryToSector(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       EntrySector,
+    IN      QWORD       EntryIndex,
+    IN      DIR_ENTRY*  DirEntry
+);
+
+STATUS
+ConvertFatDateTimeToDateTime(
+    IN      FATDATE*    FatDate,
+    IN      FATTIME*    FatTime,
+    OUT     DATETIME*   DateTime
+);
+
+void
+ConvertDateTimeToFatDateTime(
+    IN      PDATETIME   DateTime,
+    OUT     FATDATE*    FatDate,
+    OUT     FATTIME*    FatTime
+);
+
+STATUS
+ConvertFatNameToName(
+    IN_READS(SHORT_NAME_CHARS)      char*       FatName,
+    IN                              DWORD       BufferSize,
+    OUT_WRITES(BufferSize)          char*       Buffer,
+    OUT                             DWORD*      ActualNameLength
+);
+
+STATUS
+WritePartialLongFatNameToName(
+    IN                          LONG_DIR_ENTRY* LongDirEntry,
+    IN                          DWORD           BufferSize,
+    INOUT_UPDATES(BufferSize)   char*           Buffer
+);
diff --git a/src_proiect/FAT32/inc/fat32.h b/src_proiect/FAT32/inc/fat32.h
new file mode 100644
index 0000000..879f68f
--- /dev/null
+++ b/src_proiect/FAT32/inc/fat32.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry        FatDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/FAT32/src/fat32.c b/src_proiect/FAT32/src/fat32.c
new file mode 100644
index 0000000..79370f4
--- /dev/null
+++ b/src_proiect/FAT32/src/fat32.c
@@ -0,0 +1,519 @@
+#include "fat32_base.h"
+#include "fat32.h"
+#include "fat_operations.h"
+
+FUNC_DriverDispatch     _FatDispatchCreate;
+FUNC_DriverDispatch     _FatDispatchClose;
+FUNC_DriverDispatch     _FatDispatchReadWrite;
+FUNC_DriverDispatch     _FatDispatchQueryInformation;
+FUNC_DriverDispatch     _FatDispatchDirectoryControl;
+
+typedef struct _FCB
+{
+    // the offset in the volume, in sectors
+    QWORD               FileOffsetInVolume;
+
+    QWORD               ParentOffsetInVolume;
+
+    FILE_INFORMATION    FileInformation;
+} FCB, *PFCB;
+
+STATUS
+(__cdecl FatDriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    )
+{
+    STATUS status;
+    PDEVICE_OBJECT* pVolumeDevices;
+    PDEVICE_OBJECT pCurVolume;
+    PARTITION_INFORMATION partitionInformation;
+    DWORD i;
+    DWORD numberOfDevices;
+    PIRP pIrp;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PFAT_DATA pFatData;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DriverObject);
+
+    status = STATUS_SUCCESS;
+    pVolumeDevices = NULL;
+    pCurVolume = NULL;
+    numberOfDevices = 0;
+    pIrp = NULL;
+    pFileSystemDevice = NULL;
+    pFatData = NULL;
+
+    DriverObject->DispatchFunctions[IRP_MJ_CREATE] = _FatDispatchCreate;
+    DriverObject->DispatchFunctions[IRP_MJ_CLOSE] = _FatDispatchClose;
+    DriverObject->DispatchFunctions[IRP_MJ_READ] = _FatDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_WRITE] = _FatDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_QUERY_INFORMATION] = _FatDispatchQueryInformation;
+    DriverObject->DispatchFunctions[IRP_MJ_DIRECTORY_CONTROL] = _FatDispatchDirectoryControl;
+
+    status = IoGetDevicesByType(DeviceTypeVolume, &pVolumeDevices, &numberOfDevices);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetDeviceByType", status);
+        return status;
+    }
+
+    __try
+    {
+        for (i = 0; i < numberOfDevices; ++i)
+        {
+            pCurVolume = pVolumeDevices[i];
+
+            if (NULL != pFileSystemDevice)
+            {
+                IoDeleteDevice(pFileSystemDevice);
+                pFileSystemDevice = NULL;
+            }
+
+            memzero(&partitionInformation, sizeof(PARTITION_INFORMATION));
+
+            if (NULL != pIrp)
+            {
+                IoFreeIrp(pIrp);
+                pIrp = NULL;
+            }
+
+            // send an IOCTL to see device description
+            pIrp = IoBuildDeviceIoControlRequest(IOCTL_VOLUME_PARTITION_INFO,
+                pCurVolume,
+                NULL,
+                0,
+                &partitionInformation,
+                sizeof(PARTITION_INFORMATION)
+            );
+            if (NULL == pIrp)
+            {
+                LOG_ERROR("IoBuildDeviceIoControlRequest failed\n");
+                continue;
+            }
+
+            status = IoCallDriver(pCurVolume, pIrp);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoCallDriver", status);
+                continue;
+            }
+
+            if (!SUCCEEDED(pIrp->IoStatus.Status))
+            {
+                LOG_FUNC_ERROR("IoCallDriver", pIrp->IoStatus.Status);
+                continue;
+            }
+
+            LOG_TRACE_FILESYSTEM("Succesfully called device with IOCTL IOCTL_VOLUME_PARTITION_INFO\n");
+
+            if (PARTITION_TYPE_FAT_CHS != partitionInformation.PartitionType &&
+                PARTITION_TYPE_FAT_LBA != partitionInformation.PartitionType
+                )
+            {
+                LOG_WARNING("Partition type 0x%x not supported\n", partitionInformation.PartitionType);
+                continue;
+            }
+
+            LOG_TRACE_FILESYSTEM("Found supported partition type: 0x%x\n", partitionInformation.PartitionType);
+
+            pFileSystemDevice = IoCreateDevice(DriverObject, sizeof(FAT_DATA), DeviceTypeFilesystem);
+            if (NULL == pFileSystemDevice)
+            {
+                LOG_FUNC_ERROR_ALLOC("IoCreateDevice", sizeof(FAT_DATA));
+                status = STATUS_DEVICE_COULD_NOT_BE_CREATED;
+                __leave;
+            }
+
+            pFileSystemDevice->DeviceAlignment = pCurVolume->DeviceAlignment;
+
+            pFatData = IoGetDeviceExtension(pFileSystemDevice);
+            ASSERT(NULL != pFatData);
+
+            pFatData->VolumeDevice = pCurVolume;
+
+            status = FatInitVolume(pFatData);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("FatInitVolume", status);
+                continue;
+            }
+
+            LOG_TRACE_FILESYSTEM("FatInitVolume succeeded\n");
+
+            // attach to volume
+            IoAttachDevice(pFileSystemDevice, pCurVolume);
+
+            pCurVolume->Vpb->FilesystemDevice = pFileSystemDevice;
+            pCurVolume->Vpb->Flags.Mounted = TRUE;
+            pFileSystemDevice->Vpb = pCurVolume->Vpb;
+
+            pFileSystemDevice = NULL;
+            pFatData = NULL;
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        if (NULL != pVolumeDevices)
+        {
+            IoFreeTemporaryData(pVolumeDevices);
+            pVolumeDevices = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+(__cdecl _FatDispatchCreate)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PFAT_DATA pFatData;
+    QWORD fileSector;
+    BYTE fileType;
+    FILE_INFORMATION fileInformation;
+    BOOLEAN createOperation;
+    PFCB pFcb;
+    QWORD parentSector;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    fileSector = 0;
+    pStackLocation = NULL;
+    pFatData = NULL;
+    fileType = 0;
+    memzero(&fileInformation, sizeof(FILE_INFORMATION));
+    createOperation = FALSE;
+    pFcb = NULL;
+    parentSector = 0;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_CREATE == pStackLocation->MajorFunction);
+
+    pFatData = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pFatData);
+
+    ASSERT(NULL == pStackLocation->FileObject->RelatedFileObject);
+
+    fileType = (TRUE == pStackLocation->FileObject->Flags.DirectoryFile) ? ATTR_DIRECTORY : ATTR_NORMAL;
+    createOperation = (BOOLEAN)pStackLocation->FileObject->Flags.Create;
+
+    __try
+    {
+        if (createOperation)
+        {
+            // we first create the file
+            status = FatCreateDirectoryEntry(pFatData, pStackLocation->FileObject->FileName, fileType);
+            if (!SUCCEEDED(status))
+            {
+                LOG_TRACE_FILESYSTEM("[ERROR]FatCreateDirectoryEntry with status 0x%x\n", status);
+                __leave;
+            }
+
+            LOG_TRACE_FILESYSTEM("FatCreateDirectoryEntry succeeded\n");
+        }
+
+        status = FatSearch(pFatData,
+            pStackLocation->FileObject->FileName,
+            &fileSector,
+            fileType,
+            &fileInformation,
+            &parentSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_TRACE_FILESYSTEM("[ERROR]FatSearch failed with status 0x%x\n", status);
+            __leave;
+        }
+
+        // create FCB
+        pFcb = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(FCB), HEAP_FS_TAG, 0);
+        if (NULL == pFcb)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(FCB));
+            __leave;
+        }
+
+        pFcb->FileOffsetInVolume = fileSector;
+        pFcb->ParentOffsetInVolume = parentSector;
+        memcpy(&pFcb->FileInformation, &fileInformation, sizeof(FILE_INFORMATION));
+
+        pStackLocation->FileObject->FileSize = fileInformation.FileSize;
+        pStackLocation->FileObject->FsContext2 = pFcb;
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = 0;
+
+        IoCompleteIrp(Irp);
+
+        LOG_FUNC_END;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _FatDispatchClose)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PFCB pFcb;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pFcb = NULL;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+
+    ASSERT(IRP_MJ_CLOSE == pStackLocation->MajorFunction);
+
+    ASSERT(NULL != pStackLocation->FileObject);
+    pFcb = pStackLocation->FileObject->FsContext2;
+
+    ASSERT(NULL != pFcb);
+
+    // as part of the close we need to free the FCB
+    ExFreePoolWithTag(pFcb, HEAP_FS_TAG);
+    pFcb = NULL;
+    pStackLocation->FileObject->FsContext2 = NULL;
+
+    Irp->IoStatus.Status = status;
+
+    IoCompleteIrp(Irp);
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _FatDispatchReadWrite)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PFAT_DATA pFatData;
+    PFCB pFcb;
+    QWORD sectorsReadOrWritten;
+
+    PFUNC_FatReadWriteFile FatReadWriteFunc;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+    pFatData = NULL;
+    pFcb = NULL;
+    sectorsReadOrWritten = 0;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_READ == pStackLocation->MajorFunction || IRP_MJ_WRITE == pStackLocation->MajorFunction);
+
+    pFatData = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pFatData);
+
+    pFcb = (PFCB)pStackLocation->FileObject->FsContext2;
+    ASSERT(NULL != pFcb);
+
+    ASSERT(MAX_DWORD >= pFcb->FileOffsetInVolume);
+    ASSERT(MAX_DWORD >= pStackLocation->Parameters.ReadWrite.Offset);
+    ASSERT(MAX_DWORD >= pStackLocation->Parameters.ReadWrite.Length);
+
+    LOG_TRACE_FILESYSTEM("pFcb->OffsetInVolume: 0x%X\n", pFcb->FileOffsetInVolume);
+
+    __try
+    {
+        if (IRP_MJ_READ == pStackLocation->MajorFunction)
+        {
+            FatReadWriteFunc = FatReadFile;
+        }
+        else
+        {
+            ASSERT(pStackLocation->MajorFunction == IRP_MJ_WRITE);
+            FatReadWriteFunc = FatWriteFile;
+        }
+
+        status = FatReadWriteFunc(
+            pFatData,
+            (DWORD)pFcb->FileOffsetInVolume,
+            (DWORD)(pStackLocation->Parameters.ReadWrite.Offset / pFatData->BytesPerSector),
+            pFcb->ParentOffsetInVolume,
+            Irp->Buffer,
+            (DWORD)(pStackLocation->Parameters.ReadWrite.Length / pFatData->BytesPerSector),
+            &sectorsReadOrWritten,
+            (BOOLEAN)Irp->Flags.Asynchronous
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("FatReadWriteFunc", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = sectorsReadOrWritten * pFatData->BytesPerSector;
+
+        IoCompleteIrp(Irp);
+
+        LOG_FUNC_END;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _FatDispatchQueryInformation)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PFCB pFcb;
+    DWORD information;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+    pFcb = NULL;
+    information = sizeof(FILE_INFORMATION);
+
+    __try
+    {
+        pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+        ASSERT(IRP_MJ_QUERY_INFORMATION == pStackLocation->MajorFunction);
+        ASSERT(IRP_MN_INFORMATION_FILE_INFORMATION == pStackLocation->MinorFunction);
+
+        if (pStackLocation->Parameters.QueryFile.Length < information)
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+            __leave;
+        }
+
+        ASSERT(NULL != pStackLocation->FileObject);
+
+        pFcb = (PFCB)pStackLocation->FileObject->FsContext2;
+        ASSERT(NULL != pFcb);
+
+        memcpy(Irp->Buffer, &pFcb->FileInformation, information);
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = information;
+
+        IoCompleteIrp(Irp);
+
+        LOG_FUNC_END;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _FatDispatchDirectoryControl)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PFCB pFcb;
+    DWORD information;
+    PFAT_DATA pFatData;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+    pFcb = NULL;
+    information = 0;
+    pFatData = NULL;
+
+    __try
+    {
+        pFatData = IoGetDeviceExtension(DeviceObject);
+        ASSERT(NULL != pFatData);
+
+        pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+
+        ASSERT(IRP_MJ_DIRECTORY_CONTROL == pStackLocation->MajorFunction);
+        ASSERT(IRP_MN_QUERY_DIRECTORY == pStackLocation->MinorFunction);
+
+        ASSERT(NULL != pStackLocation->FileObject);
+
+        if (!pStackLocation->FileObject->Flags.DirectoryFile)
+        {
+            // we need an actual directory to perform a directory query :)
+            status = STATUS_FILE_NOT_DIRECTORY;
+            __leave;
+        }
+
+        pFcb = (PFCB)pStackLocation->FileObject->FsContext2;
+
+        ASSERT(NULL != pFcb);
+
+        // status = FatQueryDirectory
+        status = FatQueryDirectory(pFatData,
+            pFcb->FileOffsetInVolume,
+            pStackLocation->Parameters.QueryDirectory.Length,
+            Irp->Buffer,
+            &information
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("FatQueryDirectory", status);
+            __leave;
+        }
+
+        if (information > pStackLocation->Parameters.QueryDirectory.Length)
+        {
+            // FatQueryDirectory doesn't return any error if the buffer is too small
+            status = STATUS_BUFFER_TOO_SMALL;
+        }
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = information;
+
+        IoCompleteIrp(Irp);
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/FAT32/src/fat_operations.c b/src_proiect/FAT32/src/fat_operations.c
new file mode 100644
index 0000000..e1dc124
--- /dev/null
+++ b/src_proiect/FAT32/src/fat_operations.c
@@ -0,0 +1,1458 @@
+#include "fat32_base.h"
+#include "fat_operations.h"
+#include "fat_utils.h"
+
+
+static
+void
+_FatPopulateFileInformationFromFatEntry(
+    IN      PFAT_DATA               FatData,
+    IN      PDIR_ENTRY              DirEntry,
+    OUT     PFILE_INFORMATION       FileInformation
+);
+
+STATUS
+FatInitVolume(
+    INOUT          PFAT_DATA           FatData
+)
+{
+    STATUS status;
+    FAT_BPB bpb;
+    PDEVICE_OBJECT pVolumeDevice;
+    QWORD bytesToRead;
+    DWORD fatSize;
+    DWORD totalSectors;
+    DWORD dataSectors;
+
+    ASSERT(NULL != FatData);
+
+    status = STATUS_SUCCESS;
+    pVolumeDevice = FatData->VolumeDevice;
+    bytesToRead = sizeof(FAT_BPB);
+    ASSERT(NULL != pVolumeDevice);
+
+    status = IoReadDevice(pVolumeDevice, &bpb, &bytesToRead, 0);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoReadDevice", status);
+        return status;
+    }
+
+    if (MBR_BOOT_SIGNATURE != ((WORD*)&bpb)[255])
+    {
+        LOG_ERROR("Invalid FAT Partition\n");
+        return STATUS_DISK_MBR_NOT_PRESENT;
+    }
+
+    // Display basic information about the FAT structure
+    LOG_TRACE_FILESYSTEM("OEM Name: %s\n", bpb.BS_OEMName);
+    LOG_TRACE_FILESYSTEM("Bytes per sector: 0x%X\n", bpb.BPB_BytsPerSec);
+    LOG_TRACE_FILESYSTEM("Sectors per cluster: 0x%X\n", bpb.BPB_SecPerClus);
+    LOG_TRACE_FILESYSTEM("Reserved sectors: 0x%X\n", bpb.BPB_RsvdSecCnt);
+    LOG_TRACE_FILESYSTEM("Number of FATs: 0x%X\n", bpb.BPB_NumFATs);
+
+    // We start determining the type of FAT it is
+    // FATSz = Size of a FAT
+    if (0 != bpb.BPB_FATSz16)
+    {
+        fatSize = bpb.BPB_FATSz16;
+    }
+    else
+    {
+        fatSize = bpb.DiffOffset.FAT32_BPB.BPB_FATSz32;
+    }
+
+    LOG_TRACE_FILESYSTEM("Fat Size: 0x%X\n", fatSize);
+
+    // TotalSectors
+    if (0 != bpb.BPB_TotSec16)
+    {
+        totalSectors = bpb.BPB_TotSec16;
+    }
+    else
+    {
+        totalSectors = bpb.BPB_TotSec32;
+    }
+
+    LOG_TRACE_FILESYSTEM("Total sectors: 0x%X\n", totalSectors);
+
+    // Data sectors
+    dataSectors = totalSectors - (bpb.BPB_RsvdSecCnt + (bpb.BPB_NumFATs * fatSize));
+    LOG_TRACE_FILESYSTEM("Data sectors: 0x%X\n", dataSectors);
+
+    // Number of clusters
+    FatData->CountOfClusters = dataSectors / bpb.BPB_SecPerClus;
+    LOG_TRACE_FILESYSTEM("Count of clusters: %d\n", FatData->CountOfClusters);
+
+    // Determining the type of FAT
+    if (FatData->CountOfClusters < FAT12_MAX_CLUSTERS)
+    {
+        LOG_TRACE_FILESYSTEM("Volume is FAT12\n");
+        LOG_TRACE_FILESYSTEM("We work only with FAT32\n");
+        return STATUS_DEVICE_FILESYSTEM_UNSUPPORTED;
+    }
+    else
+    {
+        if (FatData->CountOfClusters < FAT16_MAX_CLUSTERS)
+        {
+            LOG_TRACE_FILESYSTEM("Volume is FAT16\n");
+            LOG_TRACE_FILESYSTEM("We work only with FAT32\n");
+            return STATUS_DEVICE_FILESYSTEM_UNSUPPORTED;
+        }
+        else
+        {
+            LOG_TRACE_FILESYSTEM("Volume is FAT32\n");
+        }
+    }
+
+
+    // Sector in which data starts
+    FatData->FirstDataSector = bpb.BPB_RsvdSecCnt + (bpb.BPB_NumFATs * fatSize);
+
+    LOG_TRACE_FILESYSTEM("First data sector: 0x%X\n", FatData->FirstDataSector);
+    LOG_TRACE_FILESYSTEM("Root directory: 0x%X\n", bpb.DiffOffset.FAT32_BPB.BPB_RootClus);
+
+    // Number of sectors per cluster
+    FatData->SectorsPerCluster = bpb.BPB_SecPerClus;
+
+    // we set the value of the RootDirectoryStartSector
+    status = FirstSectorOfCluster(FatData, bpb.DiffOffset.FAT32_BPB.BPB_RootClus, &(FatData->RootDirectoryStartSector));
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_FirstSectorOfCluster", status);
+        return status;
+    }
+
+    // Number of FAT entries on a sector
+    FatData->EntriesPerSector = bpb.BPB_BytsPerSec / sizeof(DIR_ENTRY);
+
+    // Number of reserved sectors
+    FatData->ReservedSectors = bpb.BPB_RsvdSecCnt;
+
+    // Number of bytes per sector
+    FatData->BytesPerSector = bpb.BPB_BytsPerSec;
+
+    FatData->AllocationSize = FatData->SectorsPerCluster * FatData->BytesPerSector;
+    LOG_TRACE_FILESYSTEM("ALlocation size: %d\n", FatData->AllocationSize);
+
+    ASSERT_INFO(FatData->AllocationSize >= pVolumeDevice->DeviceAlignment,
+        "The FAT driver does not handle issues caused by greater device alignment needed by volume devices");
+
+    return status;
+}
+
+STATUS
+FatSearch(
+    IN      PFAT_DATA               FatData,
+    IN_Z    char*                   Name,
+    OUT     QWORD*                  DirectorySector,
+    IN      BYTE                    SearchType,
+    OUT_OPT PFILE_INFORMATION       FileInformation,
+    OUT     QWORD*                  ParentSector
+)
+{
+    // name of current entry to search ( name between backslashes )
+    char partialName[LONG_NAME_MAX_CHARS];
+
+    // current index of partial name in the full path name
+    DWORD startIndexInName;
+
+    char* partialNameEnd;
+    DWORD partialNameLength;
+
+    // set to 1 when we reach the last directory
+    BOOLEAN finishedParse;
+
+    QWORD tempResult;
+    QWORD currentSearchSector;
+
+    // until the last instance we're searching only for directories
+    BYTE currentSearchType;
+    STATUS status;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != Name);
+    ASSERT(NULL != DirectorySector);
+    ASSERT(NULL != ParentSector);
+
+    memzero(partialName, sizeof(partialName));
+    startIndexInName = 0;
+    partialNameEnd = NULL;
+    partialNameLength = 0;
+    finishedParse = FALSE;
+    tempResult = 0;
+    currentSearchSector = 0;
+    currentSearchType = ATTR_DIRECTORY;
+    status = STATUS_SUCCESS;
+
+    if (FAT_DELIMITER != Name[0])
+    {
+        // path must start with backslash
+        return STATUS_INVALID_FILE_NAME;
+    }
+
+    LOG_TRACE_FILESYSTEM("Will search for file [%s], search type: [%x]\n", Name, SearchType);
+
+    currentSearchSector = FatData->RootDirectoryStartSector;
+
+    if (1 == strlen(Name))
+    {
+        LOG_TRACE_FILESYSTEM("Search for root directory\n");
+
+        // we have the root directory
+        if (ATTR_DIRECTORY != (SearchType & ATTR_DIRECTORY))
+        {
+            return STATUS_FILE_TYPE_INVALID;
+        }
+
+        // we already checked that Name[0] is '\\'
+        *DirectorySector = currentSearchSector;
+        *ParentSector = 0;
+
+        if (NULL != FileInformation)
+        {
+            memzero(FileInformation, sizeof(FILE_INFORMATION));
+            FileInformation->FileAttributes = FILE_ATTRIBUTE_VOLUME;
+        }
+
+        return STATUS_SUCCESS;
+    }
+
+    startIndexInName++;
+
+    do
+    {
+        // we get a pointer to the first occurrence of a backslash after the
+        // last found backslash
+        partialNameEnd = (char*)strchr((Name + startIndexInName), FAT_DELIMITER);
+
+        if (Name + startIndexInName == partialNameEnd)
+        {
+            // if we didn't find an occurrence => we arrived to the last
+            // file
+            partialNameLength = strlen(Name) - startIndexInName;
+            currentSearchType = SearchType;
+            finishedParse = TRUE; // we finished the search
+        }
+        else
+        {
+            partialNameLength = (DWORD)(partialNameEnd - (Name + startIndexInName));
+        }
+
+        if (partialNameLength >= sizeof(partialName) || partialNameLength == 0)
+        {
+            LOG_TRACE_FILESYSTEM("[ERROR]Partial name length is %u\n", partialNameLength);
+            return STATUS_PATH_NOT_VALID;
+        }
+
+        // we copy the name to a new buffer so we can append a '\0' to it
+        // (done automatically by str(n)cpy
+        strncpy(partialName, (Name + startIndexInName), partialNameLength);
+        startIndexInName += partialNameLength + 1; // we update the index in the name buffer
+
+                                                   // We search for the partial name in the current directory sector
+        status = FatSearchDirectoryEntry(FatData, currentSearchSector, partialName, currentSearchType, &tempResult, FileInformation, ParentSector);
+        if (!SUCCEEDED(status))
+        {
+            // something bad happened
+            LOG_TRACE_FILESYSTEM("[ERROR]SearchDirectoryEntry failed with status 0x%x\n", status);
+            return status;
+        }
+
+        // we update the current directory sector
+        currentSearchSector = tempResult;
+
+    } while (!finishedParse);
+
+    *DirectorySector = currentSearchSector;
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+FatReadFile(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       BaseFileSector,
+    IN      QWORD       SectorOffset,
+    IN      QWORD       DirEntrySector,
+    IN      PVOID       Buffer,
+    IN      QWORD       SectorsToRead,
+    OUT     QWORD*      SectorsRead,
+    IN      BOOLEAN     Asynchronous
+)
+{
+    STATUS status;
+    QWORD currentSector;                // the sector in which the file is
+    QWORD nextSector;
+    QWORD sectorsRemaining;             // how much of the file we have parsed so far
+    QWORD sectorsToRead;
+    QWORD bytesToRead;
+    PBYTE pData;
+    QWORD sectorsTraversed;
+
+    DIR_ENTRY  dirEntry = { 0 };
+    QWORD dirEntryIndex = 0;
+    DATETIME currentDateTime = { 0 };
+    FATDATE fatDate = { 0 };
+    FATTIME fatTime = { 0 };
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != Buffer);
+
+    ASSERT(IsAddressAligned(BaseFileSector, FatData->SectorsPerCluster));
+
+    status = STATUS_SUCCESS;
+    currentSector = BaseFileSector;
+    nextSector = 0;
+    sectorsRemaining = SectorsToRead;
+    sectorsTraversed = 0;
+    sectorsToRead = 0;
+    bytesToRead = 0;
+    pData = (PBYTE)Buffer;
+
+    LOG_TRACE_FILESYSTEM("Base file sector: [0x%x]\n", BaseFileSector);
+    LOG_TRACE_FILESYSTEM("Sector offset: [0x%x]\n", SectorOffset);
+
+    if (0 == sectorsRemaining)
+    {
+        *SectorsRead = 0;
+        return STATUS_SUCCESS;
+    }
+
+    while (sectorsTraversed + FatData->SectorsPerCluster <= SectorOffset)
+    {
+        ASSERT(SectorOffset >= FatData->SectorsPerCluster);
+
+        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+            return status;
+        }
+
+        currentSector = nextSector;
+        sectorsTraversed = sectorsTraversed + FatData->SectorsPerCluster;
+    }
+    ASSERT(0 != currentSector);
+
+    // we modify current sector to sectorToReach because
+    // we do not need to read the whole cluster
+    currentSector = currentSector + (SectorOffset % FatData->SectorsPerCluster);
+
+    // it is possible that the first sector to read is in the middle of a cluster
+    sectorsToRead = min(sectorsRemaining, FatData->SectorsPerCluster - (SectorOffset % FatData->SectorsPerCluster));
+    bytesToRead = sectorsToRead * FatData->BytesPerSector;
+
+    for (;;)
+    {
+        LOG_TRACE_FILESYSTEM("Will read [0x%x] sectors starting from sector [0x%x]\n", sectorsToRead, currentSector);
+
+        status = IoReadDeviceEx(
+            FatData->VolumeDevice,
+            pData,
+            &bytesToRead,
+            currentSector * FatData->BytesPerSector,
+            Asynchronous
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDeviceEx", status);
+            return status;
+        }
+        ASSERT(bytesToRead == sectorsToRead * FatData->BytesPerSector);
+
+        pData = pData + bytesToRead;
+
+        sectorsRemaining = sectorsRemaining - sectorsToRead;
+
+        if (0 == sectorsRemaining)
+        {
+            break;
+        }
+
+        // find next sector
+        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+            return status;
+        }
+
+        if (0 == nextSector)
+        {
+            // reached EOC marker
+            break;
+        }
+
+        currentSector = nextSector;
+
+        sectorsToRead = min(FatData->SectorsPerCluster, sectorsRemaining);
+        bytesToRead = sectorsToRead * FatData->BytesPerSector;
+    }
+
+    status = GetDirEntryFromSector(FatData, DirEntrySector, BaseFileSector, &dirEntryIndex, &dirEntry);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("GetDirEntryFromSector", status);
+        return status;
+    }
+
+    currentDateTime = IoGetCurrentDateTime();
+
+    ConvertDateTimeToFatDateTime(&currentDateTime, &fatDate, &fatTime);
+
+    dirEntry.DIR_LstAccDate = fatDate;
+
+    status = WriteDirEntryToSector(FatData, DirEntrySector, dirEntryIndex, &dirEntry);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("WriteDirEntryToSector", status);
+        return status;
+    }
+
+    *SectorsRead = SectorsToRead - sectorsRemaining;
+
+    return status;
+}
+
+STATUS
+FatWriteFile(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       BaseFileSector,
+    IN      QWORD       SectorOffset,
+    IN      QWORD       DirEntrySector,
+    IN      PVOID       Buffer,
+    IN      QWORD       SectorsToWrite,
+    OUT     QWORD*      SectorsWritten,
+    IN      BOOLEAN     Asynchronous
+)
+{
+    STATUS status;
+    QWORD currentSector;                // the sector in which the file is
+    QWORD nextSector;
+    QWORD sectorsRemaining;             // how much of the file we have parsed so far
+    QWORD sectorsToWrite;
+    QWORD bytesToWrite;
+    PBYTE pData;
+    QWORD sectorsTraversed;
+    DIR_ENTRY  dirEntry = { 0 };
+    QWORD dirEntryIndex = 0;
+    DATETIME currentDateTime = { 0 };
+    FATDATE fatDate = { 0 };
+    FATTIME fatTime = { 0 };
+    DWORD nextByteToWrite = 0;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != Buffer);
+
+    ASSERT(IsAddressAligned(BaseFileSector, FatData->SectorsPerCluster));
+
+    status = STATUS_SUCCESS;
+    currentSector = BaseFileSector;
+    nextSector = 0;
+    sectorsRemaining = SectorsToWrite;
+    sectorsTraversed = 0;
+    sectorsToWrite = 0;
+    bytesToWrite = 0;
+    pData = (PBYTE)Buffer;
+
+    LOG_TRACE_FILESYSTEM("Base file sector: [0x%x]\n", BaseFileSector);
+    LOG_TRACE_FILESYSTEM("Sector offset: [0x%x]\n", SectorOffset);
+
+    if (0 == sectorsRemaining)
+    {
+        *SectorsWritten = 0;
+        return STATUS_SUCCESS;
+    }
+
+    while (sectorsTraversed + FatData->SectorsPerCluster <= SectorOffset)
+    {
+        ASSERT(SectorOffset >= FatData->SectorsPerCluster);
+
+        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, TRUE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+            return status;
+        }
+
+        currentSector = nextSector;
+        sectorsTraversed = sectorsTraversed + FatData->SectorsPerCluster;
+    }
+    ASSERT(0 != currentSector);
+
+    // we modify current sector to sectorToReach because
+    // we do not need to write to the whole cluster
+    currentSector = currentSector + (SectorOffset % FatData->SectorsPerCluster);
+
+    // it is possible that the first sector to write to is in the middle of a cluster
+    sectorsToWrite = min(sectorsRemaining, FatData->SectorsPerCluster - (SectorOffset % FatData->SectorsPerCluster));
+    bytesToWrite = sectorsToWrite * FatData->BytesPerSector;
+
+    for (;;)
+    {
+        LOG_TRACE_FILESYSTEM("Will write [0x%x] sectors starting from sector [0x%x]\n", sectorsToWrite, currentSector);
+
+        status = IoWriteDeviceEx(
+            FatData->VolumeDevice,
+            pData,
+            &bytesToWrite,
+            currentSector * FatData->BytesPerSector,
+            Asynchronous
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDeviceEx", status);
+            return status;
+        }
+        ASSERT(bytesToWrite == sectorsToWrite * FatData->BytesPerSector);
+
+        pData = pData + bytesToWrite;
+
+        sectorsRemaining = sectorsRemaining - sectorsToWrite;
+
+        if (0 == sectorsRemaining)
+        {
+            break;
+        }
+
+        // find next sector, extend chain if necessary
+        status = NextSectorInClusterChain(FatData, currentSector, &nextSector, TRUE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+            return status;
+        }
+
+        currentSector = nextSector;
+
+        sectorsToWrite = min(FatData->SectorsPerCluster, sectorsRemaining);
+        bytesToWrite = sectorsToWrite * FatData->BytesPerSector;
+    }
+
+    status = GetDirEntryFromSector(FatData, DirEntrySector, BaseFileSector, &dirEntryIndex, &dirEntry);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("GetDirEntryFromSector", status);
+        return status;
+    }
+
+    nextByteToWrite = (DWORD)(SectorOffset + SectorsToWrite) * FatData->BytesPerSector;
+
+    if (nextByteToWrite > dirEntry.DIR_FileSize)
+    {
+        dirEntry.DIR_FileSize = nextByteToWrite;
+    }
+
+    currentDateTime = IoGetCurrentDateTime();
+
+    ConvertDateTimeToFatDateTime(&currentDateTime, &fatDate, &fatTime);
+
+    dirEntry.DIR_LstAccDate = fatDate;
+    dirEntry.DIR_WrtDate = fatDate;
+    dirEntry.DIR_WrtTime = fatTime;
+
+    status = WriteDirEntryToSector(FatData, DirEntrySector, dirEntryIndex, &dirEntry);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("WriteDirEntryToSector", status);
+        return status;
+    }
+
+    *SectorsWritten = SectorsToWrite;
+
+    return status;
+}
+
+STATUS
+FatSearchDirectoryEntry(
+    IN      PFAT_DATA               FatData,
+    IN      QWORD                   SectorToSearch,
+    IN_Z    char*                   Name,
+    IN      BYTE                    SearchType,
+    OUT     QWORD*                  SearchResult,
+    OUT_OPT PFILE_INFORMATION       FileInformation,
+    OUT     QWORD*                  ParentSector
+)
+{
+    STATUS status;
+    LONG_DIR_ENTRY* pLongEntry;
+    DIR_ENTRY* pEntry;
+    QWORD sectorToParse;
+    int index;
+    QWORD bytesToRead;
+    char normalizedShortName[SHORT_NAME_MAX_LENGTH] = { 0 };
+    char normalizedLongName[LONG_NAME_MAX_CHARS + 1] = { 0 };
+    DWORD requiredLength;
+
+    LOG_FUNC_START;
+
+    // checking pointers
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != Name);
+    ASSERT(NULL != SearchResult);
+    ASSERT(NULL != ParentSector);
+
+    // don't need to check pointer FileSize because it's ok to be NULL if the user
+    // does not want any value to be returned => will be checked later when setting result
+    LOG_TRACE_FILESYSTEM("Will search for file [%s], search type: [%x]\n", Name, SearchType);
+
+    status = STATUS_SUCCESS;
+    pLongEntry = NULL;
+    pEntry = NULL;
+    sectorToParse = SectorToSearch;
+    index = 0;
+    bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
+    requiredLength = 0;
+
+    __try
+    {
+        do
+        {
+            if (0 == (index % (FatData->EntriesPerSector  * FatData->SectorsPerCluster)))
+            {
+                // we need to read the next SectorsPerCluster sectors because we finished
+                // searching the current cluster
+                if (NULL != pEntry)
+                {
+                    // if we have already read SectorsPerCluster sectors we can deallocate the memory
+                    // because we won't need it
+                    ExFreePoolWithTag(pEntry, HEAP_TEMP_TAG);
+                    pEntry = NULL;
+
+                    // we go to the next sector we need to parse
+                    status = NextSectorInClusterChain(FatData, sectorToParse, &sectorToParse, FALSE);
+                    if (!SUCCEEDED(status))
+                    {
+                        // something bad happened :(
+                        LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+                        __leave;
+                    }
+
+                    if (0 == sectorToParse)
+                    {
+                        // we have reached the EOC marker if the sector value is 0
+                        status = STATUS_FILE_NOT_FOUND;
+                        __leave;
+                    }
+                }
+
+                // we allocate space for the buffer where a cluster will be read
+                ASSERT(bytesToRead <= MAX_DWORD);
+                pEntry = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+                if (NULL == pEntry)
+                {
+                    // malloc failed
+                    LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+                    __leave;
+                }
+
+                status = IoReadDeviceEx(FatData->VolumeDevice,
+                    pEntry,
+                    &bytesToRead,
+                    sectorToParse * FatData->BytesPerSector,
+                    TRUE
+                );
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("IoReadDeviceEx", status);
+                    __leave;
+                }
+                ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+                index = 0;    // we reset the index
+            }
+
+            if ((FREE_ENTRY == pEntry[index].DIR_Name[0]) || (FREE_JAP_ENTRY == pEntry[index].DIR_Name[0]))
+            {
+                // this entry is empty
+                index++;        // we increment the current index and we
+                continue;        // continue to the next entry
+            }
+
+            pLongEntry = (LONG_DIR_ENTRY*)&(pEntry[index]);
+
+            if ((pLongEntry->LDIR_Attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
+            {
+                status = WritePartialLongFatNameToName(pLongEntry, LONG_NAME_MAX_CHARS + 1, normalizedLongName);
+                ASSERT(SUCCEEDED(status));
+
+                index++;
+                continue;
+            }
+
+            // short directory entry
+
+            LOG_TRACE_FILESYSTEM("[%d]: [%s][%x]\n", index, pEntry[index].DIR_Name, pEntry[index].DIR_Attr);
+
+            status = ConvertFatNameToName((char*)pEntry[index].DIR_Name, SHORT_NAME_MAX_LENGTH, normalizedShortName, &requiredLength);
+            ASSERT(SUCCEEDED(status));
+
+
+            LOG_TRACE_FILESYSTEM("Normalized long  name: [%s]\n", normalizedLongName);
+            LOG_TRACE_FILESYSTEM("Normalized short name: [%s]\n", normalizedShortName);
+
+            if (0 == stricmp(normalizedLongName, Name) ||
+                0 == stricmp(normalizedShortName, Name))
+            {
+                // we found what we were looking for
+                QWORD cluster;
+
+                // now we have to check if it's a corresponding directory entry
+                BYTE maskResult = pEntry[index].DIR_Attr & (ATTR_DIRECTORY | ATTR_VOLUME_ID);
+
+                if (maskResult != SearchType)
+                {
+                    LOG_WARNING("Found file, but with different attributes, Requested: [0x%x], Found: [0x%x]\n", SearchType, pEntry[index].DIR_Attr);
+                    status = STATUS_FILE_TYPE_INVALID;
+                    __leave;
+                }
+                *ParentSector = sectorToParse;
+
+                // we find the cluster to which the DIR_ENTRY belongs to
+                cluster = WORDS_TO_DWORD(pEntry[index].DIR_FstClusHI, pEntry[index].DIR_FstClusLO);
+
+                // we set the sector from the cluster value
+                status = FirstSectorOfCluster(FatData, cluster, SearchResult);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("FirstSectorOfCluster", status);
+                    __leave;
+                }
+
+                if (NULL != FileInformation)
+                {
+                    // if the user requested the file size we set it
+                    _FatPopulateFileInformationFromFatEntry(FatData, &pEntry[index], FileInformation);
+                }
+
+                // we go to clean even if success or failure
+                __leave;
+            }
+
+            // reset long name
+            // in case the next short directory entry does not have associated long name entries
+            // it must not use the long name from a previous entry
+            normalizedLongName[0] = '\0';
+
+            // we increment the index to search the next directory entry
+
+            index++;
+
+
+        } while (FREE_ALL != pEntry[index].DIR_Name[0]);
+
+
+        status = STATUS_FILE_NOT_FOUND;
+    }
+    __finally
+    {
+        if (NULL != pEntry)
+        {
+            ExFreePoolWithTag(pEntry, HEAP_TEMP_TAG);
+            pEntry = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+static
+void
+_FatPopulateFileInformationFromFatEntry(
+    IN      PFAT_DATA               FatData,
+    IN      PDIR_ENTRY              DirEntry,
+    OUT     PFILE_INFORMATION       FileInformation
+)
+{
+    STATUS status;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != DirEntry);
+    ASSERT(NULL != FileInformation);
+
+    FileInformation->FileSize = AlignAddressUpper(DirEntry->DIR_FileSize, FatData->VolumeDevice->DeviceAlignment);
+    if (IsBooleanFlagOn(DirEntry->DIR_Attr, ATTR_VOLUME_ID))
+    {
+        FileInformation->FileAttributes = FILE_ATTRIBUTE_VOLUME;
+    }
+    else if (IsBooleanFlagOn(DirEntry->DIR_Attr, ATTR_DIRECTORY))
+    {
+        FileInformation->FileAttributes = FILE_ATTRIBUTE_DIRECTORY;
+    }
+    else
+    {
+        FileInformation->FileAttributes = FILE_ATTRIBUTE_NORMAL;
+    }
+
+    LOG_TRACE_FILESYSTEM("Attributes: [0x%x]\n", DirEntry->DIR_Attr);
+
+    // the root entry has no creation or write datetime
+    if (FILE_ATTRIBUTE_VOLUME != FileInformation->FileAttributes)
+    {
+        status = ConvertFatDateTimeToDateTime(&DirEntry->DIR_CrtDate, &DirEntry->DIR_CrtTime, &FileInformation->CreationTime);
+        ASSERT(SUCCEEDED(status));
+
+        status = ConvertFatDateTimeToDateTime(&DirEntry->DIR_WrtDate, &DirEntry->DIR_WrtTime, &FileInformation->LastWriteTime);
+        ASSERT(SUCCEEDED(status));
+    }
+}
+
+STATUS
+FatCreateDirectoryEntry(
+    IN      PFAT_DATA       FatData,
+    IN_Z    char*           Name,
+    IN      BYTE            FileAttributes
+)
+{
+    char fullPath[MAX_PATH] = { 0 };
+    char newEntryName[SHORT_NAME_CHARS + 1];
+    char* pPathToBackSlash;
+    DWORD lastBackslashIndex = 0;
+    QWORD parentSector;
+    QWORD dummySector;
+    STATUS status = STATUS_SUCCESS;
+    QWORD tempCluster;
+    QWORD currentClusterInChain;
+    QWORD finalSector;
+    QWORD sectorAllocated;
+    DWORD index = 0;                // index of the DIR_ENTRY in the current cluster
+    DIR_ENTRY* pEntry = NULL;        // pointer to DIR_ENTRY vector
+    FSINFO* pFSinfo = NULL;            // pointer to FSInfo
+    BOOLEAN found;                    // found = 1 if we find free space in last cluster in chain
+    BYTE* pFAT = NULL;                // pointer to FAT
+    DATETIME crtDateTime;            // date time read from CMOS
+    FATTIME fatTime;                    // time converted for FAT representation
+    FATDATE fatDate;                    // date converted for FAT representation
+
+    QWORD fatEntrySector;            // used for calculating the sector to read for the FAT entry
+    DWORD fatEntryOffset;            // offset in the FAT sector read
+    QWORD parentDirEntrySector;
+    QWORD bytesToRead;
+
+    LOG_FUNC_START;
+    // Step 0. Check pointers
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != Name);
+
+    LOG_TRACE_FILESYSTEM("[ERROR]Will create file [%s]\n", Name);
+
+    memset(newEntryName, ' ', SHORT_NAME_CHARS);
+
+    // fullPath contains the path until the new directory entry
+    pPathToBackSlash = (char*)strrchr(Name, FAT_DELIMITER);
+    bytesToRead = 0;
+
+    if (Name == pPathToBackSlash && FAT_DELIMITER != Name[0])
+    {
+        // path is not specified correctly
+        LOG_TRACE_FILESYSTEM("'%c' not found in [%s]\n", FAT_DELIMITER, Name);
+        return STATUS_PATH_NOT_VALID;
+    }
+
+    lastBackslashIndex = (DWORD)(pPathToBackSlash - Name);
+
+    // in fullPath we copy the parent directory path
+    if (0 == lastBackslashIndex)
+    {
+        strcpy(fullPath, "\\"); // parent directory is root
+    }
+    else
+    {
+        strncpy(fullPath, Name, lastBackslashIndex);
+    }
+
+    // newEntryName contains only the name of the to be created entry
+    strcpy(newEntryName, (Name + lastBackslashIndex + 1));
+
+    LOG_TRACE_FILESYSTEM("Directory: [%s]\n", fullPath);
+    LOG_TRACE_FILESYSTEM("Filename: [%s]\n", newEntryName);
+
+    // we don't want a NULL terminated string
+    newEntryName[strlen(newEntryName)] = ' ';
+
+    // Step 1. Check if to be parent directory exists
+    status = FatSearch(FatData, fullPath, &parentSector, ATTR_DIRECTORY, NULL, &parentDirEntrySector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("FatSearch", status);
+        return status;
+    }
+
+    // Step 2. Check if there is already a file with the same name
+    status = FatSearch(FatData, Name, &dummySector, ATTR_NORMAL, NULL, &parentDirEntrySector);
+    if (SUCCEEDED(status) || (STATUS_FILE_TYPE_INVALID == status))
+    {
+        return STATUS_FILE_ALREADY_EXISTS;
+    }
+
+    // Step 3. Go to the EOC cluster of the parent directory entry
+    /// TODO check if there is enough space before the end cluster
+    // we find the cluster of the parent
+    status = ClusterOfSector(FatData, parentSector, &currentClusterInChain);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ClusterOfSector", status);
+        return status;
+    }
+
+    tempCluster = currentClusterInChain;
+
+    // this loop will place in currentClusterInChain the last cluster belonging
+    // to the parent directory
+    while (!FAT32_EOC(tempCluster))
+    {
+        currentClusterInChain = tempCluster;
+
+        status = NextClusterInChain(FatData, currentClusterInChain, &tempCluster);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NextClusterInChain", status);
+            return status;
+        }
+    }
+
+    // we found the sector of the last cluster of the parent
+    status = FirstSectorOfCluster(FatData, currentClusterInChain, &finalSector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("FirstSectorOfCluster", status);
+        return status;
+    }
+
+    // we allocate space for the last cluster
+    bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
+
+    pEntry = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+    if (NULL == pEntry)
+    {
+        status = STATUS_HEAP_NO_MORE_MEMORY;
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+        return status;
+    }
+
+    __try
+    {
+        status = IoReadDeviceEx(FatData->VolumeDevice,
+            pEntry,
+            &bytesToRead,
+            finalSector * FatData->BytesPerSector,
+            TRUE
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDeviceEx", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+        if (finalSector == FatData->FirstDataSector)
+        {
+            // root directory => skip first 2 entries
+            // (first 2 are reserved and we can't place anything there)
+            index = 2;
+        }
+
+        // Step 4. Is there space in the current cluster?
+        /// TODO check for enough space for long dir entries
+        found = FALSE;
+        while (index < (FatData->EntriesPerSector * FatData->SectorsPerCluster))
+        {
+            if ((FREE_ENTRY == pEntry[index].DIR_Name[0]) ||
+                (FREE_ALL == pEntry[index].DIR_Name[0]) ||
+                (FREE_JAP_ENTRY == pEntry[index].DIR_Name[0]))
+            {
+                // we found a place where we can place our new entry
+                found = TRUE;
+                break;
+            }
+            ++index;
+        }
+
+        // There is space => step 7
+        // Else => step 5
+
+        if (!found)
+        {
+            // this part needs to be done
+
+            // we need to add a new cluster to the link because we didn't find any
+            // empty space
+
+            // Step 5. Update link to new Cluster from FSI
+
+
+            // Step 6. Update FreeCount and NextFree info in FSI
+
+            // ATM returns a disk full error so as not to overwrite any previous entry
+            status = STATUS_DISK_FULL;
+            __leave;
+        }
+
+
+        // Step 7. Add new directory entry in current cluster
+
+        // we zero the memory
+        memset(&(pEntry[index]), 0, sizeof(DIR_ENTRY));
+
+        // we set the name of the new entry
+        // use memcpy because we don't want NULL terminator afterwards
+        memcpy((char*)pEntry[index].DIR_Name, newEntryName, SHORT_NAME_CHARS);
+
+        // we search for the cluster we can use to allocate for the new entry
+        if (NULL == pFSinfo)
+        {
+            bytesToRead = FatData->BytesPerSector;
+
+            ASSERT(bytesToRead <= MAX_DWORD);
+
+            pFSinfo = (FSINFO*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+            if (NULL == pFSinfo)
+            {
+                status = STATUS_HEAP_NO_MORE_MEMORY;
+                LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+                __leave;
+            }
+
+            status = IoReadDevice(FatData->VolumeDevice,
+                pFSinfo,
+                &bytesToRead,
+                1 * FatData->BytesPerSector
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoReadDevice", status);
+                __leave;
+            }
+            ASSERT(bytesToRead == FatData->BytesPerSector);
+        }
+
+        if (0 == pFSinfo->FSI_Free_Count)
+        {
+            // if there are no more free clusters we fail
+            status = STATUS_DISK_FULL;
+            __leave;
+        }
+        // HERE we should check the FSI_Free_Count for 0xFFFFFFFF and if so we should recompute the
+        // free count and recheck it for 0
+
+        // we set the directory cluster (should check against 0xFFFFFFFF) and if so we should
+        // start looking for clusters starting form cluster 2
+
+        // we set the cluster where the directory entry's data will be placed
+        pEntry[index].DIR_FstClusHI = DWORD_HIGH(pFSinfo->FSI_Nxt_Free);
+        pEntry[index].DIR_FstClusLO = DWORD_LOW(pFSinfo->FSI_Nxt_Free);
+
+        currentClusterInChain = pFSinfo->FSI_Nxt_Free;
+
+        // set the new file attributes
+        pEntry[index].DIR_Attr = FileAttributes;
+        pEntry[index].DIR_FileSize = 0; // redundant because of MemSet to 0
+
+        // get current date time
+        crtDateTime = IoGetCurrentDateTime();
+
+        // we convert the date read to a date which can be written to the
+        // DIR_ENTRY
+        ConvertDateTimeToFatDateTime(&crtDateTime, &fatDate, &fatTime);
+
+        // We set the creation, write and last access date's and time
+        // to the current time
+        pEntry[index].DIR_CrtDate = fatDate;
+        pEntry[index].DIR_WrtDate = fatDate;
+        pEntry[index].DIR_LstAccDate = fatDate;
+
+        pEntry[index].DIR_CrtTime = fatTime;
+        pEntry[index].DIR_WrtTime = fatTime;
+
+
+        // Step 9. Update FSI information FreeCount and NextFree
+
+        // decrement free count
+        pFSinfo->FSI_Free_Count--;
+
+        // update next free cluster(should check if cluster is actually free)
+        pFSinfo->FSI_Nxt_Free++;
+
+        // we write the changes made to pFSinfo and to the parent cluster of the new entry
+        bytesToRead = FatData->BytesPerSector;
+        status = IoWriteDevice(FatData->VolumeDevice,
+            pFSinfo,
+            &bytesToRead,
+            1 * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector);
+
+        bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
+        status = IoWriteDevice(FatData->VolumeDevice,
+            pEntry,
+            &bytesToRead,
+            finalSector * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+        // zero the memory where the new cluster was placed
+        ExFreePoolWithTag(pEntry, HEAP_TEMP_TAG);
+        pEntry = NULL;
+
+        // we allocate data for the new DIR_ENTRY
+        bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
+        pEntry = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+        if (NULL == pEntry)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+            __leave;
+        }
+
+        // malloc already zeroes memory so no need to do it
+
+        // Step 10. Is new entry a directory?
+        // It is not => step 12
+        if (ATTR_DIRECTORY == (FileAttributes & (ATTR_DIRECTORY | ATTR_VOLUME_ID)))
+        {
+            // If it is a directory => step 11
+
+            // Step 11. Create "." and ".." entries
+            int i;
+
+            // Set the name of the "." and ".." entries
+            memcpy((char*)pEntry[DOT_ENTRY_INDEX].DIR_Name, DOT_ENTRY_NAME, SHORT_NAME_CHARS);
+            memcpy((char*)pEntry[DOT_DOT_ENTRY_INDEX].DIR_Name, DOT_DOT_ENTRY_NAME, SHORT_NAME_CHARS);
+
+            // set their attributes and date and time
+            for (i = 0; i < FAT_DIR_NO_DEFAULT_ENTRIES; ++i)
+            {
+                pEntry[i].DIR_Attr = ATTR_DIRECTORY;
+                pEntry[i].DIR_CrtTime = pEntry[i].DIR_WrtTime = fatTime;
+                pEntry[i].DIR_CrtDate = pEntry[i].DIR_WrtDate = pEntry[i].DIR_LstAccDate = fatDate;
+            }
+
+
+            if (FatData->FirstDataSector == parentSector)
+            {
+                // => parent is root directory => we need to set the cluster value to 0
+                pEntry[DOT_DOT_ENTRY_INDEX].DIR_FstClusHI = pEntry[DOT_DOT_ENTRY_INDEX].DIR_FstClusLO = 0;
+            }
+            else
+            {
+                // if the parent is not root directory we need to set the actual cluster value
+                status = ClusterOfSector(FatData, parentSector, &tempCluster);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("ClusterOfSector", status);
+                    __leave;
+                }
+
+                // we set to the ".." entry a reference to it's parent
+                pEntry[DOT_DOT_ENTRY_INDEX].DIR_FstClusHI = DWORD_HIGH(tempCluster);
+                pEntry[DOT_DOT_ENTRY_INDEX].DIR_FstClusLO = DWORD_LOW(tempCluster);
+            }
+
+            // we set to the "." entry a reference to itself
+            pEntry[DOT_ENTRY_INDEX].DIR_FstClusHI = DWORD_HIGH(currentClusterInChain);
+            pEntry[DOT_ENTRY_INDEX].DIR_FstClusLO = DWORD_LOW(currentClusterInChain);
+        }
+
+        // we find the sector in which we added the new DIR_ENTRY contents
+        status = FirstSectorOfCluster(FatData, currentClusterInChain, &sectorAllocated);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("FirstSectorOfCluster", status);
+            __leave;
+        }
+
+        status = IoWriteDevice(FatData->VolumeDevice,
+            pEntry,
+            &bytesToRead,
+            sectorAllocated * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+        // Step 12. Add EOC for new cluster used
+
+        // we allocate space for the FAT
+        bytesToRead = FatData->BytesPerSector;
+        pFAT = (BYTE*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+        if (NULL == pFAT)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+            __leave;
+        }
+
+        // we find the sector and the offset of the FAT
+        fatEntrySector = FatData->ReservedSectors + (currentClusterInChain * sizeof(DWORD)) / FatData->BytesPerSector;
+        fatEntryOffset = (currentClusterInChain * sizeof(DWORD)) % FatData->BytesPerSector;
+
+
+        status = IoReadDevice(FatData->VolumeDevice,
+            pFAT,
+            &bytesToRead,
+            fatEntrySector * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector);
+
+
+        *((DWORD*)&(pFAT[fatEntryOffset])) = *((DWORD*)&(pFAT[fatEntryOffset])) & (~FAT32_CLUSTER_MASK);    // we need to preserve the 4 reserved bits
+        *((DWORD*)&(pFAT[fatEntryOffset])) = *((DWORD*)&(pFAT[fatEntryOffset])) | FAT32_EOC_MARK;            // we add the EOC mark
+
+
+        status = IoWriteDevice(FatData->VolumeDevice,
+            pFAT,
+            &bytesToRead,
+            fatEntrySector * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector);
+    }
+    __finally
+    {
+        if (NULL != pFAT)
+        {
+            ExFreePoolWithTag(pFAT, HEAP_TEMP_TAG);
+            pFAT = NULL;
+        }
+
+        if (NULL != pFSinfo)
+        {
+            ExFreePoolWithTag(pFSinfo, HEAP_TEMP_TAG);
+            pFSinfo = NULL;
+        }
+
+        if (NULL != pEntry)
+        {
+            ExFreePoolWithTag(pEntry, HEAP_TEMP_TAG);
+            pEntry = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+// warning C6101: Returning uninitialized memory '*DirectoryInformation'.  A successful path through the function does not set the named _Out_ parameter. 
+
+STATUS
+FatQueryDirectory(
+    IN                                              PFAT_DATA                       FatData,
+    IN                                              QWORD                           DirectorySector,
+    IN                                              DWORD                           DirectoryInformationSize,
+    OUT_WRITES_BYTES(DirectoryInformationSize)      FILE_DIRECTORY_INFORMATION      *DirectoryInformation,
+    OUT                                             DWORD*                          RequiredDirectionInformationSize
+)
+{
+    STATUS status;
+    LONG_DIR_ENTRY* pLongEntry;
+    DIR_ENTRY* pEntry;
+    int index;
+    QWORD sectorToParse;        // directory sector to parse
+    QWORD bytesToRead;
+    DWORD requiredSize;
+    PFILE_DIRECTORY_INFORMATION pCurEntry;
+    PFILE_DIRECTORY_INFORMATION pPrevEntry;
+
+    char longName[LONG_NAME_MAX_CHARS + 1] = { 0 };
+    DWORD longNameLength;
+    char shortName[SHORT_NAME_MAX_LENGTH] = { 0 };
+    DWORD shortNameLength;
+    DWORD curStructureSize;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != DirectoryInformation || 0 == DirectoryInformationSize);
+    ASSERT(NULL != RequiredDirectionInformationSize);
+
+    status = STATUS_SUCCESS;
+    pLongEntry = NULL;
+    pEntry = NULL;
+    index = 0;
+    sectorToParse = DirectorySector;
+    bytesToRead = 0;
+    requiredSize = 0;
+    pCurEntry = DirectoryInformation;
+    pPrevEntry = NULL;
+
+    longNameLength = 0;
+    shortNameLength = 0;
+
+    __try
+    {
+        do
+        {
+            if (0 == (index % (FatData->EntriesPerSector  * FatData->SectorsPerCluster)))
+            {
+                // we need to read from the next sector, we don't care about this one
+                // anymore
+                if (NULL != pEntry)
+                {
+                    ExFreePoolWithTag(pEntry, HEAP_TEMP_TAG);
+                    pEntry = NULL;
+
+                    // we go to the next sector by following the cluster chain
+                    status = NextSectorInClusterChain(FatData, sectorToParse, &sectorToParse, FALSE);
+                    if (!SUCCEEDED(status))
+                    {
+                        LOG_FUNC_ERROR("NextSectorInClusterChain", status);
+                        __leave;
+                    }
+
+                    if (0 == sectorToParse)
+                    {
+                        // we have reached the EOC marker => we finished parsing the directory
+                        __leave;
+                    }
+                }
+
+                // we allocate a buffer where to read the current cluster in the chain
+                bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
+                pEntry = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+                if (NULL == pEntry)
+                {
+                    // malloc failed
+                    status = STATUS_HEAP_NO_MORE_MEMORY;
+                    LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+                    __leave;
+                }
+
+                // we read the next cluster
+                status = IoReadDeviceEx(FatData->VolumeDevice,
+                    pEntry,
+                    &bytesToRead,
+                    sectorToParse * FatData->BytesPerSector,
+                    TRUE
+                );
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("IoReadDeviceEx", status);
+                    __leave;
+                }
+                ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+
+                // reseting the index in the DIR_ENTRY array
+                index = 0;
+            }
+
+
+            if ((FREE_ENTRY == pEntry[index].DIR_Name[0]) || (FREE_JAP_ENTRY == pEntry[index].DIR_Name[0]))
+            {
+                // this entry is empty
+                index++;        // we increment the current index and we
+                continue;        // continue to the next entry
+            }
+
+            pLongEntry = (LONG_DIR_ENTRY*)&(pEntry[index]);
+
+            if ((pLongEntry->LDIR_Attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
+            {
+                status = WritePartialLongFatNameToName(pLongEntry, LONG_NAME_MAX_CHARS + 1, longName);
+                ASSERT(SUCCEEDED(status));
+
+                index++;
+                continue;
+            }
+
+            // short directory entry
+
+            status = ConvertFatNameToName((char*)pEntry[index].DIR_Name, SHORT_NAME_MAX_LENGTH, shortName, &shortNameLength);
+            ASSERT(SUCCEEDED(status));
+
+            longNameLength = strlen_s(longName, LONG_NAME_MAX_CHARS);
+            if (0 == longNameLength)
+            {
+                longNameLength = shortNameLength;
+                strncpy(longName, shortName, shortNameLength);
+            }
+
+            curStructureSize = sizeof(FILE_DIRECTORY_INFORMATION) + longNameLength;
+
+            requiredSize = requiredSize + curStructureSize;
+
+            if (requiredSize <= DirectoryInformationSize)
+            {
+                if (NULL != pPrevEntry)
+                {
+                    // update previous entry offset
+                    pPrevEntry->NextEntryOffset = (DWORD)((PBYTE)pCurEntry - (PBYTE)pPrevEntry);
+                }
+
+                LOG_TRACE_FILESYSTEM("[%d]: [%s][%x]\n", index, pEntry[index].DIR_Name, pEntry[index].DIR_Attr);
+                LOG_TRACE_FILESYSTEM("File short name: [%s]\n", shortName);
+                LOG_TRACE_FILESYSTEM("File long  name: [%s]\n", longName);
+
+                // populate current entry
+
+                // we set offset to 0 because we don't know if there are any entries
+                // after us
+                pCurEntry->NextEntryOffset = 0;
+
+                _FatPopulateFileInformationFromFatEntry(FatData, &pEntry[index], &pCurEntry->BasicFileInformation);
+                memcpy(pCurEntry->ShortFilename, shortName, shortNameLength);
+
+                pCurEntry->FilenameLength = longNameLength;
+                memcpy(pCurEntry->Filename, longName, longNameLength);
+
+                // update previous and current entry
+                pPrevEntry = pCurEntry;
+                pCurEntry = (PFILE_DIRECTORY_INFORMATION)((PBYTE)pCurEntry + curStructureSize);
+            }
+
+            // reset long name
+            // in case the next short directory entry does not have associated long name entries
+            // it must not use the long name from a previous entry
+            longName[0] = '\0';
+
+
+            // we increase the index in the entry array
+            index++;
+
+        } while (FREE_ALL != pEntry[index].DIR_Name[0]);
+    }
+    __finally
+    {
+        if (NULL != pEntry)
+        {
+            ExFreePoolWithTag(pEntry, HEAP_TEMP_TAG);
+            pEntry = NULL;
+        }
+
+        *RequiredDirectionInformationSize = requiredSize;
+    }
+
+    return status;
+}
diff --git a/src_proiect/FAT32/src/fat_utils.c b/src_proiect/FAT32/src/fat_utils.c
new file mode 100644
index 0000000..edd97a8
--- /dev/null
+++ b/src_proiect/FAT32/src/fat_utils.c
@@ -0,0 +1,1003 @@
+#include "fat32_base.h"
+#include "fat_operations.h"
+#include "fat_utils.h"
+
+static
+STATUS
+_ConvertFatDateToDate(
+    IN      FATDATE*    FatDate,
+    OUT     DATE*       RealDate
+    );
+
+static
+STATUS
+_ConvertFatTimeToTime(
+    IN      FATTIME*    FatTime,
+    OUT     TIME*       RealTime
+    );
+
+static
+void
+_ConvertDateToFatDate(
+    IN      DATE*       RealDate,
+    OUT     FATDATE*    FatDate
+    );
+
+static
+void
+_ConvertTimeToFatTime(
+    IN      TIME*       RealTime,
+    OUT     FATTIME*    FatTime
+    );
+
+static
+STATUS
+_AddNewClusterToChain(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           LastClusterFromChain,
+    OUT     QWORD*          ReservedCluster
+);
+
+STATUS
+NextSectorInClusterChain(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           CurrentSector,
+    OUT     QWORD*          NextSector,
+    IN      BOOLEAN         ExtendChain
+    )
+{
+    STATUS status;
+    QWORD currentCluster;
+    QWORD nextCluster;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != NextSector);
+
+    status = STATUS_SUCCESS;
+    currentCluster = 0;
+    nextCluster = 0;
+
+    // we get the cluster of the current sector
+    status = ClusterOfSector(FatData, CurrentSector, &currentCluster);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ClusterOfSector", status);
+        return status;
+    }
+
+    // we get the cluster following the current one
+    status = NextClusterInChain(FatData, currentCluster, &nextCluster);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NextClusterInChain", status);
+        return status;
+    }
+
+    // we check if we reached the end of chain
+    if (FAT32_EOC(nextCluster))
+    {
+        if (!ExtendChain)
+        {
+        // arrived to the end of the cluster chain
+        *NextSector = 0;
+        return status;
+    }
+
+        status = _AddNewClusterToChain(FatData, currentCluster, &nextCluster);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("AddNewClusterToChain", status);
+            return status;
+        }
+    }
+
+    // we get the sector belonging to the found cluster
+    status = FirstSectorOfCluster(FatData, nextCluster, NextSector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("FirstSectorOfCluster", status);
+        return status;
+    }
+
+    return status;
+}
+
+STATUS
+NextClusterInChain(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           CurrentCluster,
+    OUT     QWORD*          NextCluster
+    )
+{
+    STATUS status;
+    FAT32_ENTRY* pFat32Entries;        // pointer to a FAT table
+    QWORD sectorNumber;
+    QWORD indexInSector;
+    QWORD bytesToReadWrite;
+    QWORD offset;
+    QWORD nextCluster;
+
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != NextCluster);
+
+    status = STATUS_UNSUCCESSFUL;
+    pFat32Entries = NULL;
+    nextCluster = 0;
+
+    sectorNumber = FatData->ReservedSectors + (CurrentCluster * (sizeof(FAT32_ENTRY)) / FatData->BytesPerSector);
+    indexInSector = CurrentCluster % (FatData->BytesPerSector / sizeof(FAT32_ENTRY));
+    bytesToReadWrite = FatData->BytesPerSector;
+    offset = sectorNumber * FatData->BytesPerSector;
+
+    __try
+    {
+        pFat32Entries = (FAT32_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0);
+    if (NULL == pFat32Entries)
+    {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+        // could not allocate memory for a FAT32 sector
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", FatData->BytesPerSector);
+            __leave;
+    }
+
+    // We read the sector
+        status = IoReadDevice(
+            FatData->VolumeDevice,
+                          pFat32Entries,
+            &bytesToReadWrite,
+                          offset
+                          );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoReadDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+
+        nextCluster = pFat32Entries[indexInSector] & FAT32_CLUSTER_MASK;
+
+        if (0 == nextCluster)
+        {
+            LOG_TRACE_FILESYSTEM("Found zero in cluster chain");
+            // has to be treated as EOC marker
+            nextCluster = FAT32_EOC_MARK;
+
+            // write EOC marker back to disk, such that the cluster is not treated as a free one
+            pFat32Entries[indexInSector] &= ~FAT32_CLUSTER_MASK;    // we need to preserve the 4 reserved bits
+            pFat32Entries[indexInSector] |= FAT32_EOC_MARK;            // we add the EOC mark
+
+            status = IoWriteDevice(
+                FatData->VolumeDevice,
+                pFat32Entries,
+                &bytesToReadWrite,
+                offset
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoWriteDevice", status);
+                __leave;
+            }
+            ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+        }
+        else if (FAT32_BAD_CLUSTER == nextCluster)
+        {
+            // maybe we should cut off the cluster chain, so it doesn't reach the bad cluster
+            nextCluster = FAT32_EOC_MARK;
+        }
+
+        status = STATUS_SUCCESS;
+    }
+    __finally
+    {
+        *NextCluster = nextCluster;
+
+        // We free the memory allocated
+        if (NULL != pFat32Entries)
+        {
+            ExFreePoolWithTag(pFat32Entries, HEAP_TEMP_TAG);
+            pFat32Entries = NULL;
+        }
+    }
+
+        return status;
+    }
+
+static
+STATUS
+_FirstFreeCluster(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           FirstCheckedCluster,
+    IN      BOOLEAN         MarkReserved,
+    OUT     QWORD*          FreeCluster
+)
+{
+    STATUS status = STATUS_UNSUCCESSFUL;
+    FAT32_ENTRY* pFat32Entries = NULL;        // pointer to a FAT table
+    QWORD firstCheckedCluster = FirstCheckedCluster;
+    QWORD entriesPerFat = 0;
+    QWORD sectorsPerFat = 0;
+    QWORD firstFatSector = 0;
+    QWORD currentSector = 0;
+    QWORD bytesToReadWrite = 0;
+    QWORD indexInSector = 0;
+    QWORD clusterIndex = 0;
+
+    __try
+    {
+        pFat32Entries = (FAT32_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0);
+        if (NULL == pFat32Entries)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            // could not allocate memory for a FAT32 sector
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", FatData->BytesPerSector);
+            __leave;
+        }
+
+        bytesToReadWrite = FatData->BytesPerSector; // read the FAT sector by sector
+
+        firstFatSector = FatData->ReservedSectors;
+        entriesPerFat = FatData->CountOfClusters + 2;
+        sectorsPerFat = entriesPerFat * sizeof(FAT32_ENTRY) / FatData->BytesPerSector;
+
+        // if search should begin after the last cluster
+        if (entriesPerFat <= firstCheckedCluster)
+        {
+            status = STATUS_SUCCESS;
+            __leave;
+        }
+
+        if (FAT32_UNKNOWN == firstCheckedCluster)
+        {
+            firstCheckedCluster = 2;
+        }
+
+        currentSector = firstFatSector + (firstCheckedCluster * sizeof(FAT32_ENTRY) / FatData->BytesPerSector);
+        indexInSector = firstCheckedCluster % (FatData->BytesPerSector / sizeof(FAT32_ENTRY));
+        // for each sector of the FAT
+        for (; currentSector < sectorsPerFat; currentSector++)
+        {
+            // We read the sector
+            status = IoReadDevice(
+                FatData->VolumeDevice,
+                pFat32Entries,
+                &bytesToReadWrite,
+                currentSector * FatData->BytesPerSector
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoReadDevice", status);
+                __leave;
+            }
+            ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+
+            // check all the entries in the current sector of the FAT
+            for (; indexInSector < FatData->BytesPerSector / sizeof(FAT32_ENTRY); indexInSector++)
+            {
+                if (0 == (pFat32Entries[indexInSector] & FAT32_CLUSTER_MASK)) // found free cluster
+                {
+                    if (MarkReserved)
+                    {
+                        // write EOC marker back to disk, such that the cluster is reserved
+                        pFat32Entries[indexInSector] &= ~FAT32_CLUSTER_MASK;    // we need to preserve the 4 reserved bits
+                        pFat32Entries[indexInSector] |= FAT32_EOC_MARK;         // we add the EOC mark
+
+                        status = IoWriteDevice(
+                            FatData->VolumeDevice,
+                            pFat32Entries,
+                            &bytesToReadWrite,
+                            currentSector * FatData->BytesPerSector
+                        );
+                        if (!SUCCEEDED(status))
+                        {
+                            LOG_FUNC_ERROR("IoWriteDevice", status);
+                            __leave;
+                        }
+                        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+                    }
+
+                    // clusterIndex = Index of sector inside FAT * Nr of FAT entryies per sector + FAT entry index in current sector
+                    clusterIndex = (currentSector - firstFatSector) * (FatData->BytesPerSector / sizeof(FAT32_ENTRY)) + indexInSector;
+
+                    ASSERT(2 <= clusterIndex && clusterIndex < entriesPerFat);
+                    ASSERT(FAT32_UNKNOWN != clusterIndex);
+
+                    currentSector = sectorsPerFat; // break outer for loop
+                    break;
+                }
+            }
+            // reset entry index
+            indexInSector = 0;
+        }
+    }
+    __finally
+    {
+        *FreeCluster = clusterIndex;
+
+    // We free the memory allocated
+        if (NULL != pFat32Entries)
+        {
+    ExFreePoolWithTag(pFat32Entries, HEAP_TEMP_TAG);
+            pFat32Entries = NULL;
+        }
+    }
+
+    return status;
+}
+
+static
+STATUS
+_AddNewClusterToChain(
+    IN      PFAT_DATA       FatData,
+    IN      QWORD           LastClusterFromChain,
+    OUT     QWORD*          ReservedCluster
+)
+{
+    ASSERT(FatData != NULL);
+    ASSERT(ReservedCluster != NULL);
+
+    ASSERT(!FAT32_EOC(LastClusterFromChain));
+
+    STATUS status = STATUS_UNSUCCESSFUL;
+    FSINFO* pFsInfo = NULL;            // pointer to FSInfo
+    FAT32_ENTRY* pFat32Entries = NULL;        // pointer to a FAT table
+    QWORD bytesToReadWrite = 0;
+    QWORD freeCluster = 0;
+    QWORD reservedCluster = 0;
+    QWORD sectorFromFat = 0;
+    QWORD indexInSector = 0;
+
+    __try
+    {
+        pFsInfo = (FSINFO*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(FSINFO), HEAP_TEMP_TAG, 0);
+        if (NULL == pFsInfo)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(FSINFO));
+            __leave;
+        }
+
+        bytesToReadWrite = sizeof(FSINFO);
+        status = IoReadDevice(
+            FatData->VolumeDevice,
+            pFsInfo,
+            &bytesToReadWrite,
+            1 * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+
+        // if there are no more free clusters we fail
+        if (0 == pFsInfo->FSI_Free_Count)
+        {
+            pFsInfo->FSI_Nxt_Free = FAT32_UNKNOWN;
+
+            status = STATUS_DISK_FULL;
+            __leave;
+        }
+
+        status = _FirstFreeCluster(FatData, pFsInfo->FSI_Nxt_Free, TRUE, &reservedCluster);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("FirstFreeCluster", status);
+            __leave;
+        }
+
+        if (0 == reservedCluster) // no free cluster found
+        {
+            // FSI_Free_Count was not zero, but there was no free cluster
+            ASSERT(FAT32_UNKNOWN == pFsInfo->FSI_Free_Count);
+
+            pFsInfo->FSI_Free_Count = 0;
+            pFsInfo->FSI_Nxt_Free = FAT32_UNKNOWN;
+
+            status = STATUS_DISK_FULL;
+            __leave;
+        }
+
+        // a free cluster was reserved
+        // write it to the end of the cluster chain
+        pFat32Entries = (FAT32_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, FatData->BytesPerSector, HEAP_TEMP_TAG, 0);
+        if (NULL == pFat32Entries)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            // could not allocate memory for a FAT32 sector
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", FatData->BytesPerSector);
+            __leave;
+        }
+
+        sectorFromFat = FatData->ReservedSectors + (LastClusterFromChain * sizeof(FAT32_ENTRY) / FatData->BytesPerSector);
+        indexInSector = LastClusterFromChain % (FatData->BytesPerSector / sizeof(FAT32_ENTRY));
+
+        bytesToReadWrite = FatData->BytesPerSector;
+        // We read the sector
+        status = IoReadDevice(
+            FatData->VolumeDevice,
+            pFat32Entries,
+            &bytesToReadWrite,
+            sectorFromFat * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+
+        pFat32Entries[indexInSector] &= ~FAT32_CLUSTER_MASK;    // we need to preserve the 4 reserved bits
+        pFat32Entries[indexInSector] |= (DWORD)reservedCluster;
+
+        status = IoWriteDevice(
+            FatData->VolumeDevice,
+            pFat32Entries,
+            &bytesToReadWrite,
+            sectorFromFat * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+
+        // Update the FSI_Nxt_Free and FSI_Free_Count
+
+        // fatgen103.pdf:
+        // Typically this value is set to the last cluster number that the driver allocated.
+        pFsInfo->FSI_Nxt_Free = (DWORD)reservedCluster;
+
+        if (FAT32_UNKNOWN == pFsInfo->FSI_Free_Count)
+        {
+            // calculate remaining free clusters
+            pFsInfo->FSI_Free_Count = 0;
+
+            freeCluster = reservedCluster;
+
+            for(;;)
+            {
+                status = _FirstFreeCluster(FatData, freeCluster + 1, FALSE, &freeCluster);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("FirstFreeCluster", status);
+                    __leave;
+                }
+
+                if (0 == freeCluster)
+                {
+                    break;
+                }
+
+                pFsInfo->FSI_Free_Count++;
+            }
+        }
+        else // FSI_Free_Count != FAT32_UNKNOWN or 0
+        {
+            pFsInfo->FSI_Free_Count--;
+        }
+
+    }
+    __finally
+    {
+        *ReservedCluster = reservedCluster;
+
+        // Write the FsInfo back to the disk
+        // (placed here in case of __leave when disk is full)
+        bytesToReadWrite = sizeof(FSINFO);
+        status = IoWriteDevice(
+            FatData->VolumeDevice,
+            pFsInfo,
+            &bytesToReadWrite,
+            1 * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector);
+
+        // We free the memory allocated
+        if (NULL != pFsInfo)
+        {
+            ExFreePoolWithTag(pFsInfo, HEAP_TEMP_TAG);
+            pFsInfo = NULL;
+        }
+
+        // We free the memory allocated
+        if (NULL != pFat32Entries)
+        {
+            ExFreePoolWithTag(pFat32Entries, HEAP_TEMP_TAG);
+            pFat32Entries = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+FirstSectorOfCluster(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       Cluster,
+    OUT     QWORD*      Sector
+    )
+{
+    ASSERT(NULL != FatData);
+    ASSERT(NULL != Sector);
+
+    if ((Cluster > FatData->CountOfClusters + 1) || (Cluster < 2))
+    {
+        // there is no such cluster
+        LOG_TRACE_FILESYSTEM("Cluster: 0x%X\n", Cluster);
+        LOG_TRACE_FILESYSTEM("Count of clusters: 0x%x\n", FatData->CountOfClusters);
+        LOG_TRACE_FILESYSTEM("Sectors per cluster: 0x%x\n", FatData->SectorsPerCluster);
+        LOG_TRACE_FILESYSTEM("FatData->FirstDataSector: 0x%x\n", FatData->FirstDataSector);
+
+        return STATUS_DEVICE_CLUSTER_INVALID;
+    }
+
+    *Sector = (((Cluster - 2) * FatData->SectorsPerCluster) + FatData->FirstDataSector);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+ClusterOfSector(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       Sector,
+    OUT     QWORD*      Cluster
+    )
+{
+    ASSERT(NULL != Cluster);
+
+    *Cluster = (((Sector - FatData->FirstDataSector) / FatData->SectorsPerCluster) + 2);
+
+    LOG_TRACE_FILESYSTEM("Sector: 0x%x\n", Sector);
+    LOG_TRACE_FILESYSTEM("*Result: 0x%x\n", *Cluster);
+    LOG_TRACE_FILESYSTEM("Count of clusters: 0x%x\n", FatData->CountOfClusters);
+    LOG_TRACE_FILESYSTEM("Sectors per cluster: 0x%x\n", FatData->SectorsPerCluster);
+    LOG_TRACE_FILESYSTEM("FatData->FirstDataSector: 0x%x\n", FatData->FirstDataSector);
+
+    if ((*Cluster > FatData->CountOfClusters + 1) || (*Cluster < 2))
+    {
+        return STATUS_DEVICE_CLUSTER_INVALID;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+GetDirEntryFromSector(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       EntrySector,
+    IN      QWORD       DirFirstSector, // search criterion
+    OUT     QWORD*      EntryIndex,
+    OUT     DIR_ENTRY*  DirEntry
+)
+{
+    STATUS status = STATUS_UNSUCCESSFUL;
+    LONG_DIR_ENTRY* pLongEntry = NULL;
+    DIR_ENTRY* pDirEntryArray = NULL;
+    QWORD index = 0;
+    QWORD bytesToRead = 0;
+    QWORD dirFstClusterToSearch = 0;
+
+    __try
+    {
+        bytesToRead = FatData->BytesPerSector * FatData->SectorsPerCluster;
+
+        pDirEntryArray = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToRead, HEAP_TEMP_TAG, 0);
+        if (NULL == pDirEntryArray)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            // malloc failed
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToRead);
+            __leave;
+        }
+
+        status = IoReadDevice(FatData->VolumeDevice,
+            pDirEntryArray,
+            &bytesToRead,
+            EntrySector * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToRead == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+        status = ClusterOfSector(FatData, DirFirstSector, &dirFstClusterToSearch);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("ClusterOfSector", status);
+            __leave;
+        }
+
+        for (index = 0; index < bytesToRead / sizeof(DIR_ENTRY); index++)
+        {
+            if ((FREE_ENTRY == pDirEntryArray[index].DIR_Name[0]) ||
+                (FREE_JAP_ENTRY == pDirEntryArray[index].DIR_Name[0]))
+            {
+                // this entry is empty
+                continue;
+            }
+
+            pLongEntry = (LONG_DIR_ENTRY*)&(pDirEntryArray[index]);
+
+            if ((pLongEntry->LDIR_Attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
+            {
+                // might be used in the future
+
+                continue;
+            }
+
+            if (dirFstClusterToSearch == WORDS_TO_DWORD(pDirEntryArray[index].DIR_FstClusHI, pDirEntryArray[index].DIR_FstClusLO))
+            {
+                memcpy(DirEntry, &pDirEntryArray[index], sizeof(DIR_ENTRY));
+                *EntryIndex = index;
+
+                status = STATUS_SUCCESS;
+                __leave;
+            }
+        }
+
+        *EntryIndex = MAX_DWORD;
+        status = STATUS_ELEMENT_NOT_FOUND;
+    }
+    __finally
+    {
+        if (NULL != pDirEntryArray)
+        {
+            ExFreePoolWithTag(pDirEntryArray, HEAP_TEMP_TAG);
+            pDirEntryArray = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+WriteDirEntryToSector(
+    IN      PFAT_DATA   FatData,
+    IN      QWORD       EntrySector,
+    IN      QWORD       EntryIndex,
+    IN      DIR_ENTRY*  DirEntry
+)
+{
+    STATUS status = STATUS_UNSUCCESSFUL;
+    DIR_ENTRY* pDirEntryArray = NULL;
+    QWORD bytesToReadWrite = 0;
+
+    __try
+    {
+        bytesToReadWrite = FatData->BytesPerSector * FatData->SectorsPerCluster;
+
+        pDirEntryArray = (DIR_ENTRY*)ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)bytesToReadWrite, HEAP_TEMP_TAG, 0);
+        if (NULL == pDirEntryArray)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            // malloc failed
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", bytesToReadWrite);
+            __leave;
+        }
+
+        status = IoReadDevice(FatData->VolumeDevice,
+            pDirEntryArray,
+            &bytesToReadWrite,
+            EntrySector * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+        memcpy(&pDirEntryArray[EntryIndex], (PVOID)DirEntry, sizeof(DIR_ENTRY));
+
+        status = IoWriteDevice(FatData->VolumeDevice,
+            pDirEntryArray,
+            &bytesToReadWrite,
+            EntrySector * FatData->BytesPerSector
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDevice", status);
+            __leave;
+        }
+        ASSERT(bytesToReadWrite == FatData->BytesPerSector * FatData->SectorsPerCluster);
+
+        status = STATUS_SUCCESS;
+    }
+    __finally
+    {
+        if (NULL != pDirEntryArray)
+        {
+            ExFreePoolWithTag(pDirEntryArray, HEAP_TEMP_TAG);
+            pDirEntryArray = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+ConvertFatDateTimeToDateTime(
+    IN      FATDATE*    FatDate,
+    IN      FATTIME*    FatTime,
+    OUT     DATETIME*   DateTime
+    )
+{
+    STATUS status;
+
+    ASSERT(NULL != DateTime);
+
+    status = STATUS_SUCCESS;
+
+    status = _ConvertFatDateToDate(FatDate, &DateTime->Date);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ConvertFatDateToDate", status);
+        return status;
+    }
+
+    status = _ConvertFatTimeToTime(FatTime, &DateTime->Time);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ConvertFatTimeToTime", status);
+        return status;
+    }
+
+    return status;
+}
+
+void
+ConvertDateTimeToFatDateTime(
+    IN      PDATETIME   DateTime,
+    OUT     FATDATE*    FatDate,
+    OUT     FATTIME*    FatTime
+    )
+{
+    ASSERT(NULL != DateTime);
+
+    _ConvertDateToFatDate(&DateTime->Date, FatDate);
+    _ConvertTimeToFatTime(&DateTime->Time, FatTime);
+}
+
+STATUS
+ConvertFatNameToName(
+    IN_READS(SHORT_NAME_CHARS)      char*       FatName,
+    IN                              DWORD       BufferSize,
+    OUT_WRITES(BufferSize)          char*       Buffer,
+    OUT                             DWORD*      ActualNameLength
+    )
+{
+    STATUS status;
+    DWORD nameLen;
+    char extName[4];
+    char normalName[9];
+    DWORD lastSpaceIndex;
+    DWORD i;
+
+    ASSERT(NULL != FatName);
+    ASSERT(NULL != Buffer);
+    ASSERT(NULL != ActualNameLength);
+
+    status = STATUS_SUCCESS;
+    nameLen = 0;
+    lastSpaceIndex = SHORT_NAME_NAME;
+
+    // retrieve normal name
+    for (i = 0; i < SHORT_NAME_NAME; ++i)
+    {
+        normalName[i] = FatName[i];
+        if (FatName[i] == ' ')
+        {
+            if (lastSpaceIndex > i)
+            {
+                lastSpaceIndex = i;
+            }
+        }
+        else
+        {
+            lastSpaceIndex = SHORT_NAME_NAME;
+        }
+    }
+    normalName[lastSpaceIndex] = '\0';
+
+    // retrieve extension
+    for (i = 0; i < SHORT_NAME_EXT; ++i)
+    {
+        extName[i] = FatName[i+SHORT_NAME_NAME];
+        if (FatName[i + SHORT_NAME_NAME] == ' ')
+        {
+            // we found a space and it's over
+            break;
+        }
+    }
+    extName[i] = '\0';
+
+    nameLen = strlen(normalName) + i + ( ( 0 != i ) ? 1 : 0 );
+    *ActualNameLength = nameLen;
+    if (nameLen >= BufferSize)
+    {
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+
+    if (0 == i)
+    {
+        // there is no extension
+        strcpy(Buffer, normalName);
+    }
+    else
+    {
+        // there is an extension
+        status = snprintf(Buffer, BufferSize, "%s.%s", normalName, extName);
+    }
+
+    return status;
+}
+
+STATUS
+WritePartialLongFatNameToName(
+    IN                          LONG_DIR_ENTRY* LongDirEntry,
+    IN                          DWORD           BufferSize,
+    INOUT_UPDATES(BufferSize)   char*           Buffer
+)
+{
+    ASSERT(NULL != LongDirEntry);
+    ASSERT(0 != BufferSize);
+    ASSERT(NULL != Buffer);
+
+    STATUS status = STATUS_SUCCESS;
+    DWORD entryOrdinal = (LongDirEntry->LDIR_Ord & ~LONG_NAME_ORD_END_MASK) - 1;
+    BOOLEAN lastLongEntry = IsBooleanFlagOn(LongDirEntry->LDIR_Ord, LONG_NAME_ORD_END_MASK);
+    DWORD bufferWriteIndex = 0;
+    DWORD i = 0;
+    DWORD j = 0;
+
+    BYTE const* longNames[3] = { 0 };
+    DWORD longNameLengths[3] = { 0 };
+
+    longNames[0] = LongDirEntry->LDIR_Name1;
+    longNames[1] = LongDirEntry->LDIR_Name2;
+    longNames[2] = LongDirEntry->LDIR_Name3;
+
+    longNameLengths[0] = LONG_NAME1_CHARS * sizeof(WCHAR);
+    longNameLengths[1] = LONG_NAME2_CHARS * sizeof(WCHAR);
+    longNameLengths[2] = LONG_NAME3_CHARS * sizeof(WCHAR);
+
+    // calculate position of partial long name in the final name
+    bufferWriteIndex = LONG_NAME_TOTAL_CHARS * entryOrdinal;
+
+    // for each array of characters in the long directory entry
+    for (j = 0; j < ARRAYSIZE(longNames); j++)
+    {
+        // for each ascii character
+        for (i = 0; i < longNameLengths[j]; i += sizeof(WCHAR))
+        {
+            if ('\0' == longNames[j][i])
+            {
+                j = ARRAYSIZE(longNames); // break outer loop too
+                break;
+            }
+
+            if (bufferWriteIndex >= BufferSize - 1)
+            {
+                return STATUS_BUFFER_TOO_SMALL;
+            }
+
+            Buffer[bufferWriteIndex] = longNames[j][i];
+
+            bufferWriteIndex++;
+        }
+    }
+
+    if (lastLongEntry)
+    {
+        Buffer[bufferWriteIndex] = '\0';
+    }
+
+    return status;
+}
+
+static
+STATUS
+_ConvertFatDateToDate(
+    IN      FATDATE*    FatDate,
+    OUT     DATE*       RealDate
+    )
+{
+    ASSERT(NULL != RealDate);
+    ASSERT(NULL != FatDate);
+
+    RealDate->Day = (BYTE) FatDate->Day;
+
+    if ((RealDate->Day < FAT_DAY_RANGE_MIN) || (RealDate->Day > FAT_DAY_RANGE_MAX))
+    {
+        // The day is not valid
+        return STATUS_TIME_INVALID;
+    }
+
+    RealDate->Month = (BYTE) FatDate->Month;
+
+    if ((RealDate->Month < FAT_MONTH_RANGE_MIN) || (RealDate->Month > FAT_MONTH_RANGE_MAX))
+    {
+        // the month is invalid
+        return STATUS_TIME_INVALID;
+    }
+
+    RealDate->Year = FatDate->Year + FAT_START_YEAR;
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_ConvertFatTimeToTime(
+    IN      FATTIME*    FatTime,
+    OUT     TIME*       RealTime
+    )
+{
+    ASSERT(NULL != RealTime);
+
+    RealTime->Second = (BYTE) FatTime->Second;
+
+    if ((RealTime->Second < FAT_SECOND_RANGE_MIN) || (RealTime->Second > FAT_SECOND_RANGE_MAX))
+    {
+        // the seconds parameter is invalid
+        return STATUS_TIME_INVALID;
+    }
+
+    RealTime->Second *= 2;
+
+    RealTime->Minute = (BYTE) FatTime->Minute;
+
+    if ((RealTime->Minute < FAT_MINUTE_RANGE_MIN) || (RealTime->Minute > FAT_MINUTE_RANGE_MAX))
+    {
+        // the minutes parameter is invalid
+        return STATUS_TIME_INVALID;
+    }
+
+    RealTime->Hour = (BYTE) FatTime->Hour;
+
+    if ((RealTime->Hour < FAT_HOUR_RANGE_MIN) || (RealTime->Hour > FAT_HOUR_RANGE_MAX))
+    {
+        // the hours parameter is invalid
+        return STATUS_TIME_INVALID;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+_ConvertDateToFatDate(
+    IN      DATE*       RealDate,
+    OUT     FATDATE*    FatDate
+    )
+{
+    ASSERT(NULL != RealDate);
+    ASSERT(NULL != FatDate);
+
+    FatDate->Year = RealDate->Year - FAT_START_YEAR;
+    FatDate->Month = RealDate->Month;
+    FatDate->Day = RealDate->Day;
+}
+
+static
+void
+_ConvertTimeToFatTime(
+    IN      TIME*       RealTime,
+    OUT     FATTIME*    FatTime
+    )
+{
+    ASSERT(NULL != RealTime);
+    ASSERT(NULL != FatTime);
+
+    FatTime->Hour = RealTime->Hour;
+    FatTime->Minute = RealTime->Minute;
+    FatTime->Second = RealTime->Second / 2;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/HAL.vcxproj b/src_proiect/HAL/HAL.vcxproj
new file mode 100644
index 0000000..eb42ad6
--- /dev/null
+++ b/src_proiect/HAL/HAL.vcxproj
@@ -0,0 +1,204 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>HAL</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <ShowIncludes>false</ShowIncludes>
+      <EnablePREfast>true</EnablePREfast>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <YASM>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <ShowIncludes>false</ShowIncludes>
+      <EnablePREfast>true</EnablePREfast>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <Link>
+      <SubSystem>Console</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <YASM>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\cmos.c" />
+    <ClCompile Include="src\gdt.c" />
+    <ClCompile Include="src\hal.c" />
+    <ClCompile Include="src\hw_fpu.c" />
+    <ClCompile Include="src\idt.c" />
+    <ClCompile Include="src\ioapic.c" />
+    <ClCompile Include="src\lapic.c" />
+    <ClCompile Include="src\pci.c" />
+    <ClCompile Include="src\pcie.c" />
+    <ClCompile Include="src\pci_device.c" />
+    <ClCompile Include="src\pic.c" />
+    <ClCompile Include="src\pit.c" />
+    <ClCompile Include="src\pte.c" />
+    <ClCompile Include="src\rtc.c" />
+    <ClCompile Include="src\serial.c" />
+    <ClCompile Include="src\tss.c" />
+    <ClCompile Include="src\vmx.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\hal_base.h" />
+    <ClInclude Include="headers\ioapic_registers.h" />
+    <ClInclude Include="headers\lapic_registers.h" />
+    <ClInclude Include="headers\pci_common.h" />
+    <ClInclude Include="inc\apic_common.h" />
+    <ClInclude Include="inc\cmos.h" />
+    <ClInclude Include="inc\cpu.h" />
+    <ClInclude Include="inc\cpuid_leaf.h" />
+    <ClInclude Include="inc\cpu_if.h" />
+    <ClInclude Include="inc\cpu_utils.h" />
+    <ClInclude Include="inc\gdt.h" />
+    <ClInclude Include="inc\hal.h" />
+    <ClInclude Include="inc\hw_fpu.h" />
+    <ClInclude Include="inc\idt.h" />
+    <ClInclude Include="inc\int15.h" />
+    <ClInclude Include="inc\ioapic.h" />
+    <ClInclude Include="inc\lapic.h" />
+    <ClInclude Include="inc\msr.h" />
+    <ClInclude Include="inc\mtrr.h" />
+    <ClInclude Include="inc\pci.h" />
+    <ClInclude Include="inc\pcie.h" />
+    <ClInclude Include="inc\pci_device.h" />
+    <ClInclude Include="inc\pci_registers.h" />
+    <ClInclude Include="inc\pic.h" />
+    <ClInclude Include="inc\pit.h" />
+    <ClInclude Include="inc\pte.h" />
+    <ClInclude Include="inc\register.h" />
+    <ClInclude Include="inc\rtc.h" />
+    <ClInclude Include="inc\serial.h" />
+    <ClInclude Include="inc\tss.h" />
+    <ClInclude Include="inc\vmcs_fields.h" />
+    <ClInclude Include="inc\vmx.h" />
+    <ClInclude Include="inc\vmx_exit.h" />
+    <ClInclude Include="inc\vmx_exit_reasons.h" />
+    <ClInclude Include="inc\yasm_imports.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_exports.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.targets" />
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/HAL/HAL.vcxproj.filters b/src_proiect/HAL/HAL.vcxproj.filters
new file mode 100644
index 0000000..6b6601c
--- /dev/null
+++ b/src_proiect/HAL/HAL.vcxproj.filters
@@ -0,0 +1,189 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{fa602fc5-7cf9-45fb-8274-44905e052960}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\inc\Virtualization">
+      <UniqueIdentifier>{cb6e23e9-4765-4733-8e52-d8bf31ddc027}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\idt.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\hal.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\tss.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\gdt.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pci.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pte.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pic.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmos.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pit.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\rtc.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\serial.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\lapic.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ioapic.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pci_device.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pcie.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\vmx.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\hw_fpu.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\yasm_imports.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cpu.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\gdt.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\hal.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\idt.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\msr.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pci.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pte.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\register.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\tss.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\hal_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\mtrr.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\int15.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pic.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cmos.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pit.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\rtc.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\serial.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\lapic.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\lapic_registers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\apic_common.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\ioapic.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\apic_common.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ioapic_registers.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pci_registers.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pci_device.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pcie.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\pci_common.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\vmx_exit_reasons.h">
+      <Filter>Header Files\inc\Virtualization</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\vmcs_fields.h">
+      <Filter>Header Files\inc\Virtualization</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\vmx.h">
+      <Filter>Header Files\inc\Virtualization</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\vmx_exit.h">
+      <Filter>Header Files\inc\Virtualization</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\hw_fpu.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cpuid_leaf.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cpu_utils.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\cpu_if.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_exports.yasm" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/HAL/headers/hal_base.h b/src_proiect/HAL/headers/hal_base.h
new file mode 100644
index 0000000..4dd76ed
--- /dev/null
+++ b/src_proiect/HAL/headers/hal_base.h
@@ -0,0 +1,4 @@
+#pragma once
+
+#include "common_lib.h"
+#include "hal.h"
\ No newline at end of file
diff --git a/src_proiect/HAL/headers/ioapic_registers.h b/src_proiect/HAL/headers/ioapic_registers.h
new file mode 100644
index 0000000..650a769
--- /dev/null
+++ b/src_proiect/HAL/headers/ioapic_registers.h
@@ -0,0 +1,194 @@
+#pragma once
+
+#define IO_APIC_IDENTIFICATION_REGISTER_OFFSET          0x0
+#define IO_APIC_VERSION_REGISTER_OFFSET                 0x1
+#define IO_APIC_REDIRECTION_TABLE_BASE_OFFSET           0x10
+#define IO_APIC_REDIRECTION_TABLE_ENTRY_SIZE            0x2
+
+#define PREDEFINED_IO_APIC_REGISTER_SIZE                0x10
+#define PREDEFINED_IO_APIC_USABLE_REGISTER_SIZE         0x4
+
+#define PREDEFINED_IO_APIC_TABLE_REDIR_ENTRY_SIZE       0x8
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+typedef struct _IO_APIC_REGISTER
+{
+    volatile DWORD          Value;
+    DWORD                   __Reserved[3];
+} IO_APIC_REGISTER, *PIO_APIC_REGISTER;
+STATIC_ASSERT(sizeof(IO_APIC_REGISTER) == PREDEFINED_IO_APIC_REGISTER_SIZE);
+
+typedef union _IO_APIC_REG_SEL
+{
+    struct
+    {
+        BYTE                    ApicAddress;
+        BYTE                    __Reserved[3];
+    };
+    DWORD                   Value;
+} IO_APIC_REG_SEL, *PIO_APIC_REG_SEL;
+STATIC_ASSERT(sizeof(IO_APIC_REG_SEL) == PREDEFINED_IO_APIC_USABLE_REGISTER_SIZE);
+
+typedef union _IO_APIC_ID_REGISTER
+{
+    struct
+    {
+        BYTE                __Reserved0[3];
+
+        BYTE                ApicId                      :  4;
+        BYTE                __Reserved1                 :  4;
+    };
+    DWORD                   Value;
+} IO_APIC_ID_REGISTER, *PIO_APIC_ID_REGISTER;
+STATIC_ASSERT(sizeof(IO_APIC_ID_REGISTER) == PREDEFINED_IO_APIC_USABLE_REGISTER_SIZE);
+
+typedef union _IO_APIC_VERSION_REGISTER
+{
+    struct
+    {
+        BYTE                ApicVersion;
+
+        BYTE                __Reserved0;
+
+        BYTE                MaximumRedirectionEntry;
+        BYTE                __Reserved1;
+    };
+    DWORD                   Value;
+} IO_APIC_VERSION_REGISTER, *PIO_APIC_VERSION_REGISTER;
+STATIC_ASSERT(sizeof(IO_APIC_VERSION_REGISTER) == PREDEFINED_IO_APIC_USABLE_REGISTER_SIZE);
+
+typedef union _IO_APIC_REDIR_TABLE_ENTRY
+{
+    struct
+    {
+        // Interrupt Vector(INTVEC)R / W: The vector field is an 8 bit field containing the interrupt
+        // vector for this interrupt.Vector values range from 10h to FEh.
+        QWORD                   Vector                  :  8;
+
+        // Delivery Mode(DELMOD)R / W.The Delivery Mode is a 3 bit field that specifies how the
+        // APICs listed in the destination field should act upon reception of this signal.Note that certain
+        // Delivery Modes only operate as intended when used in conjunction with a specific trigger Mode.
+        // These restrictions are indicated in the following table for each Delivery Mode.
+
+        // Bits
+        // [10:8] Mode Description
+        // 000 Fixed    Deliver the signal on the INTR signal of all processor cores listed in the
+        //              destination.Trigger Mode for "fixed" Delivery Mode can be edge or level.
+        // 001 Lowest
+        // Priority     Deliver the signal on the INTR signal of the processor core that is
+        //              executing at the lowest priority among all the processors listed in the
+        //              specified destination.Trigger Mode for "lowest priority".Delivery Mode
+        //              can be edge or level.
+        // 010 SMI      System Management Interrupt.A delivery mode equal to SMI requires an
+        //              edge trigger mode.The vector information is ignored but must be
+        //              programmed to all zeroes for future compatibility.
+        // 011 Reserved
+        // 100          NMI Deliver the signal on the NMI signal of all processor cores listed in the
+        //              destination.Vector information is ignored.NMI is treated as an edge
+        //              triggered interrupt, even if it is programmed as a level triggered interrupt.
+        //              For proper operation, this redirection table entry must be programmed to
+        //              edge triggered interrupt.
+        // 101 INIT     Deliver the signal to all processor cores listed in the destination by
+        //              asserting the INIT signal.All addressed local APICs will assume their
+        //              INIT state.INIT is always treated as an edge triggered interrupt, even if
+        //              programmed otherwise.For proper operation, this redirection table entry
+        //              must be programmed to edge triggered interrupt.
+        // 110 Reserved
+        // 111 ExtINT   Deliver the signal to the INTR signal of all processor cores listed in the
+        //              destination as an interrupt that originated in an externally connected
+        //              (8259A - compatible) interrupt controller.The INTA cycle that corresponds
+        //              to this ExtINT delivery is routed to the external controller that is expected
+        //              to supply the vector.A Delivery Mode of "ExtINT" requires an edge
+        //              trigger mode.
+        QWORD                   DeliveryMode            :  3;
+
+        // Destination Mode(DESTMOD)R / W.This field determines the interpretation of the
+        // Destination field.When DESTMOD = 0 (physical mode), a destination APIC is identified by its ID.
+        // Bits 56 through 59 of the Destination field specify the 4 bit APIC ID.When DESTMOD = 1 (logical
+        // mode), destinations are identified by matching on the logical destination under the control of the
+        // Destination Format Register and Logical Destination Register in each Local APIC.
+
+        // Destination Mode IOREDTBLx[11] Logical Destination Address
+        // 0, Physical Mode IOREDTBLx[59:56] = APIC ID
+        // 1, Logical Mode IOREDTBLx[63:56] = Set of processors
+        QWORD                   DestinationMode         :  1;
+
+        // Delivery Status(DELIVS)RO.The Delivery Status bit contains the current status of the
+        // delivery of this interrupt.Delivery Status is read - only and writes to this bit(as part of a 32 bit
+        // word) do not effect this bit. 0 = IDLE(there is currently no activity for this interrupt). 1 = Send
+        // Pending(the interrupt has been injected but its delivery is temporarily held up due to the APIC
+        // bus being busy or the inability of the receiving APIC unit to accept that interrupt at that time).
+        QWORD                   DeliveryStatus          :  1;
+
+        // Interrupt Input Pin Polarity(INTPOL)R / W.This bit specifies the polarity of the interrupt
+        // signal. 0 = High active, 1 = Low active.
+        QWORD                   PinPolarity             :  1;
+
+        // Remote IRRRO. This bit is used for level triggered interrupts. Its meaning is undefined for
+        // edge triggered interrupts. For level triggered interrupts, this bit is set to 1 when local APIC(s)
+        // accept the level interrupt sent by the IOAPIC. The Remote IRR bit is set to 0 when an EOI
+        // message with a matching interrupt vector is received from a local APIC.
+        QWORD                   RemoteIRR               :  1;
+
+        // Trigger ModeR / W.The trigger mode field indicates the type of signal on the interrupt pin that
+        // triggers an interrupt. 1 = Level sensitive, 0 = Edge sensitive.
+        QWORD                   TriggerMode             :  1;
+
+        // Interrupt MaskR / W.When this bit is 1, the interrupt signal is masked.Edge - sensitive
+        // interrupts signaled on a masked interrupt pin are ignored(i.e., not delivered or held pending).
+        // Level - asserts or negates occurring on a masked level - sensitive pin are also ignored and have no
+        // side effects.Changing the mask bit from unmasked to masked after the interrupt is accepted by
+        // a local APIC has no effect on that interrupt.This behavior is identical to the case where the
+        // device withdraws the interrupt before that interrupt is posted to the processor.It is software's
+        // responsibility to handle the case where the mask bit is set after the interrupt message has been
+        // accepted by a local APIC unit but before the interrupt is dispensed to the processor.When this
+        // bit is 0, the interrupt is not masked.An edge or level on an interrupt pin that is not masked
+        // results in the delivery of the interrupt to the destination.
+        QWORD                   Masked                  :  1;
+
+        QWORD                   __Reserved0             : 15;
+
+        QWORD                   __Reserved1             : 24;
+
+
+        // Destination FieldR/W. If the Destination Mode of this entry is Physical Mode(bit 11 = 0), bits
+        // [59:56] contain an APIC ID.If Logical Mode is selected(bit 11 = 1), the Destination Field
+        // potentially defines a set of processors.Bits[63:56] of the Destination Field specify the logical
+        // destination address.
+
+        // Destination Mode IOREDTBLx[11] Logical Destination Address
+        // 0, Physical Mode IOREDTBLx[59:56] = APIC ID
+        // 1, Logical Mode IOREDTBLx[63:56] = Set of processors
+        QWORD                   Destination             :  8;
+    };
+    struct
+    {
+        DWORD                   LowDword;
+        DWORD                   HighDword;
+    };
+} IO_APIC_REDIR_TABLE_ENTRY, *PIO_APIC_REDIR_TABLE_ENTRY;
+STATIC_ASSERT(sizeof(IO_APIC_REDIR_TABLE_ENTRY) == PREDEFINED_IO_APIC_TABLE_REDIR_ENTRY_SIZE );
+
+typedef struct _IO_APIC
+{
+    IO_APIC_REGISTER        IoRegSel;
+
+    IO_APIC_REGISTER        IoRegData;
+
+    IO_APIC_REGISTER        __Reserved0[2];
+
+    // valid only if version >= 0x20
+    // see: http://lxr.free-electrons.com/source/arch/x86/kernel/apic/io_apic.c
+    IO_APIC_REGISTER        IoRegEOI;
+} IO_APIC, *PIO_APIC;
+
+#pragma warning(pop)
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src_proiect/HAL/headers/lapic_registers.h b/src_proiect/HAL/headers/lapic_registers.h
new file mode 100644
index 0000000..75b2486
--- /dev/null
+++ b/src_proiect/HAL/headers/lapic_registers.h
@@ -0,0 +1,251 @@
+#pragma once
+
+#define LAPIC_VERSION_REGISTER_OFFSET                   0x030
+#define LAPIC_ERROR_REGISTER_OFFSET                     0x280
+#define LAPIC_LVT_TIMER_REGISTER_OFFSET                 0x320
+#define LAPIC_TIMER_INITIAL_COUNT_REGISTER_OFFSET       0x380
+#define LAPIC_TIMER_CURRENT_COUNT_REGISTER_OFFSET       0x390
+#define LAPIC_TIMER_DIVIDE_REGISTER_OFFSET              0x3E0
+
+#define PREDEFINED_LAPIC_USABLE_REG_SIZE                4
+#define PREDEFINED_LAPIC_REGISTER_SIZE                  0x10
+#define PREDEFINED_LAPIC_SIZE                           0x400
+
+#define APIC_TIMER_ONE_SHOT_MODE                        0b00
+#define APIC_TIMER_PERIOD_MODE                          0b01
+
+#define APIC_FIRST_USABLE_INTERRUPT_INDEX               0x20
+
+#define APIC_TIMER_CONFIGURATION_SLEEP                  (10*MS_IN_US)
+
+#define APIC_VECTORS_PER_ISR_REGISTER                   32
+
+#define IA32_APIC_BASE_MASK(reg)                        (((QWORD)(reg))&0xFFFFFF000)
+#define IA32_APIC_BASE_ENABLE_FLAG                      (1<<11)     // if set => APIC enabled
+#define IA32_APIC_EXT_ENABLE_FLAG                       (1<<10)        // x2 APIC enable
+#define IA32_APIC_BSP_FLAG                              (1<<8)
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+typedef union _ICR_HIGH_REGISTER
+{
+    struct
+    {
+        DWORD           Reserved                :   24;
+        DWORD           Destination             :   8;
+    };
+    DWORD               Raw;
+} ICR_HIGH_REGISTER, *PICR_HIGH_REGISTER;
+STATIC_ASSERT(sizeof(ICR_HIGH_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef union _ICR_LOW_REGISTER
+{
+    struct
+    {
+        DWORD           Vector                  :   8;
+        DWORD           DeliveryMode            :   3;
+        DWORD           DestinationMode         :   1;
+        DWORD           DeliveryStatus          :   1;
+        DWORD           Reserved0               :   1;
+        DWORD           Level                   :   1;
+        DWORD           TriggerMode             :   1;
+        DWORD           Reserved1               :   2;
+        DWORD           DestinationShorthand    :   2;
+        DWORD           Reserved2               :  12;
+    };
+    DWORD               Raw;
+} ICR_LOW_REGISTER, *PICR_LOW_REGISTER;
+STATIC_ASSERT(sizeof(ICR_LOW_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef union _LAPIC_VERSION_REGISTER
+{
+    struct
+    {
+        BYTE            Version;
+        BYTE            __Reserved0;
+        BYTE            MaxLvtEntry;
+        BYTE            EoiBcastSuppressSupport :    1;
+        BYTE            __Reserved1             :    7;
+    };
+    DWORD               Raw;
+} LAPIC_VERSION_REGISTER, *PLAPIC_VERSION_REGISTER;
+STATIC_ASSERT(sizeof(LAPIC_VERSION_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef union _SVR_REGISTER
+{
+    struct
+    {
+        DWORD           Vector                  :    8;
+        DWORD           ApicEnable              :    1;
+        DWORD           FocusProcessorChecking  :    1;
+        DWORD           __Reserved0             :    2;
+        DWORD           EOIBroadcastSuppresion  :    1;
+        DWORD           __Reserved1             :   19;
+    };
+    DWORD               Raw;
+} SVR_REGISTER, *PSVR_REGISTER;
+STATIC_ASSERT(sizeof(SVR_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef union _LVT_REGISTER
+{
+    struct
+    {
+        DWORD           Vector                  :    8;
+
+        // Reserved for Timer and Error
+        DWORD           DeliveryMode            :    3;
+
+        DWORD           __Reserved0             :    1;
+
+        DWORD           DeliveryStatus          :    1;
+
+        // Valid only for LINT0 and LINT1
+        DWORD           PinPolarity             :    1;
+        DWORD           RemoteIRR               :    1;
+        DWORD           TriggerMode             :    1;
+
+        // Valid for all
+        DWORD           Masked                  :    1;
+
+        // valid only for TIMER
+        DWORD           TimerMode               :    2;
+
+        DWORD           __Reserved1             :   13;
+    };
+    DWORD               Raw;
+} LVT_REGISTER, *PLVT_REGISTER;
+STATIC_ASSERT(sizeof(LVT_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef union _LDR_REGISTER
+{
+    struct
+    {
+        BYTE            __Reserved0[3];
+
+        BYTE            LogicalApicId;
+    };
+    DWORD               Raw;
+} LDR_REGISTER, *PLDR_REGISTER;
+STATIC_ASSERT(sizeof(LDR_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef union _DFR_REGISTER
+{
+    struct
+    {
+        DWORD           __Reserved0             :  28;
+
+        DWORD           Model                   :   4;
+    };
+    DWORD               Raw;
+} DFR_REGISTER, *PDFR_REGISTER;
+STATIC_ASSERT(sizeof(DFR_REGISTER) == PREDEFINED_LAPIC_USABLE_REG_SIZE);
+
+typedef struct _LAPIC_REGISTER
+{
+    volatile DWORD          Value;
+    DWORD                   __Reserved[3];
+} LAPIC_REGISTER, *PLAPIC_REGISTER;
+STATIC_ASSERT(sizeof(LAPIC_REGISTER) == PREDEFINED_LAPIC_REGISTER_SIZE);
+
+typedef struct _LAPIC
+{
+    LAPIC_REGISTER          __Reserved0[2];
+
+    // R/W
+    LAPIC_REGISTER          ApicId;
+
+    // Read only
+    LAPIC_REGISTER          ApicVersion;
+    LAPIC_REGISTER          __Reserved1[4];
+
+    // R/W
+    LAPIC_REGISTER          TPR;
+
+    // Read only
+    LAPIC_REGISTER          APR;
+
+    // Read only
+    LAPIC_REGISTER          PPR;
+
+    // Write only
+    LAPIC_REGISTER          EOI;
+
+    // Read only
+    LAPIC_REGISTER          RRD;
+
+    // R/W
+    LAPIC_REGISTER          LogicalDestination;
+
+    // R/W
+    LAPIC_REGISTER          DestinationFormat;
+
+    // R/W
+    LAPIC_REGISTER          SpuriousInterruptVector;
+
+    // Read only
+    LAPIC_REGISTER          ISR[8];
+
+    // Read only
+    LAPIC_REGISTER          TMR[8];
+
+    // Read only
+    LAPIC_REGISTER          IRR[8];
+
+    // Read only
+    LAPIC_REGISTER          ErrorStatus;
+
+    LAPIC_REGISTER          __Reserved2[6];
+
+    // R/W
+    LAPIC_REGISTER          LvtCMCI;
+
+    // R/W
+    LAPIC_REGISTER          IcrLow;
+    LAPIC_REGISTER          IcrHigh;
+
+    // R/W
+    LAPIC_REGISTER          LvtTimer;
+
+    // R/W
+    LAPIC_REGISTER          LvtThermalSensor;
+
+    // R/W
+    LAPIC_REGISTER          LvtPerformanceMonitoringCounters;
+
+    // R/W
+    LAPIC_REGISTER          LvtLINT0;
+    LAPIC_REGISTER          LvtLINT1;
+
+    // R/W
+    LAPIC_REGISTER          LvtError;
+
+    // R/W
+    LAPIC_REGISTER          TimerInitialCount;
+
+    // Read only
+    LAPIC_REGISTER          TimerCurrentCount;
+
+    LAPIC_REGISTER          __Reserved3[4];
+
+    // R/W
+    LAPIC_REGISTER          TimerDivideConfiguration;
+
+    LAPIC_REGISTER          __Reserved4;
+} LAPIC, *PLAPIC;
+STATIC_ASSERT(sizeof(LAPIC) == PREDEFINED_LAPIC_SIZE );
+STATIC_ASSERT(FIELD_OFFSET(LAPIC,ApicVersion) == LAPIC_VERSION_REGISTER_OFFSET);
+STATIC_ASSERT(FIELD_OFFSET(LAPIC,ErrorStatus) == LAPIC_ERROR_REGISTER_OFFSET);
+STATIC_ASSERT(FIELD_OFFSET(LAPIC,LvtTimer) == LAPIC_LVT_TIMER_REGISTER_OFFSET );
+STATIC_ASSERT(FIELD_OFFSET(LAPIC,TimerInitialCount) == LAPIC_TIMER_INITIAL_COUNT_REGISTER_OFFSET );
+STATIC_ASSERT(FIELD_OFFSET(LAPIC,TimerCurrentCount) == LAPIC_TIMER_CURRENT_COUNT_REGISTER_OFFSET );
+STATIC_ASSERT(FIELD_OFFSET(LAPIC,TimerDivideConfiguration) == LAPIC_TIMER_DIVIDE_REGISTER_OFFSET );
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/HAL/headers/pci_common.h b/src_proiect/HAL/headers/pci_common.h
new file mode 100644
index 0000000..83fe41c
--- /dev/null
+++ b/src_proiect/HAL/headers/pci_common.h
@@ -0,0 +1,5 @@
+#pragma once
+
+#define PCI_NO_OF_BUSES                                 256
+#define PCI_NO_OF_DEVICES                               32
+#define PCI_NO_OF_FUNCTIONS                             8
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/apic_common.h b/src_proiect/HAL/inc/apic_common.h
new file mode 100644
index 0000000..5273d30
--- /dev/null
+++ b/src_proiect/HAL/inc/apic_common.h
@@ -0,0 +1,55 @@
+#pragma once
+
+typedef enum _APIC_DELIVERY_MODE
+{
+    ApicDeliveryModeFixed,
+    ApicDeliveryModeLowest,
+    ApicDeliveryModeSMI = 2,
+    ApicDeliveryModeNMI = 4,
+    ApicDeliveryModeINIT,
+    ApicDeliveryModeSIPI,
+    ApicDeliveryModeExtINT
+} APIC_DELIVERY_MODE;
+
+typedef enum _APIC_DESTINATION_MODE
+{
+    ApicDestinationModePhysical,
+    ApicDestinationModeLogical
+} APIC_DESTINATION_MODE;
+
+typedef enum _APIC_DESTINATION_SHORTHAND
+{
+    ApicDestinationShorthandNone,
+    ApicDestinationShorthandSelf,
+    ApicDestinationShorthandAll,
+    ApicDestinationShorthandAllExcludingSelf
+} APIC_DESTINATION_SHORTHAND;
+
+typedef enum _APIC_DIVIDE_VALUE
+{
+    ApicDivideBy2       = 0b0'0'00,
+    ApicDivideBy4       = 0b0'0'01,
+    ApicDivideBy8       = 0b0'0'10,
+    ApicDivideBy16      = 0b0'0'11,
+    ApicDivideBy32      = 0b1'0'00,
+    ApicDivideBy64      = 0b1'0'01,
+    ApicDivideBy128     = 0b1'0'10,
+    ApicDivideBy1       = 0b1'0'11,
+
+    ApicDivideReserved  = 0b1'1'11
+} APIC_DIVIDE_VALUE;
+
+typedef enum _APIC_PIN_POLARITY
+{
+    ApicPinPolarityActiveHigh,
+    ApicPinPolarityActiveLow
+} APIC_PIN_POLARITY;
+
+typedef enum _APIC_TRIGGER_MODE
+{
+    ApicTriggerModeEdge,
+    ApicTriggerModeLevel
+} APIC_TRIGGER_MODE;
+
+#define APIC_DESTINATION_FORMAT_FLAT_MODEL         0b1111
+#define APIC_DESTINATION_FORMAT_CLUSTER_MODEL      0b0000
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/cmos.h b/src_proiect/HAL/inc/cmos.h
new file mode 100644
index 0000000..e312126
--- /dev/null
+++ b/src_proiect/HAL/inc/cmos.h
@@ -0,0 +1,59 @@
+#pragma once
+
+typedef struct _CMOS_DATA
+{
+    BYTE            Second;
+    BYTE            Minute;
+    BYTE            Hour;
+    BYTE            Day;
+    BYTE            Month;
+    WORD            Year;
+} CMOS_DATA, *PCMOS_DATA;
+
+typedef enum _CMOS_REGISTER
+{
+    CmosRegisterSeconds = 0x0,
+    CmosRegisterMinutes = 0x2,
+    CmosRegisterHours   = 0x4,
+    CmosRegisterDay     = 0x7,
+    CmosRegisterMonth   = 0x8,
+    CmosRegisterYear    = 0x9,
+    CmosRegisterCentury = 0x32,
+    CmosRegisterStatusA = 0xA,
+    CmosRegisterStatusB = 0xB,
+    CmosRegisterStatusC = 0xC
+} CMOS_REGISTER;
+
+// Status Register A flags
+#define CMOS_UPDATE_IN_PROGRESS         (1<<7)
+
+// Status Register B flags
+#define CMOS_PERIODIC_INTERRUPT         (1<<6)
+#define CMOS_ALARM_INTERRUPT            (1<<5)
+#define CMOS_UPDATE_INTERRUPT           (1<<4)
+#define CMOS_BINARY_MODE                (1<<2)
+#define CMOS_24H_FORMAT                 (1<<1)
+
+void
+CmosReadData(
+    OUT     PCMOS_DATA      CmosData
+    );
+
+BYTE
+CmosGetValue(
+    IN  CMOS_REGISTER   RegisterIndex,
+    IN  BOOLEAN         DisableNMI
+    );
+
+#define CmosGetValueDisableNMI(Idx)     CmosGetValue((Idx),TRUE)
+#define CmosGetValueNMI(Idx)            CmosGetValue((Idx),FALSE)
+
+void
+CmosWriteValue(
+    IN  CMOS_REGISTER   RegisterIndex,
+    IN  BOOLEAN         DisableNMI,
+    IN  BYTE            Value
+    );
+
+#define CmosWriteValueDisableNMI(Idx,Data)      CmosWriteValue((Idx),TRUE,(Data))
+#define CmosWriteValueNMI(Idx,Data)             CmosWriteValue((Idx),FALSE,(Data))
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/cpu.h b/src_proiect/HAL/inc/cpu.h
new file mode 100644
index 0000000..a73725f
--- /dev/null
+++ b/src_proiect/HAL/inc/cpu.h
@@ -0,0 +1,46 @@
+#pragma once
+
+#include "register.h"
+#include "hw_fpu.h"
+#include "cpuid_leaf.h"
+#include "cpu_if.h"
+
+typedef
+QWORD
+(__cdecl FUNC_ReadFsQword)(
+    IN              DWORD           Offset
+    );
+
+extern FUNC_ReadFsQword                     __HALreadfsqword;
+
+#define NO_OF_TOTAL_INTERRUPTS              256
+#define NO_OF_RESERVED_EXCEPTIONS           32
+
+#define NO_OF_USABLE_INTERRUPTS             (NO_OF_TOTAL_INTERRUPTS - NO_OF_RESERVED_EXCEPTIONS)
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used : nameless struct/union
+#pragma warning(disable:4201)
+
+typedef struct _REGISTER_AREA
+{
+    QWORD                                           RegisterValues[RegisterR15 + 1];
+
+    QWORD                                           Rip;
+
+    QWORD                                           Rflags;
+} REGISTER_AREA, *PREGISTER_AREA;
+
+typedef struct _COMPLETE_PROCESSOR_STATE
+{
+    XSAVE_AREA                                      XsaveArea;
+
+    REGISTER_AREA                                   RegisterArea;
+} COMPLETE_PROCESSOR_STATE, *PCOMPLETE_PROCESSOR_STATE;
+#pragma warning(pop)
+#pragma pack(pop)
+
+#include "cpu_utils.h"
diff --git a/src_proiect/HAL/inc/cpu_if.h b/src_proiect/HAL/inc/cpu_if.h
new file mode 100644
index 0000000..dad5251
--- /dev/null
+++ b/src_proiect/HAL/inc/cpu_if.h
@@ -0,0 +1,56 @@
+#pragma once
+
+#pragma pack(push, 1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used : nameless struct/union
+#pragma warning(disable:4201)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+#define PREDEFINED_CPU_RST_CTRL_REG_SIZE    1
+
+#define CPU_RST_CTRL_REG_PORT               0xCF9
+
+typedef union _CPU_RST_CTRL_REG
+{
+    struct
+    {
+        BYTE                                        __reserved0                 : 1;
+
+        // System Reset(SYS_RST) - R / W. This bit is used to determine a hard or soft reset to the
+        // processor.
+        //     0 = When RST_CPU bit goes from 0 to 1, the PCH performs a soft reset by activating INIT# for 16
+        //     PCI clocks.
+        //     1 = When RST_CPU bit goes from 0 to 1, the PCH performs a hard reset by activating PLTRST# and
+        //     SUS_STAT# active for a minimum of about 1 milliseconds.In this case, SLP_S3#, SLP_S4#
+        //     and SLP_S5# state(assertion or de-assertion) depends on FULL_RST bit setting.The PCH
+        //     main power well is reset when this bit is 1. It also resets the resume well bits(except for those
+        //         noted throughout this document).
+        BYTE                                        SYS_RST                     : 1;
+
+        // Reset Processor(RST_CPU) - R / W. When this bit transitions from a 0 to a 1, it initiates a hard or
+        // soft reset, as determined by the SYS_RST bit(bit 1 of this register).
+        BYTE                                        RST_CPU                     : 1;
+
+        // Full Reset(FULL_RST) - R / W.This bit is used to determine the states of SLP_S3#, SLP_S4#, and
+        //     SLP_S5# after a CF9 hard reset(SYS_RST = 1 and RST_CPU is set to 1), after PWROK going low
+        //     (with RSMRST# high), or after two TCO timeouts.
+        //     0 = PCH will keep SLP_S3#, SLP_S4# and SLP_S5# high.
+        //     1 = PCH will drive SLP_S3#, SLP_S4# and SLP_S5# low for 35 seconds.
+        //     Note : When this bit is set, it also causes the full power cycle(SLP_S3 / 4 / 5# assertion) in response
+        //     to SYS_RESET#, PWROK#, and Watchdog timer reset sources.
+        BYTE                                        FULL_RST                    : 1;
+
+        BYTE                                        __reserved4_7               : 4;
+    };
+
+    BYTE                                            Raw;
+} CPU_RST_CTRL_REG;
+STATIC_ASSERT_INFO(sizeof(CPU_RST_CTRL_REG) == PREDEFINED_CPU_RST_CTRL_REG_SIZE,
+    "See Intel 9 Series Chipset Family Platform Controller Hub(PCH) section 12.7.5 RST_CNT - Reset Control Register");
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/HAL/inc/cpu_utils.h b/src_proiect/HAL/inc/cpu_utils.h
new file mode 100644
index 0000000..ca31ddc
--- /dev/null
+++ b/src_proiect/HAL/inc/cpu_utils.h
@@ -0,0 +1,88 @@
+#pragma once
+
+__forceinline
+extern
+void
+CpuClearDirectionFlag(
+    void
+    )
+{
+    __writeeflags(__readeflags() & (~RFLAGS_DIRECTION_BIT));
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrGetState(
+    void
+    )
+{
+    return IsBooleanFlagOn(__readeflags(), RFLAGS_INTERRUPT_FLAG_BIT);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrSetState(
+    const      INTR_STATE         IntrState
+    )
+{
+    QWORD rFlags = __readeflags();
+    QWORD newFlags = IntrState ? ( rFlags | RFLAGS_INTERRUPT_FLAG_BIT ) : ( rFlags & ( ~RFLAGS_INTERRUPT_FLAG_BIT));
+
+    __writeeflags(newFlags);
+
+    return IsBooleanFlagOn(rFlags, RFLAGS_INTERRUPT_FLAG_BIT);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrDisable(
+    void
+    )
+{
+    return CpuIntrSetState(FALSE);
+}
+
+__forceinline
+extern
+INTR_STATE
+CpuIntrEnable(
+    void
+    )
+{
+    return CpuIntrSetState(TRUE);
+}
+
+typedef BYTE APIC_ID;
+
+__forceinline
+extern
+APIC_ID
+CpuGetApicId(
+    void
+    )
+{
+    CPUID_INFO cpuId;
+
+    __cpuid(cpuId.values, CpuidIdxFeatureInformation);
+
+    return cpuId.FeatureInformation.ebx.ApicId;
+}
+
+__forceinline
+extern
+BOOLEAN
+CpuIsIntel(
+    void
+    )
+{
+    CPUID_INFO cpuId;
+
+    __cpuid(cpuId.values, CpuidIdxBasicInformation);
+
+    return ( cpuId.ebx == 'uneG' &&
+             cpuId.edx == 'Ieni' &&
+             cpuId.ecx == 'letn' );
+}
diff --git a/src_proiect/HAL/inc/cpuid_leaf.h b/src_proiect/HAL/inc/cpuid_leaf.h
new file mode 100644
index 0000000..a9412cf
--- /dev/null
+++ b/src_proiect/HAL/inc/cpuid_leaf.h
@@ -0,0 +1,376 @@
+#pragma once
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used : nameless struct/union
+#pragma warning(disable:4201)
+
+typedef enum _CPUID_IDX
+{
+    CpuidIdxBasicInformation                    = 0x0,
+    CpuidIdxFeatureInformation,
+    CpuidIdxMonitorLeaf                         = 0x5,
+    CpuidIdxStructuredExtendedFeaturesLeaf      = 0x7,
+    CpuidIdxArchPerfMonLeaf                     = 0xA,
+    CpuidIdxExtendedStateEnumerationMainLeaf    = 0xD,
+    CpuidIdxExtendedMaxFunction                 = 0x8000'0000,
+    CpuidIdxExtendedFeatureInformation          = 0x8000'0001,
+    CpuidIdxProcessorAddressSizes               = 0x8000'0008,
+} CPUID_IDX;
+
+// CPUID related information
+
+// 0x0
+typedef struct _CPUID_BASIC_INFORMATION
+{
+    DWORD           MaxValueForBasicInfo;
+    DWORD           CpuIdString0;
+    DWORD           CpuidString2;
+    DWORD           CpuidString1;
+} CPUID_BASIC_INFORMATION, *PCPUID_BASIC_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_BASIC_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x1
+typedef struct _CPUID_EBX_FEATURE_INFORMATION
+{
+    BYTE            BrandIndex;
+
+    // This value * 8 => cache line size in bytes ( used by CLFLUSHOPT too)
+    BYTE            CLFlushLineSize;
+
+    BYTE            MaxNumberOfAddressableIds;
+
+    BYTE            ApicId;
+} CPUID_EBX_FEATURE_INFORMATION, *PCPUID_EBX_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EBX_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_ECX_FEATURE_INFORMATION
+{
+    DWORD           SSE3                        :   1;
+    DWORD           PCLMULQDQ                   :   1;
+    DWORD           DTES64                      :   1;
+    DWORD           MONITOR                     :   1;
+    DWORD           DS_CPL                      :   1;
+    DWORD           VMX                         :   1;
+    DWORD           SMX                         :   1;
+    DWORD           EIST                        :   1;
+    DWORD           TM2                         :   1;
+    DWORD           SSSE3                       :   1;
+    DWORD           CNXT_ID                     :   1;
+    DWORD           SDBG                        :   1;
+    DWORD           FMA                         :   1;
+    DWORD           CMPXCHG16B                  :   1;
+    DWORD           xTPRUpdateControl           :   1;
+    DWORD           PDCM                        :   1;
+    DWORD           __Reserved0                 :   1;
+    DWORD           PCID                        :   1;
+    DWORD           DCA                         :   1;
+    DWORD           SSE4_1                      :   1;
+    DWORD           SSE4_2                      :   1;
+    DWORD           x2APIC                      :   1;
+    DWORD           MOVBE                       :   1;
+    DWORD           POPCNT                      :   1;
+    DWORD           TSC_Deadline                :   1;
+    DWORD           AESNI                       :   1;
+    DWORD           XSAVE                       :   1;
+    DWORD           OSXSAVE                     :   1;
+    DWORD           AVX                         :   1;
+    DWORD           F16C                        :   1;
+    DWORD           RDRAND                      :   1;
+    DWORD           HV                          :   1;
+} CPUID_ECX_FEATURE_INFORMATION, *PCPUID_ECX_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_ECX_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_EDX_FEATURE_INFORMATION
+{
+    DWORD           FPU                         :   1;
+    DWORD           VME                         :   1;
+    DWORD           DE                          :   1;
+    DWORD           PSE                         :   1;
+    DWORD           TSC                         :   1;
+    DWORD           MSR                         :   1;
+    DWORD           PAE                         :   1;
+    DWORD           MCE                         :   1;
+    DWORD           CX8                         :   1;
+    DWORD           APIC                        :   1;
+    DWORD           __Reserved0                 :   1;
+    DWORD           SEP                         :   1;
+    DWORD           MTRR                        :   1;
+    DWORD           PGE                         :   1;
+    DWORD           MCA                         :   1;
+    DWORD           CMOV                        :   1;
+    DWORD           PAT                         :   1;
+    DWORD           PSE_36                      :   1;
+    DWORD           PSN                         :   1;
+    DWORD           CLFSH                       :   1;
+    DWORD           __Reserved1                 :   1;
+    DWORD           DS                          :   1;
+    DWORD           ACPI                        :   1;
+    DWORD           MMX                         :   1;
+    DWORD           FXSR                        :   1;
+    DWORD           SSE                         :   1;
+    DWORD           SSE2                        :   1;
+    DWORD           SS                          :   1;
+    DWORD           HTT                         :   1;
+    DWORD           TM                          :   1;
+    DWORD           __Reserved2                 :   1;
+    DWORD           PBE                         :   1;
+} CPUID_EDX_FEATURE_INFORMATION, *PCPUID_EDX_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EDX_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_FEATURE_INFORMATION
+{
+    DWORD                               eax;
+    CPUID_EBX_FEATURE_INFORMATION       ebx;
+    CPUID_ECX_FEATURE_INFORMATION       ecx;
+    CPUID_EDX_FEATURE_INFORMATION       edx;
+} CPUID_FEATURE_INFORMATION, *PCPUID_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_FEATURE_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x5
+typedef struct _CPUID_EAX_MONITOR_LEAF
+{
+    WORD                                SmallestMonitorLineSize;
+    WORD                                __Reserved0;
+} CPUID_EAX_MONITOR_LEAF, *PCPUID_EAX_MONITOR_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EAX_MONITOR_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_EBX_MONITOR_LEAF
+{
+    WORD                                LargestMonitorLineSize;
+    WORD                                __Reserved0;
+} CPUID_EBX_MONITOR_LEAF, *PCPUID_EBX_MONITOR_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EBX_MONITOR_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_MONITOR_LEAF
+{
+    CPUID_EAX_MONITOR_LEAF              eax;
+    CPUID_EBX_MONITOR_LEAF              ebx;
+    DWORD                               ecx;
+    DWORD                               edx;
+} CPUID_MONITOR_LEAF, *PCPUID_MONITOR_LEAF;
+STATIC_ASSERT(sizeof(CPUID_MONITOR_LEAF) == sizeof(DWORD) * 4);
+
+// 0x7, 0x0
+typedef struct _CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF
+{
+    DWORD                               FSGSBASE                                : 1;
+    DWORD                               IA32_TSC_ADJUST_MSR                     : 1;
+    DWORD                               SGX                                     : 1;
+    DWORD                               BMI1                                    : 1;
+    DWORD                               HLE                                     : 1;
+    DWORD                               AVX2                                    : 1;
+    DWORD                               FP_EXCEPTIN_ONLY                        : 1;
+    DWORD                               SMEP                                    : 1;
+    DWORD                               BMI2                                    : 1;
+    DWORD                               EnhancedRepMovsb                        : 1;
+    DWORD                               INVPCID                                 : 1;
+    DWORD                               RTM                                     : 1;
+    DWORD                               RDTM                                    : 1;
+    DWORD                               DeprecatesFpuDsCs                       : 1;
+    DWORD                               MPX                                     : 1;
+    DWORD                               RDTA                                    : 1;
+    DWORD                               __Reserved16_17                         : 2;
+    DWORD                               RDSEED                                  : 1;
+    DWORD                               ADX                                     : 1;
+    DWORD                               SMAP                                    : 1;
+    DWORD                               __Reserved21_22                         : 2;
+    DWORD                               CLFLUSHOPT                              : 1;
+    DWORD                               __Reserved24                            : 1;
+    DWORD                               ProcessorTrace                          : 1;
+    DWORD                               __Reserved26_28                         : 3;
+    DWORD                               SHA                                     : 1;
+    DWORD                               __Reserved30_31                         : 2;
+} CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF, *PCPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF
+{
+    DWORD                               PREFETCHWT1                             : 1;
+    DWORD                               __Reserved1                             : 1;
+    DWORD                               UMIP                                    : 1;
+    DWORD                               PKU                                     : 1;
+    DWORD                               OSPKE                                   : 1;
+    DWORD                               __Reserved5_16                          : 12;
+    DWORD                               MAWAU                                   : 5;
+    DWORD                               RDPID                                   : 1;
+    DWORD                               __Reserved23_29                         : 7;
+    DWORD                               SGX_LC                                  : 1;
+    DWORD                               __Reserved31                            : 1;
+} CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF, *PCPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF;
+STATIC_ASSERT(sizeof(CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF
+{
+    DWORD                                               MaxSubleaf;
+    CPUID_EBX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    ebx;
+    CPUID_ECX_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    ecx;
+    DWORD                                               __Reserved;
+} CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF, *PCPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF;
+STATIC_ASSERT(sizeof(CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF) == sizeof(DWORD) * 4);
+
+// 0xA
+typedef struct _CPUID_EAX_ARCH_PERF_MON_LEAF
+{
+    BYTE                                VersionId;
+    BYTE                                NumberOfPmcsPerCpu;
+    BYTE                                BitWidth;
+    BYTE                                LengthOfEbxBitVector;
+} CPUID_EAX_ARCH_PERF_MON_LEAF, *PCPUID_EAX_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EAX_ARCH_PERF_MON_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_EBX_ARCH_PERF_MON_LEAF
+{
+    DWORD                               CoreCycleEventNotAvail                  : 1;
+    DWORD                               InstructionRetiredEventNotAvail         : 1;
+    DWORD                               ReferenceCyclesEventNotAvail            : 1;
+    DWORD                               LastLevelCacheReferenceEventNotAvail    : 1;
+    DWORD                               LastLevelCacheMissesEventNotAvail       : 1;
+    DWORD                               BranchInstructionRetiredEventNotAvail   : 1;
+    DWORD                               BranchMispredictRetiredEventNotAvail    : 1;
+    DWORD                               __Reserved7_31                          : 25;
+} CPUID_EBX_ARCH_PERF_MON_LEAF, *PCPUID_EBX_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EBX_ARCH_PERF_MON_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_EDX_ARCH_PERF_MON_LEAF
+{
+    // If VersionID > 1
+    DWORD                               NoOfFixedPmcs                           : 5;
+
+    // If VersionID > 1
+    DWORD                               BitWidthOfFixedPmcs                     : 8;
+
+    DWORD                               __Reserved13_31                         : 19;
+} CPUID_EDX_ARCH_PERF_MON_LEAF, *PCPUID_EDX_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EDX_ARCH_PERF_MON_LEAF) == sizeof(DWORD));
+
+typedef struct _CPUID_ARCH_PERF_MON_LEAF
+{
+    CPUID_EAX_ARCH_PERF_MON_LEAF        eax;
+    CPUID_EBX_ARCH_PERF_MON_LEAF        ebx;
+    DWORD                               ecx;
+    CPUID_EDX_ARCH_PERF_MON_LEAF        edx;
+} CPUID_ARCH_PERF_MON_LEAF, *PCPUID_ARCH_PERF_MON_LEAF;
+STATIC_ASSERT(sizeof(CPUID_ARCH_PERF_MON_LEAF) == sizeof(DWORD) * 4);
+
+// 0xD
+typedef struct _CPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF
+{
+    DWORD                               Xcr0FeatureSupportLow;
+
+    DWORD                               MaxSizeRequiredByFeaturesInXcr0;
+
+    DWORD                               MaxSizeRequiredByFeaturesSupportedByCpu;
+
+    DWORD                               Xcr0FeatureSupportHigh;
+} CPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF, *PCPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF;
+STATIC_ASSERT(sizeof(CPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF) == sizeof(DWORD) * 4);
+
+// 0x8000'0000
+typedef struct _CPUID_EXTENDED_CPUID_INFORMATION
+{
+    DWORD                               MaxValueForExtendedInfo;
+    DWORD                               __Reserved0;
+    DWORD                               __Reserved1;
+    DWORD                               __Reserved2;
+} CPUID_EXTENDED_CPUID_INFORMATION, *PCPUID_EXTENDED_CPUID_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EXTENDED_CPUID_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x8000'0001
+typedef struct _CPUID_ECX_EXTENDED_FEATURE_INFORMATION
+{
+    DWORD                               LahfSahf            : 1;
+    DWORD                               __Reserved0         : 4;
+    DWORD                               LZCNT               : 1;
+    DWORD                               __Reserved1         : 2;
+    DWORD                               PREFETCHW           : 1;
+    DWORD                               __Reserved2         : 23;
+} CPUID_ECX_EXTENDED_FEATURE_INFORMATION, *PCPUID_ECX_EXTENDED_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_ECX_EXTENDED_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_EDX_EXTENDED_FEATURE_INFORMATION
+{
+    DWORD                               __Reserved0         : 11;
+    DWORD                               Syscall             : 1;
+    DWORD                               __Reserved1         : 8;
+    DWORD                               ExecuteDisable      : 1;
+    DWORD                               __Reserved2         : 5;
+    DWORD                               LargePages          : 1;
+    DWORD                               RDTSCP              : 1;
+    DWORD                               __Reserved3         : 1;
+    DWORD                               Intel64             : 1;
+    DWORD                               __Reserved4         : 2;
+} CPUID_EDX_EXTENDED_FEATURE_INFORMATION, *PCPUID_EDX_EXTENDED_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EDX_EXTENDED_FEATURE_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_EXTENDED_FEATURE_INFORMATION
+{
+    DWORD                                   ExtendedProcessorSignature;
+    DWORD                                   __Reserved;
+    CPUID_ECX_EXTENDED_FEATURE_INFORMATION  ecx;
+    CPUID_EDX_EXTENDED_FEATURE_INFORMATION  edx;
+} CPUID_EXTENDED_FEATURE_INFORMATION, *PCPUID_EXTENDED_FEATURE_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EXTENDED_FEATURE_INFORMATION) == sizeof(DWORD) * 4);
+
+// 0x8000'0008
+typedef struct _CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION
+{
+    BYTE                                    PhysicalAddressBits;
+    BYTE                                    LinearAddressBits;
+    WORD                                    __Reserved;
+} CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION, *PCPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION) == sizeof(DWORD));
+
+typedef struct _CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION
+{
+    CPUID_EAX_PROCESSOR_ADDRESS_SIZES_INFORMATION   eax;
+    DWORD                                           __Reserved0;
+    DWORD                                           __Reserved1;
+    DWORD                                           __Reserved2;
+} CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION, *PCPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION;
+STATIC_ASSERT(sizeof(CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION) == sizeof(DWORD) * 4);
+
+// structure retrieved by __cpuid operations
+typedef struct _CPUID_INFO
+{
+    union {
+        int values[4];
+        struct {
+            DWORD eax;
+            DWORD ebx;
+            DWORD ecx;
+            DWORD edx;
+        };
+        // 0x0
+        CPUID_BASIC_INFORMATION                     BasicInformation;
+
+        // 0x1
+        CPUID_FEATURE_INFORMATION                   FeatureInformation;
+
+        // 0x5
+        CPUID_MONITOR_LEAF                          MonitorLeaf;
+
+        // 0x7
+        CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    StructuredExtendedFeatures;
+
+        // 0xA
+        CPUID_ARCH_PERF_MON_LEAF                    ArchitecturalPerfMonLeaf;
+
+        // 0xD
+        CPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF  ExtendedStateMainLeaf;
+
+        // 0x8000'0000
+        CPUID_EXTENDED_CPUID_INFORMATION            ExtendedInformation;
+
+        // 0x8000'0001
+        CPUID_EXTENDED_FEATURE_INFORMATION          ExtendedFeatures;
+
+        // 0x8000'0008
+        CPUID_PROCESSOR_ADDRESS_SIZES_INFORMATION   CpuAddressSizes;
+    };
+} CPUID_INFO, *PCPUID_INFO;
+STATIC_ASSERT(sizeof(CPUID_INFO) == sizeof(DWORD) * 4);
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/HAL/inc/gdt.h b/src_proiect/HAL/inc/gdt.h
new file mode 100644
index 0000000..67a7dc9
--- /dev/null
+++ b/src_proiect/HAL/inc/gdt.h
@@ -0,0 +1,187 @@
+#pragma once
+
+#define PREDEFINED_GDT_SIZE                     10
+#define PREDEFINED_GDT32_SIZE                   6
+#define PREDEFINED_TSS_DESC_SIZE                16
+#define PREDEFINED_SEG_DESC_SIZE                8
+
+
+// Privilege levels
+#define RING_ZERO_PL                0
+#define RING_THREE_PL               3
+
+#define NO_OF_PRIVILLEGE_LEVELS     3
+
+// If the S bit is 0 these apply to the Type field of the descriptor
+// 3.5, Vol 3, No. 56
+typedef enum _SYSTEM_SEGMENT_TYPES
+{
+    SystemSegmentLDT = 2,
+    SystemSegment64BitTssAvailable = 9,
+    SystemSegment64BitTssBusy = 11,
+    SystemSegment64BitTaskGate = 12,
+    SystemSegment64BitInterruptGate = 14,
+    SystemSegment64BitTrapGate = 15
+} SYSTEM_SEGMENT_TYPES;
+
+// If the S bit is 1 these apply to the Type field of the descriptor
+// 3.4.5.1, Vol 3, No. 56
+typedef enum _NON_SYSTEM_SEGMENT_TYPES
+{
+    // data segments
+    NonSystemSegmentDataReadOnly,
+    NonSystemSegmentDataReadOnlyAccessed,
+    NonSystemSegmentDataReadWrite,
+    NonSystemSegmentDataReadWriteAccessed,
+    NonSystemSegmentDataReadOnlyExpandDown,
+    NonSystemSegmentDataReadOnlyExpandDownAccessed,
+    NonSystemSegmentDataReadWriteExpandDown,
+    NonSystemSegmentDataReadWriteExpandDownAccessed,
+
+    // code segments
+    NonSystemSegmentCodeExecuteOnly,
+    NonSystemSegmentCodeExecuteOnlyAccessed,
+    NonSystemSegmentCodeExecuteRead,
+    NonSystemSegmentCodeExecuteReadAccessed,
+    NonSystemSegmentCodeExecuteOnlyConforming,
+    NonSystemSegmentCodeExecuteOnlyConformingAccessed,
+    NonSystemSegmentCodeExecuteReadConforming,
+    NonSystemSegmentCodeExecuteReadConformingAccessed
+} NON_SYSTEM_SEGMENT_TYPES;
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+//warning C4214: nonstandard extension used : bit field types other than int
+#pragma warning(disable:4214)
+
+// 3.4.5, Vol 3, No. 56
+typedef struct _SEGMENT_DESCRIPTOR
+{
+    // 15:0
+    WORD                SegmentLimitLow;            // Segment Limit 15:0
+
+                                                    // 31:16
+    WORD                BaseAddressLow;             // Base Address 15:0
+
+                                                    // 39:32
+    BYTE                BaseAddressMid;             // Base Address 23:16
+
+                                                    // 43:40
+    BYTE                Type                : 4;
+
+    // 44
+    BYTE                DescriptorType      : 1;    // (0 = System; 1 = code or data)
+
+                                                    // 46:45
+    BYTE                DPL                 : 2;
+
+    // 47
+    BYTE                Present             : 1;
+
+    // 51:48
+    BYTE                SegmentLimitHigh    : 4;    // Segment Limit 19:16
+
+                                                    // 52
+    BYTE                AVL                 : 1;    // Available for use by system SW
+
+                                                    // 53
+    BYTE                L                   : 1;    // 1 = 64-bit code segment
+
+                                                    // 54
+    BYTE                D_B                 : 1;    // Default Operation Size
+
+                                                    // 55
+    BYTE                G                   : 1;    // granularity
+
+                                                    // 63:56
+    BYTE                BaseAddressHigh;            // Base Address 31:24
+
+} SEGMENT_DESCRIPTOR, *PSEGMENT_DESCRIPTOR;
+STATIC_ASSERT(sizeof(SEGMENT_DESCRIPTOR) == PREDEFINED_SEG_DESC_SIZE);
+
+typedef struct _GDT32
+{
+    WORD                Limit;
+
+    DWORD               Base;
+} GDT32, *PGDT32;
+STATIC_ASSERT(sizeof(GDT32) == PREDEFINED_GDT32_SIZE);
+
+typedef struct _GDT
+{
+    // IDTR(Limit) <-- SRC[0:15];
+    WORD                    Limit;
+
+    // IDTR(Base)  <-- SRC[16:79];
+    SEGMENT_DESCRIPTOR*     Base;
+} GDT, *PGDT;
+STATIC_ASSERT(sizeof(GDT) == PREDEFINED_GDT_SIZE);
+#pragma warning(pop)
+#pragma pack(pop)
+
+typedef enum _SEGMENT_DESCRIPTOR_FLAGS
+{
+    SegmentDescriptorFlagRing0,
+    SegmentDescriptorLongMode,
+    SegmentDescriptor32bitOperation,
+    SegmentDescriptorSystemDescriptor
+} SEGMENT_DESCRIPTOR_FLAGS;
+
+
+//******************************************************************************
+// Function:     GdtInitialize
+// Description:  Initializes HALs empty GDT table without loading it for
+//               system use.
+// Returns:      STATUS
+// Parameter:    void
+//******************************************************************************
+STATUS
+GdtInitialize(
+    void
+    );
+
+//******************************************************************************
+// Function:     GdtInstallDescriptor
+// Description:  Installs a new descriptor in the GDT table at the specified
+//               index. The limit is automatically set to MAX_DWORD for non-TSS
+//               entries and to the size of the TSS in case such a segment is
+//               installed.
+// Returns:      STATUS
+// Parameter:    IN WORD GdtIndex - BYTE-counted index in the GDT.
+// Parameter:    IN QWORD Base - Should be 0 for non-TSS descriptors.
+// Parameter:    IN BYTE Type
+// Parameter:    IN SEGMENT_DESCRIPTOR_FLAGS Flags
+//******************************************************************************
+STATUS
+GdtInstallDescriptor(
+    IN          WORD                        GdtIndex,
+    IN          QWORD                       Base,
+    IN          BYTE                        Type,
+    IN          SEGMENT_DESCRIPTOR_FLAGS    Flags
+    );
+
+//******************************************************************************
+// Function:     GdtIsSegmentPrivileged
+// Description:  Checks if a segment selector is privileged (ring 0) or not.
+// Returns:      BOOLEAN - TRUE if the selector is privileged, FALSE otherwise
+// Parameter:    IN WORD Selector
+//******************************************************************************
+BOOLEAN
+GdtIsSegmentPrivileged(
+    IN          WORD            Selector
+    );
+
+//******************************************************************************
+// Function:     GdtReload
+// Description:  Reloads GDT with specified code and data selector.
+// Returns:      void
+// Parameter:    IN WORD CodeSelector
+// Parameter:    IN WORD DataSelector
+//******************************************************************************
+void
+GdtReload(
+    IN          WORD            CodeSelector,
+    IN          WORD            DataSelector
+    );
diff --git a/src_proiect/HAL/inc/hal.h b/src_proiect/HAL/inc/hal.h
new file mode 100644
index 0000000..b64a83e
--- /dev/null
+++ b/src_proiect/HAL/inc/hal.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "yasm_imports.h"
+
+//******************************************************************************
+// Function:     HalInitialize
+// Description:  Initializes the HAL library. Must be called before any other
+//               HAL function.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+HalInitialize(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/hw_fpu.h b/src_proiect/HAL/inc/hw_fpu.h
new file mode 100644
index 0000000..da93d80
--- /dev/null
+++ b/src_proiect/HAL/inc/hw_fpu.h
@@ -0,0 +1,105 @@
+#pragma once
+
+#define INCLUDE_FP_SUPPORT                  0
+
+typedef QWORD XCR0_SAVED_STATE;
+
+#define XCR0_SAVED_STATE_x87_MMX            (1ULL<<0)
+#define XCR0_SAVED_STATE_SSE                (1ULL<<1)
+#define XCR0_SAVED_STATE_AVX                (1ULL<<2)
+#define XCR0_SAVED_STATE_BNDREG             (1ULL<<3)
+#define XCR0_SAVED_STATE_BNDCSR             (1ULL<<4)
+#define XCR0_SAVED_STATE_OPMASK             (1ULL<<5)
+#define XCR0_SAVED_STATE_ZMM_HI256          (1ULL<<6)
+#define XCR0_SAVED_STATE_HI16_ZMM           (1ULL<<7)
+#define XCR0_SAVED_STATE_PKRU               (1ULL<<9)
+
+#pragma pack(push)
+#pragma pack(1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+typedef struct _M128A
+{
+    QWORD                   Low;
+    QWORD                   High;
+} M128A, *PM128A;
+
+//
+// Format of data for (F)XSAVE/(F)XRSTOR instruction
+//
+#define PREDEFINED_XSAVE_LEGACY_REGION_SIZE         0x200
+
+typedef struct  _XSAVE_LEGACY_REGION
+{
+    WORD                        ControlWord;
+    WORD                        StatusWord;
+    BYTE                        TagWord;
+    BYTE                        Reserved1;
+    WORD                        ErrorOpcode;
+    DWORD                       ErrorOffset;
+    WORD                        ErrorSelector;
+    WORD                        Reserved2;
+    DWORD                       DataOffset;
+    WORD                        DataSelector;
+    WORD                        Reserved3;
+    DWORD                       MxCsr;
+    DWORD                       MxCsr_Mask;
+    M128A                       FloatRegisters[8];
+    M128A                       XmmRegisters[16];
+    BYTE                        Reserved4[96];
+} XSAVE_LEGACY_REGION, *PXSAVE_LEGACY_REGION;
+STATIC_ASSERT_INFO(sizeof(XSAVE_LEGACY_REGION) == PREDEFINED_XSAVE_LEGACY_REGION_SIZE,
+    "Intel Software Developer Manual Vol 1 Section 13.4.1 Legacy Region of an XSAVE Area");
+
+#define PREDEFINED_XSAVE_AREA_HEADER_SIZE           0x40
+
+typedef struct  _XSAVE_AREA_HEADER
+{
+    QWORD                       Mask;
+    QWORD                       Reserved[7];
+} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;
+STATIC_ASSERT_INFO(sizeof(XSAVE_AREA_HEADER) == PREDEFINED_XSAVE_AREA_HEADER_SIZE,
+    "Intel Software Developer Manual Vol 1 Section 13.4.2 XSAVE Header");
+
+#define HAL_MAX_SUPPORTED_XSAVE_AREA_SIZE           0x3C0
+#define XSAVE_AREA_REQUIRED_ALIGNMENT               0x40
+
+#define HAL_XSAVE_AREA_RESERVED_SIZE                (HAL_MAX_SUPPORTED_XSAVE_AREA_SIZE+XSAVE_AREA_REQUIRED_ALIGNMENT)
+
+typedef union _XSAVE_AREA
+{
+    struct
+    {
+        XSAVE_LEGACY_REGION     LegacyState;
+        XSAVE_AREA_HEADER       Header;
+    };
+    BYTE                        __Reserved[HAL_XSAVE_AREA_RESERVED_SIZE];
+} XSAVE_AREA, *PXSAVE_AREA;
+STATIC_ASSERT(sizeof(XSAVE_AREA) == HAL_XSAVE_AREA_RESERVED_SIZE);
+
+#pragma warning(pop)
+#pragma pack(pop)
+
+// This function is expected to be called very, very early, it does not
+// call any other function and has optimizations turned off explicitly
+// to make sure the compiler doesn't generate SSE instructions before
+// actually activating SSE support :)
+void
+HalActivateFpu(
+    void
+    );
+
+// This function must be called after HalActivateFpu
+STATUS
+HalSetActiveFpuFeatures(
+    _In_        XCR0_SAVED_STATE            Features
+    );
+
+XCR0_SAVED_STATE
+HalGetActiveFpuFeatures(
+    _Out_opt_   DWORD*                      ActivatedFeaturesSaveSize,
+    _Out_opt_   DWORD*                      AvailableFeaturesSaveSize
+    );
diff --git a/src_proiect/HAL/inc/idt.h b/src_proiect/HAL/inc/idt.h
new file mode 100644
index 0000000..808fb00
--- /dev/null
+++ b/src_proiect/HAL/inc/idt.h
@@ -0,0 +1,42 @@
+#pragma once
+
+
+//******************************************************************************
+// Function:     IdtInitialize
+// Description:  Initializes the IDT with empty entries and loads the IDT for
+//               system use.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+IdtInitialize(
+    void
+    );
+
+//******************************************************************************
+// Function:     IdtInstallDescriptor
+// Description:  Install a descriptor in the IDT table.
+// Returns:      STATUS
+// Parameter:    IN BYTE InterruptIndex - Index at which to install interrupt
+// Parameter:    IN WORD CodeSelector
+// Parameter:    IN BYTE GateType
+// Parameter:    IN BYTE InterruptStackIndex
+// Parameter:    IN BOOLEAN Present
+// Parameter:    IN PVOID HandlerAddress - Address of interrupt handler
+//******************************************************************************
+STATUS
+IdtInstallDescriptor(
+    IN                  BYTE            InterruptIndex,
+    IN                  WORD            CodeSelector,
+    IN                  BYTE            GateType,
+    IN                  BYTE            InterruptStackIndex,
+    IN                  BOOLEAN         Present,
+    _When_(Present, IN) 
+    _When_(!Present,IN_OPT) 
+    PVOID           HandlerAddress
+    );
+
+void
+IdtReload(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/int15.h b/src_proiect/HAL/inc/int15.h
new file mode 100644
index 0000000..620f4ef
--- /dev/null
+++ b/src_proiect/HAL/inc/int15.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#pragma pack(push,1)
+typedef enum _MEMORY_MAP_TYPE
+{
+    MemoryMapTypeUsableRAM = 1,
+    MemoryMapTypeReserved,
+    MemoryMapTypeACPIReclaimable,
+    MemoryMapTypeACPINVSMemory,
+    MemoryMapTypeBadMemory,
+    MemoryMapTypeMax = MemoryMapTypeBadMemory + 1
+} MEMORY_MAP_TYPE;
+
+#define MEMORY_MAP_ENTRY_EA_VALID_ENTRY             ((DWORD)1<<0)
+#define MEMORY_MAP_ENTRY_EA_NON_VOLATILE            ((DWORD)1<<1)
+
+typedef struct _INT15_MEMORY_MAP_ENTRY
+{
+    QWORD           BaseAddress;
+    QWORD           Length;
+    DWORD           Type;
+    DWORD           ExtendedAttributes;
+} INT15_MEMORY_MAP_ENTRY, *PINT15_MEMORY_MAP_ENTRY;
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/ioapic.h b/src_proiect/HAL/inc/ioapic.h
new file mode 100644
index 0000000..5ecaaf5
--- /dev/null
+++ b/src_proiect/HAL/inc/ioapic.h
@@ -0,0 +1,56 @@
+#pragma once
+
+#include "apic_common.h"
+
+#define IO_APIC_VERSION_PCI_22_COMPLIANT        0x20
+
+BYTE
+IoApicGetId(
+    IN      PVOID                   IoApic
+    );
+
+BYTE
+IoApicGetVersion(
+    IN      PVOID                   IoApic
+    );
+
+BYTE
+IoApicGetMaximumRedirectionEntry(
+    IN      PVOID                   IoApic
+    );
+
+void
+IoApicSetRedirectionTableEntry(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Index,
+    IN      BYTE                    Vector,
+    IN _Strict_type_match_
+            APIC_DESTINATION_MODE   DestinationMode,
+    IN      BYTE                    Destination,
+    IN _Strict_type_match_
+            APIC_DELIVERY_MODE      DeliveryMode,
+    IN _Strict_type_match_
+            APIC_PIN_POLARITY       PinPolarity,
+    IN _Strict_type_match_
+            APIC_TRIGGER_MODE       TriggerMode
+    );
+
+BYTE
+IoApicGetRedirectionTableEntryVector(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Index
+    );
+
+void
+IoApicSetRedirectionTableEntryMask(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Index,
+    IN      BOOLEAN                 Masked
+    );
+
+__declspec(deprecated)
+void
+IoApicSendEOI(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Vector
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/lapic.h b/src_proiect/HAL/inc/lapic.h
new file mode 100644
index 0000000..8ddbc06
--- /dev/null
+++ b/src_proiect/HAL/inc/lapic.h
@@ -0,0 +1,103 @@
+#pragma once
+
+#include "cpu.h"
+#include "apic_common.h"
+
+void
+LapicInitialize(
+    IN      PVOID                           ApicBaseAddress
+    );
+
+void
+LapicSetLogicalApicId(
+    IN      PVOID                           ApicBaseAddress,
+    IN      _Strict_type_match_
+            APIC_ID                         LogicalApicId,
+    IN      BYTE                            DestinationFormat
+    );
+
+// Disables or enables the LAPIC in SW
+void
+LapicSetState(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            SpuriousInterruptVector,
+    IN      BOOLEAN                         Enable
+    );
+
+BOOLEAN
+LapicGetState(
+    IN      PVOID                           ApicBaseAddress
+    );
+
+void
+LapicConfigureTimer(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            TimerInterruptVector,
+    IN     _Strict_type_match_
+            APIC_DIVIDE_VALUE               DivideValue
+    );
+
+void
+LapicSetTimerInterval(
+    IN      PVOID                           ApicBaseAddress,
+    IN      DWORD                           TimerCount
+    );
+
+void
+LapicConfigureLvtRegisters(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            ErrorInterruptVector
+    );
+
+void
+LapicSendEOI(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            Vector
+    );
+
+void
+LapicSendIpi(
+    IN      PVOID                           ApicBaseAddress,
+    IN      _Strict_type_match_
+            APIC_ID                         ApicId,
+    IN      _Strict_type_match_
+            APIC_DELIVERY_MODE              DeliveryMode,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_SHORTHAND      DestinationShorthand,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_MODE           DestinationMode,
+    IN_OPT  BYTE*                           Vector
+    );
+
+BYTE
+LapicGetPpr(
+    IN      PVOID                           ApicBaseAddress
+    );
+
+DWORD
+LapicGetTimerCount(
+    IN      PVOID                           ApicBaseAddress
+    );
+
+// new functions
+PHYSICAL_ADDRESS
+LapicGetBasePhysicalAddress(
+    void
+    );
+
+void
+LapicDetermineDividedBusFrequency(
+    IN      PVOID                           ApicBaseAddress,
+    OUT     DWORD*                          DividedBusFrequency
+    );
+
+DWORD
+LapicGetErrorRegister(
+    IN      PVOID                           ApicBaseAddress
+    );
+
+BOOLEAN
+LapicIsInterruptServiced(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            Vector
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/msr.h b/src_proiect/HAL/inc/msr.h
new file mode 100644
index 0000000..c328531
--- /dev/null
+++ b/src_proiect/HAL/inc/msr.h
@@ -0,0 +1,327 @@
+#pragma once
+
+#define     MSR_DATA_SIZE                       0x8
+
+// specifies the filter size of the MONITOR instruction
+#define     IA32_MONITOR_FILTER_SIZE_MSR            0x00000006
+
+#define     IA32_APIC_BASE_MSR                  0x0000001B
+
+// IA32_FEATURE_CONTROL
+
+// Bit 20       - LMCE On
+// Bit 15       - SENTER global enable
+// Bits 14:8    - SENTER local function enable
+// Bit 2        - Enable VMX outside SMX operation
+// Bit 1        - Enable VMX inside SMX operation
+// Bit 0        - If 1 => locked => cannot write to this MSR
+#define     IA32_FEATURE_VMX_OUTSIDE_SMX        ((QWORD)1<<2)
+#define     IA32_FEATURE_VMX_INSIDE_SMX         ((QWORD)1<<1)
+#define     IA32_FEATURE_LOCKED                 ((QWORD)1<<0)
+
+#define     IA32_FEATURE_CONTROL                0x0000003A
+
+#define     IA32_PMC0                           0x000000C1
+// ...
+#define     IA32_PMC7                           0x000000C8
+
+// IA32_MTRRCAP
+
+#define     IA32_MTRRCAP                        0x000000FE
+
+#define     IA32_SYSENTER_CS                    0x00000174
+#define     IA32_SYSENTER_ESP                   0x00000175
+#define     IA32_SYSENTER_EIP                   0x00000176
+
+#define     IA32_PERFEVTSEL0                    0x00000186
+
+// IA32_MISC_ENABLE
+#define     IA32_MISC_ENABLE_PERF_MON_AVL       ((QWORD)1<<7)
+#define     IA32_MISC_ENABLE_BTS_UNAVL          ((QWORD)1<<11)
+#define     IA32_MISC_ENABLE_PEBS_UNAVL         ((QWORD)1<<12)
+
+#define     IA32_MISC_ENABLE                    0x000001A0
+
+// MSR_LBR_SELECT
+#define     IA32_MSR_LBR_SELECT                 0x000001C8
+#define     IA32_MSR_LASTBRANCH_TOS             0x000001C9
+
+#define     IA32_DEBUGCTL_LBR                       ((QWORD)1<<0)
+#define     IA32_DEBUGCTL_TR                        ((QWORD)1<<6)
+#define     IA32_DEBUGCTL_BTS                       ((QWORD)1<<7)
+#define     IA32_DEBUGCTL_BTINT                     ((QWORD)1<<8)
+#define     IA32_DEBUGCTL_BTS_OFF_OS                ((QWORD)1<<9)
+#define     IA32_DEBUGCTL_BTS_OFF_USR               ((QWORD)1<<10)
+#define     IA32_DEBUGCTL_FREEZE_LBR_ON_PMI         ((QWORD)1<<11)
+#define     IA32_DEBUGCTL_FREEZE_PERF_MON_ON_PMI    ((QWORD)1<<12)
+
+#define     IA32_DEBUGCTL                       0x000001D9
+
+// IA32_MTRR_PHYSBASE0
+// IA32_MTRR_PHYSMASK0
+// each variable length MTRR register is mapped in pair
+// and currently(Vol 30, Sept 14) there are until register9
+
+#define     IA32_MTRR_BASE_MEMORY_TYPE          (MAX_BYTE)
+
+#define     IA32_MTRR_PHYSBASE0                 0x00000200
+
+#define     IA32_MTRR_MASK_VALID_MASK           ((QWORD)1<<11)
+
+#define     IA32_MTRR_PHYSMASK0                 0x00000201
+
+
+#define     IA32_MTRR_PHYSBASE9                 0x00000212
+#define     IA32_MTRR_PHYSMASK9                 0x00000213
+
+// IA32_MTRR_FIX64K_00000
+
+#define     IA32_MTRR_FIX64K_00000              0x00000250
+
+// IA32_MTRR_FIX16K_80000
+
+#define     IA32_MTRR_FIX16K_80000              0x00000258
+
+// IA32_MTRR_FIX16K_A0000
+
+#define     IA32_MTRR_FIX16K_A0000              0x00000259
+
+// IA32_MTRR_FIX4K_C0000
+
+#define     IA32_MTRR_FIX4K_C0000               0x00000268
+
+// IA32_MTRR_FIX4K_C8000
+
+#define     IA32_MTRR_FIX4K_C8000               0x00000269
+
+// IA32_MTRR_FIX4K_D0000
+
+#define     IA32_MTRR_FIX4K_D0000               0x0000026A
+
+// IA32_MTRR_FIX4K_D8000
+
+#define     IA32_MTRR_FIX4K_D8000               0x0000026B
+
+// IA32_MTRR_FIX4K_E0000
+
+#define     IA32_MTRR_FIX4K_E0000               0x0000026C
+
+// IA32_MTRR_FIX4K_E8000
+
+#define     IA32_MTRR_FIX4K_E8000               0x0000026D
+
+// IA32_MTRR_FIX4K_F0000
+
+#define     IA32_MTRR_FIX4K_F0000               0x0000026E
+
+// IA32_MTRR_FIX4K_F8000
+
+#define     IA32_MTRR_FIX4K_F8000               0x0000026F
+
+// IA32_PAT
+
+#define     IA32_PAT                            0x00000277
+
+
+// IA32_MTRR_DEF_TYPE
+#define     IA32_MTRR_DEFAULT_MEMORY_MASK       ((QWORD)0x7)
+#define     IA32_FIXED_MTRR_ENABLE_MASK         ((QWORD)1<<10)
+#define     IA32_MTRR_ENABLE_MASK               ((QWORD)1<<11)
+
+#define     IA32_MTRR_DEF_TYPE                  0x000002FF
+
+// PERF GLOBAL CONTROL
+#define     IA32_PERF_GLOBAL_CTRL_ENABLE_PMC_BIT_BASE   0
+
+#define     IA32_PERF_CAPABILITIES                  0x00000345
+#define     IA32_FIXED_CTR_CTRL                     0x0000038D
+#define     IA32_PERF_GLOBAL_STATUS                 0x0000038E
+#define     IA32_PERF_GLOBAL_CTRL                   0x0000038F
+#define     IA32_PERF_GLOBAL_OVF_CTRL               0x00000390
+#define     IA32_PERF_GLOBAL_STATUS_SET             0x00000391
+#define     IA32_PERF_GLOBAL_INUSE                  0x00000392
+#define     IA32_PEBS_ENABLE                        0x000003F1
+
+//
+//
+// VMX based MSR's
+//
+//
+
+// BASIC VMX Information (A.1)
+
+// Bit 55       - If 1 => supports TRUE based MSRs
+// Bit 54       - If 1 => VMEXIT due to INS/OUTS reported in
+//                VM-exit instruction-information field
+// Bits 53:50   - Memory type used to access VMCS and structures
+//                referenced by it
+//                  Value       Field
+//                  0           UC
+//                  6           WB
+// Bit 49       - If 1 => cpu supports dual-monitor etc...
+// Bit 48       - If 0 => addresses limited to processor physical width
+// Bits 44:32   - number of bytes to allocate for VMXON/VMCS region
+// Bit 31       - always 0
+// Bits 30:0    - 31 bit VMCS revision identifier
+#define     IA32_VMX_BASIC_MSR                  0x00000480
+
+// VM Execution Controls (A.3)
+
+// Pin-Base VM-Execution Controls (A.3.1)
+
+// if MSR[IA32_VMX_BASIC_MSR].55 = 1 => this MSR is useless
+//                                      read IA32_VMX_TRUE_PINBASED_CTLS MSR
+// Bits 63:32   - allows control X to be 1 if bit (X+32) in the MSR is cleared to 0
+// Bits 31:0    - allows control X to be 0 if bit X in the MSR is cleared to 0
+#define     IA32_VMX_PINBASED_CTLS              0x00000481
+
+// Primary Processor-Based VM-Execution Controls (A.3.2)
+
+// Same as for IA32_VMX_PINBASED_CTLS
+// if MSR[IA32_VMX_BASIC_MSR].55 = 1 => read IA32_VMX_TRUE_PROCBASED_CTLS MSR
+#define     IA32_VMX_PROCBASED_CTLS             0x00000482
+
+// VM-EXIT Controls (A.4)
+
+// Same as for IA32_VMX_PINBASED_CTLS
+// if MSR[IA32_VMX_BASIC_MSR].55 = 1 => read IA32_VMX_TRUE_EXIT_CTLS MSR
+#define     IA32_VMX_EXIT_CTLS                  0x00000483
+
+// VM-ENTRY Control (A.5)
+
+// Same as for IA32_VMX_PINBASED_CTLS
+// if MSR[IA32_VMX_BASIC_MSR].55 = 1 => read IA32_VMX_TRUE_ENTRY_CTLS MSR
+#define     IA32_VMX_ENTRY_CTLS                 0x00000484
+
+// MISCELLANEOUS Data (A.6)
+
+// Bits 63:32   - 32-bit MSEG revision identifier
+// Bit 29       - If 1 => SW can use VMWRITE to any supported field in VMCS
+// Bit 28       - If 1 => TODO (SMM related)
+// Bits 27:25   - Maximum number of MSR in store-list or load-list
+//                  Max_MSRs = 512 * ( N + 1 )
+// Bits 24:16   - number of CR3-target values supported by the processor
+// Bit 15       - If 1 => RDMSR can be used in SMM...
+// Bits 8:6     - A bitmap of activity states supported
+//                  Bit 6 => support for activity state 1 (HLT)
+//                  Bit 7 => support for activity state 2 (shutdown)
+//                  Bit 8 => support for activity state 3 (wait-for-SIPI)
+// Bit 5        - If 1 => IA32_EFER.LMA stored into "IA-32e mode guest"
+//                VM-Entry control
+// Bits 4:0     - VMX-preemption timer counts down by 1 every time bit X in
+//                the TSC changes due to a TSC increment
+#define     IA32_VMX_MISC                       0x00000485
+
+// VMX-Fixed Bits in CR0 (A.7)
+
+// Flexible if 0 in MSR[IA32_VMX_CRO_FIXED0].X and
+//             1 in MSR[IA32_VMX_CRO_FIXED1].X
+
+// If 1 => bit fixed to 1 in VMX operation
+#define     IA32_VMX_CRO_FIXED0                 0x00000486
+
+// If 0 => bit fixed to 0 in VMX operation
+#define     IA32_VMX_CRO_FIXED1                 0x00000487
+
+// VMX-Fixed bits in CR4 (A.8)
+
+// Flexible if 0 in MSR[IA32_VMX_CR4_FIXED0].X and
+//             1 in MSR[IA32_VMX_CR4_FIXED1].X
+
+// If 1 => bit fixed to 1 in VMX operation
+#define     IA32_VMX_CR4_FIXED0                 0x00000488
+
+// If 0 => bit fixed to 0 in VMX operation
+#define     IA32_VMX_CR4_FIXED1                 0x00000489
+
+// VMCS Enumeration (A.9)
+
+// Bits 14:13   - indicate the field's width
+// Bits 11:10   - indicate the field's type
+// Bits 9:1     - contains the highest index value used for
+//                any VMCS encoding
+#define     IA32_VMX_VMCS_ENUM                  0x0000048A
+
+// Secondary Processor-Based VM-Execution Controls (A.3.3)
+
+// Exists only if MSR[IA32_VMX_PROCBASED_CTLS].63 = 1
+// Same functioning as IA32_VMX_PROCBASED_CTLS
+#define     IA32_VMX_PROCBASED_CTLS2            0x0000048B
+
+// VPID and EPT capabilities (A.10)
+
+// Bit 43       - If 1 => single-context-retaining-globals INVVPID support
+// Bit 42       - If 1 => all-context INVVPID support
+// Bit 41       - If 1 => single-context INVVPID support
+// Bit 40       - If 1 => individual-address INVVPID support
+// Bit 32       - If 1 => INVVPID support
+// Bit 26       - If 1 => all-context INVEPT supported
+// Bit 25       - If 1 => single-context INVEPT supported
+// Bit 21       - If 1 => A&D flags for EPT supported
+// Bit 20       - If 1 => INVEPT support
+// Bit 17       - If 1 => EPT PDPTE can map 1-Gbyte page
+// Bit 16       - If 1 => EPT PDE can map 2-Mbyte page
+// Bit 14       - If 1 => EPT paging-structure can use WB MT
+// Bit 8        - If 1 => EPT paging-structure can use UC memory
+// Bit 6        - Support for page-walk length of 4
+// Bit 0        - If 1 => allows execute-only EPT mapping
+#define     IA32_VMX_EPT_VPID_CAP               0x0000048C
+
+#define     IA32_VMX_TRUE_PINBASED_CTLS         0x0000048D
+#define     IA32_VMX_TRUE_PROCBASED_CTLS        0x0000048E
+#define     IA32_VMX_TRUE_EXIT_CTLS             0x0000048F
+#define     IA32_VMX_TRUE_ENTRY_CTLS            0x00000490
+
+#define     IA32_DS_AREA                        0x00000600
+
+// VM Functions (A.11)
+
+// Exists only if       MSR[IA32_VMX_PROCBASED_CTLS ].63 = 1
+//                  AND MSR[IA32_VMX_PROCBASED_CTLS2].45 = 1
+
+// If bit X is set in MSR => VMFUNC for X is allowed
+#define     IA32_VMX_VMFUNC                     0x00000491
+
+#define     IA32_EFER_SCE                       ((QWORD)1<<0)
+#define     IA32_EFER_LME                       ((QWORD)1<<8)
+#define     IA32_EFER_LMA                       ((QWORD)1<<10)
+#define     IA32_EFER_NXE                       ((QWORD)1<<11)
+
+#define     IA32_EFER                           0xC0000080
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+typedef union _IA32_STAR_MSR_DATA
+{
+    struct
+    {
+        DWORD           __Reserved0;
+        WORD            SyscallCsDs;
+        WORD            SysretCsDs;
+    };
+    QWORD               Raw;
+} IA32_STAR_MSR_DATA, *PIA32_STAR_MSR_DATA;
+STATIC_ASSERT(sizeof(IA32_STAR_MSR_DATA) == MSR_DATA_SIZE);
+
+#pragma warning(pop)
+#pragma pack(pop)
+
+#define     IA32_STAR                           0xC0000081
+#define     IA32_LSTAR                          0xC0000082
+#define     IA32_FMASK                          0xC0000084
+
+// FS_BASE MSR
+#define     IA32_FS_BASE_MSR                    0xC0000100
+
+// GS_BASE MSR
+#define     IA32_GS_BASE_MSR                    0xC0000101
+
+// IA32_KERNEL_GS_BASE
+#define     IA32_KERNEL_GS_BASE                 0xC0000102
+
+#define     IA32_TSC_AUX                        0xC0000103
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/mtrr.h b/src_proiect/HAL/inc/mtrr.h
new file mode 100644
index 0000000..8ad2f6f
--- /dev/null
+++ b/src_proiect/HAL/inc/mtrr.h
@@ -0,0 +1,13 @@
+#pragma once
+
+typedef enum _MEMORY_CACHING
+{
+    MemoryCachingStrongUncacheable,
+    MemoryCachingWriteCombine       = 1,
+    MemoryCachingWriteThrough       = 4,
+    MemoryCachingWriteProtect,
+    MemoryCachingWriteBack,
+    MemoryCachingUncacheable,
+
+    MemoryCachingReserved           = MemoryCachingUncacheable + 1
+} MEMORY_CACHING, *PMEMORY_CACHING;
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/pci.h b/src_proiect/HAL/inc/pci.h
new file mode 100644
index 0000000..127cc9a
--- /dev/null
+++ b/src_proiect/HAL/inc/pci.h
@@ -0,0 +1,62 @@
+#pragma once
+
+#include "pci_registers.h"
+
+typedef struct _PCI_DEVICE_LOCATION
+{
+    BYTE                    Bus;
+    BYTE                    Device;
+    BYTE                    Function;
+} PCI_DEVICE_LOCATION, *PPCI_DEVICE_LOCATION;
+
+typedef union _PCI_DEVICE
+{
+    PCI_COMMON_HEADER       Header;
+    BYTE                    Data[PREDEFINED_PCI_DEVICE_SPACE_SIZE];
+} PCI_DEVICE, *PPCI_DEVICE;
+STATIC_ASSERT(sizeof(PCI_DEVICE) == PREDEFINED_PCI_DEVICE_SPACE_SIZE);
+
+typedef struct _PCI_DEVICE_DESCRIPTION
+{
+    PCI_DEVICE_LOCATION                 DeviceLocation;
+    BOOLEAN                             PciExpressDevice;
+    PPCI_DEVICE                         DeviceData;
+
+    // non-NULL for devices found behind bridges
+    struct _PCI_DEVICE_DESCRIPTION*     Parent;
+} PCI_DEVICE_DESCRIPTION, *PPCI_DEVICE_DESCRIPTION;
+
+//******************************************************************************
+// Function:     PciRetrieveNextDevice
+// Description:  Parses the PCI configuration space and retrieves the next
+//               device found on the bus. 
+// Returns:      STATUS - STATUS_DEVICE_NO_MORE_DEVICES if no more devices are
+//               present on the PCI bus.
+// Parameter:    IN BOOLEAN ResetSearch - If TRUE starts searching from bus = 0,
+//               device = 0 and function = 0, else continues from where the
+//               last call left of.
+// Parameter:    OUT PPCI_DEVICE PciDevice
+// NOTE:         If the whole configuration space has been traversed the
+//               function will return STATUS_DEVICE_NO_MORE_DEVICES until a call
+//               with ResetSearch == TRUE will be made.
+//******************************************************************************
+STATUS
+PciRetrieveNextDevice(
+    IN      BOOLEAN         ResetSearch,
+    IN      WORD            BytesToRead,
+    OUT_WRITES_BYTES_ALL(BytesToRead)
+            PPCI_DEVICE_DESCRIPTION     PciDevice
+    );
+
+DWORD
+PciReadConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      BYTE                    Register
+    );
+
+void
+PciWriteConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      BYTE                    Register,
+    IN      DWORD                   Value
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/pci_device.h b/src_proiect/HAL/inc/pci_device.h
new file mode 100644
index 0000000..c37e42c
--- /dev/null
+++ b/src_proiect/HAL/inc/pci_device.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "pci.h"
+#include "apic_common.h"
+
+STATUS
+PciDevRetrieveCapabilityById(
+    IN      PPCI_DEVICE             Device,
+    IN      PCI_CAPABILITY_ID       Id,
+    OUT_PTR PPCI_CAPABILITY_HEADER* Capability
+    );
+
+STATUS
+PciDevRetrieveNextCapability(
+    IN      PPCI_DEVICE             Device,
+    IN_OPT  PPCI_CAPABILITY_HEADER  PreviousCapability,
+    OUT_PTR PPCI_CAPABILITY_HEADER* NextCapability
+    );
+
+STATUS
+PciDevDisableLegacyInterrupts(
+    IN      PPCI_DEVICE_DESCRIPTION Device
+    );
+
+STATUS
+PciDevProgramMsiInterrupt(
+    IN      PPCI_DEVICE_DESCRIPTION Device,
+    IN      BYTE                    Vector,
+    IN _Strict_type_match_
+            APIC_DESTINATION_MODE   DestinationMode,
+    IN      BYTE                    Destination,
+    IN _Strict_type_match_
+            APIC_DELIVERY_MODE      DeliveryMode,
+    IN _Strict_type_match_
+            APIC_PIN_POLARITY       PinPolarity,
+    IN _Strict_type_match_
+            APIC_TRIGGER_MODE       TriggerMode
+);
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/pci_registers.h b/src_proiect/HAL/inc/pci_registers.h
new file mode 100644
index 0000000..2c3d9d0
--- /dev/null
+++ b/src_proiect/HAL/inc/pci_registers.h
@@ -0,0 +1,463 @@
+#pragma once
+
+#define PREDEFINED_PCI_DEVICE_SPACE_SIZE            256
+#define PREDEFINED_PCI_EXPRESS_DEVICE_SPACE_SIZE    4096
+
+#define PREDEFINED_PCI_BRIDGE_HEADER_SIZE           48
+#define PREDEFINED_PCI_DEVICE_HEADER_SIZE           48
+#define PREDEFINED_PCI_COMMON_HEADER_SIZE           64
+#define PREDEFINED_PCI_BAR_SIZE                     4
+#define PREDEFINED_PCI_STATUS_SIZE                  2
+#define PREDEFINED_PCI_COMMAND_SIZE                 2
+#define PREDEFINED_PCI_HEADER_TYPE_SIZE             1
+#define PREDEFINED_PCI_CAPABILITY_HEADER_SIZE       2
+
+#define PREDEFINED_PCI_MSI_ADDRESS_REGISTER_SIZE    4
+#define PREDEFINED_PCI_MSI_DATA_REGISTER_SIZE       2
+
+#define PCI_DEVICE_NO_OF_BARS                       6U
+#define PCI_BRIDGE_NO_OF_BARS                       2U
+
+typedef enum _PCI_VENDOR_ID
+{
+    PciVendorIdIntel            = 0x8086,
+} PCI_VENDOR_ID;
+
+// PCI device classes
+typedef enum _PCI_DEVICE_CLASS
+{
+    PciDeviceClassUnclassified,
+    PciDeviceClassMassStorageController,
+    PciDeviceClassNetworkController,
+    PciDeviceClassDisplayController,
+    PciDeviceClassMultimediaController,
+    PciDeviceClassMemoryController,
+    PciDeviceClassBridge,
+    PciDeviceClassCommunicationController,
+    PciDeviceClassGenericSystemPeripheral,
+    PciDeviceClassInputDeviceController,
+    PciDeviceClassDockingStation,
+    PciDeviceClassProcessor,
+    PciDeviceClassSerialBusController,
+    PciDeviceClassWirelessController,
+    PciDeviceClassInteligentController,
+    PciDeviceClassSatelliteCommunicationController,
+    PciDeviceClassEncryptionController,
+    PciDeviceClassSignalProcessingController,
+    PciDeviceClassProcessingAccelerators,
+    PciDeviceClassNonEssentialInstrumentation,
+    PciDeviceClassCoprocessor = 0x40
+} PCI_DEVICE_CLASS;
+
+// Subclasses corresponding for
+// PCI_DEVICE_CLASS == PciDeviceClassMassStorageController
+typedef enum _PCI_MASS_STORAGE
+{
+    PciMassStorageSCSI,
+    PciMassStorageIDE,
+    PciMassStorageFloppy,
+    PciMassStorageIPI,
+    PciMassStorageRAID,
+    PciMassStorageATA,
+    PciMassStorageSATA,
+    PciMassStorageSAS,
+    PciMassStorageNonVolatileMemoryController,
+} PCI_MASS_STORAGE;
+
+// Subclasses corresponding for
+// PCI_DEVICE_CLASS == PciDeviceClassBridge
+typedef enum _PCI_BRIDGE_SUBCLASS
+{
+    PciBridgeSubclassHost,
+    PciBridgeSubclassISA,
+    PciBridgeSubclassEISA,
+    PciBridgeSubclassMCA,
+    PciBridgeSubclassPCItoPCI,
+    PciBridgeSubclassPCMCIA,
+    PciBridgeSubclassNuBus,
+    PciBridgeSubclassCardBus,
+    PciBridgeSubclassRACEway,
+} PCI_BRIDGE_SUBCLASS;
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+#define PCI_MEM_SPACE_32_BIT            0b00
+#define PCI_MEM_SPACE_64_BIT            0b10
+
+#define PCI_GET_PA_FROM_MEM_ADDR(Bar)   ((PHYSICAL_ADDRESS)((QWORD)(Bar)->Raw & 0xFFFF'FFF0))
+#define PCI_GET_PORT_FROM_IO_ADDR(Bar)  ((Bar)->Raw & 0xFFFF'FFFC)
+
+typedef volatile union _PCI_BAR
+{
+    struct {
+        // if Zero => We have a memory mapped address
+        DWORD           Zero            :    1;
+
+        // 00 Base register is 32 bits wide and mapping can be
+        //    done anywhere in the 32 - bit Memory Space.
+        // 01 Reserved46
+        // 10 Base register is 64 bits wide and can be mapped
+        //    anywhere in the 64 - bit address space.
+        // 11 Reserved
+        DWORD           Type            :    2;
+        DWORD           Prefetchable    :    1;
+        DWORD           Address         :   28;
+    } MemorySpace;
+    struct {
+        // if One => we have an I/O mapped address
+        DWORD           One             :    1;
+        DWORD           Reserved        :    1;
+        DWORD           Address         :   30;
+    } IoSpace;
+    DWORD               Raw;
+} PCI_BAR, *PPCI_BAR;
+STATIC_ASSERT(sizeof(PCI_BAR) == PREDEFINED_PCI_BAR_SIZE);
+
+typedef union _PCI_STATUS_REGISTER
+{
+    struct
+    {
+        WORD            __Reserved0         :   3;
+        WORD            InterruptStatus     :   1;
+        WORD            CapabilitiesList    :   1;
+        WORD            __Reserved1         :  11;
+    };
+    WORD                Value;
+} PCI_STATUS_REGISTER, *PPCI_STATUS_REGISTER;
+STATIC_ASSERT(sizeof(PCI_STATUS_REGISTER) == PREDEFINED_PCI_STATUS_SIZE);
+
+typedef union _PCI_COMMAND_REGISTER
+{
+    struct
+    {
+        // Controls a device's response to I/O Space accesses. A value of 0
+        // disables the device response.A value of 1 allows the device to
+        // respond to I / O Space accesses.State after RST# is 0.
+        WORD            IoSpaceEnabled      :   1;
+
+        // Controls a device's response to Memory Space accesses. A value of
+        // 0 disables the device response.A value of 1 allows the device to
+        // respond to Memory Space accesses.State after RST# is 0.
+        WORD            MemorySpaceEnabled  :   1;
+
+        // Controls a device's ability to act as a master on the PCI bus. A value
+        // of 0 disables the device from generating PCI accesses.A value of 1
+        // allows the device to behave as a bus master.State after RST# is 0.
+        WORD            BusMaster           :   1;
+
+        // Controls a device's action on Special Cycle operations. A value of 0
+        // causes the device to ignore all Special Cycle operations.A value of 1
+        // allows the device to monitor Special Cycle operations.State after
+        // RST# is 0.
+        WORD            SpecialCycle        :   1;
+
+        // This is an enable bit for using the Memory Write and Invalidate
+        // command.When this bit is 1, masters may generate the command.
+        // When it is 0, Memory Write must be used instead.State after RST#
+        // is 0. This bit must be implemented by master devices that can
+        // generate the Memory Write and Invalidate command.
+        WORD            MemWriteInvalidate  :   1;
+
+        // This bit controls how VGA compatible and graphics devices handle
+        // accesses to VGA palette registers.When this bit is 1, palette
+        // snooping is enabled(i.e., the device does not respond to palette
+        // register writes and snoops the data).When the bit is 0, the device
+        // should treat palette write accesses like all other accesses.VGA
+        // compatible devices should implement this bit.Refer to Section 3.10
+        // for more details on VGA palette snooping.
+        WORD            PalleteSnooping     :   1;
+
+        // This bit controls the device's response to parity errors. When the bit
+        // is set, the device must take its normal action when a parity error is
+        // detected.When the bit is 0, the device sets its Detected Parity Error
+        // status bit(bit 15 in the Status register) when an error is detected, but
+        // does not assert PERR# and continues normal operation.This bit's
+        // state after RST# is 0. Devices that check parity must implement this
+        // bit.Devices are still required to generate parity even if parity checking
+        // is disabled.
+        WORD            BenignParityError   :   1;
+
+        WORD            __Zero              :   1;
+
+        // This bit is an enable bit for the SERR# driver.A value of 0 disables
+        // the SERR# driver.A value of 1 enables the SERR# driver.This bit's
+        // state after RST# is 0. All devices that have an SERR# pin must
+        // implement this bit.Address parity errors are reported only if this bit
+        // and bit 6 are 1.
+        WORD            SerrDriverEnable    :   1;
+
+        // This optional read / write bit controls whether or not a master can do
+        // fast back - to - back transactions to different devices.Initialization
+        // software will set the bit if all targets are fast back - to - back capable.A
+        // value of 1 means the master is allowed to generate fast back - to - back
+        // transactions to different agents as described in Section 3.4.2.A value
+        // of 0 means fast back - to - back transactions are only allowed to the
+        // same agent.This bit's state after RST# is 0.
+        WORD            FastBackToBack      :   1;
+
+        // This bit disables the device / function from asserting INTx#.A value of
+        // 0 enables the assertion of its INTx# signal.A value of 1 disables the
+        // assertion of its INTx# signal.This bits state after RST# is 0. Refer to
+        // Section 6.8.1.3 for control of MSI.
+        WORD            InterruptDisable    :   1;
+
+        WORD            __Reserved          :   5;
+    };
+    WORD                Value;
+} PCI_COMMAND_REGISTER, *PPCI_COMMAND_REGISTER;
+STATIC_ASSERT(sizeof(PCI_COMMAND_REGISTER) == PREDEFINED_PCI_COMMAND_SIZE);
+
+#define PCI_HEADER_LAYOUT_CLASSIC               0
+#define PCI_HEADER_LAYOUT_PCI_TO_PCI            1
+#define PCI_HEADER_LAYOUT_CARDBUS               2
+
+typedef union _PCI_HEADER_TYPE_REGISTER
+{
+    struct
+    {
+        // Bits 6 through 0 identify the layout of the
+        // second part of the predefined header.The encoding 00h specifies
+        // the layout shown in Figure 6 - 1. The encoding 01h is defined for
+        // PCI - to - PCI bridges and is defined in the document PCI to PCI Bridge
+        // Architecture Specification.The encoding 02h is defined for a CardBus
+        // bridge and is documented in the PC Card Standard.All other
+        // encodings are reserved.
+        BYTE            Layout              :   7;
+
+        // Bit 7 in this register is used to identify a multi - function device.
+        // If the bit is 0, then the device is single function. If the bit is 1,
+        // then the device has multiple functions.
+        BYTE            Multifunction       :   1;
+    };
+    BYTE                Value;
+} PCI_HEADER_TYPE_REGISTER, *PPCI_HEADER_TYPE_REGISTER;
+STATIC_ASSERT(sizeof(PCI_HEADER_TYPE_REGISTER) == PREDEFINED_PCI_HEADER_TYPE_SIZE);
+
+#define PCI_CAPABILITY_ID_RESERVED              0x0
+#define PCI_CAPABILITY_ID_POWER_MGMT            0x1
+#define PCI_CAPABILITY_ID_MSI                   0x5
+#define PCI_CAPABILITY_ID_VENDOR                0x9
+#define PCI_CAPABILITY_ID_HOT_PLUG              0xC
+#define PCI_CAPABILITY_ID_BRIDGE_SUB_VENDOR     0xD
+#define PCI_CAPABILITY_ID_SECURE_DEVICE         0xF
+#define PCI_CAPABILITY_ID_PCI_EXPRESS           0x10
+#define PCI_CAPABILITY_ID_MSIX                  0x11
+
+typedef BYTE PCI_CAPABILITY_ID;
+
+typedef struct _PCI_CAPABILITY_HEADER
+{
+    PCI_CAPABILITY_ID           CapabilityId;
+
+    BYTE                        NextPointer;
+} PCI_CAPABILITY_HEADER, *PPCI_CAPABILITY_HEADER;
+STATIC_ASSERT(sizeof(PCI_CAPABILITY_HEADER) == PREDEFINED_PCI_CAPABILITY_HEADER_SIZE);
+
+// Intel specific MSI definitions
+typedef volatile union _PCI_MSI_ADDRESS_REGISTER
+{
+    struct
+    {
+        DWORD       __Reserved0             :   2;
+        DWORD       DestinationMode         :   1;
+        DWORD       RedirectionHint         :   1;
+        DWORD       __Reserved1             :   8;
+
+        // This field contains an 8 - bit destination ID.It identifies the messages target processor(s).
+        // The destination ID corresponds to bits 63:56 of the I / O APIC Redirection Table Entry if the IOAPIC is used to
+        // dispatch the interrupt to the processor(s).
+        DWORD       DestinationId           :   8;
+
+        // These bits contain a fixed value for interrupt messages(0FEEH).This value locates interrupts at
+        // the 1 - MByte area with a base address of 4G  18M.All accesses to this region are directed as interrupt
+        // messages.Care must to be taken to ensure that no other device claims the region as I / O space.
+        DWORD       UpperFixedAddress       :  12;
+    };
+    DWORD           Raw;
+} PCI_MSI_ADDRESS_REGISTER, *PPCI_MSI_ADDRESS_REGISTER;
+STATIC_ASSERT(sizeof(PCI_MSI_ADDRESS_REGISTER) == PREDEFINED_PCI_MSI_ADDRESS_REGISTER_SIZE);
+
+typedef volatile union _PCI_MSI_DATA_REGISTER
+{
+    struct
+    {
+        BYTE        Vector;
+
+        BYTE        DeliveryMode            :   3;
+        BYTE        __Reserved0             :   3;
+        BYTE        Assert                  :   1;
+        BYTE        TriggerMode             :   1;
+    };
+    WORD            Raw;
+} PCI_MSI_DATA_REGISTER, *PPCI_MSI_DATA_REGISTER;
+STATIC_ASSERT(sizeof(PCI_MSI_DATA_REGISTER) == PREDEFINED_PCI_MSI_DATA_REGISTER_SIZE);
+
+typedef volatile struct _PCI_CAPABILITY_MSI
+{
+    PCI_CAPABILITY_HEADER               Header;
+    union
+    {
+        struct
+        {
+            // RW
+            BYTE                        MsiEnable                   :   1;
+
+            // RO
+            BYTE                        MultipleMessageCapable      :   3;
+
+            // RW
+            BYTE                        MultipleMessageEnable       :   3;
+
+            // RO
+            BYTE                        Is64BitCapable              :   1;
+
+            // RO
+            BYTE                        PerVectorMasking            :   1;
+
+            BYTE                        __Reserved0                 :   7;
+        };
+        WORD                            Raw;
+    } MessageControl;
+    PCI_MSI_ADDRESS_REGISTER            MessageAddressLower;
+    union
+    {
+        struct
+        {
+            PCI_MSI_DATA_REGISTER       MessageData;
+        } Capability32Bit;
+        struct
+        {
+            DWORD                       MessageAddressHigher;
+            PCI_MSI_DATA_REGISTER       MessageData;
+        } Capability64Bit;
+    };
+} PCI_CAPABILITY_MSI, *PPCI_CAPABILITY_MSI;
+
+typedef volatile struct _PCI_CAPABILITY_MSIX
+{
+    PCI_CAPABILITY_HEADER       Header;
+    WORD                        MessageControl;
+} PCI_CAPABILITY_MSIX, *PPCI_CAPABILITY_MSIX;
+
+typedef volatile struct _PCI_DEVICE_HEADER
+{
+    // 0x10
+    PCI_BAR                         Bar[PCI_DEVICE_NO_OF_BARS];
+
+    // 0x28
+    DWORD                           CarbusCISPointer;
+
+    // 0x2C
+    WORD                            SubSystemVendorID;
+    WORD                            SubSystemID;
+
+    // 0x30
+    DWORD                           ExpansionROMBaseAddress;
+
+    // 0x34
+    BYTE                            CapabilitiesPointer;
+    BYTE                            Reserved[7];
+
+    // 0x3C
+    BYTE                            InterruptLine;
+    BYTE                            InterruptPin;
+    BYTE                            MinGrant;
+    BYTE                            MaxLatency;
+} PCI_DEVICE_HEADER, *PPCI_DEVICE_HEADER;
+STATIC_ASSERT(sizeof(PCI_DEVICE_HEADER) == PREDEFINED_PCI_DEVICE_HEADER_SIZE);
+
+typedef volatile struct _PCI_BRIDGE_HEADER
+{
+    PCI_BAR                         Bar[PCI_BRIDGE_NO_OF_BARS];
+
+    // 0x18
+
+    // The Primary Bus Number register is used to record the bus number of the PCI bus segment to
+    // which the primary interface of the bridge is connected.
+    BYTE                            PrimaryBusNumber;
+
+    // The Secondary Bus Number register is used to record the bus number of the PCI bus segment to
+    // which the secondary interface of the bridge is connected.
+    BYTE                            SecondaryBusNumber;
+
+    // The Subordinate Bus Number register is used to record the bus number of the highest numbered
+    // PCI bus segment which is behind(or subordinate to) the bridge.
+    BYTE                            SubordinateBusNumber;
+    BYTE                            SecondaryLatencyTimer;
+
+    // 0x1c
+    BYTE                            IoBase;
+    BYTE                            IoLimit;
+    WORD                            SecondaryStatus;
+
+    // 0x20
+    WORD                            MemoryBase;
+    WORD                            MemoryLimit;
+
+    // 0x24
+    WORD                            PrefetchableMemoryBase;
+    WORD                            PrefetchableMemoryLimit;
+
+    // 0x28
+    DWORD                           PrefetchableBaseUpper;
+    DWORD                           PrefetchableLimitUpper;
+
+    // 0x30
+    WORD                            IoBaseUpper;
+    WORD                            IoLimitUpper;
+
+    // 0x34
+    BYTE                            CapabilitiesPointer;
+    BYTE                            __Reserved[3];
+
+    // 0x38
+    DWORD                           ExpansionROMBaseAddress;
+
+    // 0x3C
+    BYTE                            InterruptLine;
+    BYTE                            InterruptPin;
+    WORD                            BridgeControl;
+} PCI_BRIDGE_HEADER, *PPCI_BRIDGE_HEADER;
+STATIC_ASSERT(sizeof(PCI_BRIDGE_HEADER) == PREDEFINED_PCI_BRIDGE_HEADER_SIZE);
+
+typedef volatile struct _PCI_COMMON_HEADER
+{
+    // PCI Specification 3.0 Section 6.1
+    // The first 16 bytes are defined the same for all types of devices.
+    WORD                            VendorID;
+    WORD                            DeviceID;
+
+    // 0x04
+    PCI_COMMAND_REGISTER            Command;
+    PCI_STATUS_REGISTER             Status;
+
+    // 0x08
+    BYTE                            RevisionID;
+    BYTE                            ProgIF;
+    BYTE                            Subclass;
+    BYTE                            ClassCode;
+
+    // 0x0C
+    BYTE                            CacheLineSize;
+    BYTE                            LatencyTimer;
+    PCI_HEADER_TYPE_REGISTER        HeaderType;
+    BYTE                            Bist;
+
+    union
+    {
+        PCI_DEVICE_HEADER           Device;
+        PCI_BRIDGE_HEADER           Bridge;
+    };
+} PCI_COMMON_HEADER, *PPCI_COMMON_HEADER;
+STATIC_ASSERT(sizeof(PCI_COMMON_HEADER) == PREDEFINED_PCI_COMMON_HEADER_SIZE);
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/HAL/inc/pcie.h b/src_proiect/HAL/inc/pcie.h
new file mode 100644
index 0000000..9c95a80
--- /dev/null
+++ b/src_proiect/HAL/inc/pcie.h
@@ -0,0 +1,32 @@
+#pragma once
+
+#include "pci.h"
+
+typedef struct _PCI_ROOT_COMPLEX
+{
+    volatile DWORD* BaseAddress;
+    BYTE            StartBusNumber;
+    BYTE            EndBusNumber;
+} PCI_ROOT_COMPLEX, *PPCI_ROOT_COMPLEX;
+
+STATUS
+PciExpressRetrieveNextDevice(
+    IN      PPCI_ROOT_COMPLEX           PciRootComplex,
+    IN      BOOLEAN                     ResetSearch,
+    OUT     PPCI_DEVICE_DESCRIPTION     PciDevice
+    );
+
+DWORD
+PciExpressReadConfigurationSpace(
+    IN      PPCI_ROOT_COMPLEX       PciRootComplex,
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register
+    );
+
+void
+PciExpressWriteConfigurationSpace(
+    IN      PPCI_ROOT_COMPLEX       PciRootComplex,
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      DWORD                   Value
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/pic.h b/src_proiect/HAL/inc/pic.h
new file mode 100644
index 0000000..98b2817
--- /dev/null
+++ b/src_proiect/HAL/inc/pic.h
@@ -0,0 +1,51 @@
+#pragma once
+
+typedef enum _IRQ
+{
+    IrqPitTimer,
+    IrqKeyboard,
+    IrqCascade,
+    IrqCOM2,
+    IrqCom1,
+    IrqReserved0,
+    IrqDiskette,
+    IrqLPT1,
+    IrqSpurious = IrqLPT1,
+    IrqRtc,
+    IrqCGA,
+    IrqReserved1,
+    IrqReserved2,
+    IrqReserved3,
+    IrqFPU,
+    IrqHdController
+} IRQ;
+
+#define     IRQS_PER_PIC    0x8
+#define     NO_OF_IRQS      0x10
+
+void
+PicInitialize(
+    IN BYTE MasterBase,
+    IN BYTE SlaveBase
+    );
+
+void
+PicSendEOI(
+    IN      BYTE        Irq
+    );
+
+void
+PicChangeIrqMask(
+    IN      BYTE        Irq,
+    IN      BOOLEAN     MaskIrq
+    );
+
+WORD
+PicGetIrr(
+    void
+    );
+
+WORD
+PicGetIsr(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/pit.h b/src_proiect/HAL/inc/pit.h
new file mode 100644
index 0000000..640f631
--- /dev/null
+++ b/src_proiect/HAL/inc/pit.h
@@ -0,0 +1,29 @@
+#pragma once
+
+WORD
+PitSetTimer(
+    IN      DWORD       Microseconds,
+    IN      BOOLEAN     Periodic
+    );
+
+void
+PitStartTimer(
+    void
+    );
+
+void
+PitWaitTimer(
+    void
+    );
+
+void
+PitSleep(
+    IN      DWORD       Microseconds
+    );
+
+__declspec(deprecated)
+WORD
+PitGetTimerCount(
+    IN      BOOLEAN     Periodic
+    );
+
diff --git a/src_proiect/HAL/inc/pte.h b/src_proiect/HAL/inc/pte.h
new file mode 100644
index 0000000..2013757
--- /dev/null
+++ b/src_proiect/HAL/inc/pte.h
@@ -0,0 +1,384 @@
+#pragma once
+
+#define MAXPHYADDR                                  52
+
+#define PAGING_TABLES_FIRST_LEVEL                   1
+#define PAGING_TABLES_LAST_LEVEL                    4
+
+// 63:48 must equal bit 47 for the address to be canonical
+#define VA_HIGHEST_VALID_BIT                                        47
+
+#define MASK_PML4_OFFSET(va)                        (((QWORD)(va)>>39)&0x1FF)
+#define MASK_PDPTE_OFFSET(va)                       (((QWORD)(va)>>30)&0x1FF)
+#define MASK_PDE_OFFSET(va)                         (((QWORD)(va)>>21)&0x1FF)
+#define MASK_PTE_OFFSET(va)                         (((QWORD)(va)>>12)&0x1FF)
+#define MASK_PAGE_OFFSET(va)                        ((QWORD)(va)&0xFFF)
+
+#define SHIFT_FOR_PHYSICAL_ADDR                     PAGE_SHIFT
+#define SHIFT_FOR_LARGE_PAGE                        21
+
+#define PAGE_4KB_OFFSET                             ((QWORD)(1<<12)-1)
+#define PAGE_2MB_OFFSET                             ((QWORD)(1<<21)-1)
+#define PAGE_4MB_OFFSET                             ((QWORD)(1<<22)-1)
+#define PAGE_1GB_OFFSET                             ((QWORD)(1<<30)-1)
+
+#define PCID_NO_OF_BITS                             12
+#define PCID_TOTAL_NO_OF_VALUES                     (1<<PCID_NO_OF_BITS)
+#define PCID_FIRST_VALID_VALUE                      1
+
+#define PCID_IS_VALID(pcid)                         (PCID_FIRST_VALID_VALUE <= (pcid) && (pcid) < PCID_TOTAL_NO_OF_VALUES)
+
+#define MOV_TO_CR3_DO_NOT_INVALIDATE_PCID_MAPPINGS  ((QWORD)1<<63)
+
+typedef WORD PCID;
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+//warning C4214: nonstandard extension used : bit field types other than int
+#pragma warning(disable:4214)
+
+// The PML4 points to the PML4_ENTRY array
+
+// This structure is valid for CR4.PCIDE(bit 17) = 0
+typedef union _PML4
+{
+    union
+    {
+        struct
+        {
+            QWORD           PCID                :   PCID_NO_OF_BITS;
+            QWORD           PhysicalAddress     :   MAXPHYADDR - 12;
+            QWORD           Reserved            :   64 - MAXPHYADDR;
+        } Pcide;
+        struct
+        {
+            QWORD           Ignored0            :   3;
+            QWORD           PWT                 :   1;
+            QWORD           PCD                 :   1;
+            QWORD           Ignored1            :   7;
+            QWORD           PhysicalAddress     :   MAXPHYADDR - 12;
+            QWORD           Reserved            :   64 - MAXPHYADDR;
+        } NoPcide;
+    };
+    QWORD           Raw;
+} PML4, *PPML4;
+STATIC_ASSERT(sizeof(PML4) == sizeof(QWORD));
+
+// A PML4_ENTRY points to a PDPT
+typedef struct _PML4_ENTRY
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Ignored0            :   1;
+    QWORD           Reserved            :   1;  // Must be 0
+    QWORD           Ignored1            :   4;
+    QWORD           PhysicalAddress     :   MAXPHYADDR - 12;
+    QWORD           Ignored2            :   11;
+    QWORD           XD                  :   1;
+} PML4_ENTRY, *PPML4_ENTRY;
+STATIC_ASSERT(sizeof(PML4_ENTRY) == sizeof(QWORD));
+
+// This PDPT_ENTRY points to a PD
+typedef struct _PDPT_ENTRY_PD
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Ignored0            :   1;
+    QWORD           PageSize            :   1;  // Must be 0
+    QWORD           Ignored1            :   4;
+    QWORD           PhysicalAddress     :   MAXPHYADDR - 12;
+    QWORD           Ignored2            :   11;
+    QWORD           XD                  :   1;
+} PDPT_ENTRY_PD, *PPDTP_ENTRY_PD;
+STATIC_ASSERT(sizeof(PDPT_ENTRY_PD) == sizeof(QWORD));
+
+// PDPT_ENTRY that maps a 1-GByte Page
+typedef struct _PDPT_ENTRY_1G
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Dirty               :   1;
+    QWORD           PageSize            :   1;  // Must be 1
+    QWORD           Global              :   1;
+    QWORD           Ignored             :   3;
+    QWORD           PAT                 :   1;
+    QWORD           Reserved            :   17;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-30;
+    QWORD           Ignored2            :   11;
+    QWORD           XD                  :   1;
+} PDPT_ENTRY_1G, *PPDTP_ENTRY_1G;
+STATIC_ASSERT( sizeof( PDPT_ENTRY_1G ) == sizeof( QWORD ) );
+
+// PD_ENTRY which references a Page Table
+typedef struct _PD_ENTRY_PT
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Ignored0            :   1;
+    QWORD           PageSize            :   1;  // Must be 0
+    QWORD           Ignored1            :   4;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-12;
+    QWORD           Ignored2            :   11;
+    QWORD           XD                  :   1;
+} PD_ENTRY_PT, *PPD_ENTRY_PT;
+STATIC_ASSERT( sizeof( PD_ENTRY_PT ) == sizeof( QWORD ) );
+
+// PD_ENTRY that maps a 2-MByte Page
+typedef struct _PD_ENTRY_2MB
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Dirty               :   1;
+    QWORD           PageSize            :   1;  // Must be 1
+    QWORD           Global              :   1;
+    QWORD           Ignored             :   3;
+    QWORD           PAT                 :   1;
+    QWORD           Reserved            :   8;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-21;
+    QWORD           Ignored2            :   11;
+    QWORD           XD                  :   1;
+} PD_ENTRY_2MB, *PPD_ENTRY_2MB;
+STATIC_ASSERT( sizeof( PD_ENTRY_2MB ) == sizeof( QWORD ) );
+
+typedef struct _PT_ENTRY
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Dirty               :   1;
+    QWORD           PAT                 :   1;
+    QWORD           Global              :   1;
+    QWORD           Ignored0            :   3;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-12;
+    QWORD           Ignored1            :   11;
+    QWORD           XD                  :   1;
+} PT_ENTRY, *PPT_ENTRY;
+STATIC_ASSERT( sizeof( PT_ENTRY ) == sizeof( QWORD ) );
+
+// the next structures are only valid for PAE paging
+#define MASK_PAE_PDPTE_OFFSET(va)        (((QWORD)(va)>>30)&0x3)
+
+typedef struct _CR3_PAE_STRUCTURE
+{
+    QWORD           Ignored0            :   5;
+    QWORD           PhysicalAddress     :   MAXPHYADDR - 5;
+    QWORD           Ignored1            :   64 - MAXPHYADDR;
+} CR3_PAE_STRUCTURE, *PCR3_PAE_STRUCTURE;
+STATIC_ASSERT(sizeof(CR3_PAE_STRUCTURE) == sizeof(QWORD));
+
+typedef struct _PDPT_PAE_ENTRY_PD
+{
+    QWORD           Present             :   1;
+    QWORD           Reserved0           :   2;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Reserved1           :   4;
+    QWORD           Ignored0            :   3;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-12;
+    QWORD           Reserved2           :   12;
+} PDPT_PAE_ENTRY_PD, *PPDPT_PAE_ENTRY_PD;
+STATIC_ASSERT(sizeof(PDPT_PAE_ENTRY_PD) == sizeof(QWORD));
+
+typedef struct _PD_PAE_ENTRY_PT
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Ignored0            :   1;
+    QWORD           PageSize            :   1;  // Must be 0
+    QWORD           Ignored1            :   4;
+    QWORD           PhysicalAddress     :   MAXPHYADDR - 12;
+    QWORD           Reserved            :   11;
+    QWORD           XD                  :   1;
+} PD_PAE_ENTRY_PT, *PPD_PAE_ENTRY_PT;
+STATIC_ASSERT(sizeof(PD_PAE_ENTRY_PT) == sizeof(QWORD));
+
+// PD_ENTRY that maps a 2-MByte Page
+typedef struct _PD_PAE_ENTRY_2MB
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Dirty               :   1;
+    QWORD           PageSize            :   1;  // Must be 1
+    QWORD           Global              :   1;
+    QWORD           Ignored             :   3;
+    QWORD           PAT                 :   1;
+    QWORD           Reserved0           :   8;
+    QWORD           PhysicalAddress     :   MAXPHYADDR - 21;
+    QWORD           Reserved1           :   11;
+    QWORD           XD                  :   1;
+} PD_PAE_ENTRY_2MB, *PPD_PAE_ENTRY_2MB;
+STATIC_ASSERT(sizeof(PD_PAE_ENTRY_2MB) == sizeof(QWORD));
+
+typedef struct _PT_PAE_ENTRY
+{
+    QWORD           Present             :   1;
+    QWORD           ReadWrite           :   1;
+    QWORD           UserSupervisor      :   1;
+    QWORD           PWT                 :   1;
+    QWORD           PCD                 :   1;
+    QWORD           Accessed            :   1;
+    QWORD           Dirty               :   1;
+    QWORD           PAT                 :   1;
+    QWORD           Global              :   1;
+    QWORD           Ignored             :   3;
+    QWORD           PhysicalAddress     :   MAXPHYADDR-12;
+    QWORD           Reserved            :   11;
+    QWORD           XD                  :   1;
+} PT_PAE_ENTRY, *PPT_PAE_ENTRY;
+STATIC_ASSERT(sizeof(PT_PAE_ENTRY) == sizeof(QWORD));
+
+// the next structures are only valid for 32 bit paging
+
+#define MASK_PDE32_OFFSET(va)    (((QWORD)(va)>>22)&0x3FF)
+#define MASK_PTE32_OFFSET(va)    (((QWORD)(va)>>12)&0x3FF)
+
+
+typedef struct _CR3_STRUCTURE
+{
+    DWORD            Ignored0            :    3;
+    DWORD            PWT                 :    1;
+    DWORD            PCD                 :    1;
+    DWORD            Ignored1            :    7;
+    DWORD            PhysicalAddress     :    20;
+} CR3_STRUCTURE, *PCR3_STRUCTURE;
+STATIC_ASSERT(sizeof(CR3_STRUCTURE) == sizeof(DWORD));
+
+typedef struct _PD32_ENTRY_PT
+{
+    DWORD           Present              :    1;
+    DWORD           ReadWrite            :    1;
+    DWORD           UserSupervisor       :    1;
+    DWORD           PWT                  :    1;
+    DWORD           PCD                  :    1;
+    DWORD           Accessed             :    1;
+    DWORD           Ignored0             :    1;
+    DWORD           PageSize             :    1;
+    DWORD           Ignored1             :    4;
+    DWORD           PhysicalAddress      :    20;
+} PD32_ENTRY_PT, *PPD32_ENTRY_PT;
+STATIC_ASSERT(sizeof(PD32_ENTRY_PT) == sizeof(DWORD));
+
+typedef struct _PD32_ENTRY_4MB
+{
+    DWORD           Present              :    1;
+    DWORD           ReadWrite            :    1;
+    DWORD           UserSupervisor       :    1;
+    DWORD           PWT                  :    1;
+    DWORD           PCD                  :    1;
+    DWORD           Accessed             :    1;
+    DWORD           Dirty                :    1;
+    DWORD           PageSize             :    1;
+    DWORD           Granularity          :    1;
+    DWORD           Ignored0             :    3;
+    DWORD           PAT                  :    1;
+    DWORD           UpperBits            :    9;
+    DWORD           PhysicalAddress      :    10;
+} PD32_ENTRY_4MB, *PPD32_ENTRY_4MB;
+STATIC_ASSERT(sizeof(PD32_ENTRY_4MB) == sizeof(DWORD));
+
+typedef struct _PT32_ENTRY
+{
+    DWORD           Present              :    1;
+    DWORD           ReadWrite            :    1;
+    DWORD           UserSupervisor       :    1;
+    DWORD           PWT                  :    1;
+    DWORD           PCD                  :    1;
+    DWORD           Accessed             :    1;
+    DWORD           Dirty                :    1;
+    DWORD           PAT                  :    1;
+    DWORD           Granularity          :    1;
+    DWORD           Ignored1             :    3;
+    DWORD           PhysicalAddress      :    20;
+} PT32_ENTRY, *PPT32_ENTRY;
+STATIC_ASSERT(sizeof(PT32_ENTRY) == sizeof(DWORD));
+
+typedef struct _PTE_MAP_FLAGS
+{
+    WORD            Invalidate           :    1;
+    WORD            PatIndex             :    3;
+    WORD            Writable             :    1;
+    WORD            Executable           :    1;
+    WORD            PagingStructure      :    1;
+    WORD            UserAccess           :    1;
+    WORD            GlobalPage           :    1;
+    WORD            __Reserved0          :    7;
+} PTE_MAP_FLAGS, *PPTE_MAP_FLAGS;
+STATIC_ASSERT(sizeof(PTE_MAP_FLAGS) == sizeof(WORD));
+#pragma warning(pop)
+#pragma pack(pop)
+
+void
+PteMap(
+    IN          PVOID               PageTable,
+    IN_OPT      PHYSICAL_ADDRESS    PhysicalAddress,
+    IN          PTE_MAP_FLAGS       Flags
+    );
+
+void
+PteUnmap(
+    IN          PVOID           PageTable
+    );
+
+PHYSICAL_ADDRESS
+PteGetPhysicalAddress(
+    IN          PVOID           PageTable
+    );
+
+PHYSICAL_ADDRESS
+PteLargePageGetPhysicalAddress(
+    IN          PVOID           PageTable
+    );
+
+BOOLEAN
+PteIsPresent(
+    IN          PVOID           PageTable
+    );
+
+__forceinline
+void
+PageInvalidateTlb(
+    IN          PVOID           Page
+    )
+{
+    // This is a HACK done to prevent a Visual C compiler bug which sometimes (if 2 __invlpg are one after another)
+    // causes the __invlpg to generate a swapgs instruction :|
+    // Yeah, good job Microsoft...
+    _ReadWriteBarrier();
+    __invlpg(Page);
+}
diff --git a/src_proiect/HAL/inc/register.h b/src_proiect/HAL/inc/register.h
new file mode 100644
index 0000000..304b212
--- /dev/null
+++ b/src_proiect/HAL/inc/register.h
@@ -0,0 +1,84 @@
+#pragma once
+
+// Control and system registers related information
+
+// CR0 related definitions
+#define CR0_PE                                      ((QWORD)1<<0)
+#define CR0_EM                                      ((QWORD)1<<2)
+#define CR0_ET                                      ((QWORD)1<<4)
+#define CR0_NE                                      ((QWORD)1<<5)
+#define CR0_WP                                      ((QWORD)1<<16)
+#define CR0_NW                                      ((QWORD)1<<29)
+#define CR0_CD                                      ((QWORD)1<<30)
+#define CR0_PG                                      ((QWORD)1<<31)
+
+// CR4 related definitions
+#define CR4_PAE                                     ((QWORD)1<<5)
+#define CR4_OSFXSR                                  ((QWORD)1<<9)
+#define CR4_OSXMMEXCPT                              ((QWORD)1<<10)
+#define CR4_VMXE                                    ((QWORD)1<<13)
+#define CR4_SMXE                                    ((QWORD)1<<14)
+#define CR4_PCIDE                                   ((QWORD)1<<17)
+#define CR4_OSXSAVE                                 ((QWORD)1<<18)
+#define CR4_SMEP                                    ((QWORD)1<<20)
+#define CR4_SMAP                                    ((QWORD)1<<21)
+
+// Extended control registers
+#define XCR0_INDEX                                  0
+
+// RFLAGS related definitions
+#define RFLAGS_CARRY_FLAG_BIT                       ((QWORD)1<<0)
+#define RFLAGS_RESERVED_BIT                         ((QWORD)1<<1)
+#define RFLAGS_TRAP_BIT                             ((QWORD)1<<8)
+#define RFLAGS_INTERRUPT_FLAG_BIT                   ((QWORD)1<<9)
+#define RFLAGS_DIRECTION_BIT                        ((QWORD)1<<10)
+#define RFLAGS_RESUME_FLAG_BIT                      ((QWORD)1<<16)
+
+typedef enum
+{
+    RegisterRax,
+    RegisterRcx,
+    RegisterRdx,
+    RegisterRbx,
+    RegisterRsp,
+    RegisterRbp,
+    RegisterRsi,
+    RegisterRdi,
+    RegisterR8,
+    RegisterR9,
+    RegisterR10,
+    RegisterR11,
+    RegisterR12,
+    RegisterR13,
+    RegisterR14,
+    RegisterR15
+} GeneralPurposeRegisterIndexes;
+
+typedef enum
+{
+    CR0,
+    CR1,
+    CR2,
+    CR3,
+    CR4,
+    CR5,
+    CR6,
+    CR7,
+    CR8
+} ControlRegisterIndexes;
+
+
+typedef enum
+{
+    SelectorFirst,
+
+    SelectorES = SelectorFirst,
+    SelectorCS,
+    SelectorSS,
+    SelectorDS,
+    selectorFS,
+    SelectorGS,
+    SelectorTR,
+
+    SelectorReserved = SelectorTR + 1
+} SelectorIndex;
diff --git a/src_proiect/HAL/inc/rtc.h b/src_proiect/HAL/inc/rtc.h
new file mode 100644
index 0000000..e74a7c9
--- /dev/null
+++ b/src_proiect/HAL/inc/rtc.h
@@ -0,0 +1,21 @@
+#pragma once
+
+void
+RtcInit(
+    OUT_OPT     QWORD*          TscFrequency
+    );
+
+void
+RtcAcknowledgeTimerInterrupt(
+    void
+    );
+
+__forceinline
+QWORD
+RtcGetTickCount(
+    void
+    )
+{
+    _mm_lfence();
+    return __rdtsc();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/serial.h b/src_proiect/HAL/inc/serial.h
new file mode 100644
index 0000000..cb74b5e
--- /dev/null
+++ b/src_proiect/HAL/inc/serial.h
@@ -0,0 +1,33 @@
+#pragma once
+
+void
+SerialInitialize(
+    IN  WORD    Port
+    );
+
+//******************************************************************************
+// Function:    SerialWriteBuffer
+// Description:
+// Returns:       void
+// Parameter:     IN char * Buffer
+//******************************************************************************
+void 
+SerialWriteBuffer( 
+    IN   WORD   Port,
+    IN_Z char*  Buffer 
+    );
+
+
+//******************************************************************************
+// Function:    SerialWriteNBuffer
+// Description:
+// Returns:       void
+// Parameter:     IN BYTE * Buffer
+// Parameter:     IN DWORD BufferLength
+//******************************************************************************
+void 
+SerialWriteNBuffer( 
+    IN                              WORD  Port,
+    IN_READS_BYTES(BufferLength)    BYTE* Buffer, 
+    IN                              DWORD BufferLength 
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/tss.h b/src_proiect/HAL/inc/tss.h
new file mode 100644
index 0000000..54943cb
--- /dev/null
+++ b/src_proiect/HAL/inc/tss.h
@@ -0,0 +1,108 @@
+#pragma once
+
+#include "gdt.h"
+
+#define PREDEFINED_TSS_SIZE     104
+
+#define NO_OF_IST               7
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+//warning C4214: nonstandard extension used : bit field types other than int
+#pragma warning(disable:4214)
+
+// 7.7, Vol 3, No. 56
+typedef struct _TSS
+{
+    DWORD           Reserved0;
+
+    QWORD           Rsp[NO_OF_PRIVILLEGE_LEVELS];       // RSP0,1,2 (for Ring3 we don't have a stack)
+
+    QWORD           Reserved1;                          // Probably because of IST[0] which needs to be NULL
+
+    QWORD           IST[NO_OF_IST];                     // IST[1..7]
+
+    QWORD           Reserved2;
+
+    WORD            Reserved3;
+
+    WORD            IOMapBaseAddress;
+
+} TSS, *PTSS;
+STATIC_ASSERT( sizeof( TSS ) == PREDEFINED_TSS_SIZE );
+
+// because TSS_DESCRIPTORs are cooler
+// 7.2.3, Vol 3., No. 56
+typedef struct _TSS_DESCRIPTOR
+{
+    // 15:0
+    WORD                SegmentLimitLow;            // Segment Limit 15:0
+
+    // 31:16
+    WORD                BaseAddressLowWord;         // Base Address 15:0
+
+    // 39:32
+    BYTE                BaseAddressMidDword;        // Base Address 23:16
+
+    // 43:40
+    BYTE                Type                : 4;
+
+    // 44
+    BYTE                Zero0               : 1;
+
+    // 46:45
+    BYTE                DPL                 : 2;
+
+    // 47
+    BYTE                Present             : 1;
+
+    // 51:48
+    BYTE                SegmentLimitHigh    : 4;    // Segment Limit 19:16
+
+    // 52
+    BYTE                AVL                 : 1;    // Available for use by system SW
+
+    // 53
+    BYTE                Zero1               : 1;
+
+    // 54
+    BYTE                Zero2               : 1;
+
+    // 55
+    BYTE                G                   : 1;     // granularity
+
+    // 63:56
+    BYTE                BaseAddressHighDword;       // Base Address 31:24
+
+    // 95:64
+    DWORD               BaseAddressHighQword;
+
+    // 127:96
+    DWORD               Reserved;
+
+} TSS_DESCRIPTOR, *PTSS_DESCRIPTOR;
+STATIC_ASSERT(sizeof(TSS_DESCRIPTOR) == PREDEFINED_TSS_DESC_SIZE);
+#pragma warning(pop)
+#pragma pack(pop)
+
+//******************************************************************************
+// Function:     TssInstall
+// Description:  Install a TSS descriptor in the GDT at the specified index, and
+//               loads the task register.
+// Returns:      STATUS
+// Parameter:    OUT PTSS Tss
+// Parameter:    IN WORD GdtIndex - BYTE-counted index in the GDT
+// Parameter:    IN PVOID StackBase - Stack to use in TSS
+// Parameter:    IN BYTE StackIndex - Index to use for stack
+//******************************************************************************
+STATUS
+TssInstall(
+    OUT     PTSS        Tss,
+    IN      WORD        GdtIndex,
+    IN_RANGE(1,NO_OF_IST)
+            BYTE        NumberOfStacks,
+    IN_READS(NumberOfStacks)
+            PVOID*      Stacks
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL/inc/vmcs_fields.h b/src_proiect/HAL/inc/vmcs_fields.h
new file mode 100644
index 0000000..382c9bb
--- /dev/null
+++ b/src_proiect/HAL/inc/vmcs_fields.h
@@ -0,0 +1,458 @@
+#pragma once
+
+typedef DWORD VMCS_FIELD;
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used : bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// VMCS field encoding:
+// Bits 31:15       - Reserved
+// Bits 14:13       - Width
+//                      0: 16-bit
+//                      1: 64-bit
+//                      2: 32-bit
+//                      3: natural-width
+// Bit 12           - Reserved
+// Bits 11:10       - Type
+//                      0: control
+//                      1: VM-exit information
+//                      2: guest state
+//                      3: host state
+// Bits 9:1         - Index
+// Bit 0            - Access Type( 0 = full; 1 = high )
+
+#define VMCS_FIELD_16_BIT                               0x00000000UL
+#define VMCS_FIELD_64_BIT                               0x00002000UL
+#define VMCS_FIELD_32_BIT                               0x00004000UL
+#define VMCS_FIELD_NATURAL                              0x00006000UL
+
+#define VMCS_TYPE_CONTROL                               0x00000000UL
+#define VMCS_TYPE_EXIT                                  0x00000400UL
+#define VMCS_TYPE_GUEST                                 0x00000800UL
+#define VMCS_TYPE_HOST                                  0x00000C00UL
+
+#define VMCS_ACCESS_FULL                                0x00000000UL
+#define VMCS_ACCESS_HIGH                                0x00000001UL
+
+
+// 16-Bit Fields (B.1)
+
+// 16-Bit Control Fields (B.1.1)
+
+// Only with "enable VPID" support
+#define VMCS_CONTROL_VPID_IDENTIFIER                        (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_CONTROL | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+
+// Only with "process posted interrupts" support
+#define VMCS_CONTROL_POSTED_INTERRUPT_NOTIFY_VECTOR         (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_CONTROL | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+
+// Only with "EPT-violation #VE" support
+#define VMCS_CONTROL_EPTP_INDEX                             (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_CONTROL | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+
+// 16-Bit Guest State Fields (B.1.2)
+
+#define VMCS_GUEST_ES_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_CS_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_SS_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_DS_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_FS_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_GS_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_LDTR_SELECTOR                            (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_TR_SELECTOR                              (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_INT_STATUS                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_GUEST | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+
+// 16-Bit Host State Fields (B.1.3)
+
+#define VMCS_HOST_ES_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_CS_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_SS_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_DS_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_FS_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_GS_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_TR_SELECTOR                               (VMCS_FIELD)( VMCS_FIELD_16_BIT | VMCS_TYPE_HOST | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+
+// 64-Bit Fields (B.2)
+
+// 64-Bit Control Fields (B.2.1)
+
+#define VMCS_CONTROL_IO_BITMAP_A_ADDRESS_FULL               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_IO_BITMAP_A_ADDRESS_HIGH               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 0 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_IO_BITMAP_B_ADDRESS_FULL               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_IO_BITMAP_B_ADDRESS_HIGH               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 1 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_MSR_BITMAP_ADDRESS_FULL                (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_MSR_BITMAP_ADDRESS_HIGH                (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 2 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_MSR_STORE_EXIT_ADDRESS_FULL            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_MSR_STORE_EXIT_ADDRESS_HIGH            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 3 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_MSR_LOAD_EXIT_ADDRESS_FULL             (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_MSR_LOAD_EXIT_ADDRESS_HIGH             (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 4 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_MSR_LOAD_ENTRY_ADDRESS_FULL            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_MSR_LOAD_ENTRY_ADDRESS_HIGH            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 5 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EXECUTIVE_VMCS_POINTER_FULL            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EXECUTIVE_VMCS_POINTER_HIGH            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 6 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_TSC_OFFSET_FULL                        (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_TSC_OFFSET_HIGH                        (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 8 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_VIRTUAL_APIC_ADDRESS_FULL              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 9 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VIRTUAL_APIC_ADDRESS_HIGH              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 9 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_APIC_ACCESS_ADDRESS_FULL               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 10 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_APIC_ACCESS_ADDRESS_HIGH               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 10 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_POSTED_INT_DESC_ADDRESS_FULL           (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 11 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_POSTED_INT_DESC_ADDRESS_HIGH           (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 11 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_VM_FUNC_CONTROLS_FULL                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 12 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VM_FUNC_CONTROLS_HIGH                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 12 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EPT_POINTER_FULL                       (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 13 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EPT_POINTER_HIGH                       (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 13 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EOI_EXIT0_BITMAP_FULL                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 14 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EOI_EXIT0_BITMAP_HIGH                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 14 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EOI_EXIT1_BITMAP_FULL                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 15 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EOI_EXIT1_BITMAP_HIGH                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 15 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EOI_EXIT2_BITMAP_FULL                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 16 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EOI_EXIT2_BITMAP_HIGH                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 16 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EOI_EXIT3_BITMAP_FULL                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 17 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EOI_EXIT3_BITMAP_HIGH                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 17 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_EPTP_LIST_ADDRESS_FULL                 (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 18 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EPTP_LIST_ADDRESS_HIGH                 (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 18 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_VMREAD_BITMAP_ADDRESS_FULL             (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 19 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VMREAD_BITMAP_ADDRESS_HIGH             (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 19 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_VMWRITE_BITMAP_ADDRESS_FULL            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 20 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VMWRITE_BITMAP_ADDRESS_HIGH            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 20 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_VE_INFO_ADDRESS_FULL                   (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 21 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VE_INFO_ADDRESS_HIGH                   (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 21 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_CONTROL_XSS_EXISTING_BITMAP_FULL               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 22 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_XSS_EXISTING_BITMAP_HIGH               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_CONTROL | ( 22 << 1 ) | VMCS_ACCESS_HIGH )
+
+
+// 64-Bit Exit Fields (B.2.2)
+
+// Only with "enable EPT" support
+#define VMCS_EXIT_GUEST_PHYSICAL_ADDR_FULL                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_EXIT | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_GUEST_PHYSICAL_ADDR_HIGH                  (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_EXIT | ( 0 << 1 ) | VMCS_ACCESS_HIGH )
+
+
+// 64-Bit Guest-State Fields (B.2.3)
+
+#define VMCS_GUEST_VMCS_LINK_POINTER_FULL                   (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_VMCS_LINK_POINTER_HIGH                   (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 0 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_IA32_DEBUGCTL_FULL                       (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_DEBUGCTL_HIGH                       (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 1 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_IA32_PAT_FULL                            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_PAT_HIGH                            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 2 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_IA32_EFER_FULL                           (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_EFER_HIGH                           (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 3 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_IA32_PERF_GLOBAL_CTRL_FULL               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_PERF_GLOBAL_CTRL_HIGH               (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 4 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_PDPTE0_FULL                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_PDPTE0_HIGH                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 5 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_PDPTE1_FULL                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_PDPTE1_HIGH                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 6 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_PDPTE2_FULL                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_PDPTE2_HIGH                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 7 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_GUEST_PDPTE3_FULL                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_PDPTE3_HIGH                              (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_GUEST | ( 8 << 1 ) | VMCS_ACCESS_HIGH )
+
+// 64-Bit Host-State Fields (B.2.4)
+
+#define VMCS_HOST_IA32_PAT_FULL                             (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_HOST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_IA32_PAT_HIGH                             (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_HOST | ( 0 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_HOST_IA32_EFER_FULL                            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_HOST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_IA32_EFER_HIGH                            (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_HOST | ( 1 << 1 ) | VMCS_ACCESS_HIGH )
+
+#define VMCS_HOST_IA32_PERF_GLOBAL_CTRL_FULL                (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_HOST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_IA32_PERF_GLOBAL_CTRL_HIGH                (VMCS_FIELD)( VMCS_FIELD_64_BIT | VMCS_TYPE_HOST | ( 2 << 1 ) | VMCS_ACCESS_HIGH )
+
+
+// 32-Bit Fields (B.3)
+
+// 32-Bit Control Fields (B.3.1)
+
+// Pin-Based VM-Execution Controls
+#define PIN_BASED_EXTERNAL_INT_EXIT                         ((QWORD)1<<0)
+#define PIN_BASED_NMI_EXIT                                  ((QWORD)1<<3)
+#define PIN_BASED_VIRTUAL_NMI                               ((QWORD)1<<5)
+#define PIN_BASED_ACTIVATE_PREEMPT_TIMER                    ((QWORD)1<<6)
+#define PIN_BASED_PROCESS_POSTED_INTS                       ((QWORD)1<<7)
+
+#define VMCS_CONTROL_PINBASED_CONTROLS                      (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+
+// Primary Processor-Based VM-Execution Controls
+#define PROC_BASED_PRIMARY_INT_WINDOW_EXIT                  ((QWORD)1<<2)
+#define PROC_BASED_PRIMARY_TSC_OFFSETING                    ((QWORD)1<<3)
+#define PROC_BASED_PRIMARY_HLT_EXIT                         ((QWORD)1<<7)
+#define PROC_BASED_PRIMARY_INVLPG_EXIT                      ((QWORD)1<<9)
+#define PROC_BASED_PRIMARY_MWAIT_EXIT                       ((QWORD)1<<10)
+#define PROC_BASED_PRIMARY_RDPMC_EXIT                       ((QWORD)1<<11)
+#define PROC_BASED_PRIMARY_RDTSC_EXIT                       ((QWORD)1<<12)
+#define PROC_BASED_PRIMARY_CR3_LOAD_EXIT                    ((QWORD)1<<15)
+#define PROC_BASED_PRIMARY_CR3_STORE_EXIT                   ((QWORD)1<<16)
+#define PROC_BASED_PRIMARY_CR8_LOAD_EXIT                    ((QWORD)1<<19)
+#define PROC_BASED_PRIMARY_CR8_STORE_EXIT                   ((QWORD)1<<20)
+#define PROC_BASED_PRIMARY_USE_TPR_SHADOW                   ((QWORD)1<<21)
+#define PROC_BASED_PRIMARY_NMI_WINDOW_EXIT                  ((QWORD)1<<22)
+#define PROC_BASED_PRIMARY_MOV_DR_EXIT                      ((QWORD)1<<23)
+#define PROC_BASED_PRIMARY_UNCONDITIONAL_IO_EXIT            ((QWORD)1<<24)
+#define PROC_BASED_PRIMARY_USE_IO_BITMAPS                   ((QWORD)1<<25)
+#define PROC_BASED_PRIMARY_MONITOR_TRAP_FLAG                ((QWORD)1<<27)
+#define PROC_BASED_PRIMARY_USE_MSR_BITMAPS                  ((QWORD)1<<28)
+#define PROC_BASED_PRIMARY_MONITOR_EXIT                     ((QWORD)1<<29)
+#define PROC_BASED_PRIMARY_PAUSE_EXIT                       ((QWORD)1<<30)
+#define PROC_BASED_PRIMARY_ACTIVATE_SECONDARY_CTLS          ((QWORD)1<<31)
+
+
+#define VMCS_CONTROL_PRIMARY_PROCBASED_CONTROLS             (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_EXCEPTION_BITMAP                       (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_PF_ERROR_CODE_MASK                     (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_PF_ERROR_CODE_MATCH                    (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR3_TARGET_COUNT                       (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+
+// 24.7.1 VM-Exit Controls
+#define EXIT_CONTROL_SAVE_DEBUG_CTLS                        ((QWORD)1<<2)
+#define EXIT_CONTROL_HOST_ADDRESS_SPACE_SIZE                ((QWORD)1<<9)
+#define EXIT_CONTROL_LOAD_IA32_PERF_GLOBAL_CTRL             ((QWORD)1<<12)
+#define EXIT_CONTROL_ACK_INT_ON_EXIT                        ((QWORD)1<<15)
+#define EXIT_CONTROL_SAVE_IA32_PAT                          ((QWORD)1<<18)
+#define EXIT_CONTROL_LOAD_IA32_PAT                          ((QWORD)1<<19)
+#define EXIT_CONTROL_SAVE_IA32_EFER                         ((QWORD)1<<20)
+#define EXIT_CONTROL_LOAD_IA32_EFER                         ((QWORD)1<<21)
+#define EXIT_CONTROL_SAVE_VMX_PREEMPT_TIMER_VALUE           ((QWORD)1<<22)
+
+#define VMCS_CONTROL_VM_EXIT_CONTROLS                       (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VM_EXIT_MSR_STORE_COUNT                (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VM_EXIT_MSR_LOAD_COUNT                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+
+// 24.8.1 VM-Entry Controls
+#define ENTRY_CONTROL_LOAD_DEBUG_CTLS                       ((QWORD)1<<2)
+#define ENTRY_CONTROL_IA32E_MODE_GUEST                      ((QWORD)1<<9)
+#define ENTRY_CONTROL_ENTRY_TO_SMM                          ((QWORD)1<<10)
+#define ENTRY_CONTROL_DEACTIVATE_DUAL_MONITOR               ((QWORD)1<<11)
+#define ENTRY_CONTROL_LOAD_IA32_PERF_GLOBAL_CTRL            ((QWORD)1<<13)
+#define ENTRY_CONTROL_LOAD_IA32_PAT                         ((QWORD)1<<14)
+#define ENTRY_CONTROL_LOAD_IA32_EFER                        ((QWORD)1<<15)
+
+#define VMCS_CONTROL_VM_ENTRY_CONTROLS                      (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 9 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VM_ENTRY_MSR_LOAD_COUNT                (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 10 << 1 ) | VMCS_ACCESS_FULL )
+
+enum _INTERRUPTION_TYPE
+{
+    InterruptionTypeExternalInterrupt,
+    InterruptionTypeReserved,
+    InterruptionTypeNMI,
+    InterruptionTypeHardwareException,
+    InterruptionTypeSoftwareInterrupt,
+    InterruptionTypePrivilegedSoftwareException,
+    InterruptionTypeSoftwareException,
+    InterruptionTypeOtherEvent
+} INTERRUPTION_TYPE;
+
+typedef union _VM_ENTRY_INT_INFO
+{
+    struct
+    {
+        DWORD           Vector              :       8;
+        DWORD           InterruptionType    :       3;
+        DWORD           ErrorCode           :       1;
+        DWORD           Reserved            :       19;
+        DWORD           Valid               :       1;
+    };
+    DWORD               Raw;
+} VM_ENTRY_INT_INFO, *PVM_ENTRY_INT_INFO;
+STATIC_ASSERT( sizeof( VM_ENTRY_INT_INFO ) == sizeof( DWORD ) );
+
+#define VMCS_CONTROL_VM_ENTRY_INT_INFO_FIELD                (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 11 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VM_ENTRY_EXCEPTION_ERROR_CODE          (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 12 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_VM_ENTRY_INSTRUCTION_LENGTH            (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 13 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_TPR_THRESHOLD                          (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 14 << 1 ) | VMCS_ACCESS_FULL )
+
+// Secondary Processor-Based VM-Execution Controls
+#define PROC_BASED_SECONDARY_VIRTUALIZE_APIC_ACCESS         ((QWORD)1<<0)
+#define PROC_BASED_SECONDARY_ENABLE_EPT                     ((QWORD)1<<1)
+#define PROC_BASED_SECONDARY_DESCRIPTOR_TABLE_EXIT          ((QWORD)1<<2)
+#define PROC_BASED_SECONDARY_ENABLE_RDTSCP                  ((QWORD)1<<3)
+#define PROC_BASED_SECONDARY_VIRTUALIZE_X2_APIC             ((QWORD)1<<4)
+#define PROC_BASED_SECONDARY_ENABLE_VPID                    ((QWORD)1<<5)
+#define PROC_BASED_SECONDARY_WBINVD_EXIT                    ((QWORD)1<<6)
+#define PROC_BASED_SECONDARY_UNRESTRICTED_GUEST             ((QWORD)1<<7)
+#define PROC_BASED_SECONDARY_APIC_REGISTER_VIRTUALIZATION   ((QWORD)1<<8)
+#define PROC_BASED_SECONDARY_VIRTUAL_INTERRUPT_DELIVERY     ((QWORD)1<<9)
+#define PROC_BASED_SECONDARY_PAUSE_LOOP_EXIT                ((QWORD)1<<10)
+#define PROC_BASED_SECONDARY_RDRAND_EXIT                    ((QWORD)1<<11)
+#define PROC_BASED_SECONDARY_ENABLE_INVPCID                 ((QWORD)1<<12)
+#define PROC_BASED_SECONDARY_ENABLE_VM_FUNCS                ((QWORD)1<<13)
+#define PROC_BASED_SECONDARY_VMCS_SHADOWING                 ((QWORD)1<<14)
+#define PROC_BASED_SECONDARY_RDSEED_EXIT                    ((QWORD)1<<16)
+#define PROC_BASED_SECONDARY_EPT_VIOLATION_INTERRUPT        ((QWORD)1<<18)
+#define PROC_BASED_SECONDARY_ENABLE_XSAVES_XSTORS           ((QWORD)1<<20)
+#define PROC_BASED_SECONDARY_MODE_BASED_EXECUTE_EPT         ((QWORD)1<<22)
+#define PROC_BASED_SECONDARY_USE_TSC_SCALING                ((QWORD)1<<25)
+
+#define VMCS_CONTROL_SECONDARY_PROCBASED_CONTROLS           (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 15 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_PLE_GAP                                (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 16 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_PLE_WINDOW                             (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_CONTROL | ( 17 << 1 ) | VMCS_ACCESS_FULL )
+
+// 32-Bit Exit Fields (B.3.2)
+
+#define VMCS_EXIT_INSTRUCTION_ERROR                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+
+typedef union _EXIT_REASON_STRUCT
+{
+    struct
+    {
+        WORD            BasicExitReason;
+        WORD            Reserved0                           :   12;
+        WORD            PendingMTF                          :   1;
+        WORD            RootExit                            :   1;
+        WORD            Reserved1                           :   1;
+        WORD            EntryFailure                        :   1;
+    };
+    DWORD               Raw;
+} EXIT_REASON_STRUCT, *PEXIT_REASON_STRUCT;
+STATIC_ASSERT(sizeof(EXIT_REASON_STRUCT) == sizeof(DWORD));
+
+#define VMCS_EXIT_REASON                                    (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_INT_INFO                                  (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_INT_ERROR_CODE                            (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_IDT_INFO_FIELD                            (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_IDT_ERROR_CODE                            (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_INSTRUCTION_LENGTH                        (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_INSTRUCTION_INFO                          (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_EXIT | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+
+// 32-Bit Guest-State Fields (B.3.3)
+
+#define VMCS_GUEST_ES_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_CS_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_SS_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_DS_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_FS_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_GS_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_LDTR_LIMIT                               (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_TR_LIMIT                                 (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_GDTR_LIMIT                               (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IDTR_LIMIT                               (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 9 << 1 ) | VMCS_ACCESS_FULL )
+
+
+// Table 24-2 Segment Access Rights useful defines
+#define SEGMENT_ACCESS_RIGHTS_DESC_TYPE                     ((QWORD)1<<4)
+#define SEGMENT_ACCESS_RIGHTS_P_BIT                         ((QWORD)1<<7)
+#define SEGMENT_ACCESS_RIGHTS_L_BIT                         ((QWORD)1<<13)
+#define SEGMENT_ACCESS_RIGHTS_DB_BIT                        ((QWORD)1<<14)
+#define SEGMENT_ACCESS_RIGHTS_G_BIT                         ((QWORD)1<<15)
+#define SEGMENT_ACCESS_RIGHTS_UNUSABLE                      ((QWORD)1<<16)
+
+#define VMCS_GUEST_ES_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 10 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_CS_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 11 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_SS_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 12 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_DS_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 13 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_FS_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 14 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_GS_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 15 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_LDTR_ACCESS_RIGHTS                       (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 16 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_TR_ACCESS_RIGHTS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 17 << 1 ) | VMCS_ACCESS_FULL )
+
+#define INT_STATE_BLOCKING_BY_STI                           ((QWORD)1<<0)
+#define INT_STATE_BLOCKING_BY_MOV_SS                        ((QWORD)1<<1)
+
+#define VMCS_GUEST_INT_STATE                                (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 18 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_ACTIVITY_STATE                           (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 19 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_SMBASE                                   (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 20 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_SYSENTER_CS                         (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 21 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_VMX_PREEMPT_TIMER_VALUE                  (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_GUEST | ( 23 << 1 ) | VMCS_ACCESS_FULL )
+
+// 32-Bit Host-State Fields (B.3.4)
+
+#define VMCS_HOST_IA32_SYSENTER_CS                          (VMCS_FIELD)( VMCS_FIELD_32_BIT | VMCS_TYPE_HOST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+
+// Natural-Width Fields (B.4)
+
+// Natural-Width Control Fields (B.4.1)
+
+#define VMCS_CONTROL_CR0_MASK                               (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR4_MASK                               (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR0_READ_SHADOW                        (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR4_READ_SHADOW                        (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR3_TARGET_0                           (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR3_TARGET_1                           (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR3_TARGET_2                           (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_CONTROL_CR3_TARGET_3                           (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_CONTROL | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+
+// Natural-Width Exit Fields (B.4.2)
+
+#define VMCS_EXIT_QUALIFICATION                             (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_EXIT | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_IO_RCX                                    (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_EXIT | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_IO_RSI                                    (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_EXIT | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_IO_RDI                                    (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_EXIT | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_IO_RIP                                    (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_EXIT | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_EXIT_GUEST_LINEAR_ADDRESS                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_EXIT | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+
+// Natural-Width Guest-State Fields (B.4.3)
+
+#define VMCS_GUEST_CR0                                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_CR3                                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_CR4                                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_ES_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_CS_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_SS_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_DS_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_FS_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_GS_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_LDTR_BASE                                (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 9 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_TR_BASE                                  (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 10 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_GDTR_BASE                                (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 11 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IDTR_BASE                                (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 12 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_DR7                                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 13 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_RSP                                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 14 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_RIP                                      (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 15 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_RFLAGS                                   (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 16 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_PENDING_DEBUG_EXCEPTIONS                 (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 17 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_SYSENTER_ESP                        (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 18 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_GUEST_IA32_SYSENTER_EIP                        (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_GUEST | ( 19 << 1 ) | VMCS_ACCESS_FULL )
+
+// Natural-Width Host-State Fields (B.4.4)
+
+#define VMCS_HOST_CR0                                       (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 0 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_CR3                                       (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 1 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_CR4                                       (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 2 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_FS_BASE                                   (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 3 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_GS_BASE                                   (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 4 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_TR_BASE                                   (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 5 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_GDTR_BASE                                 (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 6 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_IDTR_BASE                                 (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 7 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_IA32_SYSENTER_ESP                         (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 8 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_IA32_SYSENTER_EIP                         (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 9 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_RSP                                       (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 10 << 1 ) | VMCS_ACCESS_FULL )
+#define VMCS_HOST_RIP                                       (VMCS_FIELD)( VMCS_FIELD_NATURAL | VMCS_TYPE_HOST | ( 11 << 1 ) | VMCS_ACCESS_FULL )
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/HAL/inc/vmx.h b/src_proiect/HAL/inc/vmx.h
new file mode 100644
index 0000000..f390b3b
--- /dev/null
+++ b/src_proiect/HAL/inc/vmx.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "vmcs_fields.h"
+#include "vmx_exit.h"
+
+QWORD
+VmxRead(
+    IN _Strict_type_match_
+            VMCS_FIELD Field
+    );
+
+void
+VmxWrite(
+    IN _Strict_type_match_
+            VMCS_FIELD  Field,
+    IN      QWORD       Value
+    );
diff --git a/src_proiect/HAL/inc/vmx_exit.h b/src_proiect/HAL/inc/vmx_exit.h
new file mode 100644
index 0000000..df74302
--- /dev/null
+++ b/src_proiect/HAL/inc/vmx_exit.h
@@ -0,0 +1,186 @@
+#pragma once
+
+#include "vmx_exit_reasons.h"
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+//warning C4214: nonstandard extension used : bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+#define CR_ACCESS_TYPE_MOV_TO_CR                           0
+#define CR_ACCESS_TYPE_MOVE_FROM_CR                        1
+#define CR_ACCESS_TYPE_CLTS                                2
+#define CR_ACCESS_TYPE_LMSW                                3
+
+typedef struct _EXIT_QUALIFICATION_CR_ACCESS
+{
+    QWORD           ControlRegisterNumber               :   4;
+    QWORD           AccessType                          :   2;
+    QWORD           LMSWOperandType                     :   1;
+    QWORD           Reserved0                           :   1;
+    QWORD           GeneralPurposeRegister              :   4;
+    QWORD           Reserved1                           :   4;
+    QWORD           LMSWSourceData                      :  16;
+    QWORD           Reserved2                           :  32;
+} EXIT_QUALIFICATION_CR_ACCESS, *PEXIT_QUALIFICATION_CR_ACCESS;
+STATIC_ASSERT( sizeof( EXIT_QUALIFICATION_CR_ACCESS ) == sizeof( QWORD ) );
+
+#define IO_ACCESS_SIZE_1BYTE                                0
+#define IO_ACCESS_SIZE_2BYTES                               1
+#define IO_ACCESS_SIZE_4BYTES                               3
+
+#define IO_ACCESS_DIRECTION_OUT                             0
+#define IO_ACCESS_DIRECTION_IN                              1
+
+#define IO_ACCESS_OPERAND_DX                                0
+#define IO_ACCESS_OPERAND_IMMEDIATE                         1
+
+typedef struct _EXIT_QUALIFICATION_IO_INSTRUCTION
+{
+    QWORD           AccessSize                          :   3;
+    QWORD           AccessDirection                     :   1;
+    QWORD           StringOperation                     :   1;
+    QWORD           RepPrefixed                         :   1;
+    QWORD           OperandEncoding                     :   1;
+    QWORD           Reserved0                           :   9;
+    QWORD           PortNumber                          :  16;
+    QWORD           Reserved1                           :  32;
+} EXIT_QUALIFICATION_IO_INSTRUCTION, *PEXIT_QUALIFICATION_IO_INSTRUCTION;
+STATIC_ASSERT( sizeof( EXIT_QUALIFICATION_IO_INSTRUCTION ) == sizeof( QWORD ) );
+
+// 4 - VM_SIPI_SIGNAL
+typedef struct _EXIT_QUALIFICATION_SIPI
+{
+    QWORD           Vector                              :   8;
+    QWORD           Reserved                            :  56;
+} EXIT_QUALIFICATION_SIPI, *PEXIT_QUALIFICATION_SIPI;
+STATIC_ASSERT( sizeof( EXIT_QUALIFICATION_SIPI ) == sizeof( QWORD ) );
+
+// Table 27-10. Format of the VM-Exit Instruction-Information Field as Used for LIDT, LGDT, SIDT, or SGDT
+// 46 - LIDT/LGDT/SIDT/SGDT
+#define ADDRESS_SIZE_16_BIT                                 0b000
+#define ADDRESS_SIZE_32_BIT                                 0b001
+#define ADDRESS_SIZE_64_BIT                                 0b010
+
+#define INSTRUCTION_IDENTITY_SGDT                           0b00
+#define INSTRUCTION_IDENTITY_SIDT                           0b01
+#define INSTRUCTION_IDENTITY_LGDT                           0b10
+#define INSTRUCTION_IDENTITY_LIDT                           0b11
+
+typedef union _EXIT_INSTRUCTION_INFORMATION_GDT_IDT
+{
+    struct
+    {
+        // Undefined for instructions with no index register (bit 22 is set).
+        DWORD           Scaling                             :   2;
+        DWORD           __Reserved0                         :   5;
+        DWORD           AddressSize                         :   3;
+        DWORD           Zero                                :   1;
+
+        // Undefined for VM exits from 64-bit mode
+        DWORD           OperandSize                         :   1;
+        DWORD           __Reserved1                         :   3;
+        DWORD           SegmentRegister                     :   3;
+
+        // Undefined for instructions with no index register (bit 22 is set)
+        DWORD           IndexRegister                       :   4;
+        DWORD           IndexRegInvalid                     :   1;
+
+        // Undefined for instructions with no base register (bit 27 is set)
+        DWORD           BaseRegister                        :   4;
+        DWORD           BaseRegisterInvalid                 :   1;
+        DWORD           InstructionIdentity                 :   2;
+        DWORD           __Reserved2                         :   2;
+    };
+    DWORD               Raw;
+} EXIT_INSTRUCTION_INFORMATION_GDT_IDT, *PEXIT_INSTRUCTION_INFORMATION_GDT_IDT;
+STATIC_ASSERT( sizeof( EXIT_INSTRUCTION_INFORMATION_GDT_IDT ) == sizeof( DWORD ) );
+
+// 47 - LLDT/LTR/SLDT/STR
+typedef union _EXIT_INSTRUCTION_INFORMATION_LDT_TR
+{
+    struct
+    {
+        // Undefined for register instructions (bit 10 is set) and for memory instructions with no index register
+        // (bit 10 is clear and bit 22 is set).
+        DWORD           Scaling                             :   2;
+        DWORD           __Reserved0                         :   1;
+
+        // Undefined for memory instructions (bit 10 is clear)
+        DWORD           Register1                           :   4;
+
+        // Other values not used. Undefined for register instructions (bit 10 is set).
+        DWORD           AddressSize                         :   3;
+
+        // Mem/Reg (0 = memory; 1 = register).
+        DWORD           MemReg                              :   1;
+        DWORD           __Reserved11_14                     :   4;
+
+        // Undefined for register instructions (bit 10 is set)
+        DWORD           SegmentRegister                     :   3;
+
+        // Undefined for register instructions(bit 10 is set) and for memory instructions with no index register
+        // (bit 10 is clear and bit 22 is set).
+        DWORD           IndexReg                            :   4;
+        DWORD           IndexRegInvalid                     :   1;
+
+        // Undefined for register instructions(bit 10 is set) and for memory instructions with no base register
+        // (bit 10 is clear and bit 27 is set)
+        DWORD           BaseRegister                        :   4;
+        DWORD           BaseRegisterInvalid                 :   1;
+
+        DWORD           InstructionIdentity                 :   2;
+        DWORD           __Reserved2                         :   2;
+    };
+    DWORD               Raw;
+} EXIT_INSTRUCTION_INFORMATION_LDT_TR, *PEXIT_INSTRUCTION_INFORMATION_LDT_TR;
+STATIC_ASSERT( sizeof( EXIT_INSTRUCTION_INFORMATION_LDT_TR ) == sizeof( DWORD ) );
+
+typedef enum _OPERAND_SIZE
+{
+    OperandSizeWord,
+    OperandSizeDword,
+    OperandSizeQword,
+    OperandSizeUnused
+} OPERAND_SIZE, *POPERAND_SIZE;
+
+// 57 - VM_EXIT_RDRAND
+typedef union _EXIT_INSTRUCTION_INFORMATION_RD_INSTRUCTION
+{
+    struct
+    {
+        DWORD           Undefined0                          :   3;
+        DWORD           DestinationRegister                 :   4;
+        DWORD           Undefined1                          :   4;
+        DWORD           OperandSize                         :   2;
+        DWORD           Undefined2                          :  19;
+    };
+    DWORD               Raw;
+} EXIT_INSTRUCTION_INFORMATION_RD_INSTRUCTION, *PEXIT_INSTRUCTION_INFORMATION_RD_INSTRUCTION;
+STATIC_ASSERT( sizeof( EXIT_INSTRUCTION_INFORMATION_RD_INSTRUCTION ) == sizeof( DWORD ) );
+
+// Event-specific information is provided for VM exits due to the following vectored events: exceptions (including
+// those generated by the instructions INT3, INTO, BOUND, and UD2); external interrupts that occur while the
+// acknowledge interrupt on exit VM - exit control is 1; and non - maskable interrupts(NMIs).
+typedef union _EXIT_INTERRUPTION_INFORMATION
+{
+    struct
+    {
+        DWORD           Vector                              :   8;
+        DWORD           Type                                :   3;
+        DWORD           ErrorCodeValid                      :   1;
+        DWORD           NMIUnblockingDueToIRET              :   1;
+        DWORD           __Reserved                          :  18;
+        DWORD           Valid                               :   1;
+    };
+    DWORD               Raw;
+} EXIT_INTERRUPTION_INFORMATION, *PEXIT_INTERRUPTION_INFORMATION;
+STATIC_ASSERT( sizeof( EXIT_INTERRUPTION_INFORMATION ) == sizeof( DWORD ) );
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/HAL/inc/vmx_exit_reasons.h b/src_proiect/HAL/inc/vmx_exit_reasons.h
new file mode 100644
index 0000000..cb977b5
--- /dev/null
+++ b/src_proiect/HAL/inc/vmx_exit_reasons.h
@@ -0,0 +1,230 @@
+#pragma once
+
+// VMX Basic Exit Reasons (Appendix C)
+
+// Either:
+//      1. Guest SW caused exception and the control bit was set to 1
+//      2. NMI was delivered to processor and "NMI Exiting" is set
+#define VM_EXIT_EXCEPTION_OR_NMI                        0
+
+// An external interrupt was delivered and "external-interrupt exiting" is set
+#define VM_EXIT_EXTERNAL_INT                            1
+
+// Triple fault :)
+#define VM_EXIT_TRIPLE_FAULT                            2
+
+// An INIT signal arrived
+#define VM_EXIT_INIT_SIGNAL                             3
+
+// A SIPI signal arrived while processor was in "wait-for-SIPI" state
+#define VM_EXIT_SIPI_SIGNAL                             4
+
+// An SMI arrived after retirement of an I/O instruction (34.15.2)
+#define VM_EXIT_IO_SMI_SIGNAL                           5
+
+// An SMI arrived but not immediately after retirement of I/O instruction (34.15.2)
+#define VM_EXIT_OTHER_SMI_SIGNAL                        6
+
+// Interrupt Window
+//      At the beginning of an instruction, RFLAGS.IF was 1, events were not blocked
+//      by STI or MOV SS; and "interrupt-window exiting" was set
+#define VM_EXIT_INT_WINDOW                              7
+
+// NMI window
+//      same as above; and "NMI-window exiting" was set
+#define VM_EXIT_NMI_WINDOW                              8
+
+// Guest SW attempted a task switch
+#define VM_EXIT_TASK_SWITCH                             9
+
+// Guest SW attempted to execute CPUID
+#define VM_EXIT_CPUID                                   10
+
+// Guest SW attempted to execute GETSEC
+#define VM_EXIT_GETSEC                                  11
+
+// Guest SW attempted to execute HLT and "HLT exiting" was set
+#define VM_EXIT_HLT                                     12
+
+// Guest SW attempted to execute INVD
+#define VM_EXIT_INVD                                    13
+
+// Guest SW attempted to execute INVLPG and "INVLPG exiting" was set
+#define VM_EXIT_INVLPG                                  14
+
+// Guest SW attempted to execute RDPMC and "RDPMC exiting" was set
+#define VM_EXIT_RDPMC                                   15
+
+// Guest SW attempted to execute RDTSC and "RDTSC exiting" was set
+#define VM_EXIT_RDTSC                                   16
+
+// Guest SW attempted to execute INVD in SMM
+#define VM_EXIT_RSM                                     17
+
+// VMCALL was executed either by guest SW or by the executive monitor (34.15.2)
+#define VM_EXIT_VMCALL                                  18
+
+// Guest SW attempted to execute VMCLEAR
+#define VM_EXIT_VMCLEAR                                 19
+
+// Guest SW attempted to execute VMLAUNCH
+#define VM_EXIT_VMLAUNCH                                20
+
+// Guest SW attempted to execute VMPTRLD
+#define VM_EXIT_VMPTRLD                                 21
+
+// Guest SW attempted to execute VMPTRST
+#define VM_EXIT_VMPTRST                                 22
+
+// Guest SW attempted to execute VMREAD
+#define VM_EXIT_VMREAD                                  23
+
+// Guest SW attempted to execute VMCLEAR
+#define VM_EXIT_VMRESUME                                24
+
+// Guest SW attempted to execute VMWRITE
+#define VM_EXIT_VMWRITE                                 25
+
+// Guest SW attempted to execute VMXOFF
+#define VM_EXIT_VMXOFF                                  26
+
+// Guest SW attempted to execute VMXON
+#define VM_EXIT_VMXON                                   27
+
+// Guest SW attempted to access CR0, CR3, CR4 or CR8 (25.1)
+#define VM_EXIT_CR_ACCESS                               28
+
+// Guest SW attempted a MOV to or from a debug register and the
+// "MOV-DR exiting" was set
+#define VM_EXIT_MOV_DR                                  29
+
+// Guest SW attempted to execute an I/O Instruction and either:
+//      1. "unconditional I/O exiting" was set
+//      2. "use I/O bitmaps" was set and the bit associated with the port was set
+#define VM_EXIT_IO_INSTRUCTION                          30
+
+// Either:
+//      1. "use MSR bitmaps" was 0
+//      2. value of RCX not in a valid range( [0x0,0x1FFF] \/ [0xC0000000,0xC0001FFF] )
+//      3. RCX was in low range and the n-th bit in read bitmap for low MSR was set
+//      4. RCX was in high range and the n-th bit in read bitmap for high MSR was set
+#define VM_EXIT_RDMSR                                   31
+
+// Either:
+//      1. "use MSR bitmaps" was 0
+//      2. value of RCX not in a valid range( [0x0,0x1FFF] \/ [0xC0000000,0xC0001FFF] )
+//      3. RCX was in low range and the n-th bit in write bitmap for low MSR was set
+//      4. RCX was in high range and the n-th bit in write bitmap for high MSR was set
+#define VM_EXIT_WRMSR                                   32
+
+// A VM entry failed one of the checks (26.3.1)
+#define VM_EXIT_ENTRY_FAILURE_GUEST_STATE               33
+
+// A VM entry failed to load MSRs (26.4)
+#define VM_EXIT_ENTRY_FAILURE_MSR_LOAD                  34
+
+// Guest SW attempted to execute MWAIT and "MWAIT exiting" was set
+#define VM_EXIT_MWAIT                                   36
+
+// A VM entry occurred due to the 1-setting of the "monitor trap flag" and
+// injection of an MTF VM exit as part of VM entry (25.5.2)
+#define VM_EXIT_MONITOR_TRAP_FLAG                       37
+
+// Guest SW attempted to execute MONITOR and "MONITOR exiting" was set
+#define VM_EXIT_MONITOR                                 39
+
+// Either:
+//      1. Guest SW attempted to execute PAUSE and "PAUSE exiting" was set
+//      2. "PAUSE-loop exiting" was set and guest SW executed a PAUSE loop with
+//         execution time exceeding PLE_Window (25.1.3)
+#define VM_EXIT_PAUSE                                   40
+
+// A machine-check occurred during VM entry (26.8)
+#define VM_EXIT_ENTRY_FAILURE_MACHINE_CHECK             41
+
+// The TPR was below that of the TPR threshold field while "use TPR shadow"
+// was set, either because:
+//      1. As part of TPR virtualization (29.1.2)
+//      2. As part of VM Entry (26.6.7)
+#define VM_EXIT_TPR_BELOW_THRESHOLD                     43
+
+// Guest SW attempted to access memory at a physical address on the
+// APIC-access page and the "virtualize APIC accesses" was set (29.4)
+#define VM_EXIT_APIC_ACCESS                             44
+
+// EOI virtualization was performed for a virtual interrupt whose vector indexed
+// a bit set in the EOI-exit bitmap
+#define VM_EXIT_VIRTUALIZED_EOI                         45
+
+// Guest SW attempted LGDT, LIDT, SGDT or SIDT and "descriptor-table exiting" was set
+#define VM_EXIT_GDTR_IDTR_ACCESS                        46
+
+// Guest SW attempted LLDT, LTR, SLDT or STR and "descriptor-table exiting" was set
+#define VM_EXIT_LDTR_TR_ACCESS                          47
+
+// An attempt to access memory with a guest-physical address was disallowed by the
+// configuration of the EPT paging structures
+#define EPT_VIOLATION_EXIT_QUALITIFICATION_READ_MASK            (1<<0)
+#define EPT_VIOLATION_EXIT_QUALITIFICATION_WRITE_MASK           (1<<1)
+#define EPT_VIOLATION_EXIT_QUALITIFICATION_EXEC_MASK            (1<<2)
+
+#define EPT_VIOLATION_EXIT_QUALIFICATION_READ_PERMISSION        (1<<3)
+#define EPT_VIOLATION_EXIT_QUALIFICATION_WRITE_PERMISSION       (1<<4)
+#define EPT_VIOLATION_EXIT_QUALIFICATION_EXEC_PERMISSION        (1<<5)
+
+#define EPT_VIOLATION_GUEST_LINEAR_ADDRESS_VALID_MASK           (1<<7)
+#define EPT_VIOLATION_LINEAR_TO_PHYSICAL_TRANSLATION_MASK       (1<<8)
+
+#define VM_EXIT_EPT_VIOLATION                           48
+
+// An attempt to access memory with a guest-physical address encountered a misconfigured
+// EPT paging-structure entry
+#define VM_EXIT_EPT_MISCONFIGURATION                    49
+
+// Guest SW attempted to execute INVEPT
+#define VM_EXIT_INVEPT                                  50
+
+// Guest SW attempted to execute RDTSCP and "enable RDTSCP" and "RDTSC exiting" were BOTH set
+#define VM_EXIT_RDTSCP                                  51
+
+// The preemption timer counted down to zero.
+#define VM_EXIT_VMX_PREEMPT_TIMER_EXPIRED               52
+
+// Guest SW attempted to execute INVVPID
+#define VM_EXIT_INVVPID                                 53
+
+// Guest SW attempted to execute WBINVD and "WBINVD exiting" was set
+#define VM_EXIT_WBINVD                                  54
+
+// Guest SW attempted to execute XSETBV
+#define VM_EXIT_XSETBV                                  55
+
+// Guest SW attempted to complete a write to the virtual-APIC page that
+// must be virtualized by VMM SW (29.4.3.3)
+#define VM_EXIT_APIC_WRITE                              56
+
+// Guest SW attempted to execute RDRAND and "RDRAND exiting" was set
+#define VM_EXIT_RDRAND                                  57
+
+// Guest SW attempted to execute INVPCID and "enable INVPCID" and "INVLPG exiting" were BOTH set
+#define VM_EXIT_INVPCID                                 58
+
+// Guest SW invoked a VM function and either:
+//      1. The function invoked was not enabled
+//      2. The function generated a function-specific condition causing a VM exit
+#define VM_EXIT_VMFUNC                                  59
+
+// Guest SW attempted to execute RDSEED and "RDSEED exiting" was set
+#define VM_EXIT_RDSEED                                  61
+
+// Guest SW attempted to execute XSAVES and "enable XSAVES/XRSTORS" was set
+// and a bit was set in the logical-AND of the following 3 values:
+// EDX:EAX, IA32_XSS MSR, XSS-exiting bitmap
+#define VM_EXIT_XSAVES                                  63
+
+// Guest SW attempted to execute XRSTORS and "enable XSAVES/XRSTORS" was set
+// and a bit was set in the logical-AND of the following 3 values:
+// EDX:EAX, IA32_XSS MSR, XSS-exiting bitmap
+#define VM_EXIT_XRSTORS                                 64
+
+#define VM_EXIT_RESERVED                                VM_EXIT_XRSTORS + 1
diff --git a/src_proiect/HAL/inc/yasm_imports.h b/src_proiect/HAL/inc/yasm_imports.h
new file mode 100644
index 0000000..9063460
--- /dev/null
+++ b/src_proiect/HAL/inc/yasm_imports.h
@@ -0,0 +1,66 @@
+#pragma once
+
+#include "gdt.h"
+
+typedef
+void
+(__cdecl FUNC_Magic) (
+    void
+    );
+
+//******************************************************************************
+// Function:     FUNC_Magic
+// Description:  Generates bochs magic breakpoint
+// Returns:      void
+//******************************************************************************
+extern FUNC_Magic       __magic;
+
+typedef
+void
+(__cdecl FUNC_StiAndHlt) (
+   void
+   );
+
+//******************************************************************************
+// Function:     __sti_and_hlt
+// Description:  Enables interrupts and halts
+// Returns:      void
+//******************************************************************************
+extern FUNC_StiAndHlt   __sti_and_hlt;
+
+typedef 
+void
+(__cdecl FUNC_LoadTR ) (
+    IN       WORD       GdtIndex               
+    );
+
+//******************************************************************************
+// Function:      __ltr
+// Description:   Loads a new TR selector.
+// Returns:       void
+// Parameter:     IN WORD GdtIndex - index in GDT of the descriptor
+//******************************************************************************
+extern FUNC_LoadTR      __ltr;
+
+typedef
+void
+(__cdecl FUNC_StoreGDT) (
+    OUT     PGDT        Gdt
+    );
+
+//******************************************************************************
+// Function:      __ltr
+// Description:   Loads a new TR selector.
+// Returns:       void
+// Parameter:     IN WORD GdtIndex - index in GDT of the descriptor
+//******************************************************************************
+extern FUNC_StoreGDT    __sgdt;
+
+typedef
+void
+(__cdecl FUNC_ChangeStack)(
+    IN  PVOID       InitialStackBase,
+    IN  PVOID       NewStackBase
+    );
+
+extern FUNC_ChangeStack __changeStack;
\ No newline at end of file
diff --git a/src_proiect/HAL/src/_exports.yasm b/src_proiect/HAL/src/_exports.yasm
new file mode 100644
index 0000000..40740d8
--- /dev/null
+++ b/src_proiect/HAL/src/_exports.yasm
@@ -0,0 +1,109 @@
+global __magic
+global __sti_and_hlt
+global __ltr    
+global __sgdt
+global __reloadGDT
+global __changeStack
+global __HALreadfsqword
+
+align 0x10, db 0
+[BITS 64]
+; void __cdecl __magic(void)
+__magic:
+    xchg    bx, bx
+    ret
+
+align 0x10, db 0
+[BITS 64]
+; void __cdecl __sti_and_hlt(void)
+__sti_and_hlt:
+    sti
+    hlt
+    ret
+
+align 0x10, db 0
+[BITS 64]
+; void __cdecl __ltr( IN WORD GdtIndex )
+__ltr:
+    ltr     cx
+    ret
+
+align 0x10, db 0
+[BITS 64]
+; void __cdecl __sgdt( OUT PGDT Gdt )
+__sgdt:
+    sgdt    [rcx]
+    ret
+
+align 0x10, db 0
+[BITS 64]
+; void __cdecl __reloadGDT( GDT* Gdt, IN WORD CodeSegmentSelector, IN WORD DataSegmentSelector )
+__reloadGDT:
+    mov     r10,    rsp
+
+    mov     rax,    rcx
+    lgdt    [rax]
+    
+    xor     rax,    rax
+    mov     ax,     dx
+    
+    push    rax
+    call    $ + 5                   ; place return EIP onto the stack
+    mov     eax,    10              ; instrux length to continue right after 'retf'
+    add     [rsp],  eax
+    retf
+
+    mov     ax,     r8w
+    mov     fs,     ax
+    mov     gs,     ax
+    
+[bits 32]
+    mov     ss,     ax
+[bits 64]
+    mov     rsp,    r10
+    
+    ret
+
+
+align 0x10, db 0
+[BITS 64]
+; void __cdecl __changeStack( IN PVOID InitialStackBase, IN PVOID NewStackBase )
+__changeStack:
+    push    rdi
+    push    rsi
+
+    mov     r10,    rcx
+
+    mov     rsi,    rcx     ; initial stack base
+    sub     rsi,    1
+
+    mov     rdi,    rdx     ; new stack
+    sub     rdi,    1
+
+    mov     rax,    rcx     ; rax <- initial stack base
+    sub     rax,    rsp     ; rax <- current stack pointer
+    mov     rcx,    rax     ; rcx <- how much of stack is used
+    
+    std                     ; we want to go backwards
+    
+    rep     movsb           ; we move the stack
+    
+    mov     rax,    r10
+    sub     rax,    rsp
+    
+    sub     rdx,    rax
+    
+    mov     rsp,    rdx
+    
+    pop     rsi
+    pop     rdi
+
+    cld
+
+    ret
+
+align 0x10, db 0
+[bits 64]
+__HALreadfsqword:
+    mov rax, [fs:ecx]
+    ret
diff --git a/src_proiect/HAL/src/cmos.c b/src_proiect/HAL/src/cmos.c
new file mode 100644
index 0000000..ef90644
--- /dev/null
+++ b/src_proiect/HAL/src/cmos.c
@@ -0,0 +1,98 @@
+#include "hal_base.h"
+#include "cmos.h"
+
+#define CMOS_ADDRESS_PORT               0x70
+#define CMOS_DATA_PORT                  0x71
+
+#define CMOS_DISABLE_NMI_BIT            7
+
+BYTE
+CmosGetValue(
+    IN  CMOS_REGISTER   RegisterIndex,
+    IN  BOOLEAN         DisableNMI
+    )
+{
+    ASSERT(RegisterIndex <= MAX_BYTE);
+
+    __outbyte(CMOS_ADDRESS_PORT, (BYTE) RegisterIndex | (DisableNMI << CMOS_DISABLE_NMI_BIT ));
+    return __inbyte(CMOS_DATA_PORT);
+}
+
+void
+CmosWriteValue(
+    IN  CMOS_REGISTER   RegisterIndex,
+    IN  BOOLEAN         DisableNMI,
+    IN  BYTE            Value
+    )
+{
+    ASSERT(RegisterIndex <= MAX_BYTE);
+
+    __outbyte(CMOS_ADDRESS_PORT, (BYTE)RegisterIndex | (DisableNMI << CMOS_DISABLE_NMI_BIT));
+    __outbyte(CMOS_DATA_PORT,Value);
+}
+
+static
+__forceinline
+BOOLEAN
+_CmosIsUpdateInProgress(
+    void
+    )
+{
+    return IsBooleanFlagOn(CmosGetValueNMI(CmosRegisterStatusA), CMOS_UPDATE_IN_PROGRESS);
+}
+
+void
+CmosReadData(
+    OUT     PCMOS_DATA      CmosData
+    )
+{
+    BYTE second;
+    BYTE minute;
+    BYTE hour;
+    BYTE day;
+    BYTE month;
+    BYTE year;
+    BYTE century;
+    BYTE registerB;
+
+    ASSERT(NULL != CmosData);
+
+    // wait for the CMOS update to finish
+    while (_CmosIsUpdateInProgress());
+
+    second  = CmosGetValueNMI(CmosRegisterSeconds);
+    minute  = CmosGetValueNMI(CmosRegisterMinutes);
+    hour    = CmosGetValueNMI(CmosRegisterHours);
+    day     = CmosGetValueNMI(CmosRegisterDay);
+    month   = CmosGetValueNMI(CmosRegisterMonth);
+    year    = CmosGetValueNMI(CmosRegisterYear);
+    century = CmosGetValueNMI(CmosRegisterCentury);
+
+    registerB = CmosGetValueNMI(CmosRegisterStatusB);
+
+    // Convert BCD to binary values if necessary
+
+    if (!(IsBooleanFlagOn(registerB, CMOS_BINARY_MODE)))
+    {
+        second = (second & MAX_NIBBLE) + ((second / 16) * 10);
+        minute = (minute & MAX_NIBBLE) + ((minute / 16) * 10);
+        hour = ((hour & MAX_NIBBLE) + (((hour & 0x70) / 16) * 10)) | (hour & 0x80);
+        day = (day & MAX_NIBBLE) + ((day / 16) * 10);
+        month = (month & MAX_NIBBLE) + ((month / 16) * 10);
+        year = (year & MAX_NIBBLE) + ((year / 16) * 10);
+        century = (century & MAX_NIBBLE) + ((century / 16) * 10);
+    }
+
+    // Convert 12 hour clock to 24 hour clock if necessary
+    if (!(IsBooleanFlagOn(registerB,CMOS_24H_FORMAT)) && (hour & 0x80))
+    {
+        hour = ((hour & 0x7F) + 12) % 24;
+    }
+
+    CmosData->Second = second;
+    CmosData->Minute = minute;
+    CmosData->Hour = hour;
+    CmosData->Day = day;
+    CmosData->Month = month;
+    CmosData->Year = year + century * 100;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/gdt.c b/src_proiect/HAL/src/gdt.c
new file mode 100644
index 0000000..a377839
--- /dev/null
+++ b/src_proiect/HAL/src/gdt.c
@@ -0,0 +1,134 @@
+#include "hal_base.h"
+#include "gdt.h"
+#include "tss.h"
+
+#define GDT_MAXIMUM_DESCRIPTORS                   512
+
+typedef
+void
+(__cdecl FUNC_ReloadGDT) (
+    IN      PGDT        NewGdt,
+    IN      WORD        CsSelector,
+    IN      WORD        DsSelector
+    );
+
+extern FUNC_ReloadGDT           __reloadGDT;
+
+
+// the size of the GDT is 4K
+__declspec(align(NATURAL_ALIGNMENT))
+static SEGMENT_DESCRIPTOR       m_gdtDescriptors[GDT_MAXIMUM_DESCRIPTORS];
+static GDT                      m_gdt;
+
+STATUS
+GdtInitialize(
+    void
+    )
+{
+    m_gdt.Limit = ( sizeof(SEGMENT_DESCRIPTOR) * GDT_MAXIMUM_DESCRIPTORS ) - 1;
+    m_gdt.Base = m_gdtDescriptors;
+
+    // set all descriptors to NULL
+    memzero(m_gdt.Base, m_gdt.Limit + 1);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+GdtInstallDescriptor(
+    IN          WORD                        GdtIndex,
+    IN          QWORD                       Base,
+    IN          BYTE                        Type,
+    IN          SEGMENT_DESCRIPTOR_FLAGS    Flags
+    )
+{
+    BYTE descriptorSize;
+    BOOLEAN tssDescriptor;
+    PSEGMENT_DESCRIPTOR pSegDesc;
+    DWORD segmentLimit;
+    DWORD lowDword;
+    WORD highWord;
+    BOOLEAN sysDescriptor;
+
+    // check if system descriptor
+    sysDescriptor = IsBitSet(Flags, SegmentDescriptorSystemDescriptor);
+
+    tssDescriptor = sysDescriptor && ((SystemSegment64BitTssAvailable == Type) || (SystemSegment64BitTssBusy == Type));
+
+    if (sysDescriptor && !tssDescriptor)
+    {
+        // we can't install other system descriptors except TSS ones
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    // normal descriptors occupy only 8 bytes, while a TSS occupies 16
+    descriptorSize = tssDescriptor ? sizeof(TSS_DESCRIPTOR) : sizeof(SEGMENT_DESCRIPTOR);
+    pSegDesc = NULL;
+
+    // check if within GDT limits
+    if (GdtIndex + descriptorSize > m_gdt.Limit)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    // the limit of the TSS is given by its size, while for the rest of the descriptors
+    // we use MAX_DWORD
+    segmentLimit = tssDescriptor ? sizeof(TSS) : MAX_DWORD;
+
+    if (!tssDescriptor)
+    {
+        if (Base >= MAX_DWORD)
+        {
+            return STATUS_INVALID_PARAMETER2;
+        }
+    }
+
+    // get a pointer to the segment descriptor
+    // NOTE: even if it's a TSS descriptor the lower 8 bytes have the common structure
+    pSegDesc = (PSEGMENT_DESCRIPTOR)((PBYTE)m_gdt.Base + GdtIndex);
+    memzero(pSegDesc, descriptorSize);
+
+    lowDword = QWORD_LOW(Base);
+    highWord = DWORD_HIGH(lowDword);
+
+    pSegDesc->SegmentLimitLow = DWORD_LOW(segmentLimit);
+    pSegDesc->BaseAddressLow = DWORD_LOW(lowDword);
+    pSegDesc->BaseAddressMid = WORD_LOW(highWord);
+    pSegDesc->Type = Type;
+    pSegDesc->DescriptorType = !sysDescriptor;
+
+    // we use only ring0 and ring3 for descriptors
+    pSegDesc->DPL = IsBitSet(Flags, SegmentDescriptorFlagRing0) ? RING_ZERO_PL : RING_THREE_PL;
+    pSegDesc->Present = 1;
+    pSegDesc->SegmentLimitHigh = (BYTE)DWORD_HIGH(segmentLimit);
+    pSegDesc->AVL = 0;
+    pSegDesc->L = IsBitSet(Flags, SegmentDescriptorLongMode);
+    pSegDesc->G = IsBitSet(Flags, SegmentDescriptor32bitOperation) || IsBitSet(Flags,SegmentDescriptorLongMode);
+    pSegDesc->D_B = IsBitSet(Flags, SegmentDescriptor32bitOperation );
+    pSegDesc->BaseAddressHigh = WORD_HIGH(highWord);
+
+    if (tssDescriptor)
+    {
+        // if it is a TSS descriptor we also complete the upper 4 bytes of the address
+        ((TSS_DESCRIPTOR*)pSegDesc)->BaseAddressHighQword = QWORD_HIGH(Base);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+BOOLEAN
+GdtIsSegmentPrivileged(
+    IN          WORD            Selector
+    )
+{
+    return !(IsFlagOn(Selector, 0b11));
+}
+
+void
+GdtReload(
+    IN          WORD            CodeSelector,
+    IN          WORD            DataSelector
+    )
+{
+    __reloadGDT(&m_gdt, CodeSelector, DataSelector);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/hal.c b/src_proiect/HAL/src/hal.c
new file mode 100644
index 0000000..ac5f32e
--- /dev/null
+++ b/src_proiect/HAL/src/hal.c
@@ -0,0 +1,14 @@
+#include "hal_base.h"
+#include "hal.h"
+#include "idt.h"
+#include "gdt.h"
+
+void
+HalInitialize(
+    void
+    )
+{
+    GdtInitialize();
+
+    IdtInitialize();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/hw_fpu.c b/src_proiect/HAL/src/hw_fpu.c
new file mode 100644
index 0000000..fc00b57
--- /dev/null
+++ b/src_proiect/HAL/src/hw_fpu.c
@@ -0,0 +1,173 @@
+#include "hal_base.h"
+#include "hw_fpu.h"
+#include "cpu.h"
+
+// The pragma optimize off is required for all the functions which are called from
+// HalActivateFpu - this is because we don't want the compiler to generate any SSE
+// instructions before we actually enabled the FP unit :)
+#pragma optimize( "", off )
+__forceinline
+static
+BOOLEAN
+_HalCheckBasicFpuFeatures(
+    void
+    )
+{
+    CPUID_INFO cpuidFeatInfo;
+
+    __cpuid(cpuidFeatInfo.values, CpuidIdxFeatureInformation);
+
+    // Check for floating point unit on chip
+    // Check for FXSAVE/FXRSTOR support
+    // Check for SSE/SSE2 support
+    // Check for XSAVE/XRSTOR support
+    return
+        (
+         cpuidFeatInfo.FeatureInformation.edx.FPU   &&
+         cpuidFeatInfo.FeatureInformation.edx.FXSR  &&
+         cpuidFeatInfo.FeatureInformation.edx.SSE   &&
+         cpuidFeatInfo.FeatureInformation.edx.SSE2  &&
+         cpuidFeatInfo.FeatureInformation.ecx.XSAVE
+            );
+}
+
+__forceinline
+static
+void
+_HalEnableFpu(
+    void
+    )
+{
+    // make sure emulation is disabled in CR0
+    __writecr0(__readcr0() &~(CR0_EM));
+
+    // Enable
+    //  ->  FXSAVE and FXRSTOR instructions (needed - I have no idea why exactly)
+    //  ->  Operating System Support for Unmasked SIMD Floating-Point Exceptions
+    //  ->  XSAVE and Processor Extended States-Enable Bit
+    __writecr4(
+        __readcr4() |
+        (CR4_OSFXSR | CR4_OSXMMEXCPT | CR4_OSXSAVE)
+    );
+}
+
+void
+HalActivateFpu(
+    void
+    )
+{
+#if INCLUDE_FP_SUPPORT
+    // We have nothing here, no commonlib, no runtime support if something
+    // goes wrong => we need to halt
+    if (!_HalCheckBasicFpuFeatures()) __halt();
+
+    _HalEnableFpu();
+#endif
+}
+#pragma optimize( "", on )
+
+__forceinline
+static
+BOOLEAN
+_HalCheckRequestedFpuFeatures(
+    _In_        XCR0_SAVED_STATE            RequestedFeatures
+    )
+{
+    CPUID_INFO cpuidFeatInfo;
+    XCR0_SAVED_STATE availableFeatures;
+
+    // x87 FPU/MMX state must be 1!
+    if (!IsBooleanFlagOn(RequestedFeatures, XCR0_SAVED_STATE_x87_MMX)) return FALSE;
+
+    __cpuidex(cpuidFeatInfo.values, CpuidIdxExtendedStateEnumerationMainLeaf, 0x0);
+
+    availableFeatures = DWORDS_TO_QWORD(
+        cpuidFeatInfo.ExtendedStateMainLeaf.Xcr0FeatureSupportHigh,
+        cpuidFeatInfo.ExtendedStateMainLeaf.Xcr0FeatureSupportLow);
+
+    return IsBooleanFlagOn(
+        availableFeatures,
+        RequestedFeatures
+    );
+}
+
+__forceinline
+static
+void
+_HalSetRequestedFpuFeatures(
+    _In_        XCR0_SAVED_STATE            Features
+    )
+{
+    _xsetbv(XCR0_INDEX, Features);
+}
+
+__forceinline
+static
+BOOLEAN
+_HalCheckEnabledFeaturesSaveSize(
+    _In_        DWORD                       MaxSizeSupported
+    )
+{
+    CPUID_INFO cpuidFeatInfo;
+
+    __cpuidex(cpuidFeatInfo.values, CpuidIdxExtendedStateEnumerationMainLeaf, 0x0);
+
+    return (cpuidFeatInfo.ExtendedStateMainLeaf.MaxSizeRequiredByFeaturesInXcr0 <= MaxSizeSupported);
+}
+
+STATUS
+HalSetActiveFpuFeatures(
+    _In_        XCR0_SAVED_STATE            Features
+    )
+{
+#if INCLUDE_FP_SUPPORT
+    if (!_HalCheckRequestedFpuFeatures(Features))
+    {
+        return STATUS_CPU_UNSUPPORTED_FEATURE;
+    }
+
+    _HalSetRequestedFpuFeatures(Features);
+
+    if (!_HalCheckEnabledFeaturesSaveSize(HAL_MAX_SUPPORTED_XSAVE_AREA_SIZE))
+    {
+        return STATUS_CPU_UNSUPPORED_XSAVE_FEATURE_SIZE;
+    }
+#else
+    UNREFERENCED_PARAMETER(Features);
+#endif // INCLUDE_FP_SUPPORT
+
+    return STATUS_SUCCESS;
+}
+
+XCR0_SAVED_STATE
+HalGetActiveFpuFeatures(
+    _Out_opt_   DWORD*                      ActivatedFeaturesSaveSize,
+    _Out_opt_   DWORD*                      AvailableFeaturesSaveSize
+    )
+{
+#if INCLUDE_FP_SUPPORT
+    if (ActivatedFeaturesSaveSize != NULL || AvailableFeaturesSaveSize != NULL)
+    {
+        CPUID_INFO cpuidFeatInfo;
+
+        __cpuidex(cpuidFeatInfo.values, CpuidIdxExtendedStateEnumerationMainLeaf, 0x0);
+
+        if (ActivatedFeaturesSaveSize != NULL)
+        {
+            *ActivatedFeaturesSaveSize = cpuidFeatInfo.ExtendedStateMainLeaf.MaxSizeRequiredByFeaturesInXcr0;
+        }
+
+        if (AvailableFeaturesSaveSize != NULL)
+        {
+            *AvailableFeaturesSaveSize = cpuidFeatInfo.ExtendedStateMainLeaf.MaxSizeRequiredByFeaturesSupportedByCpu;
+        }
+    }
+
+    return _xgetbv(XCR0_INDEX);
+#else
+    if (ActivatedFeaturesSaveSize != NULL) *ActivatedFeaturesSaveSize = 0;
+    if (AvailableFeaturesSaveSize != NULL) *AvailableFeaturesSaveSize = 0;
+
+    return MAX_QWORD;
+#endif // INCLUDE_FP_SUPPORT
+}
diff --git a/src_proiect/HAL/src/idt.c b/src_proiect/HAL/src/idt.c
new file mode 100644
index 0000000..2062679
--- /dev/null
+++ b/src_proiect/HAL/src/idt.c
@@ -0,0 +1,130 @@
+#include "hal_base.h"
+#include "cpu.h"
+#include "idt.h"
+#include "tss.h"
+
+#define PREDEFINED_IDT_SIZE                     10
+#define PREDEFINED_IDT_ENTRY_SIZE               16
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+//warning C4214: nonstandard extension used : bit field types other than int
+#pragma warning(disable:4214)
+// 6.14.1, Vol 3, No. 56
+typedef struct _IDT_ENTRY
+{
+    // 15:0
+    WORD            LowWordOffset;              // Bits 15:0 of address
+
+                                                // 31:16
+    WORD            SegmentSelector;
+
+    // 34:32
+    // IST = Interrupt Stack Table
+    // if set to 0 will use legacy stack switching
+    // else will use IST entry from TSS
+    WORD            IST                 : 3;
+    WORD            Reserved0           : 5;    // these must be 0 on x64
+    WORD            Type                : 4;
+    WORD            Reserved1           : 1;    // 0
+    WORD            DPL                 : 2;
+    WORD            Present             : 1;
+    WORD            HighWordOffset;             // Bits 31:16 of address
+    DWORD           HighestDwordOffset;         // Bits 63:32 of address
+    DWORD           Reserved;
+} IDT_ENTRY, *PIDT_ENTRY;
+STATIC_ASSERT( sizeof( IDT_ENTRY ) == PREDEFINED_IDT_ENTRY_SIZE );
+#pragma warning(pop)
+
+typedef struct _IDT
+{
+    // IDTR(Limit) <-- SRC[0:15];
+    WORD            Limit;
+
+    // IDTR(Base)  <-- SRC[16:79];
+    IDT_ENTRY*      Base;
+} IDT, *PIDT;
+STATIC_ASSERT( sizeof( IDT ) == PREDEFINED_IDT_SIZE );
+#pragma pack(pop)
+
+__declspec(align(NATURAL_ALIGNMENT))
+static IDT_ENTRY    m_idtDescriptors[NO_OF_TOTAL_INTERRUPTS];
+static IDT          m_idt;
+
+void
+IdtInitialize(
+    void
+    )
+{
+    m_idt.Limit = sizeof(IDT_ENTRY) * NO_OF_TOTAL_INTERRUPTS - 1;
+    m_idt.Base = m_idtDescriptors;
+
+    // zero everything
+    memzero(m_idt.Base, m_idt.Limit + 1);
+
+    // install IDT
+    IdtReload();
+}
+
+STATUS
+IdtInstallDescriptor(
+    IN                  BYTE            InterruptIndex,
+    IN                  WORD            CodeSelector,
+    IN                  BYTE            GateType,
+    IN                  BYTE            InterruptStackIndex,
+    IN                  BOOLEAN         Present,
+    _When_(Present, IN)
+    _When_(!Present, IN_OPT)
+    PVOID           HandlerAddress
+    )
+{
+    DWORD lowAddress;
+    IDT_ENTRY* pDescriptor;
+
+    if (Present)
+    {
+        // we're talking about a real descriptor, we need to check the other fields
+        if ((SystemSegment64BitTaskGate > GateType) || (SystemSegment64BitTrapGate < GateType))
+        {
+            // invalid descriptor
+            return STATUS_INVALID_PARAMETER3;
+        }
+
+        if (NO_OF_IST < InterruptStackIndex)
+        {
+            return STATUS_INVALID_PARAMETER4;
+        }
+
+        if (NULL == HandlerAddress)
+        {
+            return STATUS_INVALID_PARAMETER6;
+        }
+    }
+
+    pDescriptor = &m_idt.Base[InterruptIndex];
+
+    lowAddress = QWORD_LOW(HandlerAddress);
+
+    // set all fields to 0
+    memzero(pDescriptor, sizeof(IDT_ENTRY));
+
+    pDescriptor->HighestDwordOffset = QWORD_HIGH(HandlerAddress);
+    pDescriptor->HighWordOffset = DWORD_HIGH(lowAddress);
+    pDescriptor->Present = (WORD)Present;
+    pDescriptor->DPL = RING_ZERO_PL;
+    pDescriptor->Type = GateType;
+    pDescriptor->IST = InterruptStackIndex;
+    pDescriptor->SegmentSelector = CodeSelector;
+    pDescriptor->LowWordOffset = DWORD_LOW(lowAddress);
+
+    return STATUS_SUCCESS;
+}
+
+void
+IdtReload(
+    void
+    )
+{
+    __lidt(&m_idt);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/ioapic.c b/src_proiect/HAL/src/ioapic.c
new file mode 100644
index 0000000..d1bc570
--- /dev/null
+++ b/src_proiect/HAL/src/ioapic.c
@@ -0,0 +1,207 @@
+#include "hal_base.h"
+#include "ioapic.h"
+#include "ioapic_registers.h"
+
+__forceinline
+static
+DWORD
+_IoApicReadOffset(
+    IN      PIO_APIC        IoApic,
+    IN      BYTE            Offset
+    )
+{
+    IO_APIC_REG_SEL regSel;
+
+    ASSERT( NULL != IoApic );
+
+    regSel.Value = 0;
+
+    regSel.ApicAddress = Offset;
+
+    IoApic->IoRegSel.Value = regSel.Value;
+
+    return IoApic->IoRegData.Value;
+}
+
+__forceinline
+static
+void
+_IoApicWriteOffset(
+    IN      PIO_APIC        IoApic,
+    IN      BYTE            Offset,
+    IN      DWORD           Data
+    )
+{
+    IO_APIC_REG_SEL regSel;
+
+    ASSERT(NULL != IoApic);
+
+    regSel.Value = 0;
+    regSel.ApicAddress = Offset;
+
+    IoApic->IoRegSel.Value = regSel.Value;
+    IoApic->IoRegData.Value = Data;
+}
+
+__forceinline
+static
+void
+_IoApicWriteRedirectionEntry(
+    IN      PIO_APIC                    IoApic,
+    IN      BYTE                        Index,
+    IN      IO_APIC_REDIR_TABLE_ENTRY   Entry
+    )
+{
+    BYTE offsetInIoApicRegisters;
+    IO_APIC_REDIR_TABLE_ENTRY prevValue;
+
+    ASSERT( NULL != IoApic );
+
+    offsetInIoApicRegisters = IO_APIC_REDIRECTION_TABLE_BASE_OFFSET + Index * IO_APIC_REDIRECTION_TABLE_ENTRY_SIZE;
+
+    // mask redirection entry
+    prevValue.LowDword = _IoApicReadOffset(IoApic, offsetInIoApicRegisters );
+    prevValue.Masked = TRUE;
+    _IoApicWriteOffset(IoApic, offsetInIoApicRegisters, prevValue.LowDword);
+
+    _IoApicWriteOffset(IoApic, offsetInIoApicRegisters + 1, Entry.HighDword);
+    _IoApicWriteOffset(IoApic, offsetInIoApicRegisters, Entry.LowDword);
+}
+
+IO_APIC_REDIR_TABLE_ENTRY
+_IoApicReadRedirectionEntry(
+    IN      PIO_APIC        IoApic,
+    IN      BYTE            Index
+    )
+{
+    BYTE offsetInIoApicRegisters;
+    IO_APIC_REDIR_TABLE_ENTRY value;
+
+    ASSERT(NULL != IoApic);
+
+    offsetInIoApicRegisters = IO_APIC_REDIRECTION_TABLE_BASE_OFFSET + Index * IO_APIC_REDIRECTION_TABLE_ENTRY_SIZE;
+
+    value.LowDword = _IoApicReadOffset(IoApic, offsetInIoApicRegisters);
+    value.HighDword = _IoApicReadOffset(IoApic, offsetInIoApicRegisters + 1);
+
+    return value;
+}
+
+BYTE
+IoApicGetId(
+    IN      PVOID               IoApic
+    )
+{
+    IO_APIC_ID_REGISTER ioApicReg;
+
+    ASSERT( NULL != IoApic );
+
+    ioApicReg.Value = _IoApicReadOffset(IoApic, IO_APIC_IDENTIFICATION_REGISTER_OFFSET );
+
+    return ioApicReg.ApicId;
+}
+
+BYTE
+IoApicGetVersion(
+    IN      PVOID                   IoApic
+    )
+{
+    IO_APIC_VERSION_REGISTER ioApicReg;
+
+    ASSERT(NULL != IoApic);
+
+    ioApicReg.Value = _IoApicReadOffset(IoApic, IO_APIC_VERSION_REGISTER_OFFSET);
+
+    return ioApicReg.ApicVersion;
+}
+
+BYTE
+IoApicGetMaximumRedirectionEntry(
+    IN      PVOID               IoApic
+    )
+{
+    IO_APIC_VERSION_REGISTER ioApicReg;
+
+    ASSERT( NULL != IoApic );
+
+    ioApicReg.Value = _IoApicReadOffset(IoApic, IO_APIC_VERSION_REGISTER_OFFSET);
+
+    return ioApicReg.MaximumRedirectionEntry;
+}
+
+void
+IoApicSetRedirectionTableEntry(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Index,
+    IN      BYTE                    Vector,
+    IN _Strict_type_match_
+            APIC_DESTINATION_MODE   DestinationMode,
+    IN      BYTE                    Destination,
+    IN _Strict_type_match_
+            APIC_DELIVERY_MODE      DeliveryMode,
+    IN _Strict_type_match_
+            APIC_PIN_POLARITY       PinPolarity,
+    IN _Strict_type_match_
+            APIC_TRIGGER_MODE       TriggerMode
+    )
+{
+    IO_APIC_REDIR_TABLE_ENTRY redirEntry;
+
+    ASSERT( NULL != IoApic );
+
+    memzero(&redirEntry, sizeof(IO_APIC_REDIR_TABLE_ENTRY));
+
+    redirEntry.DeliveryMode = DeliveryMode;
+    redirEntry.Vector = Vector;
+    redirEntry.DestinationMode = DestinationMode;
+    redirEntry.Destination = Destination;
+    redirEntry.Masked = TRUE;
+    redirEntry.PinPolarity = PinPolarity;
+    redirEntry.TriggerMode = TriggerMode;
+
+    _IoApicWriteRedirectionEntry(IoApic, Index, redirEntry );
+}
+
+BYTE
+IoApicGetRedirectionTableEntryVector(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Index
+    )
+{
+    IO_APIC_REDIR_TABLE_ENTRY entry;
+    
+    entry = _IoApicReadRedirectionEntry(IoApic, Index);
+
+    return (BYTE) entry.Vector;
+}
+
+void
+IoApicSetRedirectionTableEntryMask(
+    IN      PVOID               IoApic,
+    IN      BYTE                Index,
+    IN      BOOLEAN             Masked
+    )
+{
+    IO_APIC_REDIR_TABLE_ENTRY entry;
+
+    ASSERT( NULL != IoApic );
+
+    entry = _IoApicReadRedirectionEntry(IoApic, Index);
+    entry.Masked = Masked;
+    _IoApicWriteRedirectionEntry(IoApic, Index, entry );
+}
+
+void
+IoApicSendEOI(
+    IN      PVOID                   IoApic,
+    IN      BYTE                    Vector
+    )
+{
+    PIO_APIC pIoApic;
+
+    ASSERT( NULL != IoApic );
+
+    pIoApic = IoApic;
+
+    pIoApic->IoRegEOI.Value = Vector;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/lapic.c b/src_proiect/HAL/src/lapic.c
new file mode 100644
index 0000000..25cb213
--- /dev/null
+++ b/src_proiect/HAL/src/lapic.c
@@ -0,0 +1,434 @@
+#include "hal_base.h"
+#include "lapic.h"
+#include "pit.h"
+#include "msr.h"
+#include "lapic_registers.h"
+
+__forceinline
+static
+BOOLEAN
+_LapicIsCpuBsp(
+    void
+    )
+{
+    return IsBooleanFlagOn( __readmsr(IA32_APIC_BASE_MSR), IA32_APIC_BSP_FLAG );
+}
+
+static
+void
+_LapicConfigureLocalInts(
+    IN      PLAPIC                          Apic
+    );
+
+static
+void
+_LapicConfigureErrorRegister(
+    IN      PLAPIC                          Apic,
+    IN      BYTE                            ErrorInterruptVector
+    );
+
+void
+LapicInitialize(
+    IN      PVOID                           ApicBaseAddress
+    )
+{
+    QWORD apicMsr;
+    PLAPIC pLapic;
+
+    pLapic = ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    // make sure APIC is enabled and
+    // not XAPIC
+    apicMsr = __readmsr(IA32_APIC_BASE_MSR);
+
+    apicMsr |= IA32_APIC_BASE_ENABLE_FLAG;
+    apicMsr &= (~IA32_APIC_EXT_ENABLE_FLAG);
+
+    __writemsr(IA32_APIC_BASE_MSR, apicMsr);
+}
+
+void
+LapicSetLogicalApicId(
+    IN      PVOID                           ApicBaseAddress,
+    IN      _Strict_type_match_
+            APIC_ID                         LogicalApicId,
+    IN      BYTE                            DestinationFormat
+    )
+{
+    PLAPIC pLapic;
+    LDR_REGISTER ldrRegister;
+    DFR_REGISTER dfrRegister;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT (NULL != pLapic);
+
+    memzero(&ldrRegister, sizeof(LDR_REGISTER));
+
+    dfrRegister.Raw = MAX_DWORD;
+    dfrRegister.Model = DestinationFormat;
+
+    pLapic->DestinationFormat.Value = dfrRegister.Raw;
+
+    ldrRegister.LogicalApicId = LogicalApicId;
+
+    pLapic->LogicalDestination.Value = ldrRegister.Raw;
+}
+
+void
+LapicSetState(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            SpuriousInterruptVector,
+    IN      BOOLEAN                         Enable
+    )
+{
+    SVR_REGISTER svrValue;
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC) ApicBaseAddress;
+
+    ASSERT (NULL != pLapic);
+
+    memzero(&svrValue, sizeof(SVR_REGISTER));
+
+    svrValue.Vector = SpuriousInterruptVector;
+    svrValue.ApicEnable = Enable;
+    pLapic->SpuriousInterruptVector.Value = svrValue.Raw;
+}
+
+BOOLEAN
+LapicGetState(
+    IN      PVOID                           ApicBaseAddress
+    )
+{
+    SVR_REGISTER svrValue;
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    svrValue.Raw = pLapic->SpuriousInterruptVector.Value;
+
+    return (BOOLEAN) svrValue.ApicEnable;
+}
+
+void
+LapicSendEOI(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            Vector
+    )
+{
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    pLapic->EOI.Value = Vector;
+}
+
+void
+LapicSendIpi(
+    IN      PVOID                           ApicBaseAddress,
+    IN      _Strict_type_match_
+            APIC_ID                         ApicId,
+    IN      _Strict_type_match_
+            APIC_DELIVERY_MODE              DeliveryMode,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_SHORTHAND      DestinationShorthand,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_MODE           DestinationMode,
+    IN_OPT  BYTE*                           Vector
+    )
+{
+    ICR_LOW_REGISTER lowIcrValue = { 0 };
+    ICR_HIGH_REGISTER highIcrValue = { 0 };
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    if ((ApicDestinationShorthandSelf == DestinationShorthand) || (ApicDestinationShorthandAll == DestinationShorthand))
+    {
+        // in this case only FIXED IPI can be sent
+        ASSERT(ApicDeliveryModeFixed == DeliveryMode);
+    }
+
+    highIcrValue.Destination = ApicId;
+
+    if (NULL != Vector)
+    {
+        lowIcrValue.Vector = *Vector;
+    }
+
+    lowIcrValue.DeliveryMode = DeliveryMode;
+
+    // ASSERT
+    lowIcrValue.Level = 1;
+
+    lowIcrValue.DestinationMode = DestinationMode;
+    lowIcrValue.DestinationShorthand = DestinationShorthand;
+
+    pLapic->IcrHigh.Value = highIcrValue.Raw;
+    pLapic->IcrLow.Value = lowIcrValue.Raw;
+}
+
+BYTE
+LapicGetPpr(
+    IN      PVOID                           ApicBaseAddress
+    )
+{
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    return (BYTE) ( pLapic->PPR.Value >> 4 );
+}
+
+DWORD
+LapicGetTimerCount(
+    IN      PVOID                           ApicBaseAddress
+    )
+{
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    return pLapic->TimerCurrentCount.Value;
+}
+
+void
+LapicConfigureTimer(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            TimerInterruptVector,
+    IN      _Strict_type_match_
+            APIC_DIVIDE_VALUE               DivideValue
+    )
+{
+    LVT_REGISTER timerRegister;
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+    ASSERT( ApicDivideReserved != DivideValue );
+
+    memzero(&timerRegister, sizeof(LVT_REGISTER));
+
+    timerRegister.Vector = TimerInterruptVector;
+
+    // set initial count to 0 (disable timer)
+    pLapic->TimerInitialCount.Value = 0;
+
+    // set divide value
+    pLapic->TimerDivideConfiguration.Value = DivideValue;
+
+    // un-mask timer interrupts
+    timerRegister.TimerMode = APIC_TIMER_PERIOD_MODE;
+    timerRegister.Masked = FALSE;
+
+    pLapic->LvtTimer.Value = timerRegister.Raw;
+}
+
+void
+LapicSetTimerInterval(
+    IN      PVOID                           ApicBaseAddress,
+    IN      DWORD                           TimerCount
+    )
+{
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    pLapic->TimerInitialCount.Value = TimerCount;
+}
+
+void
+LapicConfigureLvtRegisters(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            ErrorInterruptVector
+    )
+{
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    // configure LINT vectors
+    _LapicConfigureLocalInts(pLapic);
+
+    // configure error register
+    _LapicConfigureErrorRegister(pLapic, ErrorInterruptVector);
+
+    // configure future LVT registers
+    // ...
+}
+
+PHYSICAL_ADDRESS
+LapicGetBasePhysicalAddress(
+    void
+    )
+{
+    QWORD apicBaseRegister;
+
+    apicBaseRegister = __readmsr(IA32_APIC_BASE_MSR);
+
+    return (PHYSICAL_ADDRESS)IA32_APIC_BASE_MASK(apicBaseRegister);
+}
+
+void
+LapicDetermineDividedBusFrequency(
+    IN      PVOID                           ApicBaseAddress,
+    OUT     DWORD*                          BusFrequency
+    )
+{
+    LVT_REGISTER timerRegister;
+    PLAPIC pLapic;
+    DWORD cpuBusFrequency;
+    DWORD currentCount;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+    ASSERT(NULL != BusFrequency);
+
+    memzero(&timerRegister, sizeof(LVT_REGISTER));
+    currentCount = 0;
+
+    // divisor rate = 1
+    pLapic->TimerDivideConfiguration.Value = ApicDivideBy1;
+
+    timerRegister.TimerMode = APIC_TIMER_ONE_SHOT_MODE; // one shot-mode
+    timerRegister.Masked = 1;
+
+    pLapic->LvtTimer.Value = timerRegister.Raw;
+
+    PitSetTimer(APIC_TIMER_CONFIGURATION_SLEEP, FALSE);
+
+    PitStartTimer();
+
+    pLapic->TimerInitialCount.Value = MAX_DWORD;
+
+    PitWaitTimer();
+
+    currentCount = pLapic->TimerCurrentCount.Value;
+
+    cpuBusFrequency = ((MAX_DWORD - currentCount) + 1) * 1 * 100;
+
+    // set initial count to 0 (disable timer)
+    pLapic->TimerInitialCount.Value = 0;
+
+    *BusFrequency = cpuBusFrequency;
+}
+
+DWORD
+LapicGetErrorRegister(
+    IN      PVOID                           ApicBaseAddress
+    )
+{
+    PLAPIC pLapic;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT(NULL != pLapic);
+
+    // 10.5.3
+    // The ESR is a read write  register. Before attempt to read from
+    // the ESR, software should first write it. The value written does not
+    // affect the values read subsequently
+    pLapic->ErrorStatus.Value = 0;
+
+    return pLapic->ErrorStatus.Value;
+}
+
+BOOLEAN
+LapicIsInterruptServiced(
+    IN      PVOID                           ApicBaseAddress,
+    IN      BYTE                            Vector
+    )
+{
+    PLAPIC pLapic;
+    DWORD isrValue;
+
+    pLapic = (PLAPIC)ApicBaseAddress;
+
+    ASSERT( NULL != pLapic );
+    ASSERT( Vector >= APIC_FIRST_USABLE_INTERRUPT_INDEX );
+
+    isrValue = pLapic->ISR[Vector / APIC_VECTORS_PER_ISR_REGISTER].Value;
+
+    return ( isrValue & ( 1 << (Vector % APIC_VECTORS_PER_ISR_REGISTER))) != 0;
+}
+
+static
+void
+_LapicConfigureLocalInts(
+    IN      PLAPIC                      Apic
+    )
+{
+    LVT_REGISTER lvtTemp;
+
+    ASSERT(NULL != Apic);
+
+    // disable LINT0
+    // This is required to exit virtual-wire mode through LAPIC and enter symmetric mode
+    // i.e. the PIC will no longer be used for interrupt delivery
+    lvtTemp.Raw = 0;
+    lvtTemp.Masked = TRUE;
+
+    Apic->LvtLINT0.Value = lvtTemp.Raw;
+
+    // enable LINT1 (NMI)
+    lvtTemp.Raw = 0;
+
+    lvtTemp.Masked = FALSE;
+    lvtTemp.DeliveryMode = ApicDeliveryModeNMI;
+
+    Apic->LvtLINT1.Value = lvtTemp.Raw;
+}
+
+static
+void
+_LapicConfigureErrorRegister(
+    IN      PLAPIC                          Apic,
+    IN      BYTE                            ErrorInterruptVector
+    )
+{
+    LVT_REGISTER lvt;
+    DWORD error;
+
+    ASSERT( NULL != Apic );
+
+    // set Error LVT
+    lvt.Raw = 0;
+    lvt.Masked = FALSE;
+    lvt.Vector = ErrorInterruptVector;
+
+    Apic->LvtError.Value = lvt.Raw;
+
+    Apic->ErrorStatus.Value = 0;
+
+    /// we need to write 0 TWICE in the register to properly record any
+    /// future errors
+    // Assumption: first zero write causes all APIC errors which occurred
+    // before our configuration to be recorded => we need to write another 0
+    // to only hold the errors we will cause
+    error = LapicGetErrorRegister(Apic);
+
+    // make sure no errors occurred
+    ASSERT_INFO(0 == error,
+                "Lapic ERROR status: 0x%x\n",
+                error
+                );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/pci.c b/src_proiect/HAL/src/pci.c
new file mode 100644
index 0000000..2600ff4
--- /dev/null
+++ b/src_proiect/HAL/src/pci.c
@@ -0,0 +1,243 @@
+#include "hal_base.h"
+#include "pci.h"
+#include "pci_common.h"
+
+#define PCI_CONFIG_ADDRESS                              0xCF8
+#define PCI_CONFIG_DATA                                 0xCFC
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+typedef union _PCI_CONFIG_REGISTER
+{
+    struct
+    {
+        // Since all reads and writes must be both 32-bits and aligned to work on all
+        // implementations, the two lowest bits of PCI_CONFIG_REGISTER must always be zero,
+        // with the remaining six bits allowing you to choose each of the 64 32-bit words.
+        BYTE    __Reserved0                 : 2;
+
+        BYTE    RegisterNumber              : 6;
+        BYTE    FunctionNumber              : 3;
+        BYTE    DeviceNumber                : 5;
+        BYTE    BusNumber;
+        BYTE    __Reserved1                 : 7;
+        BYTE    EnableBit                   : 1;
+    };
+    DWORD       Raw;
+} PCI_CONFIG_REGISTER, *PPCI_CONFIG_REGISTER;
+STATIC_ASSERT(sizeof(PCI_CONFIG_REGISTER) == sizeof(DWORD));
+
+#pragma warning(pop)
+#pragma pack(pop)
+
+#define PCI_SET_CONFIG_REGISTER(X,Bus,Dev,Func,Reg)     \
+            memzero(&(X), sizeof(PCI_CONFIG_REGISTER)); \
+            (X).EnableBit = 1;                          \
+            (X).BusNumber = (Bus);                      \
+            (X).DeviceNumber = (Dev);                   \
+            (X).FunctionNumber = (Func);                \
+            (X).RegisterNumber = (Reg);
+
+static
+__forceinline
+DWORD
+_PciReadRegister(
+    IN      PCI_CONFIG_REGISTER ConfigRegister
+    )
+{
+    __outdword(PCI_CONFIG_ADDRESS, ConfigRegister.Raw);
+    return __indword(PCI_CONFIG_DATA);
+}
+
+static
+__forceinline
+void
+_PciWriteRegister(
+    IN      PCI_CONFIG_REGISTER ConfigRegister,
+    IN      DWORD               Data
+    )
+{
+    __outdword(PCI_CONFIG_ADDRESS, ConfigRegister.Raw);
+    __outdword(PCI_CONFIG_DATA, Data);
+}
+
+//******************************************************************************
+// Function:     _PciRetrieveDevice
+// Description:  Retrieves the device found at the specified PCI address.
+// Returns:      BOOLEAN - TRUE => found device
+//                         FALSE => no device present at the specified address.
+// Parameter:    IN BYTE Bus
+// Parameter:    IN BYTE Device
+// Parameter:    IN BYTE Function
+// Parameter:    OUT PPCI_DEVICE PciDevice
+//******************************************************************************
+static
+BOOL_SUCCESS
+BOOLEAN
+_PciRetrieveDevice(
+    IN      PCI_DEVICE_LOCATION DeviceLocation,
+    IN      WORD                BytesToRead,
+    OUT_WRITES_BYTES_ALL(BytesToRead)
+            PPCI_DEVICE_DESCRIPTION         PciDevice
+    );
+
+STATUS
+PciRetrieveNextDevice(
+    IN      BOOLEAN         ResetSearch,
+    IN      WORD            BytesToRead,
+    OUT_WRITES_BYTES_ALL(BytesToRead)
+            PPCI_DEVICE_DESCRIPTION     PciDevice
+    )
+{
+    BOOLEAN         foundDevice;
+
+    static PCI_DEVICE_LOCATION __currentDeviceLocation = { 0 };
+    static BOOLEAN  __exhausedPciSpace = FALSE;
+
+    if (BytesToRead > PREDEFINED_PCI_DEVICE_SPACE_SIZE)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == PciDevice)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    foundDevice = FALSE;
+
+    if (ResetSearch)
+    {
+        memzero(&__currentDeviceLocation, sizeof(PCI_DEVICE_LOCATION));
+        __exhausedPciSpace = FALSE;
+    }
+
+    if (__exhausedPciSpace)
+    {
+        return STATUS_DEVICE_NO_MORE_DEVICES;
+    }
+
+    do
+    {
+        foundDevice = _PciRetrieveDevice(__currentDeviceLocation, BytesToRead, PciDevice);
+
+        __currentDeviceLocation.Function = (__currentDeviceLocation.Function + 1) % PCI_NO_OF_FUNCTIONS;
+        if (0 == __currentDeviceLocation.Function)
+        {
+            __currentDeviceLocation.Device = (__currentDeviceLocation.Device + 1) % PCI_NO_OF_DEVICES;
+            if (0 == __currentDeviceLocation.Device)
+            {
+                __currentDeviceLocation.Bus = (__currentDeviceLocation.Bus + 1) % PCI_NO_OF_BUSES;
+                if (0 == __currentDeviceLocation.Bus)
+                {
+                    // because we found a device we can't return an error yet =>
+                    // we just set the static variable
+                    __exhausedPciSpace = TRUE;
+                    if (!foundDevice)
+                    {
+                        // we didn't manage to find another PCI device so we can return
+                        // the status right now
+                        return STATUS_DEVICE_NO_MORE_DEVICES;
+                    }
+                }
+            }
+        }
+
+        // we loop until we find a PCI device or until we exhausted
+        // all the PCI space
+    } while (!foundDevice);
+
+    ASSERT(foundDevice);
+    return STATUS_SUCCESS;
+}
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_PciRetrieveDevice(
+    IN      PCI_DEVICE_LOCATION DeviceLocation,
+    IN      WORD                BytesToRead,
+    OUT_WRITES_BYTES_ALL(BytesToRead)
+            PPCI_DEVICE_DESCRIPTION         PciDevice
+    )
+{
+    STATUS status;
+    WORD currentRegister;
+    PCI_CONFIG_REGISTER addrMsg;
+    DWORD dataRead;
+
+    ASSERT( BytesToRead <= PREDEFINED_PCI_DEVICE_SPACE_SIZE );
+    ASSERT( NULL != PciDevice );
+
+    status = STATUS_SUCCESS;
+    currentRegister = 0;
+    PCI_SET_CONFIG_REGISTER(addrMsg, DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function, 0);
+
+    ASSERT(NULL != PciDevice);
+
+    for (currentRegister = 0;
+    currentRegister < BytesToRead;
+        currentRegister = currentRegister + sizeof(PCI_CONFIG_REGISTER)
+        )
+    {
+        // we shift by 2 because the register represents an index
+        // in a DWORD array :)
+        addrMsg.RegisterNumber = (BYTE) ( currentRegister >> 2 );
+
+        dataRead = _PciReadRegister(addrMsg);
+
+        if (0 == currentRegister)
+        {
+            if (MAX_DWORD == dataRead)
+            {
+                return FALSE;
+            }
+        }
+
+        memcpy( PciDevice->DeviceData->Data + currentRegister, &dataRead, sizeof(PCI_CONFIG_REGISTER));
+    }
+
+    PciDevice->PciExpressDevice = FALSE;
+    memcpy(&PciDevice->DeviceLocation, (PVOID) &DeviceLocation, sizeof(PCI_DEVICE_LOCATION));
+
+    return TRUE;
+}
+
+DWORD
+PciReadConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      BYTE                    Register
+    )
+{
+    PCI_CONFIG_REGISTER addrMsg;
+
+    ASSERT(IsAddressAligned(Register, sizeof(PCI_CONFIG_REGISTER)));
+
+    PCI_SET_CONFIG_REGISTER(addrMsg, DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function, Register >> 2);
+
+    return _PciReadRegister(addrMsg);
+}
+
+void
+PciWriteConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      BYTE                    Register,
+    IN      DWORD                   Value
+    )
+{
+    PCI_CONFIG_REGISTER addrMsg;
+
+    ASSERT(IsAddressAligned(Register, sizeof(PCI_CONFIG_REGISTER)));
+
+    PCI_SET_CONFIG_REGISTER(addrMsg, DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function, Register >> 2 );
+
+    _PciWriteRegister(addrMsg, Value );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/pci_device.c b/src_proiect/HAL/src/pci_device.c
new file mode 100644
index 0000000..2bd3ac0
--- /dev/null
+++ b/src_proiect/HAL/src/pci_device.c
@@ -0,0 +1,237 @@
+#include "hal_base.h"
+#include "pci_device.h"
+
+static
+void
+_PciDevProgramIoPortMsiInterrupt(
+    IN      PPCI_DEVICE_DESCRIPTION Device,
+    IN      PPCI_CAPABILITY_MSI     PciCap
+    );
+
+STATUS
+PciDevRetrieveCapabilityById(
+    IN      PPCI_DEVICE             Device,
+    IN      PCI_CAPABILITY_ID       Id,
+    OUT_PTR PPCI_CAPABILITY_HEADER* Capability
+    )
+{
+    BYTE capPtr;
+    PPCI_CAPABILITY_HEADER pciCap;
+
+    if (NULL == Device)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == Capability)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (!Device->Header.Status.CapabilitiesList)
+    {
+        return STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED;
+    }
+
+    capPtr = Device->Header.Device.CapabilitiesPointer;
+
+
+    while (0 != capPtr)
+    {
+        pciCap = (PPCI_CAPABILITY_HEADER)(Device->Data + capPtr);
+
+        if (pciCap->CapabilityId == Id)
+        {
+            *Capability = pciCap;
+            return STATUS_SUCCESS;
+        }
+
+        capPtr = pciCap->NextPointer;
+    }
+
+    return STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST;
+}
+
+STATUS
+PciDevRetrieveNextCapability(
+    IN      PPCI_DEVICE             Device,
+    IN_OPT  PPCI_CAPABILITY_HEADER  PreviousCapability,
+    OUT_PTR PPCI_CAPABILITY_HEADER* NextCapability
+    )
+{
+    BYTE capPtr;
+    PPCI_CAPABILITY_HEADER pciCap;
+
+    if (NULL == Device)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == NextCapability)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (!Device->Header.Status.CapabilitiesList)
+    {
+        return STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED;
+    }
+
+    capPtr = NULL != PreviousCapability ? PreviousCapability->NextPointer : Device->Header.Device.CapabilitiesPointer;
+
+    if (0 != capPtr)
+    {
+        pciCap = (PPCI_CAPABILITY_HEADER)(Device->Data + capPtr);
+
+        *NextCapability = pciCap;
+
+        return STATUS_SUCCESS;
+    }
+
+    return STATUS_DEVICE_CAPABILITY_DOES_NOT_EXIST;
+}
+
+STATUS
+PciDevDisableLegacyInterrupts(
+    IN      PPCI_DEVICE_DESCRIPTION Device
+    )
+{
+    if (NULL == Device)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    Device->DeviceData->Header.Command.InterruptDisable = TRUE;
+
+    if (!Device->PciExpressDevice)
+    {
+        // disable legacy interrupts
+        PciWriteConfigurationSpace(Device->DeviceLocation,
+                                   FIELD_OFFSET(PCI_COMMON_HEADER, Command),
+                                   *(DWORD*)&Device->DeviceData->Header.Command
+                                   );
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+PciDevProgramMsiInterrupt(
+    IN      PPCI_DEVICE_DESCRIPTION Device,
+    IN      BYTE                    Vector,
+    IN _Strict_type_match_
+            APIC_DESTINATION_MODE   DestinationMode,
+    IN      BYTE                    Destination,
+    IN _Strict_type_match_
+            APIC_DELIVERY_MODE      DeliveryMode,
+    IN _Strict_type_match_
+            APIC_PIN_POLARITY       PinPolarity,
+    IN _Strict_type_match_
+            APIC_TRIGGER_MODE       TriggerMode
+    )
+{
+    STATUS status;
+    PPCI_CAPABILITY_MSI pciCap;
+    PCI_MSI_DATA_REGISTER msgData;
+    PCI_MSI_ADDRESS_REGISTER msgAddrLower;
+
+    if (NULL == Device)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+    pciCap = NULL;
+    msgData.Raw = 0;
+    msgAddrLower.Raw = 0;
+
+    status = PciDevRetrieveCapabilityById(Device->DeviceData,
+                                          PCI_CAPABILITY_ID_MSI,
+                                          (PPCI_CAPABILITY_HEADER*)&pciCap
+    );
+    if (!SUCCEEDED(status))
+    {
+        return STATUS_DEVICE_INTERRUPT_TYPE_NOT_SUPPORTED;
+    }
+    ASSERT(NULL != pciCap);
+
+    msgAddrLower.DestinationId = Destination;
+    msgAddrLower.DestinationMode = DestinationMode;
+    msgAddrLower.RedirectionHint = TRUE;
+    msgAddrLower.UpperFixedAddress = 0xFEE;
+
+    msgData.Vector = Vector;
+    msgData.DeliveryMode = DeliveryMode;
+    msgData.Assert = PinPolarity;
+    msgData.TriggerMode = TriggerMode;
+
+    pciCap->MessageAddressLower.Raw = msgAddrLower.Raw;
+
+    if (pciCap->MessageControl.Is64BitCapable)
+    {
+        pciCap->Capability64Bit.MessageAddressHigher = 0;
+
+        pciCap->Capability64Bit.MessageData.Raw = msgData.Raw;
+    }
+    else
+    {
+        // 32 bit capable
+        pciCap->Capability32Bit.MessageData.Raw = msgData.Raw;
+    }
+
+    pciCap->MessageControl.MsiEnable = TRUE;
+
+    if (!Device->PciExpressDevice)
+    {
+        _PciDevProgramIoPortMsiInterrupt(Device, pciCap);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+_PciDevProgramIoPortMsiInterrupt(
+    IN      PPCI_DEVICE_DESCRIPTION Device,
+    IN      PPCI_CAPABILITY_MSI     PciCap
+    )
+{  
+
+    ASSERT(NULL != Device);
+    ASSERT(NULL != PciCap);
+
+    // write Message Address Lower
+    PciWriteConfigurationSpace(Device->DeviceLocation,
+                               (BYTE)(PtrDiff(PciCap,Device->DeviceData) + FIELD_OFFSET(PCI_CAPABILITY_MSI,MessageAddressLower)),
+                               *((PDWORD)PciCap + 1)
+                               );
+
+    if (PciCap->MessageControl.Is64BitCapable)
+    {
+        // write message address upper
+        PciWriteConfigurationSpace(Device->DeviceLocation,
+                                   (BYTE)(PtrDiff(PciCap,Device->DeviceData) + FIELD_OFFSET(PCI_CAPABILITY_MSI,Capability64Bit.MessageAddressHigher)),
+                                   *((PDWORD)PciCap + 2)
+                                   );
+
+        // write message data
+        PciWriteConfigurationSpace(Device->DeviceLocation,
+                                   (BYTE)(PtrDiff(PciCap, Device->DeviceData) + FIELD_OFFSET(PCI_CAPABILITY_MSI, Capability64Bit.MessageData)),
+                                   *((PDWORD)PciCap + 3)
+                                   );
+    }
+    else
+    {
+        // write message data
+        PciWriteConfigurationSpace(Device->DeviceLocation,
+                                   (BYTE)(PtrDiff(PciCap, Device->DeviceData) + FIELD_OFFSET(PCI_CAPABILITY_MSI, Capability32Bit.MessageData)),
+                                   *((PDWORD)PciCap + 2)
+                                   );
+    }
+
+    // write Message Control, this will enable MSI interrupts
+    PciWriteConfigurationSpace(Device->DeviceLocation,
+                               (BYTE)(PtrDiff(PciCap, Device->DeviceData)),
+                               *(PDWORD)PciCap
+                               );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/pcie.c b/src_proiect/HAL/src/pcie.c
new file mode 100644
index 0000000..a023900
--- /dev/null
+++ b/src_proiect/HAL/src/pcie.c
@@ -0,0 +1,131 @@
+#include "hal_base.h"
+#include "pcie.h"
+#include "pci_common.h"
+
+#define PCI_EXPRESS_FORM_ADDRESS(Base,Bus,Dev,Func)     (volatile DWORD*) (((PBYTE)(Base))        + \
+                                                                           ((QWORD)(Bus)<<20)     + \
+                                                                           ((QWORD)(Dev)<<15)     + \
+                                                                           ((QWORD)(Func)<<12))
+
+STATUS
+PciExpressRetrieveNextDevice(
+    IN      PPCI_ROOT_COMPLEX           PciRootComplex,
+    IN      BOOLEAN                     ResetSearch,
+    OUT     PPCI_DEVICE_DESCRIPTION     PciDevice
+    )
+{
+    BOOLEAN         foundDevice;
+
+    static PCI_DEVICE_LOCATION __currentDeviceLocation = { 0 };
+    static BOOLEAN  __exhausedPciSpace = FALSE;
+
+    if (NULL == PciRootComplex)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == PciDevice)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    foundDevice = FALSE;
+
+    if (ResetSearch)
+    {
+        memzero(&__currentDeviceLocation, sizeof(PCI_DEVICE_LOCATION));
+        __currentDeviceLocation.Bus = PciRootComplex->StartBusNumber;
+
+        __exhausedPciSpace = FALSE;
+    }
+
+    if (__exhausedPciSpace)
+    {
+        return STATUS_DEVICE_NO_MORE_DEVICES;
+    }
+
+    do
+    {
+        volatile DWORD* pFunctionBase = PCI_EXPRESS_FORM_ADDRESS(PciRootComplex->BaseAddress,
+                                                                 __currentDeviceLocation.Bus,
+                                                                 __currentDeviceLocation.Device,
+                                                                 __currentDeviceLocation.Function);
+
+        foundDevice = MAX_DWORD != *pFunctionBase;
+
+        if (foundDevice)
+        {
+            memcpy(&PciDevice->DeviceLocation, &__currentDeviceLocation, sizeof(PCI_DEVICE_LOCATION));
+            PciDevice->PciExpressDevice = TRUE;
+            PciDevice->DeviceData = (PPCI_DEVICE) pFunctionBase;
+        }
+
+        __currentDeviceLocation.Function = (__currentDeviceLocation.Function + 1) % PCI_NO_OF_FUNCTIONS;
+        if (0 == __currentDeviceLocation.Function)
+        {
+            __currentDeviceLocation.Device = (__currentDeviceLocation.Device + 1) % PCI_NO_OF_DEVICES;
+            if (0 == __currentDeviceLocation.Device)
+            {
+                __currentDeviceLocation.Bus = (__currentDeviceLocation.Bus + 1) % PCI_NO_OF_BUSES;
+                if (0 == __currentDeviceLocation.Bus || 
+                    (PciRootComplex->EndBusNumber + 1) == __currentDeviceLocation.Bus)
+                {
+                    // because we found a device we can't return an error yet =>
+                    // we just set the static variable
+                    __exhausedPciSpace = TRUE;
+                    if (!foundDevice)
+                    {
+                        // we didn't manage to find another PCI device so we can return
+                        // the status right now
+                        return STATUS_DEVICE_NO_MORE_DEVICES;
+                    }
+                }
+            }
+        }
+
+        // we loop until we find a PCI device or until we exhausted
+        // all the PCI space
+    } while (!foundDevice);
+
+    ASSERT(foundDevice);
+    return STATUS_SUCCESS;
+}
+
+DWORD
+PciExpressReadConfigurationSpace(
+    IN      PPCI_ROOT_COMPLEX       PciRootComplex,
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register
+    )
+{
+    ASSERT( NULL != PciRootComplex );
+    ASSERT( NULL != PciRootComplex->BaseAddress );
+    ASSERT( Register < PREDEFINED_PCI_EXPRESS_DEVICE_SPACE_SIZE );
+
+    volatile DWORD* pFunctionBase = PCI_EXPRESS_FORM_ADDRESS(PciRootComplex->BaseAddress,
+                                                             DeviceLocation.Bus,
+                                                             DeviceLocation.Device,
+                                                             DeviceLocation.Function);
+
+    return *((volatile DWORD*)PtrOffset(pFunctionBase, Register));
+}
+
+void
+PciExpressWriteConfigurationSpace(
+    IN      PPCI_ROOT_COMPLEX       PciRootComplex,
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      DWORD                   Value
+    )
+{
+    ASSERT(NULL != PciRootComplex);
+    ASSERT(NULL != PciRootComplex->BaseAddress);
+    ASSERT(Register < PREDEFINED_PCI_EXPRESS_DEVICE_SPACE_SIZE);
+
+    volatile DWORD* pFunctionBase = PCI_EXPRESS_FORM_ADDRESS(PciRootComplex->BaseAddress,
+                                                             DeviceLocation.Bus,
+                                                             DeviceLocation.Device,
+                                                             DeviceLocation.Function);
+
+    *((volatile DWORD*)PtrOffset(pFunctionBase, Register)) = Value;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/pic.c b/src_proiect/HAL/src/pic.c
new file mode 100644
index 0000000..7c44f85
--- /dev/null
+++ b/src_proiect/HAL/src/pic.c
@@ -0,0 +1,191 @@
+#include "hal_base.h"
+#include "pic.h"
+
+// COMMAND on write | STATUS on read
+// DATA on write | IMR on read
+
+#define     PIC1_BASE           0x20
+#define     PIC1_COMMAND        PIC1_BASE
+#define     PIC1_DATA           (PIC1_BASE+1)
+
+#define     PIC2_BASE           0xA0
+#define     PIC2_COMMAND        PIC2_BASE
+#define     PIC2_DATA           (PIC2_BASE+1)
+
+#define     PIC_COMMAND_EOI     0x20    
+
+//     If set(1), the PIC expects to receive IC4 during initialization.
+#define     ICW1_ICW4           0x01
+
+// If cleared, PIC is cascaded with slave PICs, and ICW3 must be sent to controller.
+#define     ICW1_SINGLE         0x02
+
+//  ignored by x86, and is default to 0
+#define     ICW1_INTERVAL4      0x04
+
+// If Not set (0), Operate in Edge Triggered Mode
+#define     ICW1_LEVEL          0x08
+
+// Initialization bit. Set 1 if PIC is to be initialized
+#define     ICW1_INIT           0x10
+
+//     If set (1), it is in 80x86 mode
+#define     ICW4_8086           0x01
+#define     ICW4_AUTO           0x02        /* Auto (normal) EOI */
+#define     ICW4_BUF_SLAVE      0x08        /* Buffered mode/slave */
+#define     ICW4_BUF_MASTER     0x0C        /* Buffered mode/master */
+#define     ICW4_SFNM           0x10        /* Special fully nested (not) */
+
+// OCW3
+#define     PIC_OCW3_READ_IRR   0x0A        // OCW3 irq ready next CMD read
+#define     PIC_OCW3_READ_ISR   0x0B        // OCW3 irq service next CMD read    
+
+__forceinline
+static
+WORD
+_PicGetIrqRegister(
+    IN      BYTE        Ocw3
+    )
+{
+    __outbyte( PIC1_COMMAND, Ocw3 );
+    __outbyte( PIC2_COMMAND, Ocw3 );
+
+    return BYTES_TO_WORD(__inbyte(PIC2_COMMAND), __inbyte(PIC1_COMMAND) );
+}
+
+void
+PicInitialize(
+    IN BYTE MasterBase,
+    IN BYTE SlaveBase
+    )
+{
+    // ICW1 - This is the primary control word used to initialize the PIC
+
+    // starts the initialization sequence (in cascade mode)
+    __outbyte(PIC1_COMMAND, ICW1_INIT | ICW1_ICW4);  
+
+    // must be sent to both PICs
+    __outbyte(PIC2_COMMAND, ICW1_INIT | ICW1_ICW4);
+
+
+    // ICW2 - This control word is used to map the base address of the IDT of which the PIC are to use
+
+    // Starting offset for PIC1
+    __outbyte(PIC1_DATA, MasterBase);
+
+    // Starting offset for PIC2
+    __outbyte(PIC2_DATA, SlaveBase);
+
+    
+    // ICW3 - let the PICs know what IRQ lines to use when communicating with each other
+
+    // ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0000 0100)
+    // We must send the bit which corresponds to IRQ2 (1<<2)
+    __outbyte(PIC1_DATA, 1 << 2);                       
+    
+    // ICW3: tell Slave PIC its cascade identity (0000 0010)
+    // For some reason on the secondary PIC we need to tell it the value instead of the bit :)
+    __outbyte(PIC2_DATA, 2);                       
+
+
+    // ICW4 - This controls how everything is to operate
+    __outbyte(PIC1_DATA, ICW4_8086);
+    
+    __outbyte(PIC2_DATA, ICW4_8086);
+    
+    // mask all interrupts, we will be using the IOAPIC
+    __outbyte(PIC1_DATA, MAX_BYTE);
+    __outbyte(PIC2_DATA, MAX_BYTE);
+
+    // Intel MP specification Section 3.6.2.1 PIC Mode
+    // Before entering Symmetric I/O Mode, either the BIOS or the operating system must switch out of
+    // PIC Mode by changing the IMCR.
+    // To access the IMCR, write a value of 70h to I / O port 22h, which
+    // selects the IMCR.Then write the data to I / O port 23h.The power - on default value is zero, which
+    // connects the NMI and 8259 INTR lines directly to the BSP.Writing a value of 01h forces the
+    // NMI and 8259 INTR signals to pass through the APIC.
+
+    /// Intel MP specification Section B.3 Interrupt Mode Initialization and Handling
+    /// The operating system should switch over to Symmetric I / O Mode to start multiprocessor operation.
+    /// If the IMCRP bit of the MP feature information bytes is set, the operating system must set the
+    /// IMCR to APIC mode.The operating system should not write to the IMCR unless the IMCRP bit
+    /// is set7
+
+    // Select IMCR
+    __outbyte( 0x22, 0x70 );
+
+    // Write 0x1
+    __outbyte( 0x23, 0x1 );
+}
+
+void
+PicSendEOI(
+    IN      BYTE        Irq
+    )
+{
+    WORD picCommand;
+
+    ASSERT(Irq < 2 * IRQS_PER_PIC);
+
+    picCommand = Irq >= IRQS_PER_PIC ? PIC2_COMMAND : PIC1_COMMAND;
+
+    __outbyte(picCommand, PIC_COMMAND_EOI);
+}
+
+void
+PicChangeIrqMask(
+    IN      BYTE        Irq,
+    IN      BOOLEAN     MaskIrq
+    )
+{
+    WORD picData;
+    BYTE value;
+    BYTE irqLine;
+    BYTE irqShift;
+
+    ASSERT(Irq < 2 * IRQS_PER_PIC);
+
+    irqLine = Irq;
+    irqShift = 0;
+
+    if (Irq < IRQS_PER_PIC)
+    {
+        picData = PIC1_DATA;
+    }
+    else
+    {
+        picData = PIC2_DATA;
+        irqLine = irqLine - IRQS_PER_PIC;
+    }
+
+    irqShift = (1 << irqLine);
+
+    value = __inbyte(picData);
+    if (MaskIrq)
+    {
+        value = value | irqShift;
+    }
+    else
+    {
+        // we want to clear it => enable interrupt for it
+        value = value & (~irqShift);
+    }
+
+    __outbyte(picData, value);
+}
+
+WORD
+PicGetIrr(
+    void
+    )
+{
+    return _PicGetIrqRegister(PIC_OCW3_READ_IRR);
+}
+
+WORD
+PicGetIsr(
+    void
+    )
+{
+    return _PicGetIrqRegister(PIC_OCW3_READ_ISR);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/pit.c b/src_proiect/HAL/src/pit.c
new file mode 100644
index 0000000..e886696
--- /dev/null
+++ b/src_proiect/HAL/src/pit.c
@@ -0,0 +1,208 @@
+#include "hal_base.h"
+#include "pit.h"
+
+#define PIT_FREQUENCY_HZ                                    (1'193'182ULL)
+
+#define PIT_PERIODIC_CHANNEL                                0
+#define PIT_ONETIME_CHANNEL                                 2
+
+#define PIT_NO_OF_CHANNELS                                  3
+
+// PIT ports
+#define PIT_CHANNEL_DATA_PORT_BASE                          PIT_CHANNEL0_DATA_PORT
+#define PIT_CHANNEL0_DATA_PORT                              0x40
+#define PIT_CHANNEL1_DATA_PORT                              0x41
+#define PIT_CHANNEL2_DATA_PORT                              0x42
+#define PIT_COMMAND_REG_PORT                                0x43
+
+// this controls the PIT gates
+#define PIT_CONTROL_REG_PORT                                0x61
+
+#define PIT_CONTROL_CH2_INPUT                               (1<<0)
+#define PIT_CONTROL_SPEAKER_OUTPUT                          (1<<1)
+#define PIT_CONTROL_CH2_OUTPUT                              (1<<5)
+
+#define STATUS_GATE2_MASK                                   (1<<0)
+#define STATUS_SPEAKER_MASK                                 (1<<1)
+#define STATUS_OUT1_MASK                                    (1<<4)
+#define STATUS_OUT2_MASK                                    (1<<5)
+
+#define PIT_COMM_OPERATE_INTERRUPT_ON_TERMINAL_COUNT        0
+#define PIT_COMM_OPERATE_RATE_GENERATOR                     2
+
+#define PIT_COMM_ACCESS_LATCH                               0x00
+#define PIT_COMM_ACCESS_LO_ONLY                             0x01
+#define PIT_COMM_ACCESS_HI_ONLY                             0x02
+#define PIT_COMM_ACCESS_LO_HI                               0x03
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+typedef union _PIT_COMMAND_REGISTER
+{
+    struct
+    {
+        BYTE            BcdMode             :   1;
+        BYTE            OperatingMode       :   3;
+        BYTE            AccessMode          :   2;
+        BYTE            Channel             :   2;
+    };
+    BYTE                Raw;
+} PIT_COMMAND_REGISTER, *PPIT_COMMAND_REGISTER;
+STATIC_ASSERT(sizeof(PIT_COMMAND_REGISTER) == sizeof(BYTE));
+
+#pragma warning(pop)
+#pragma pack(pop)
+
+static
+void
+_PitWriteData(
+    IN      BYTE        Channel,
+    IN      BYTE        OperatingMode,
+    IN      WORD        Data
+    );
+
+static
+WORD
+_PitReadData(
+    IN      BYTE        Channel
+    );
+
+WORD
+PitSetTimer(
+    IN      DWORD       Microseconds,
+    IN      BOOLEAN     Periodic
+    )
+{
+    DWORD initialCount;
+
+    ASSERT( 0 != Microseconds && Microseconds <= SEC_IN_US);
+
+    initialCount = PIT_FREQUENCY_HZ / (SEC_IN_US / Microseconds);
+    ASSERT( initialCount <= MAX_WORD);
+
+    if (!Periodic)
+    {
+        BYTE value;
+
+        // get current gate controls
+        value = __inbyte(PIT_CONTROL_REG_PORT);
+
+        // 0xFD is used to disable speaker output (bit #1)
+        // bit0 enables channel 2
+        __outbyte(PIT_CONTROL_REG_PORT, (value & (~PIT_CONTROL_SPEAKER_OUTPUT)) | PIT_CONTROL_CH2_INPUT);
+    }
+
+    // write frequency to data buffer
+    _PitWriteData( Periodic ? PIT_PERIODIC_CHANNEL : PIT_ONETIME_CHANNEL,
+                   Periodic ? PIT_COMM_OPERATE_RATE_GENERATOR : PIT_COMM_OPERATE_INTERRUPT_ON_TERMINAL_COUNT,
+                   (WORD) initialCount
+                   );
+
+    return (WORD) initialCount;
+}
+
+void
+PitStartTimer(
+    void
+    )
+{
+    BYTE value;
+
+    // stop timer countdown
+    value = __inbyte(PIT_CONTROL_REG_PORT) & (~PIT_CONTROL_CH2_INPUT);
+    __outbyte(PIT_CONTROL_REG_PORT, value);
+
+    // start timer countdown
+    __outbyte(PIT_CONTROL_REG_PORT, value | PIT_CONTROL_CH2_INPUT);
+}
+
+void
+PitWaitTimer(
+    void
+    )
+{
+    // when bit 5 is set => Timer fired
+    while (!(__inbyte(PIT_CONTROL_REG_PORT) & PIT_CONTROL_CH2_OUTPUT));
+}
+
+void
+PitSleep(
+    IN      DWORD       Microseconds
+    )
+{
+    PitSetTimer(Microseconds, FALSE);
+    PitStartTimer();
+    PitWaitTimer();
+}
+
+WORD
+PitGetTimerCount(
+    IN      BOOLEAN     Periodic
+    )
+{
+    return _PitReadData(Periodic ? PIT_PERIODIC_CHANNEL : PIT_ONETIME_CHANNEL);
+}
+
+static
+void
+_PitWriteData(
+    IN      BYTE        Channel,
+    IN      BYTE        OperatingMode,
+    IN      WORD        Data
+    )
+{
+    PIT_COMMAND_REGISTER cmdRegister = { 0 };
+
+    ASSERT( Channel < PIT_NO_OF_CHANNELS );
+
+    // we switch to mode 0
+    cmdRegister.OperatingMode = OperatingMode;
+    cmdRegister.AccessMode = PIT_COMM_ACCESS_LO_HI;
+    cmdRegister.Channel = Channel;
+    __outbyte(PIT_COMMAND_REG_PORT, cmdRegister.Raw);
+
+    // write low frequency
+    __outbyte(PIT_CHANNEL_DATA_PORT_BASE + Channel, WORD_LOW(Data));
+
+    // short delay
+    __inbyte(0x60);
+
+    // write high frequency
+    __outbyte(PIT_CHANNEL_DATA_PORT_BASE + Channel, WORD_HIGH(Data));
+}
+
+static
+WORD
+_PitReadData(
+    IN      BYTE        Channel
+    )
+{
+    PIT_COMMAND_REGISTER cmdRegister = { 0 };
+    BYTE lo, hi;
+
+    ASSERT( Channel < PIT_NO_OF_CHANNELS );
+
+    // bits 3 - 0 must be zero for future compatibility
+    cmdRegister.OperatingMode = 0;
+    cmdRegister.AccessMode = PIT_COMM_ACCESS_LATCH;
+    cmdRegister.Channel = Channel;
+    __outbyte(PIT_COMMAND_REG_PORT, cmdRegister.Raw);
+
+    // write low frequency
+    lo = __inbyte(PIT_CHANNEL_DATA_PORT_BASE + Channel);
+
+    // short delay
+    __inbyte(0x60);
+
+    hi = __inbyte(PIT_CHANNEL_DATA_PORT_BASE + Channel);
+
+    return BYTES_TO_WORD(hi,lo);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/pte.c b/src_proiect/HAL/src/pte.c
new file mode 100644
index 0000000..e33cbf6
--- /dev/null
+++ b/src_proiect/HAL/src/pte.c
@@ -0,0 +1,89 @@
+#include "hal_base.h"
+#include "pte.h"
+
+void
+PteMap(
+    IN          PVOID               PageTable,
+    IN_OPT      PHYSICAL_ADDRESS    PhysicalAddress,
+    IN          PTE_MAP_FLAGS       Flags
+    )
+{
+    PT_ENTRY* pTablePointer;
+
+    ASSERT(NULL != PageTable);
+
+    pTablePointer = PageTable;
+    memzero(pTablePointer, sizeof(PVOID));
+
+    pTablePointer->PhysicalAddress = (QWORD) PhysicalAddress >> SHIFT_FOR_PHYSICAL_ADDR;
+    pTablePointer->Present = 1;
+
+    pTablePointer->ReadWrite = Flags.Writable;
+    pTablePointer->XD = !Flags.Executable;
+
+    // 0 means user-mode accesses are forbidden
+    pTablePointer->UserSupervisor = Flags.UserAccess;
+
+    if (!Flags.PagingStructure)
+    {
+        // set caching
+        pTablePointer->PAT = (Flags.PatIndex >> 2) & 1;
+        pTablePointer->PCD = (Flags.PatIndex >> 1) & 1;
+        pTablePointer->PWT = (Flags.PatIndex >> 0) & 1;
+
+        pTablePointer->Global = Flags.GlobalPage;
+    }
+}
+
+void
+PteUnmap(
+    IN          PVOID           PageTable
+    )
+{
+    ASSERT( NULL != PageTable );
+    
+    memzero(PageTable, sizeof(PT_ENTRY));
+}
+
+PHYSICAL_ADDRESS
+PteGetPhysicalAddress(
+    IN          PVOID           PageTable
+    )
+{
+    PPT_ENTRY pEntry;
+
+    ASSERT( NULL != PageTable );
+
+    pEntry = (PPT_ENTRY) PageTable;
+
+    return (PHYSICAL_ADDRESS) ( pEntry->PhysicalAddress << SHIFT_FOR_PHYSICAL_ADDR );
+}
+
+PHYSICAL_ADDRESS
+PteLargePageGetPhysicalAddress(
+    IN          PVOID           PageTable
+    )
+{
+    PPD_ENTRY_2MB pEntry;
+
+    ASSERT(NULL != PageTable);
+
+    pEntry = (PPD_ENTRY_2MB)PageTable;
+
+    return (PHYSICAL_ADDRESS)(pEntry->PhysicalAddress << SHIFT_FOR_LARGE_PAGE);
+
+}
+
+BOOLEAN
+PteIsPresent(
+    IN          PVOID           PageTable
+    )
+{
+    PML4_ENTRY* pTablePointer;
+
+    ASSERT( NULL != PageTable );
+
+    pTablePointer = PageTable;
+
+    return ( 1== pTablePointer->Present );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/rtc.c b/src_proiect/HAL/src/rtc.c
new file mode 100644
index 0000000..4749af0
--- /dev/null
+++ b/src_proiect/HAL/src/rtc.c
@@ -0,0 +1,124 @@
+#include "hal_base.h"
+#include "rtc.h"
+#include "cmos.h"
+#include "cpu.h"
+#include "pit.h"
+
+#define RTC_LOWEST_RATE                     3
+#define RTC_HIGHEST_RATE                    15
+
+#define RDTSC_TIMER_CONFIGURATION_SLEEP     1*MS_IN_US
+#define RDTSC_TIMER_CONFIGURATION_SAMPLES   4
+
+static QWORD                            m_tscFrequency;
+
+static
+void
+_RtcInitializeTimerInterrupt(
+    void
+    );
+
+static
+QWORD
+_RtcDetermineTscFrequency(
+    IN          DWORD                   NoOfSamples,
+    IN          DWORD                   SleepUsPerSample
+    );
+
+void
+RtcInit(
+    OUT_OPT     QWORD*          TscFrequency
+    )
+{
+    m_tscFrequency = _RtcDetermineTscFrequency(RDTSC_TIMER_CONFIGURATION_SAMPLES,
+                                               RDTSC_TIMER_CONFIGURATION_SLEEP
+                                               );
+
+    _RtcInitializeTimerInterrupt();
+    
+    if (NULL != TscFrequency)
+    {
+        *TscFrequency = m_tscFrequency;
+    }
+}
+
+void
+RtcAcknowledgeTimerInterrupt(
+    void
+    )
+{
+    // just throw away contents
+    CmosGetValueNMI(CmosRegisterStatusC);
+}
+
+static
+void
+_RtcInitializeTimerInterrupt(
+    void
+    )
+{
+    INTR_STATE prevIntrState;
+    BYTE prevValue;
+
+    prevValue = 0;
+
+    prevIntrState = CpuIntrDisable();
+
+    // read the current value of register B
+    prevValue = CmosGetValueDisableNMI(CmosRegisterStatusB);
+
+    // write the previous value ORed with 0x10. This turns on update interrupts
+    CmosWriteValueDisableNMI(CmosRegisterStatusB, prevValue | CMOS_UPDATE_INTERRUPT);
+
+    RtcAcknowledgeTimerInterrupt();
+
+    // restore interrupt state
+    CpuIntrSetState(prevIntrState);
+}
+
+static
+QWORD
+_RtcDetermineTscFrequency(
+    IN          DWORD                   NoOfSamples,
+    IN          DWORD                   SleepUsPerSample
+    )
+{
+    QWORD initialRdtsc;
+    QWORD finalRdtsc;
+    QWORD ticksElapsed;
+    QWORD tickFrequency;
+    DWORD i;
+    QWORD minTick = MAX_QWORD;
+    QWORD maxTick = 0;
+    QWORD total = 0;
+    QWORD tickMean;
+
+    for (i = 0; i < NoOfSamples; ++i)
+    {
+        initialRdtsc = RtcGetTickCount(); 
+        PitSetTimer(SleepUsPerSample, FALSE);
+
+        PitStartTimer();
+
+        PitWaitTimer();
+        finalRdtsc = RtcGetTickCount();
+
+        ticksElapsed = finalRdtsc - initialRdtsc;
+
+        if (ticksElapsed < minTick)
+        {
+            minTick = ticksElapsed;
+        }
+
+        if (ticksElapsed > maxTick)
+        {
+            maxTick = ticksElapsed;
+        }
+        total = total + ticksElapsed;
+    }
+
+    tickMean = total / NoOfSamples;
+    tickFrequency = tickMean * ( ( 1 * SEC_IN_US ) / SleepUsPerSample );
+
+    return tickFrequency;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/serial.c b/src_proiect/HAL/src/serial.c
new file mode 100644
index 0000000..c2460b3
--- /dev/null
+++ b/src_proiect/HAL/src/serial.c
@@ -0,0 +1,123 @@
+#include "hal_base.h"
+#include "serial.h"
+
+// Serial Port Register Offsets
+#define     DATA_REG_OFFSET                 0x0     // Stores Data for both I&O
+#define     INT_REG_OFFSET                  0x1     // Interrupt Register
+#define     FIFO_REG_OFFSET                 0x2     // FIFO Register
+#define     LINE_CREG_OFFSET                0x3     // Line Control Register
+#define     MODEM_CREG_OFFSET               0x4     // Modem Control Register
+#define     LSR_REG_OFFSET                  0x5     // Line Status Register
+#define     MODEM_SREG_OFFSET               0x6     // Modem Status Register
+#define     SCRATCH_REG_OFFSET              0x7     // Scratch Register
+#define     RESERVED_REG_OFFSET             0x8
+
+// these are valid only if DLAB is set
+#define     LSB_DIV_OFFSET_VALUE            0x0     // LSB of BaudRate divisor
+#define     MSB_DIV_OFFSET_VALUE            0x1     // MSB of BaudRate divisor
+
+// LSR masks
+#define     LSR_THR_READY                   (1<<5)  // data is ready to be sent
+#define     LSR_OVERRUN_ERROR               (1<<1)
+
+#define     DLAB_MASK                       (1<<7)
+
+// FIFO masks
+#define     FIFO_ENABLE                     (1<<0)
+#define     FIFO_RECEIVER_RESET             (1<<1)
+#define     FIFO_TRANSMIT_RESET             (1<<2)
+#define     FIFO_RECEIVE_TRIG_0             (1<<6)
+#define     FIFO_RECEIVE_TRIG_1             (1<<7)
+
+// we will send 7 bits of data
+#define     DATA_BITS                       2
+
+// 1 stop bit
+#define     STOP_BIT                        (0<<2)
+
+// no parity bit
+#define     PARITY_BIT                      (0<<3)
+
+
+//******************************************************************************
+// Function:    SerialOut
+// Description: Outputs a byte of data through the serial port.
+// Returns:       void
+// Parameter:     IN BYTE Data - byte to output.
+//******************************************************************************
+__forceinline
+static
+void 
+_SerialOut(
+    IN WORD Port,
+    IN BYTE Data 
+    )
+{
+    // we wait for the data register to be ready to receive new data
+    while( ( __inbyte( Port + LSR_REG_OFFSET ) & LSR_THR_READY ) == 0 );
+
+    // we output the byte
+    __outbyte( Port, Data );
+}
+
+void
+SerialInitialize( 
+    IN  WORD    Port
+    )
+{
+    ASSERT( 0 != Port );
+
+    // Disable all interrupts
+    __outbyte( Port + INT_REG_OFFSET, 0x00);    
+    __outbyte( Port + LINE_CREG_OFFSET, DLAB_MASK );
+
+    // set baud rate divisor to 1 => BaudRate = 115200
+    __outbyte( Port + LSB_DIV_OFFSET_VALUE, 1 );
+    __outbyte( Port + MSB_DIV_OFFSET_VALUE, 0 );
+
+    // 7 data bits, no parity, one stop bit
+    __outbyte( Port + LINE_CREG_OFFSET, PARITY_BIT | STOP_BIT | DATA_BITS );
+
+    // we enable FIFO
+    // we would theoretically be interrupted every 14 characters received but because we have interrupts disabled
+    // this will never happen
+    __outbyte( Port + FIFO_REG_OFFSET, FIFO_RECEIVE_TRIG_1 | FIFO_RECEIVE_TRIG_0 | FIFO_TRANSMIT_RESET | FIFO_RECEIVER_RESET | FIFO_ENABLE );
+}
+
+void 
+SerialWriteBuffer(
+    IN   WORD   Port,
+    IN_Z char*  Buffer 
+    )
+{
+    DWORD i;
+
+    ASSERT( 0 != Port );
+    ASSERT( NULL != Buffer );
+
+    i = 0;
+
+    while( '\0' != Buffer[i] )
+    {
+        _SerialOut( Port, Buffer[i] );
+        ++i;
+    }
+}
+
+void
+SerialWriteNBuffer(
+    IN                              WORD  Port,
+    IN_READS_BYTES(BufferLength)    BYTE* Buffer,
+    IN                              DWORD BufferLength
+    )
+{
+    DWORD i;
+
+    ASSERT(0 != Port);
+    ASSERT(NULL != Buffer);
+
+    for( i = 0; i < BufferLength; ++i )
+    {
+        _SerialOut( Port, Buffer[i] );
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/tss.c b/src_proiect/HAL/src/tss.c
new file mode 100644
index 0000000..f06ce41
--- /dev/null
+++ b/src_proiect/HAL/src/tss.c
@@ -0,0 +1,57 @@
+#include "hal_base.h"
+#include "tss.h"
+
+STATUS
+TssInstall(
+    OUT     PTSS        Tss,
+    IN      WORD        GdtIndex,
+    IN_RANGE(1,NO_OF_IST)
+            BYTE        NumberOfStacks,
+    IN_READS(NumberOfStacks)
+            PVOID*      Stacks
+    )
+{
+    STATUS status;
+    SEGMENT_DESCRIPTOR_FLAGS flags;
+
+    if (NULL == Tss)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if ((0 == NumberOfStacks) || ( NumberOfStacks > NO_OF_IST) )
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if( NULL == Stacks )
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    status = STATUS_SUCCESS;
+
+    // zero the whole TSS
+    memzero(Tss, sizeof(TSS));
+
+    for( DWORD i = 0; i < NumberOfStacks; ++i )
+    {
+        // setup ISTs
+        Tss->IST[i] = (QWORD) Stacks[i];
+    }
+
+    // Set the IO Bitmap address at the end of the TSS, as a result all IO port accesses
+    // made in user-mode will result in #GP exceptions
+    Tss->IOMapBaseAddress = sizeof(TSS);
+
+    // install descriptor in GDT
+    flags = (1 << SegmentDescriptorFlagRing0) | (1 << SegmentDescriptorSystemDescriptor);
+
+    status = GdtInstallDescriptor(GdtIndex, (QWORD) Tss, SystemSegment64BitTssAvailable, flags);
+    if (!SUCCEEDED(status))
+    {
+        return status;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL/src/vmx.c b/src_proiect/HAL/src/vmx.c
new file mode 100644
index 0000000..91e1d48
--- /dev/null
+++ b/src_proiect/HAL/src/vmx.c
@@ -0,0 +1,101 @@
+#include "hal_base.h"
+#include "vmx.h"
+
+#pragma warning(push)
+
+// warning C28039: The type of actual parameter '24576|2048|((0<<1))|0' should exactly match the type 'VMCS_FIELD':
+#pragma warning(disable: 28039)
+
+#define VMX_RESULT_SUCCESS                  (VMX_RESULT)0
+#define VMX_RESULT_FAIL_WITH_ERROR          (VMX_RESULT)1
+#define VMX_RESULT_FAIL_NO_ERROR            (VMX_RESULT)2
+
+typedef DWORD VM_INSTR_ERROR;
+
+typedef enum _VM_INSTR_ERROR
+{
+    VmInstrErrorReserved                    = 0,
+
+    VmInstrErrorVmCallInVmxRoot,
+    VmInstrErrorVmClearWithInvalidPhysAddr,
+    VmInstrErrorVmClearWithVmxonPointer,
+    VmInstrErrorVmLaunchWithNonClearVmcs,
+    VmInstrErrorVmResumeWithNonLaunchedVmcs,
+    VmInstrErrorVmResumeAfterVmxOff,
+    VmInstrErrorVmEntryWithInvalidControlFields,
+    VmInstrErrorVmEntryWithInvalidHostStateFields,
+    VmInstrErrorVmPtrldWithInvalidPhysAddr,
+    VmInstrErrorVmPtrldWithVmxonPointer,
+    VmInstrErrorVmPtrldWithIncorrectVmcsRevision,
+    VmInstrErrorVmReadFromUnsupportedVmcsField,
+    VmInstrErrorVmWriteToUnsupportedVmcsField = VmInstrErrorVmReadFromUnsupportedVmcsField,
+    VmInstrErrorVmWriteToReadOnlyVmcsField,
+
+    VmInstrErrorVmxonInVmxRoot = 15,
+    VmInstrErrorVmEntryWithInvalidExecutiveVmcsPointer,
+    VmInstrErrorVmEntryWithNonLaunchedExecutiveVmcs,
+    VmInstrErrorVmEntryWithExecutiveVmcsPointerNotVmxonPointer,
+    VmInstrErrorVmCallWithNonClearVmcs,
+    VmInstrErrorVmCallWithInvalidVmExitControlFields,
+
+    VmInstrErrorVmCallWithIncorrectMSEG = 22,
+    VmInstrErrorVmxoffUnderDualMonitor,
+    VmInstrErrorVmCallWithInvalidSmmFeatures,
+    VmInstrErrorVmEntryWithInvalidVmExecutionFieldsInExecutiveVmcs,
+    VmInstrErrorVmEntryWithEventsBlockedByMovSS,
+    VmInstrErrorInvalidOperandToInveptInvvpid,
+
+    VmInstrErrorInstrErrorNotValid           = MAX_DWORD
+} VM_INSTR_ERROR;
+
+
+static
+__forceinline
+VM_INSTR_ERROR
+_VmxGetInstrError(
+    IN _Strict_type_match_
+            VMX_RESULT  Result
+    )
+{
+    if (Result == VMX_RESULT_SUCCESS) return VmInstrErrorReserved;
+    if (Result == VMX_RESULT_FAIL_NO_ERROR) return (VM_INSTR_ERROR) VmInstrErrorInstrErrorNotValid;
+
+    return (VM_INSTR_ERROR) VmxRead(VMCS_EXIT_INSTRUCTION_ERROR);
+}
+
+QWORD
+VmxRead(
+    IN _Strict_type_match_
+            VMCS_FIELD Field
+    )
+{
+    QWORD fieldValue;
+
+    VMX_RESULT vmxResult = __vmx_vmread(Field, &fieldValue);
+    VM_INSTR_ERROR errCode = _VmxGetInstrError(vmxResult);
+
+    ASSERT_INFO(
+        errCode == VmInstrErrorReserved,
+        "Failed VMREAD on field 0x%08x with error code %u\n",
+        Field, errCode);
+
+    return fieldValue;
+}
+
+void
+VmxWrite(
+    IN _Strict_type_match_
+            VMCS_FIELD  Field,
+    IN      QWORD       Value
+    )
+{
+    VMX_RESULT vmxResult = __vmx_vmwrite(Field, Value);
+    VM_INSTR_ERROR errCode = _VmxGetInstrError(vmxResult);
+
+    ASSERT_INFO(
+        errCode == VmInstrErrorReserved,
+        "Failed VMRITE on field 0x%08x with value 0x%X with error code %u\n",
+        Field, Value, errCode);
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000.sln b/src_proiect/HAL9000.sln
new file mode 100644
index 0000000..38bd508
--- /dev/null
+++ b/src_proiect/HAL9000.sln
@@ -0,0 +1,1355 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.30517.126
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL9000", "HAL9000\HAL9000.vcxproj", "{79A21DCA-19AF-4F8E-9B83-62D7CF504104}"
+	ProjectSection(ProjectDependencies) = postProject
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8} = {642F9F32-68EC-40AD-BAAF-3436DA0B66A8}
+		{9412F640-A271-4661-B437-5932E9B95C26} = {9412F640-A271-4661-B437-5932E9B95C26}
+		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D} = {4DA7677D-D0E7-44EC-B350-F7170E0ED84D}
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A} = {E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E} = {0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1} = {02EC2CAD-C1E9-45FB-96AC-27976A9300F1}
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608} = {0C5EB2D2-DA05-44F7-89CA-A15CB692D608}
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1} = {F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL", "HAL\HAL.vcxproj", "{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Filesystems", "Filesystems", "{2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FAT32", "FAT32\FAT32.vcxproj", "{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Misc", "Misc", "{0B471868-BE09-4F73-996F-2EAFFDF591CE}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PE_Parser", "PE_Parser\PE_Parser.vcxproj", "{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Networking", "Networking", "{C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Eth_82574L", "Eth_82574L\Eth_82574L.vcxproj", "{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}"
+	ProjectSection(ProjectDependencies) = postProject
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F} = {B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NetworkStack", "NetworkStack\NetworkStack.vcxproj", "{9412F640-A271-4661-B437-5932E9B95C26}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NetworkPort", "NetworkPort\NetworkPort.vcxproj", "{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Storage", "Storage", "{9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Disk", "Disk\Disk.vcxproj", "{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Volume", "Volume\Volume.vcxproj", "{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ata", "Ata\Ata.vcxproj", "{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "User-mode", "User-mode", "{3E0FB3C6-F876-44FD-8DF7-1D3F1AFA002C}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Applications", "Applications", "{7B55EACA-2B29-423D-8D6C-C9986E3864AA}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Utils", "Utils", "{BBA96504-05A4-41DC-9312-AF786B4B9281}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AppHelloWorld", "Usermode\AppHelloWorld\AppHelloWorld.vcxproj", "{E5ABDC11-649C-430A-B4E0-4603247A38C5}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CopyUmAppsToVm", "Usermode\CopyUmAppsToVm\CopyUmAppsToVm.vcxproj", "{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9} = {D4EF4101-8E74-45C4-93B0-1AC3F29399B9}
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4} = {A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD} = {61E34105-4020-4582-9F7C-E86DB0BDD7BD}
+		{F092D608-D31B-4E30-9650-11058BD45093} = {F092D608-D31B-4E30-9650-11058BD45093}
+		{7A6D1E11-2D94-4154-8147-153427DA2E98} = {7A6D1E11-2D94-4154-8147-153427DA2E98}
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5} = {E5ABDC11-649C-430A-B4E0-4603247A38C5}
+		{CA491A14-A976-4C84-8530-C72974026FCE} = {CA491A14-A976-4C84-8530-C72974026FCE}
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5} = {343E7816-3E2E-4A46-9500-730E5CC7CCB5}
+		{8853A519-4E05-429D-A2A1-911BACE363C6} = {8853A519-4E05-429D-A2A1-911BACE363C6}
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099} = {A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729} = {5040B126-0E99-434A-9F35-E1B5CDCE0729}
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5} = {68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}
+		{4088C233-7226-4098-9711-23D48000C2B8} = {4088C233-7226-4098-9711-23D48000C2B8}
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86} = {AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626} = {89F0CC41-F7A4-46B8-B680-776EA30B3626}
+		{D6247145-847F-4337-877E-E5F2ADAF3D37} = {D6247145-847F-4337-877E-E5F2ADAF3D37}
+		{833F5049-D661-4297-842C-D9C9AC8469C0} = {833F5049-D661-4297-842C-D9C9AC8469C0}
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632} = {30DB9549-4343-4EBC-AC4F-72F98EBD0632}
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851} = {B3D30950-51C0-44A6-84B3-AFE6203E8851}
+		{60070351-33A9-4935-9BA4-8EC021CB47B7} = {60070351-33A9-4935-9BA4-8EC021CB47B7}
+		{E6B41356-895B-419D-93A4-8746C086F7E8} = {E6B41356-895B-419D-93A4-8746C086F7E8}
+		{D6919C57-7503-4F41-914E-4F0A5642D795} = {D6919C57-7503-4F41-914E-4F0A5642D795}
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D} = {752C9059-8C84-4FFD-938A-055E76E6BD2D}
+		{E757415D-952B-41EB-91D2-678ED2A21241} = {E757415D-952B-41EB-91D2-678ED2A21241}
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39} = {2BF11960-6B4A-46CE-92C0-21C30FF1AB39}
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04} = {31D6EE61-177E-4CFB-A8E6-B16015C12E04}
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2} = {A2CF4462-C6E6-441B-ADD4-352E0D0871B2}
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B} = {9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639} = {6505AA65-A3C0-4792-BDEE-0E7BE0425639}
+		{D157B165-F35B-4D6A-B23D-90596B0328FD} = {D157B165-F35B-4D6A-B23D-90596B0328FD}
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2} = {5E6E5E67-1760-4744-8483-478B41F5D3E2}
+		{E1BC4F68-4192-4408-B94D-B161C6133C73} = {E1BC4F68-4192-4408-B94D-B161C6133C73}
+		{73243670-829F-4E0C-B332-EC673749FAD4} = {73243670-829F-4E0C-B332-EC673749FAD4}
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696} = {5BFAEE74-425B-49C9-BC09-BD0B9081E696}
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890} = {DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482} = {54AE077D-560D-4FCC-97BA-D357CCF9A482}
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83} = {45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B} = {D61D8289-38BD-4CC1-B943-A53C2DCD800B}
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9} = {FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}
+		{638AD489-3390-414F-8931-ABBB7CEED92D} = {638AD489-3390-414F-8931-ABBB7CEED92D}
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2} = {DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A} = {2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8} = {79DDA691-0EEA-4658-8372-E6B1C2E77FE8}
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677} = {F5B97493-5840-4D09-88D7-44CB0C4E0677}
+		{F6B76094-CB73-463F-8FAA-794214EC3621} = {F6B76094-CB73-463F-8FAA-794214EC3621}
+		{D28E7F99-B199-4953-BB56-4F6574763A52} = {D28E7F99-B199-4953-BB56-4F6574763A52}
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A} = {3E621DA0-AD72-46DC-813A-78541ACBE00A}
+		{0D8D80A1-E274-401D-BDED-928A315700D7} = {0D8D80A1-E274-401D-BDED-928A315700D7}
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E} = {A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2} = {9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B} = {809928AD-2ACC-4F25-80D0-3ABCD962607B}
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370} = {F434C3B0-1C9A-4A00-94EF-B8124021D370}
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251} = {FE1AD7B0-8779-46A9-9404-5E9F70B5F251}
+		{CEF377B2-DE01-4858-B831-4B698952B5C8} = {CEF377B2-DE01-4858-B831-4B698952B5C8}
+		{D127B5B4-F60E-4436-B663-45404E95BB97} = {D127B5B4-F60E-4436-B663-45404E95BB97}
+		{357100B6-0650-44F2-9BB6-F3337249D714} = {357100B6-0650-44F2-9BB6-F3337249D714}
+		{758FCEB9-B595-4827-8B74-44B96E668B5E} = {758FCEB9-B595-4827-8B74-44B96E668B5E}
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4} = {837D6ABA-2C74-4163-9D85-4E78D52883E4}
+		{0B6872BE-9637-45B8-8404-287173BF8B35} = {0B6872BE-9637-45B8-8404-287173BF8B35}
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0} = {F91940C3-0684-4512-B3C1-D68ECEA7D4E0}
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F} = {59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}
+		{2C3203CA-606A-4748-9859-06D6545DD166} = {2C3203CA-606A-4748-9859-06D6545DD166}
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A} = {39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42} = {F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196} = {4F0011CD-9DDB-43C2-8555-5928F3BE8196}
+		{88595ECD-557E-4B04-A510-76D670899876} = {88595ECD-557E-4B04-A510-76D670899876}
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99} = {E16F11CF-443B-4A4E-ADC4-7B224867BA99}
+		{1983BDD5-FB4A-4400-9D69-CD8156541622} = {1983BDD5-FB4A-4400-9D69-CD8156541622}
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97} = {46B6D3D5-1320-42E8-97EB-E91CF0C47B97}
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7} = {FC4360D9-B78C-4CD3-82EE-67877E091EC7}
+		{34D1EFDE-5F45-462F-A610-F925822F10BE} = {34D1EFDE-5F45-462F-A610-F925822F10BE}
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9} = {818797E2-6CDC-41D4-8BCF-03A670BA33F9}
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A} = {30A04CE4-0907-4357-A8CB-BAF5D7FB463A}
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D} = {C26BFEEE-6078-400E-AD95-CC25B351BA4D}
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7} = {7A3F18F0-B375-4A08-B944-AC7148793AE7}
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722} = {1DD3D1FA-62BB-47AD-B04C-853F278B8722}
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61} = {858F4EFC-1C02-402A-ADEE-4E40DEE20B61}
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3} = {A995D9FC-DBB6-4178-A067-21FBA8364CD3}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "UsermodeLibrary", "Usermode\UsermodeLibrary\UsermodeLibrary.vcxproj", "{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}"
+	ProjectSection(ProjectDependencies) = postProject
+		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Utils", "Utils", "{2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RunTests", "Utils\RunTests\RunTests.vcxproj", "{291C9D17-6BA7-404F-8664-C60F38E061C7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104} = {79A21DCA-19AF-4F8E-9B83-62D7CF504104}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RemoveAllTests", "Utils\RemoveAllTests\RemoveAllTests.vcxproj", "{6CAFB378-993C-4078-B545-9D8636F383DC}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Tests", "Tests", "{B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Args", "Usermode\Args\Args.vcxproj", "{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadJumpKernel", "Usermode\BadJumpKernel\BadJumpKernel.vcxproj", "{638AD489-3390-414F-8931-ABBB7CEED92D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadJumpNull", "Usermode\BadJumpNull\BadJumpNull.vcxproj", "{F092D608-D31B-4E30-9650-11058BD45093}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadReadKernel", "Usermode\BadReadKernel\BadReadKernel.vcxproj", "{D127B5B4-F60E-4436-B663-45404E95BB97}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadReadNull", "Usermode\BadReadNull\BadReadNull.vcxproj", "{4F0011CD-9DDB-43C2-8555-5928F3BE8196}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadWriteKernel", "Usermode\BadWriteKernel\BadWriteKernel.vcxproj", "{6505AA65-A3C0-4792-BDEE-0E7BE0425639}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadWriteNull", "Usermode\BadWriteNull\BadWriteNull.vcxproj", "{F6B76094-CB73-463F-8FAA-794214EC3621}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCloseBad", "Usermode\FileCloseBad\FileCloseBad.vcxproj", "{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCloseNormal", "Usermode\FileCloseNormal\FileCloseNormal.vcxproj", "{88595ECD-557E-4B04-A510-76D670899876}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCloseStdout", "Usermode\FileCloseStdout\FileCloseStdout.vcxproj", "{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCloseTwice", "Usermode\FileCloseTwice\FileCloseTwice.vcxproj", "{D28E7F99-B199-4953-BB56-4F6574763A52}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateExistent", "Usermode\FileCreateExistent\FileCreateExistent.vcxproj", "{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateBadPointer", "Usermode\FileCreateBadPointer\FileCreateBadPointer.vcxproj", "{818797E2-6CDC-41D4-8BCF-03A670BA33F9}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateEmptyPath", "Usermode\FileCreateEmptyPath\FileCreateEmptyPath.vcxproj", "{5E6E5E67-1760-4744-8483-478B41F5D3E2}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateNormal", "Usermode\FileCreateNormal\FileCreateNormal.vcxproj", "{5BFAEE74-425B-49C9-BC09-BD0B9081E696}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateNull", "Usermode\FileCreateNull\FileCreateNull.vcxproj", "{D6247145-847F-4337-877E-E5F2ADAF3D37}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateTwice", "Usermode\FileCreateTwice\FileCreateTwice.vcxproj", "{E16F11CF-443B-4A4E-ADC4-7B224867BA99}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileCreateMissing", "Usermode\FileCreateMissing\FileCreateMissing.vcxproj", "{758FCEB9-B595-4827-8B74-44B96E668B5E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileReadNormal", "Usermode\FileReadNormal\FileReadNormal.vcxproj", "{7A6D1E11-2D94-4154-8147-153427DA2E98}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileReadStdout", "Usermode\FileReadStdout\FileReadStdout.vcxproj", "{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileReadBadHandle", "Usermode\FileReadBadHandle\FileReadBadHandle.vcxproj", "{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileReadBadPointer", "Usermode\FileReadBadPointer\FileReadBadPointer.vcxproj", "{30DB9549-4343-4EBC-AC4F-72F98EBD0632}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileReadKernel", "Usermode\FileReadKernel\FileReadKernel.vcxproj", "{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessWaitBadHandle", "Usermode\ProcessWaitBadHandle\ProcessWaitBadHandle.vcxproj", "{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessWaitNormal", "Usermode\ProcessWaitNormal\ProcessWaitNormal.vcxproj", "{4088C233-7226-4098-9711-23D48000C2B8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessWaitTerminated", "Usermode\ProcessWaitTerminated\ProcessWaitTerminated.vcxproj", "{F434C3B0-1C9A-4A00-94EF-B8124021D370}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCreateOnce", "Usermode\ProcessCreateOnce\ProcessCreateOnce.vcxproj", "{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCreateMultiple", "Usermode\ProcessCreateMultiple\ProcessCreateMultiple.vcxproj", "{60070351-33A9-4935-9BA4-8EC021CB47B7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCreateWithArguments", "Usermode\ProcessCreateWithArguments\ProcessCreateWithArguments.vcxproj", "{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCreateMissingFile", "Usermode\ProcessCreateMissingFile\ProcessCreateMissingFile.vcxproj", "{34D1EFDE-5F45-462F-A610-F925822F10BE}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCreateBadPointer", "Usermode\ProcessCreateBadPointer\ProcessCreateBadPointer.vcxproj", "{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessGetPid", "Usermode\ProcessGetPid\ProcessGetPid.vcxproj", "{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessExit", "Usermode\ProcessExit\ProcessExit.vcxproj", "{A995D9FC-DBB6-4178-A067-21FBA8364CD3}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessWaitClosedHandle", "Usermode\ProcessWaitClosedHandle\ProcessWaitClosedHandle.vcxproj", "{809928AD-2ACC-4F25-80D0-3ABCD962607B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCloseNormal", "Usermode\ProcessCloseNormal\ProcessCloseNormal.vcxproj", "{61E34105-4020-4582-9F7C-E86DB0BDD7BD}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCloseTwice", "Usermode\ProcessCloseTwice\ProcessCloseTwice.vcxproj", "{CEF377B2-DE01-4858-B831-4B698952B5C8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCloseFile", "Usermode\ProcessCloseFile\ProcessCloseFile.vcxproj", "{0D8D80A1-E274-401D-BDED-928A315700D7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessCloseParentHandle", "Usermode\ProcessCloseParentHandle\ProcessCloseParentHandle.vcxproj", "{54AE077D-560D-4FCC-97BA-D357CCF9A482}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FileReadZero", "Usermode\FileReadZero\FileReadZero.vcxproj", "{357100B6-0650-44F2-9BB6-F3337249D714}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Dummy", "Usermode\Dummy\Dummy.vcxproj", "{5040B126-0E99-434A-9F35-E1B5CDCE0729}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DummyFail", "Usermode\DummyFail\DummyFail.vcxproj", "{1DD3D1FA-62BB-47AD-B04C-853F278B8722}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Arguments", "Arguments", "{7CC293C5-7E90-40D8-82EF-9A1C1FD7DF7B}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "bad-actions", "bad-actions", "{C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "file-syscalls", "file-syscalls", "{7715E14D-A26C-41FB-B9DE-B4484AE9439E}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "process-syscalls", "process-syscalls", "{3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadReadMsr", "Usermode\BadReadMsr\BadReadMsr.vcxproj", "{752C9059-8C84-4FFD-938A-055E76E6BD2D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadWriteMsr", "Usermode\BadWriteMsr\BadWriteMsr.vcxproj", "{CA491A14-A976-4C84-8530-C72974026FCE}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadReadIoPort", "Usermode\BadReadIoPort\BadReadIoPort.vcxproj", "{F5B97493-5840-4D09-88D7-44CB0C4E0677}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadWriteIoPort", "Usermode\BadWriteIoPort\BadWriteIoPort.vcxproj", "{837D6ABA-2C74-4163-9D85-4E78D52883E4}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadReadNonCanonical", "Usermode\BadReadNonCanonical\BadReadNonCanonical.vcxproj", "{D157B165-F35B-4D6A-B23D-90596B0328FD}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadWriteNonCanonical", "Usermode\BadWriteNonCanonical\BadWriteNonCanonical.vcxproj", "{E757415D-952B-41EB-91D2-678ED2A21241}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BadJumpNoncanonical", "Usermode\BadJumpNoncanonical\BadJumpNoncanonical.vcxproj", "{8853A519-4E05-429D-A2A1-911BACE363C6}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "thread-syscalls", "thread-syscalls", "{BBA99A17-8590-4DA9-B63F-675DADCF2504}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadCloseTwice", "Usermode\ThreadCloseTwice\ThreadCloseTwice.vcxproj", "{89F0CC41-F7A4-46B8-B680-776EA30B3626}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadCreateBadPointer", "Usermode\ThreadCreateBadPointer\ThreadCreateBadPointer.vcxproj", "{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadCreateMultiple", "Usermode\ThreadCreateMultiple\ThreadCreateMultiple.vcxproj", "{3E621DA0-AD72-46DC-813A-78541ACBE00A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadCreateOnce", "Usermode\ThreadCreateOnce\ThreadCreateOnce.vcxproj", "{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadCreateWithArguments", "Usermode\ThreadCreateWithArguments\ThreadCreateWithArguments.vcxproj", "{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadExit", "Usermode\ThreadExit\ThreadExit.vcxproj", "{1983BDD5-FB4A-4400-9D69-CD8156541622}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadGetTid", "Usermode\ThreadGetTid\ThreadGetTid.vcxproj", "{B3D30950-51C0-44A6-84B3-AFE6203E8851}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadWaitBadHandle", "Usermode\ThreadWaitBadHandle\ThreadWaitBadHandle.vcxproj", "{31D6EE61-177E-4CFB-A8E6-B16015C12E04}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadWaitClosedHandle", "Usermode\ThreadWaitClosedHandle\ThreadWaitClosedHandle.vcxproj", "{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadWaitNormal", "Usermode\ThreadWaitNormal\ThreadWaitNormal.vcxproj", "{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ThreadWaitTerminated", "Usermode\ThreadWaitTerminated\ThreadWaitTerminated.vcxproj", "{343E7816-3E2E-4A46-9500-730E5CC7CCB5}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLib", "CommonLib\CommonLib.vcxproj", "{CA44C37A-1730-447F-8975-3DF40D559310}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapFS", "SwapFS\SwapFS.vcxproj", "{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "syscalls", "syscalls", "{BFB23853-6940-4444-89C7-5364AD6AD41C}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Userprog", "Userprog", "{6E6A08BF-A678-4239-8310-48844D3AFB56}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Virtual Memory", "Virtual Memory", "{A08E6F21-0543-4984-8E84-A80E6C11A582}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "process-quota", "process-quota", "{699EC88B-CEE0-40E4-9F98-1409E0FCE305}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "swap", "swap", "{AC31B304-896F-4AA6-BDDC-548E89A4E90E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocNormal", "Usermode\VirtualAllocNormal\VirtualAllocNormal.vcxproj", "{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocAccessFail", "Usermode\VirtualAllocAccessFail\VirtualAllocAccessFail.vcxproj", "{E1BC4F68-4192-4408-B94D-B161C6133C73}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocHugeLazy", "Usermode\VirtualAllocHugeLazy\VirtualAllocHugeLazy.vcxproj", "{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocHugeEager", "Usermode\VirtualAllocHugeEager\VirtualAllocHugeEager.vcxproj", "{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocZeros", "Usermode\VirtualAllocZeros\VirtualAllocZeros.vcxproj", "{C26BFEEE-6078-400E-AD95-CC25B351BA4D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualAllocWriteExec", "Usermode\VirtualAllocWriteExec\VirtualAllocWriteExec.vcxproj", "{D6919C57-7503-4F41-914E-4F0A5642D795}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualFreeInvalid", "Usermode\VirtualFreeInvalid\VirtualFreeInvalid.vcxproj", "{833F5049-D661-4297-842C-D9C9AC8469C0}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualFreeMore", "Usermode\VirtualFreeMore\VirtualFreeMore.vcxproj", "{E6B41356-895B-419D-93A4-8746C086F7E8}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "VirtualSharedNormal", "Usermode\VirtualSharedNormal\VirtualSharedNormal.vcxproj", "{0B6872BE-9637-45B8-8404-287173BF8B35}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessQuotaJustRight", "Usermode\ProcessQuotaJustRight\ProcessQuotaJustRight.vcxproj", "{73243670-829F-4E0C-B332-EC673749FAD4}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessQuotaMore", "Usermode\ProcessQuotaMore\ProcessQuotaMore.vcxproj", "{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ProcessQuotaGood", "Usermode\ProcessQuotaGood\ProcessQuotaGood.vcxproj", "{2C3203CA-606A-4748-9859-06D6545DD166}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapZeros", "Usermode\SwapZeros\SwapZeros.vcxproj", "{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapZerosWritten", "Usermode\SwapZerosWritten\SwapZerosWritten.vcxproj", "{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapLinear", "Usermode\SwapLinear\SwapLinear.vcxproj", "{D61D8289-38BD-4CC1-B943-A53C2DCD800B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapMultipleShared", "Usermode\SwapMultipleShared\SwapMultipleShared.vcxproj", "{FC4360D9-B78C-4CD3-82EE-67877E091EC7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLibUnitTests", "CommonLibUnitTests\CommonLibUnitTests.vcxproj", "{098EB03E-8151-46DB-9052-5136D9BC14EA}"
+	ProjectSection(ProjectDependencies) = postProject
+		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StackGrowthRecursiveFunction", "Usermode\StackGrowthRecursiveFunction\StackGrowthRecursiveFunction.vcxproj", "{7A3F18F0-B375-4A08-B944-AC7148793AE7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "stack-growth", "stack-growth", "{159880E4-3D75-48CB-B113-A2D217CE423C}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StackGrowthVariables", "Usermode\StackGrowthVariables\StackGrowthVariables.vcxproj", "{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {0866C84E-30D1-441A-A1EF-3FCAF0A1D319}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		CommonLibTests|x64 = CommonLibTests|x64
+		Threads|x64 = Threads|x64
+		Userprog|x64 = Userprog|x64
+		VirtualMemory|x64 = VirtualMemory|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.Build.0 = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.Build.0 = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.VirtualMemory|x64.Build.0 = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.Build.0 = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.Build.0 = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.VirtualMemory|x64.Build.0 = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.Build.0 = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.Build.0 = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.VirtualMemory|x64.Build.0 = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.Build.0 = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.Build.0 = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.VirtualMemory|x64.Build.0 = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.Build.0 = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.Build.0 = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.VirtualMemory|x64.Build.0 = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.Build.0 = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.Build.0 = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.VirtualMemory|x64.Build.0 = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.Build.0 = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.Build.0 = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.VirtualMemory|x64.Build.0 = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.Build.0 = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.Build.0 = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.VirtualMemory|x64.Build.0 = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.Build.0 = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.Build.0 = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.Build.0 = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.Build.0 = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.VirtualMemory|x64.Build.0 = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Threads|x64.ActiveCfg = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Threads|x64.Build.0 = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Userprog|x64.ActiveCfg = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.Userprog|x64.Build.0 = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5}.VirtualMemory|x64.Build.0 = Debug|x64
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.Threads|x64.ActiveCfg = Debug|x64
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.Userprog|x64.ActiveCfg = Debug|x64
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.Userprog|x64.Build.0 = Debug|x64
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}.VirtualMemory|x64.Build.0 = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Threads|x64.ActiveCfg = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Threads|x64.Build.0 = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Userprog|x64.ActiveCfg = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.Userprog|x64.Build.0 = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}.VirtualMemory|x64.Build.0 = Debug|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.CommonLibTests|x64.ActiveCfg = Userprog|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Threads|x64.ActiveCfg = Threads|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Userprog|x64.ActiveCfg = Userprog|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.VirtualMemory|x64.ActiveCfg = VirtualMemory|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.Threads|x64.ActiveCfg = Debug|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.Userprog|x64.ActiveCfg = Debug|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Threads|x64.ActiveCfg = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Threads|x64.Build.0 = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Userprog|x64.ActiveCfg = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.Userprog|x64.Build.0 = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099}.VirtualMemory|x64.Build.0 = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.Threads|x64.ActiveCfg = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.Threads|x64.Build.0 = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.Userprog|x64.ActiveCfg = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.Userprog|x64.Build.0 = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{638AD489-3390-414F-8931-ABBB7CEED92D}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.Threads|x64.ActiveCfg = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.Threads|x64.Build.0 = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.Userprog|x64.ActiveCfg = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.Userprog|x64.Build.0 = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F092D608-D31B-4E30-9650-11058BD45093}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.Threads|x64.ActiveCfg = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.Threads|x64.Build.0 = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.Userprog|x64.ActiveCfg = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.Userprog|x64.Build.0 = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D127B5B4-F60E-4436-B663-45404E95BB97}.VirtualMemory|x64.Build.0 = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Threads|x64.ActiveCfg = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Threads|x64.Build.0 = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Userprog|x64.ActiveCfg = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.Userprog|x64.Build.0 = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196}.VirtualMemory|x64.Build.0 = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Threads|x64.ActiveCfg = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Threads|x64.Build.0 = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Userprog|x64.ActiveCfg = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.Userprog|x64.Build.0 = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.Threads|x64.ActiveCfg = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.Threads|x64.Build.0 = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.Userprog|x64.ActiveCfg = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.Userprog|x64.Build.0 = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F6B76094-CB73-463F-8FAA-794214EC3621}.VirtualMemory|x64.Build.0 = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Threads|x64.ActiveCfg = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Threads|x64.Build.0 = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Userprog|x64.ActiveCfg = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.Userprog|x64.Build.0 = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4}.VirtualMemory|x64.Build.0 = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.Threads|x64.ActiveCfg = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.Threads|x64.Build.0 = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.Userprog|x64.ActiveCfg = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.Userprog|x64.Build.0 = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{88595ECD-557E-4B04-A510-76D670899876}.VirtualMemory|x64.Build.0 = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Threads|x64.ActiveCfg = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Threads|x64.Build.0 = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Userprog|x64.ActiveCfg = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.Userprog|x64.Build.0 = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.Threads|x64.ActiveCfg = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.Threads|x64.Build.0 = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.Userprog|x64.ActiveCfg = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.Userprog|x64.Build.0 = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D28E7F99-B199-4953-BB56-4F6574763A52}.VirtualMemory|x64.Build.0 = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Threads|x64.ActiveCfg = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Threads|x64.Build.0 = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Userprog|x64.ActiveCfg = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.Userprog|x64.Build.0 = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B}.VirtualMemory|x64.Build.0 = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Threads|x64.ActiveCfg = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Threads|x64.Build.0 = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Userprog|x64.ActiveCfg = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.Userprog|x64.Build.0 = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9}.VirtualMemory|x64.Build.0 = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Threads|x64.ActiveCfg = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Threads|x64.Build.0 = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Userprog|x64.ActiveCfg = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.Userprog|x64.Build.0 = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2}.VirtualMemory|x64.Build.0 = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Threads|x64.ActiveCfg = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Threads|x64.Build.0 = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Userprog|x64.ActiveCfg = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.Userprog|x64.Build.0 = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Threads|x64.ActiveCfg = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Threads|x64.Build.0 = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Userprog|x64.ActiveCfg = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.Userprog|x64.Build.0 = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D6247145-847F-4337-877E-E5F2ADAF3D37}.VirtualMemory|x64.Build.0 = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Threads|x64.ActiveCfg = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Threads|x64.Build.0 = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Userprog|x64.ActiveCfg = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.Userprog|x64.Build.0 = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99}.VirtualMemory|x64.Build.0 = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Threads|x64.ActiveCfg = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Threads|x64.Build.0 = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Userprog|x64.ActiveCfg = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.Userprog|x64.Build.0 = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{758FCEB9-B595-4827-8B74-44B96E668B5E}.VirtualMemory|x64.Build.0 = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Threads|x64.ActiveCfg = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Threads|x64.Build.0 = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Userprog|x64.ActiveCfg = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.Userprog|x64.Build.0 = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{7A6D1E11-2D94-4154-8147-153427DA2E98}.VirtualMemory|x64.Build.0 = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Threads|x64.ActiveCfg = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Threads|x64.Build.0 = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Userprog|x64.ActiveCfg = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.Userprog|x64.Build.0 = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8}.VirtualMemory|x64.Build.0 = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Threads|x64.ActiveCfg = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Threads|x64.Build.0 = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Userprog|x64.ActiveCfg = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.Userprog|x64.Build.0 = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2}.VirtualMemory|x64.Build.0 = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Threads|x64.ActiveCfg = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Threads|x64.Build.0 = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Userprog|x64.ActiveCfg = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.Userprog|x64.Build.0 = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632}.VirtualMemory|x64.Build.0 = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Threads|x64.ActiveCfg = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Threads|x64.Build.0 = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Userprog|x64.ActiveCfg = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.Userprog|x64.Build.0 = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2}.VirtualMemory|x64.Build.0 = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Threads|x64.ActiveCfg = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Threads|x64.Build.0 = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Userprog|x64.ActiveCfg = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.Userprog|x64.Build.0 = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9}.VirtualMemory|x64.Build.0 = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.Threads|x64.ActiveCfg = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.Threads|x64.Build.0 = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.Userprog|x64.ActiveCfg = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.Userprog|x64.Build.0 = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{4088C233-7226-4098-9711-23D48000C2B8}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Threads|x64.ActiveCfg = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Threads|x64.Build.0 = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Userprog|x64.ActiveCfg = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.Userprog|x64.Build.0 = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370}.VirtualMemory|x64.Build.0 = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Threads|x64.ActiveCfg = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Threads|x64.Build.0 = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Userprog|x64.ActiveCfg = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.Userprog|x64.Build.0 = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E}.VirtualMemory|x64.Build.0 = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Threads|x64.ActiveCfg = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Threads|x64.Build.0 = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Userprog|x64.ActiveCfg = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.Userprog|x64.Build.0 = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{60070351-33A9-4935-9BA4-8EC021CB47B7}.VirtualMemory|x64.Build.0 = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Threads|x64.ActiveCfg = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Threads|x64.Build.0 = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Userprog|x64.ActiveCfg = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.Userprog|x64.Build.0 = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97}.VirtualMemory|x64.Build.0 = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Threads|x64.ActiveCfg = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Threads|x64.Build.0 = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Userprog|x64.ActiveCfg = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.Userprog|x64.Build.0 = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{34D1EFDE-5F45-462F-A610-F925822F10BE}.VirtualMemory|x64.Build.0 = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Threads|x64.ActiveCfg = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Threads|x64.Build.0 = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Userprog|x64.ActiveCfg = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.Userprog|x64.Build.0 = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61}.VirtualMemory|x64.Build.0 = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Threads|x64.ActiveCfg = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Threads|x64.Build.0 = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Userprog|x64.ActiveCfg = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.Userprog|x64.Build.0 = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83}.VirtualMemory|x64.Build.0 = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Threads|x64.ActiveCfg = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Threads|x64.Build.0 = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Userprog|x64.ActiveCfg = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.Userprog|x64.Build.0 = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3}.VirtualMemory|x64.Build.0 = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Threads|x64.ActiveCfg = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Threads|x64.Build.0 = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Userprog|x64.ActiveCfg = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.Userprog|x64.Build.0 = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B}.VirtualMemory|x64.Build.0 = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Threads|x64.ActiveCfg = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Threads|x64.Build.0 = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Userprog|x64.ActiveCfg = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.Userprog|x64.Build.0 = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD}.VirtualMemory|x64.Build.0 = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Threads|x64.ActiveCfg = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Threads|x64.Build.0 = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Userprog|x64.ActiveCfg = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.Userprog|x64.Build.0 = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{CEF377B2-DE01-4858-B831-4B698952B5C8}.VirtualMemory|x64.Build.0 = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.Threads|x64.ActiveCfg = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.Threads|x64.Build.0 = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.Userprog|x64.ActiveCfg = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.Userprog|x64.Build.0 = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{0D8D80A1-E274-401D-BDED-928A315700D7}.VirtualMemory|x64.Build.0 = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Threads|x64.ActiveCfg = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Threads|x64.Build.0 = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Userprog|x64.ActiveCfg = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.Userprog|x64.Build.0 = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482}.VirtualMemory|x64.Build.0 = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.Threads|x64.ActiveCfg = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.Threads|x64.Build.0 = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.Userprog|x64.ActiveCfg = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.Userprog|x64.Build.0 = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{357100B6-0650-44F2-9BB6-F3337249D714}.VirtualMemory|x64.Build.0 = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Threads|x64.ActiveCfg = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Threads|x64.Build.0 = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Userprog|x64.ActiveCfg = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.Userprog|x64.Build.0 = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729}.VirtualMemory|x64.Build.0 = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Threads|x64.ActiveCfg = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Threads|x64.Build.0 = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Userprog|x64.ActiveCfg = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.Userprog|x64.Build.0 = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722}.VirtualMemory|x64.Build.0 = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Threads|x64.ActiveCfg = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Threads|x64.Build.0 = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Userprog|x64.ActiveCfg = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.Userprog|x64.Build.0 = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D}.VirtualMemory|x64.Build.0 = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.Threads|x64.ActiveCfg = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.Threads|x64.Build.0 = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.Userprog|x64.ActiveCfg = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.Userprog|x64.Build.0 = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{CA491A14-A976-4C84-8530-C72974026FCE}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Threads|x64.ActiveCfg = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Threads|x64.Build.0 = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Userprog|x64.ActiveCfg = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.Userprog|x64.Build.0 = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677}.VirtualMemory|x64.Build.0 = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Threads|x64.ActiveCfg = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Threads|x64.Build.0 = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Userprog|x64.ActiveCfg = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.Userprog|x64.Build.0 = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Threads|x64.ActiveCfg = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Threads|x64.Build.0 = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Userprog|x64.ActiveCfg = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.Userprog|x64.Build.0 = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D157B165-F35B-4D6A-B23D-90596B0328FD}.VirtualMemory|x64.Build.0 = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.Threads|x64.ActiveCfg = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.Threads|x64.Build.0 = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.Userprog|x64.ActiveCfg = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.Userprog|x64.Build.0 = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{E757415D-952B-41EB-91D2-678ED2A21241}.VirtualMemory|x64.Build.0 = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.Threads|x64.ActiveCfg = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.Threads|x64.Build.0 = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.Userprog|x64.ActiveCfg = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.Userprog|x64.Build.0 = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{8853A519-4E05-429D-A2A1-911BACE363C6}.VirtualMemory|x64.Build.0 = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Threads|x64.ActiveCfg = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Threads|x64.Build.0 = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Userprog|x64.ActiveCfg = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.Userprog|x64.Build.0 = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626}.VirtualMemory|x64.Build.0 = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Threads|x64.ActiveCfg = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Threads|x64.Build.0 = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Userprog|x64.ActiveCfg = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.Userprog|x64.Build.0 = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251}.VirtualMemory|x64.Build.0 = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Threads|x64.ActiveCfg = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Threads|x64.Build.0 = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Userprog|x64.ActiveCfg = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.Userprog|x64.Build.0 = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A}.VirtualMemory|x64.Build.0 = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Threads|x64.ActiveCfg = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Threads|x64.Build.0 = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Userprog|x64.ActiveCfg = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.Userprog|x64.Build.0 = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890}.VirtualMemory|x64.Build.0 = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Threads|x64.ActiveCfg = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Threads|x64.Build.0 = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Userprog|x64.ActiveCfg = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.Userprog|x64.Build.0 = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A}.VirtualMemory|x64.Build.0 = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Threads|x64.ActiveCfg = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Threads|x64.Build.0 = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Userprog|x64.ActiveCfg = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.Userprog|x64.Build.0 = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{1983BDD5-FB4A-4400-9D69-CD8156541622}.VirtualMemory|x64.Build.0 = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Threads|x64.ActiveCfg = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Threads|x64.Build.0 = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Userprog|x64.ActiveCfg = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.Userprog|x64.Build.0 = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851}.VirtualMemory|x64.Build.0 = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Threads|x64.ActiveCfg = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Threads|x64.Build.0 = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Userprog|x64.ActiveCfg = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.Userprog|x64.Build.0 = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04}.VirtualMemory|x64.Build.0 = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Threads|x64.ActiveCfg = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Threads|x64.Build.0 = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Userprog|x64.ActiveCfg = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.Userprog|x64.Build.0 = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86}.VirtualMemory|x64.Build.0 = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Threads|x64.ActiveCfg = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Threads|x64.Build.0 = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Userprog|x64.ActiveCfg = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.Userprog|x64.Build.0 = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5}.VirtualMemory|x64.Build.0 = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Threads|x64.ActiveCfg = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Threads|x64.Build.0 = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Userprog|x64.ActiveCfg = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.Userprog|x64.Build.0 = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5}.VirtualMemory|x64.Build.0 = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.ActiveCfg = DebugNonNative|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.Build.0 = DebugNonNative|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.ActiveCfg = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.Build.0 = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.ActiveCfg = DebugNoLocks|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.Build.0 = DebugNoLocks|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.VirtualMemory|x64.ActiveCfg = DebugNoLocks|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.VirtualMemory|x64.Build.0 = DebugNoLocks|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.Build.0 = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.Build.0 = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.VirtualMemory|x64.Build.0 = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Threads|x64.ActiveCfg = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Threads|x64.Build.0 = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Userprog|x64.ActiveCfg = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.Userprog|x64.Build.0 = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A}.VirtualMemory|x64.Build.0 = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Threads|x64.ActiveCfg = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Threads|x64.Build.0 = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Userprog|x64.ActiveCfg = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.Userprog|x64.Build.0 = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{E1BC4F68-4192-4408-B94D-B161C6133C73}.VirtualMemory|x64.Build.0 = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Threads|x64.ActiveCfg = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Threads|x64.Build.0 = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Userprog|x64.ActiveCfg = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.Userprog|x64.Build.0 = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Threads|x64.ActiveCfg = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Threads|x64.Build.0 = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Userprog|x64.ActiveCfg = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.Userprog|x64.Build.0 = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0}.VirtualMemory|x64.Build.0 = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Threads|x64.ActiveCfg = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Threads|x64.Build.0 = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Userprog|x64.ActiveCfg = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.Userprog|x64.Build.0 = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.Threads|x64.ActiveCfg = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.Threads|x64.Build.0 = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.Userprog|x64.ActiveCfg = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.Userprog|x64.Build.0 = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D6919C57-7503-4F41-914E-4F0A5642D795}.VirtualMemory|x64.Build.0 = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.Threads|x64.ActiveCfg = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.Threads|x64.Build.0 = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.Userprog|x64.ActiveCfg = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.Userprog|x64.Build.0 = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{833F5049-D661-4297-842C-D9C9AC8469C0}.VirtualMemory|x64.Build.0 = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.Threads|x64.ActiveCfg = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.Threads|x64.Build.0 = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.Userprog|x64.ActiveCfg = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.Userprog|x64.Build.0 = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{E6B41356-895B-419D-93A4-8746C086F7E8}.VirtualMemory|x64.Build.0 = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.Threads|x64.ActiveCfg = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.Threads|x64.Build.0 = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.Userprog|x64.ActiveCfg = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.Userprog|x64.Build.0 = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{0B6872BE-9637-45B8-8404-287173BF8B35}.VirtualMemory|x64.Build.0 = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.Threads|x64.ActiveCfg = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.Threads|x64.Build.0 = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.Userprog|x64.ActiveCfg = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.Userprog|x64.Build.0 = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{73243670-829F-4E0C-B332-EC673749FAD4}.VirtualMemory|x64.Build.0 = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Threads|x64.ActiveCfg = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Threads|x64.Build.0 = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Userprog|x64.ActiveCfg = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.Userprog|x64.Build.0 = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A}.VirtualMemory|x64.Build.0 = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.Threads|x64.ActiveCfg = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.Threads|x64.Build.0 = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.Userprog|x64.ActiveCfg = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.Userprog|x64.Build.0 = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{2C3203CA-606A-4748-9859-06D6545DD166}.VirtualMemory|x64.Build.0 = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Threads|x64.ActiveCfg = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Threads|x64.Build.0 = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Userprog|x64.ActiveCfg = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.Userprog|x64.Build.0 = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39}.VirtualMemory|x64.Build.0 = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Threads|x64.ActiveCfg = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Threads|x64.Build.0 = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Userprog|x64.ActiveCfg = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.Userprog|x64.Build.0 = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Threads|x64.ActiveCfg = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Threads|x64.Build.0 = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Userprog|x64.ActiveCfg = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.Userprog|x64.Build.0 = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B}.VirtualMemory|x64.Build.0 = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Threads|x64.ActiveCfg = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Threads|x64.Build.0 = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Userprog|x64.ActiveCfg = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.Userprog|x64.Build.0 = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7}.VirtualMemory|x64.Build.0 = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.Build.0 = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Threads|x64.ActiveCfg = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Userprog|x64.ActiveCfg = Release|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.VirtualMemory|x64.ActiveCfg = Release|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.CommonLibTests|x64.Build.0 = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Threads|x64.ActiveCfg = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Threads|x64.Build.0 = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Userprog|x64.ActiveCfg = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.Userprog|x64.Build.0 = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7}.VirtualMemory|x64.Build.0 = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.CommonLibTests|x64.Build.0 = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Threads|x64.ActiveCfg = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Threads|x64.Build.0 = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Userprog|x64.ActiveCfg = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.Userprog|x64.Build.0 = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.VirtualMemory|x64.ActiveCfg = Debug|x64
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9}.VirtualMemory|x64.Build.0 = Debug|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D} = {2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A} = {0B471868-BE09-4F73-996F-2EAFFDF591CE}
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608} = {C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}
+		{9412F640-A271-4661-B437-5932E9B95C26} = {C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F} = {C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
+		{7B55EACA-2B29-423D-8D6C-C9986E3864AA} = {3E0FB3C6-F876-44FD-8DF7-1D3F1AFA002C}
+		{BBA96504-05A4-41DC-9312-AF786B4B9281} = {3E0FB3C6-F876-44FD-8DF7-1D3F1AFA002C}
+		{E5ABDC11-649C-430A-B4E0-4603247A38C5} = {7B55EACA-2B29-423D-8D6C-C9986E3864AA}
+		{42D8C78E-FCAD-4452-8098-BC8C2DFD562E} = {BBA96504-05A4-41DC-9312-AF786B4B9281}
+		{0866C84E-30D1-441A-A1EF-3FCAF0A1D319} = {BBA96504-05A4-41DC-9312-AF786B4B9281}
+		{291C9D17-6BA7-404F-8664-C60F38E061C7} = {2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}
+		{6CAFB378-993C-4078-B545-9D8636F383DC} = {2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}
+		{B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87} = {7B55EACA-2B29-423D-8D6C-C9986E3864AA}
+		{A7FC9721-01EA-4CD7-8D9E-C1DFE90D0099} = {7CC293C5-7E90-40D8-82EF-9A1C1FD7DF7B}
+		{638AD489-3390-414F-8931-ABBB7CEED92D} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{F092D608-D31B-4E30-9650-11058BD45093} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{D127B5B4-F60E-4436-B663-45404E95BB97} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{4F0011CD-9DDB-43C2-8555-5928F3BE8196} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{6505AA65-A3C0-4792-BDEE-0E7BE0425639} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{F6B76094-CB73-463F-8FAA-794214EC3621} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{A3FBF603-47C5-40BB-92D1-57B0DBE2D4E4} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{88595ECD-557E-4B04-A510-76D670899876} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{59FDE7C8-88BD-4850-9D64-A4FEF7500A3F} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{D28E7F99-B199-4953-BB56-4F6574763A52} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{9A40E264-FE2A-4F5D-A2A1-FA2539F93D0B} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{818797E2-6CDC-41D4-8BCF-03A670BA33F9} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{5E6E5E67-1760-4744-8483-478B41F5D3E2} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{5BFAEE74-425B-49C9-BC09-BD0B9081E696} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{D6247145-847F-4337-877E-E5F2ADAF3D37} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{E16F11CF-443B-4A4E-ADC4-7B224867BA99} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{758FCEB9-B595-4827-8B74-44B96E668B5E} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{7A6D1E11-2D94-4154-8147-153427DA2E98} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{79DDA691-0EEA-4658-8372-E6B1C2E77FE8} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{DD1FFE8A-C00D-496F-8B49-F67984DBE9F2} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{30DB9549-4343-4EBC-AC4F-72F98EBD0632} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{9BD7F8A3-F558-4D72-AA8D-B54A89F04AB2} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{FBA79B89-F2F7-40A7-AA87-87A1D8A367D9} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{4088C233-7226-4098-9711-23D48000C2B8} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{F434C3B0-1C9A-4A00-94EF-B8124021D370} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{A6F6A4A3-A04B-4AAD-8AC8-31BD2D515D9E} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{60070351-33A9-4935-9BA4-8EC021CB47B7} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{46B6D3D5-1320-42E8-97EB-E91CF0C47B97} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{34D1EFDE-5F45-462F-A610-F925822F10BE} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{858F4EFC-1C02-402A-ADEE-4E40DEE20B61} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{45E73486-6F22-4D46-BF4D-A4EFA4A5BE83} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{A995D9FC-DBB6-4178-A067-21FBA8364CD3} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{809928AD-2ACC-4F25-80D0-3ABCD962607B} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{61E34105-4020-4582-9F7C-E86DB0BDD7BD} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{CEF377B2-DE01-4858-B831-4B698952B5C8} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{0D8D80A1-E274-401D-BDED-928A315700D7} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{54AE077D-560D-4FCC-97BA-D357CCF9A482} = {3D7C3BFC-FECB-4812-951C-0B1A9A8D2242}
+		{357100B6-0650-44F2-9BB6-F3337249D714} = {7715E14D-A26C-41FB-B9DE-B4484AE9439E}
+		{5040B126-0E99-434A-9F35-E1B5CDCE0729} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{1DD3D1FA-62BB-47AD-B04C-853F278B8722} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{7CC293C5-7E90-40D8-82EF-9A1C1FD7DF7B} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{7715E14D-A26C-41FB-B9DE-B4484AE9439E} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{3D7C3BFC-FECB-4812-951C-0B1A9A8D2242} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{752C9059-8C84-4FFD-938A-055E76E6BD2D} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{CA491A14-A976-4C84-8530-C72974026FCE} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{F5B97493-5840-4D09-88D7-44CB0C4E0677} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{837D6ABA-2C74-4163-9D85-4E78D52883E4} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{D157B165-F35B-4D6A-B23D-90596B0328FD} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{E757415D-952B-41EB-91D2-678ED2A21241} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{8853A519-4E05-429D-A2A1-911BACE363C6} = {C730B0E5-DBA9-4A96-BDC4-F39087D4A4AF}
+		{BBA99A17-8590-4DA9-B63F-675DADCF2504} = {6E6A08BF-A678-4239-8310-48844D3AFB56}
+		{89F0CC41-F7A4-46B8-B680-776EA30B3626} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{FE1AD7B0-8779-46A9-9404-5E9F70B5F251} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{3E621DA0-AD72-46DC-813A-78541ACBE00A} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{DC6DA37B-B2EB-466D-B0F4-D2BEE6F86890} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{39D761CB-FD1F-4A0A-8BE1-DB1F30A6BA5A} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{1983BDD5-FB4A-4400-9D69-CD8156541622} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{B3D30950-51C0-44A6-84B3-AFE6203E8851} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{31D6EE61-177E-4CFB-A8E6-B16015C12E04} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{AFF37A3E-E5CA-4A99-BDF1-1735C1254D86} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{68F29F2C-EFBD-472B-9B5E-D8FD4EA782C5} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{343E7816-3E2E-4A46-9500-730E5CC7CCB5} = {BBA99A17-8590-4DA9-B63F-675DADCF2504}
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}
+		{BFB23853-6940-4444-89C7-5364AD6AD41C} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
+		{6E6A08BF-A678-4239-8310-48844D3AFB56} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{A08E6F21-0543-4984-8E84-A80E6C11A582} = {B2B8C7EC-B2C0-4D06-BCF7-858A50A4DB87}
+		{699EC88B-CEE0-40E4-9F98-1409E0FCE305} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
+		{AC31B304-896F-4AA6-BDDC-548E89A4E90E} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
+		{2ECD668B-A99F-4C8A-B2FC-1FDBF1B6F25A} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{E1BC4F68-4192-4408-B94D-B161C6133C73} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{A2CF4462-C6E6-441B-ADD4-352E0D0871B2} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{F91940C3-0684-4512-B3C1-D68ECEA7D4E0} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{C26BFEEE-6078-400E-AD95-CC25B351BA4D} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{D6919C57-7503-4F41-914E-4F0A5642D795} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{833F5049-D661-4297-842C-D9C9AC8469C0} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{E6B41356-895B-419D-93A4-8746C086F7E8} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{0B6872BE-9637-45B8-8404-287173BF8B35} = {BFB23853-6940-4444-89C7-5364AD6AD41C}
+		{73243670-829F-4E0C-B332-EC673749FAD4} = {699EC88B-CEE0-40E4-9F98-1409E0FCE305}
+		{30A04CE4-0907-4357-A8CB-BAF5D7FB463A} = {699EC88B-CEE0-40E4-9F98-1409E0FCE305}
+		{2C3203CA-606A-4748-9859-06D6545DD166} = {699EC88B-CEE0-40E4-9F98-1409E0FCE305}
+		{2BF11960-6B4A-46CE-92C0-21C30FF1AB39} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
+		{F50BA1CB-DFB3-4C75-9C21-AAFBF009CA42} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
+		{D61D8289-38BD-4CC1-B943-A53C2DCD800B} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
+		{FC4360D9-B78C-4CD3-82EE-67877E091EC7} = {AC31B304-896F-4AA6-BDDC-548E89A4E90E}
+		{7A3F18F0-B375-4A08-B944-AC7148793AE7} = {159880E4-3D75-48CB-B113-A2D217CE423C}
+		{159880E4-3D75-48CB-B113-A2D217CE423C} = {A08E6F21-0543-4984-8E84-A80E6C11A582}
+		{D4EF4101-8E74-45C4-93B0-1AC3F29399B9} = {159880E4-3D75-48CB-B113-A2D217CE423C}
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {3AE286A9-35D7-4547-86BE-AB7EAF8A3602}
+	EndGlobalSection
+EndGlobal
diff --git a/src_proiect/HAL9000/HAL9000.ruleset b/src_proiect/HAL9000/HAL9000.ruleset
new file mode 100644
index 0000000..8332061
--- /dev/null
+++ b/src_proiect/HAL9000/HAL9000.ruleset
@@ -0,0 +1,370 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<RuleSet Name="Rules for HAL9000" Description="Code analysis rules for HAL9000.vcxproj." ToolsVersion="14.0">
+  <IncludeAll Action="Warning" />
+  <Rules AnalyzerId="Microsoft.Analyzers.ManagedCodeAnalysis" RuleNamespace="Microsoft.Rules.Managed">
+    <Rule Id="CA1000" Action="None" />
+    <Rule Id="CA1001" Action="None" />
+    <Rule Id="CA1002" Action="None" />
+    <Rule Id="CA1003" Action="None" />
+    <Rule Id="CA1004" Action="None" />
+    <Rule Id="CA1005" Action="None" />
+    <Rule Id="CA1006" Action="None" />
+    <Rule Id="CA1007" Action="None" />
+    <Rule Id="CA1008" Action="None" />
+    <Rule Id="CA1009" Action="None" />
+    <Rule Id="CA1010" Action="None" />
+    <Rule Id="CA1011" Action="None" />
+    <Rule Id="CA1012" Action="None" />
+    <Rule Id="CA1013" Action="None" />
+    <Rule Id="CA1014" Action="None" />
+    <Rule Id="CA1016" Action="None" />
+    <Rule Id="CA1017" Action="None" />
+    <Rule Id="CA1018" Action="None" />
+    <Rule Id="CA1019" Action="None" />
+    <Rule Id="CA1020" Action="None" />
+    <Rule Id="CA1021" Action="None" />
+    <Rule Id="CA1023" Action="None" />
+    <Rule Id="CA1024" Action="None" />
+    <Rule Id="CA1025" Action="None" />
+    <Rule Id="CA1026" Action="None" />
+    <Rule Id="CA1027" Action="None" />
+    <Rule Id="CA1028" Action="None" />
+    <Rule Id="CA1030" Action="None" />
+    <Rule Id="CA1031" Action="None" />
+    <Rule Id="CA1032" Action="None" />
+    <Rule Id="CA1033" Action="None" />
+    <Rule Id="CA1034" Action="None" />
+    <Rule Id="CA1035" Action="None" />
+    <Rule Id="CA1036" Action="None" />
+    <Rule Id="CA1038" Action="None" />
+    <Rule Id="CA1039" Action="None" />
+    <Rule Id="CA1040" Action="None" />
+    <Rule Id="CA1041" Action="None" />
+    <Rule Id="CA1043" Action="None" />
+    <Rule Id="CA1044" Action="None" />
+    <Rule Id="CA1045" Action="None" />
+    <Rule Id="CA1046" Action="None" />
+    <Rule Id="CA1047" Action="None" />
+    <Rule Id="CA1048" Action="None" />
+    <Rule Id="CA1049" Action="None" />
+    <Rule Id="CA1050" Action="None" />
+    <Rule Id="CA1051" Action="None" />
+    <Rule Id="CA1052" Action="None" />
+    <Rule Id="CA1053" Action="None" />
+    <Rule Id="CA1054" Action="None" />
+    <Rule Id="CA1055" Action="None" />
+    <Rule Id="CA1056" Action="None" />
+    <Rule Id="CA1057" Action="None" />
+    <Rule Id="CA1058" Action="None" />
+    <Rule Id="CA1059" Action="None" />
+    <Rule Id="CA1060" Action="None" />
+    <Rule Id="CA1061" Action="None" />
+    <Rule Id="CA1062" Action="None" />
+    <Rule Id="CA1063" Action="None" />
+    <Rule Id="CA1064" Action="None" />
+    <Rule Id="CA1065" Action="None" />
+    <Rule Id="CA1300" Action="None" />
+    <Rule Id="CA1301" Action="None" />
+    <Rule Id="CA1302" Action="None" />
+    <Rule Id="CA1303" Action="None" />
+    <Rule Id="CA1304" Action="None" />
+    <Rule Id="CA1305" Action="None" />
+    <Rule Id="CA1306" Action="None" />
+    <Rule Id="CA1307" Action="None" />
+    <Rule Id="CA1308" Action="None" />
+    <Rule Id="CA1309" Action="None" />
+    <Rule Id="CA1400" Action="None" />
+    <Rule Id="CA1401" Action="None" />
+    <Rule Id="CA1402" Action="None" />
+    <Rule Id="CA1403" Action="None" />
+    <Rule Id="CA1404" Action="None" />
+    <Rule Id="CA1405" Action="None" />
+    <Rule Id="CA1406" Action="None" />
+    <Rule Id="CA1407" Action="None" />
+    <Rule Id="CA1408" Action="None" />
+    <Rule Id="CA1409" Action="None" />
+    <Rule Id="CA1410" Action="None" />
+    <Rule Id="CA1411" Action="None" />
+    <Rule Id="CA1412" Action="None" />
+    <Rule Id="CA1413" Action="None" />
+    <Rule Id="CA1414" Action="None" />
+    <Rule Id="CA1415" Action="None" />
+    <Rule Id="CA1500" Action="None" />
+    <Rule Id="CA1501" Action="None" />
+    <Rule Id="CA1502" Action="None" />
+    <Rule Id="CA1504" Action="None" />
+    <Rule Id="CA1505" Action="None" />
+    <Rule Id="CA1506" Action="None" />
+    <Rule Id="CA1600" Action="None" />
+    <Rule Id="CA1601" Action="None" />
+    <Rule Id="CA1700" Action="None" />
+    <Rule Id="CA1701" Action="None" />
+    <Rule Id="CA1702" Action="None" />
+    <Rule Id="CA1703" Action="None" />
+    <Rule Id="CA1704" Action="None" />
+    <Rule Id="CA1707" Action="None" />
+    <Rule Id="CA1708" Action="None" />
+    <Rule Id="CA1709" Action="None" />
+    <Rule Id="CA1710" Action="None" />
+    <Rule Id="CA1711" Action="None" />
+    <Rule Id="CA1712" Action="None" />
+    <Rule Id="CA1713" Action="None" />
+    <Rule Id="CA1714" Action="None" />
+    <Rule Id="CA1715" Action="None" />
+    <Rule Id="CA1716" Action="None" />
+    <Rule Id="CA1717" Action="None" />
+    <Rule Id="CA1719" Action="None" />
+    <Rule Id="CA1720" Action="None" />
+    <Rule Id="CA1721" Action="None" />
+    <Rule Id="CA1722" Action="None" />
+    <Rule Id="CA1724" Action="None" />
+    <Rule Id="CA1725" Action="None" />
+    <Rule Id="CA1726" Action="None" />
+    <Rule Id="CA1800" Action="None" />
+    <Rule Id="CA1801" Action="None" />
+    <Rule Id="CA1802" Action="None" />
+    <Rule Id="CA1804" Action="None" />
+    <Rule Id="CA1806" Action="None" />
+    <Rule Id="CA1809" Action="None" />
+    <Rule Id="CA1810" Action="None" />
+    <Rule Id="CA1811" Action="None" />
+    <Rule Id="CA1812" Action="None" />
+    <Rule Id="CA1813" Action="None" />
+    <Rule Id="CA1814" Action="None" />
+    <Rule Id="CA1815" Action="None" />
+    <Rule Id="CA1816" Action="None" />
+    <Rule Id="CA1819" Action="None" />
+    <Rule Id="CA1820" Action="None" />
+    <Rule Id="CA1821" Action="None" />
+    <Rule Id="CA1822" Action="None" />
+    <Rule Id="CA1823" Action="None" />
+    <Rule Id="CA1824" Action="None" />
+    <Rule Id="CA1900" Action="None" />
+    <Rule Id="CA1901" Action="None" />
+    <Rule Id="CA1903" Action="None" />
+    <Rule Id="CA2000" Action="None" />
+    <Rule Id="CA2001" Action="None" />
+    <Rule Id="CA2002" Action="None" />
+    <Rule Id="CA2003" Action="None" />
+    <Rule Id="CA2004" Action="None" />
+    <Rule Id="CA2006" Action="None" />
+    <Rule Id="CA2100" Action="None" />
+    <Rule Id="CA2101" Action="None" />
+    <Rule Id="CA2102" Action="None" />
+    <Rule Id="CA2103" Action="None" />
+    <Rule Id="CA2104" Action="None" />
+    <Rule Id="CA2105" Action="None" />
+    <Rule Id="CA2106" Action="None" />
+    <Rule Id="CA2107" Action="None" />
+    <Rule Id="CA2108" Action="None" />
+    <Rule Id="CA2109" Action="None" />
+    <Rule Id="CA2111" Action="None" />
+    <Rule Id="CA2112" Action="None" />
+    <Rule Id="CA2114" Action="None" />
+    <Rule Id="CA2115" Action="None" />
+    <Rule Id="CA2116" Action="None" />
+    <Rule Id="CA2117" Action="None" />
+    <Rule Id="CA2118" Action="None" />
+    <Rule Id="CA2119" Action="None" />
+    <Rule Id="CA2120" Action="None" />
+    <Rule Id="CA2121" Action="None" />
+    <Rule Id="CA2122" Action="None" />
+    <Rule Id="CA2123" Action="None" />
+    <Rule Id="CA2124" Action="None" />
+    <Rule Id="CA2126" Action="None" />
+    <Rule Id="CA2130" Action="None" />
+    <Rule Id="CA2131" Action="None" />
+    <Rule Id="CA2132" Action="None" />
+    <Rule Id="CA2133" Action="None" />
+    <Rule Id="CA2134" Action="None" />
+    <Rule Id="CA2135" Action="None" />
+    <Rule Id="CA2136" Action="None" />
+    <Rule Id="CA2137" Action="None" />
+    <Rule Id="CA2138" Action="None" />
+    <Rule Id="CA2139" Action="None" />
+    <Rule Id="CA2140" Action="None" />
+    <Rule Id="CA2141" Action="None" />
+    <Rule Id="CA2142" Action="None" />
+    <Rule Id="CA2143" Action="None" />
+    <Rule Id="CA2144" Action="None" />
+    <Rule Id="CA2145" Action="None" />
+    <Rule Id="CA2146" Action="None" />
+    <Rule Id="CA2147" Action="None" />
+    <Rule Id="CA2149" Action="None" />
+    <Rule Id="CA2151" Action="None" />
+    <Rule Id="CA2200" Action="None" />
+    <Rule Id="CA2201" Action="None" />
+    <Rule Id="CA2202" Action="None" />
+    <Rule Id="CA2204" Action="None" />
+    <Rule Id="CA2205" Action="None" />
+    <Rule Id="CA2207" Action="None" />
+    <Rule Id="CA2208" Action="None" />
+    <Rule Id="CA2210" Action="None" />
+    <Rule Id="CA2211" Action="None" />
+    <Rule Id="CA2212" Action="None" />
+    <Rule Id="CA2213" Action="None" />
+    <Rule Id="CA2214" Action="None" />
+    <Rule Id="CA2215" Action="None" />
+    <Rule Id="CA2216" Action="None" />
+    <Rule Id="CA2217" Action="None" />
+    <Rule Id="CA2218" Action="None" />
+    <Rule Id="CA2219" Action="None" />
+    <Rule Id="CA2220" Action="None" />
+    <Rule Id="CA2221" Action="None" />
+    <Rule Id="CA2222" Action="None" />
+    <Rule Id="CA2223" Action="None" />
+    <Rule Id="CA2224" Action="None" />
+    <Rule Id="CA2225" Action="None" />
+    <Rule Id="CA2226" Action="None" />
+    <Rule Id="CA2227" Action="None" />
+    <Rule Id="CA2228" Action="None" />
+    <Rule Id="CA2229" Action="None" />
+    <Rule Id="CA2230" Action="None" />
+    <Rule Id="CA2231" Action="None" />
+    <Rule Id="CA2232" Action="None" />
+    <Rule Id="CA2233" Action="None" />
+    <Rule Id="CA2234" Action="None" />
+    <Rule Id="CA2235" Action="None" />
+    <Rule Id="CA2236" Action="None" />
+    <Rule Id="CA2237" Action="None" />
+    <Rule Id="CA2238" Action="None" />
+    <Rule Id="CA2239" Action="None" />
+    <Rule Id="CA2240" Action="None" />
+    <Rule Id="CA2241" Action="None" />
+    <Rule Id="CA2242" Action="None" />
+    <Rule Id="CA2243" Action="None" />
+    <Rule Id="CA5122" Action="None" />
+  </Rules>
+  <Rules AnalyzerId="Microsoft.Analyzers.NativeCodeAnalysis" RuleNamespace="Microsoft.Rules.Native">
+    <Rule Id="C26100" Action="Error" />
+    <Rule Id="C26101" Action="Error" />
+    <Rule Id="C26105" Action="Error" />
+    <Rule Id="C26110" Action="Error" />
+    <Rule Id="C26111" Action="Error" />
+    <Rule Id="C26112" Action="Error" />
+    <Rule Id="C26115" Action="Error" />
+    <Rule Id="C26116" Action="Error" />
+    <Rule Id="C26117" Action="Error" />
+    <Rule Id="C26130" Action="Error" />
+    <Rule Id="C26135" Action="Error" />
+    <Rule Id="C28039" Action="Error" />
+    <Rule Id="C28112" Action="Error" />
+    <Rule Id="C28132" Action="Error" />
+    <Rule Id="C28133" Action="Warning" />
+    <Rule Id="C28164" Action="Error" />
+    <Rule Id="C28182" Action="Error" />
+    <Rule Id="C28183" Action="Error" />
+    <Rule Id="C28193" Action="Error" />
+    <Rule Id="C28196" Action="Error" />
+    <Rule Id="C28199" Action="Error" />
+    <Rule Id="C28617" Action="None" />
+    <Rule Id="C28623" Action="None" />
+    <Rule Id="C28624" Action="None" />
+    <Rule Id="C28636" Action="None" />
+    <Rule Id="C28645" Action="None" />
+    <Rule Id="C28648" Action="None" />
+    <Rule Id="C28714" Action="Error" />
+    <Rule Id="C28715" Action="Error" />
+    <Rule Id="C28716" Action="Error" />
+    <Rule Id="C28717" Action="None" />
+    <Rule Id="C28721" Action="None" />
+    <Rule Id="C28730" Action="Error" />
+    <Rule Id="C28751" Action="Error" />
+    <Rule Id="C6001" Action="Error" />
+    <Rule Id="C6011" Action="Error" />
+    <Rule Id="C6014" Action="Error" />
+    <Rule Id="C6029" Action="Error" />
+    <Rule Id="C6031" Action="Error" />
+    <Rule Id="C6053" Action="Error" />
+    <Rule Id="C6054" Action="Error" />
+    <Rule Id="C6059" Action="Error" />
+    <Rule Id="C6101" Action="Error" />
+    <Rule Id="C6200" Action="Error" />
+    <Rule Id="C6201" Action="Error" />
+    <Rule Id="C6235" Action="Error" />
+    <Rule Id="C6236" Action="Error" />
+    <Rule Id="C6237" Action="Error" />
+    <Rule Id="C6239" Action="Error" />
+    <Rule Id="C6240" Action="Error" />
+    <Rule Id="C6244" Action="Error" />
+    <Rule Id="C6246" Action="Error" />
+    <Rule Id="C6248" Action="None" />
+    <Rule Id="C6255" Action="None" />
+    <Rule Id="C6258" Action="None" />
+    <Rule Id="C6259" Action="Error" />
+    <Rule Id="C6260" Action="Error" />
+    <Rule Id="C6262" Action="Error" />
+    <Rule Id="C6263" Action="None" />
+    <Rule Id="C6268" Action="Error" />
+    <Rule Id="C6269" Action="Error" />
+    <Rule Id="C6276" Action="Error" />
+    <Rule Id="C6277" Action="None" />
+    <Rule Id="C6278" Action="None" />
+    <Rule Id="C6279" Action="None" />
+    <Rule Id="C6281" Action="Error" />
+    <Rule Id="C6282" Action="Error" />
+    <Rule Id="C6285" Action="Error" />
+    <Rule Id="C6286" Action="Error" />
+    <Rule Id="C6287" Action="Error" />
+    <Rule Id="C6288" Action="Error" />
+    <Rule Id="C6289" Action="Error" />
+    <Rule Id="C6290" Action="Error" />
+    <Rule Id="C6291" Action="Error" />
+    <Rule Id="C6292" Action="Error" />
+    <Rule Id="C6293" Action="Error" />
+    <Rule Id="C6294" Action="Error" />
+    <Rule Id="C6295" Action="Error" />
+    <Rule Id="C6297" Action="Error" />
+    <Rule Id="C6298" Action="Error" />
+    <Rule Id="C6302" Action="Error" />
+    <Rule Id="C6303" Action="Error" />
+    <Rule Id="C6305" Action="Error" />
+    <Rule Id="C6306" Action="Error" />
+    <Rule Id="C6313" Action="Error" />
+    <Rule Id="C6314" Action="Error" />
+    <Rule Id="C6315" Action="Error" />
+    <Rule Id="C6316" Action="Error" />
+    <Rule Id="C6317" Action="Error" />
+    <Rule Id="C6319" Action="Error" />
+    <Rule Id="C6324" Action="Error" />
+    <Rule Id="C6326" Action="Error" />
+    <Rule Id="C6328" Action="Error" />
+    <Rule Id="C6330" Action="Error" />
+    <Rule Id="C6331" Action="None" />
+    <Rule Id="C6332" Action="None" />
+    <Rule Id="C6333" Action="None" />
+    <Rule Id="C6334" Action="Error" />
+    <Rule Id="C6335" Action="None" />
+    <Rule Id="C6336" Action="Error" />
+    <Rule Id="C6340" Action="Error" />
+    <Rule Id="C6381" Action="None" />
+    <Rule Id="C6383" Action="Error" />
+    <Rule Id="C6384" Action="Error" />
+    <Rule Id="C6385" Action="Error" />
+    <Rule Id="C6386" Action="Error" />
+    <Rule Id="C6387" Action="Error" />
+    <Rule Id="C6388" Action="Error" />
+    <Rule Id="C6400" Action="None" />
+    <Rule Id="C6401" Action="None" />
+    <Rule Id="C6500" Action="Info" />
+    <Rule Id="C6501" Action="Info" />
+    <Rule Id="C6503" Action="Info" />
+    <Rule Id="C6504" Action="Error" />
+    <Rule Id="C6505" Action="Error" />
+    <Rule Id="C6506" Action="Error" />
+    <Rule Id="C6508" Action="Info" />
+    <Rule Id="C6509" Action="Error" />
+    <Rule Id="C6510" Action="Error" />
+    <Rule Id="C6511" Action="Info" />
+    <Rule Id="C6513" Action="Info" />
+    <Rule Id="C6515" Action="Error" />
+    <Rule Id="C6516" Action="Info" />
+    <Rule Id="C6517" Action="Info" />
+    <Rule Id="C6518" Action="Error" />
+    <Rule Id="C6522" Action="Error" />
+    <Rule Id="C6525" Action="Info" />
+    <Rule Id="C6530" Action="Info" />
+    <Rule Id="C6551" Action="Info" />
+    <Rule Id="C6993" Action="None" />
+  </Rules>
+</RuleSet>
\ No newline at end of file
diff --git a/src_proiect/HAL9000/HAL9000.vcxproj b/src_proiect/HAL9000/HAL9000.vcxproj
new file mode 100644
index 0000000..779c36a
--- /dev/null
+++ b/src_proiect/HAL9000/HAL9000.vcxproj
@@ -0,0 +1,409 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{79A21DCA-19AF-4F8E-9B83-62D7CF504104}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>HAL9000</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetName>HAL9000</TargetName>
+    <TargetExt>.bin</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+    <EmbedManifest>false</EmbedManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetName>HAL9000</TargetName>
+    <TargetExt>.bin</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+    <EmbedManifest>false</EmbedManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>X64;AMD64;DEBUG;_DEBUG;WIN64</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <AdditionalIncludeDirectories>headers;..\shared\common;..\shared\kernel;..\..\acpi\inc;..\commonlib\inc;..\HAL\inc;..\SwapFS\inc;..\FAT32\inc;..\PE_Parser\inc;..\Eth_82574L\inc;..\NetworkStack\inc;..\Disk\inc;..\Volume\inc;..\Ata\inc</AdditionalIncludeDirectories>
+      <DisableSpecificWarnings>4313;4474;4476;4477;</DisableSpecificWarnings>
+      <ShowIncludes>false</ShowIncludes>
+      <MinimalRebuild>false</MinimalRebuild>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <StringPooling>true</StringPooling>
+      <OmitFramePointers>true</OmitFramePointers>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+    </ClCompile>
+    <Link>
+      <SubSystem>Native</SubSystem>
+      <GenerateDebugInformation>Debug</GenerateDebugInformation>
+      <OutputFile>$(OutDir)\HAL9000.bin</OutputFile>
+      <AdditionalDependencies>HAL.lib;CommonLib.lib;FAT32.lib;SwapFS.lib;PE_Parser.lib;Eth_82574L.lib;NetworkStack.lib;NetworkPort.lib;Disk.lib;Volume.lib;Ata.lib;Acpica.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <GenerateMapFile>true</GenerateMapFile>
+      <MapFileName>$(OutDir)\HAL9000.map</MapFileName>
+      <MapExports>true</MapExports>
+      <EntryPointSymbol>__EntryMultiboot</EntryPointSymbol>
+      <BaseAddress>0xFFFF800001000000</BaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+      <AdditionalOptions>/ALIGN:0x200 /IGNORE:4108 /MERGE:.mboot=.text %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\HAL;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\FAT32;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\SwapFS;$(SolutionDir)..\acpi\bin\$(PlatformName)\$(ConfigurationName);$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\commonlib;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\PE_Parser;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Eth_82574L;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkStack;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkPort;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Disk;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Volume;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Ata</AdditionalLibraryDirectories>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+    </Link>
+    <YASM>
+      <Defines>DEBUG</Defines>
+      <AdditionalOptions>-f x64 -X vc -w %(AdditionalOptions)</AdditionalOptions>
+      <Debug>true</Debug>
+    </YASM>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\post_hv.cmd $(ProjectName) "$(SolutionDir)" $(PlatformName) $(ConfigurationName) $(ProjectName)  $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>X64;AMD64;NDEBUG;WIN64</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <AdditionalIncludeDirectories>headers;..\shared\common;..\shared\kernel;..\..\acpi\inc;..\commonlib\inc;..\HAL\inc;..\SwapFS\inc;..\FAT32\inc;..\PE_Parser\inc;..\Eth_82574L\inc;..\NetworkStack\inc;..\Disk\inc;..\Volume\inc;..\Ata\inc</AdditionalIncludeDirectories>
+      <DisableSpecificWarnings>4313;4474;4476;4477;</DisableSpecificWarnings>
+      <ShowIncludes>false</ShowIncludes>
+      <MinimalRebuild>false</MinimalRebuild>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <StringPooling>true</StringPooling>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <AssemblerOutput>AssemblyAndSourceCode</AssemblerOutput>
+    </ClCompile>
+    <Link>
+      <SubSystem>Native</SubSystem>
+      <GenerateDebugInformation>Debug</GenerateDebugInformation>
+      <OutputFile>$(OutDir)\HAL9000.bin</OutputFile>
+      <AdditionalDependencies>HAL.lib;CommonLib.lib;FAT32.lib;SwapFS.lib;PE_Parser.lib;Eth_82574L.lib;NetworkStack.lib;NetworkPort.lib;Disk.lib;Volume.lib;Ata.lib;Acpica.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <GenerateMapFile>true</GenerateMapFile>
+      <MapFileName>$(OutDir)\HAL9000.map</MapFileName>
+      <MapExports>true</MapExports>
+      <EntryPointSymbol>__EntryMultiboot</EntryPointSymbol>
+      <BaseAddress>0xFFFF800001000000</BaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+      <AdditionalOptions>/ALIGN:0x200 /IGNORE:4108 /MERGE:.mboot=.text %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\HAL;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\FAT32;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\SwapFS;$(SolutionDir)..\acpi\bin\$(PlatformName)\Debug;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\commonlib;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\PE_Parser;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Eth_82574L;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkStack;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\NetworkPort;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Disk;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Volume;$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)\Ata</AdditionalLibraryDirectories>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+    </Link>
+    <YASM>
+      <Defines>DEBUG</Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+      <Debug>true</Debug>
+    </YASM>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\post_hv.cmd $(ProjectName) "$(SolutionDir)" $(PlatformName) $(ConfigurationName) $(ProjectName)  $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\acpi_interface.c" />
+    <ClCompile Include="src\acpi_osl.c" />
+    <ClCompile Include="src\ap_tramp.c" />
+    <ClCompile Include="src\boot_module.c" />
+    <ClCompile Include="src\cmd_basic.c" />
+    <ClCompile Include="src\cmd_proc_helper.c" />
+    <ClCompile Include="src\dmp_process.c" />
+    <ClCompile Include="src\process.c" />
+    <ClCompile Include="src\cmd_fs_helper.c" />
+    <ClCompile Include="src\cmd_interpreter.c" />
+    <ClCompile Include="src\cmd_net_helper.c" />
+    <ClCompile Include="src\cmd_sys_helper.c" />
+    <ClCompile Include="src\cmd_thread_helper.c" />
+    <ClCompile Include="src\core.c" />
+    <ClCompile Include="src\cpumu.c" />
+    <ClCompile Include="src\display.c" />
+    <ClCompile Include="src\dmp_ata.c" />
+    <ClCompile Include="src\dmp_cmos.c" />
+    <ClCompile Include="src\dmp_common.c" />
+    <ClCompile Include="src\dmp_cpu.c" />
+    <ClCompile Include="src\dmp_disk.c" />
+    <ClCompile Include="src\dmp_int15.c" />
+    <ClCompile Include="src\dmp_io.c" />
+    <ClCompile Include="src\dmp_ioapic.c" />
+    <ClCompile Include="src\dmp_lapic.c" />
+    <ClCompile Include="src\dmp_mbr.c" />
+    <ClCompile Include="src\dmp_mdl.c" />
+    <ClCompile Include="src\dmp_memory.c" />
+    <ClCompile Include="src\dmp_multiboot.c" />
+    <ClCompile Include="src\dmp_network.c" />
+    <ClCompile Include="src\dmp_net_device.c" />
+    <ClCompile Include="src\dmp_pci.c" />
+    <ClCompile Include="src\dmp_volume.c" />
+    <ClCompile Include="src\dmp_nt.c" />
+    <ClCompile Include="src\Entry64.c" />
+    <ClCompile Include="src\ex.c" />
+    <ClCompile Include="src\ex_event.c" />
+    <ClCompile Include="src\ex_system.c" />
+    <ClCompile Include="src\ex_timer.c" />
+    <ClCompile Include="src\gdtmu.c" />
+    <ClCompile Include="src\hal_assert.c" />
+    <ClCompile Include="src\idt_handlers.c" />
+    <ClCompile Include="src\ioapic_system.c" />
+    <ClCompile Include="src\io_devices.c" />
+    <ClCompile Include="src\iomu.c" />
+    <ClCompile Include="src\io_files.c" />
+    <ClCompile Include="src\ipc.c" />
+    <ClCompile Include="src\isr.c" />
+    <ClCompile Include="src\keyboard.c" />
+    <ClCompile Include="src\keyboard_utils.c" />
+    <ClCompile Include="src\lapic_system.c" />
+    <ClCompile Include="src\log.c" />
+    <ClCompile Include="src\mdl.c" />
+    <ClCompile Include="src\mmu.c" />
+    <ClCompile Include="src\network_utils.c" />
+    <ClCompile Include="src\perf_framework.c" />
+    <ClCompile Include="src\pmm.c" />
+    <ClCompile Include="src\mutex.c" />
+    <ClCompile Include="src\os_info.c" />
+    <ClCompile Include="src\pci_system.c" />
+    <ClCompile Include="src\print.c" />
+    <ClCompile Include="src\serial_comm.c" />
+    <ClCompile Include="src\smp.c" />
+    <ClCompile Include="src\syscall.c" />
+    <ClCompile Include="src\test_priority_donation.c" />
+    <ClCompile Include="src\test_priority_scheduler.c" />
+    <ClCompile Include="src\test_process.c" />
+    <ClCompile Include="src\test_timer.c" />
+    <ClCompile Include="src\um_application.c" />
+    <ClCompile Include="src\system.c" />
+    <ClCompile Include="src\system_driver.c" />
+    <ClCompile Include="src\test_bitmap.c" />
+    <ClCompile Include="src\test_common.c" />
+    <ClCompile Include="src\test_dma.c" />
+    <ClCompile Include="src\test_file_io.c" />
+    <ClCompile Include="src\test_net_stack.c" />
+    <ClCompile Include="src\test_pmm.c" />
+    <ClCompile Include="src\test_thread.c" />
+    <ClCompile Include="src\test_vmm.c" />
+    <ClCompile Include="src\thread.c" />
+    <ClCompile Include="src\os_time.c" />
+    <ClCompile Include="src\vmm.c" />
+    <ClCompile Include="src\vm_reservation_space.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\shared\common\mem_structures.h" />
+    <ClInclude Include="..\shared\common\process_defs.h" />
+    <ClInclude Include="..\shared\common\syscall_defs.h" />
+    <ClInclude Include="..\shared\common\syscall_func.h" />
+    <ClInclude Include="..\shared\common\syscall_no.h" />
+    <ClInclude Include="..\shared\common\thread_defs.h" />
+    <ClInclude Include="..\shared\kernel\cpu_structures.h" />
+    <ClInclude Include="..\shared\kernel\ex.h" />
+    <ClInclude Include="..\shared\kernel\ex_event.h" />
+    <ClInclude Include="..\shared\kernel\filesystem.h" />
+    <ClInclude Include="..\shared\kernel\heap_tags.h" />
+    <ClInclude Include="..\shared\kernel\io.h" />
+    <ClInclude Include="..\shared\kernel\io_structures.h" />
+    <ClInclude Include="..\shared\kernel\log.h" />
+    <ClInclude Include="..\shared\kernel\network.h" />
+    <ClInclude Include="..\shared\kernel\network_device.h" />
+    <ClInclude Include="..\shared\kernel\network_packets.h" />
+    <ClInclude Include="..\shared\kernel\network_utils.h" />
+    <ClInclude Include="..\shared\kernel\pci_system.h" />
+    <ClInclude Include="..\shared\kernel\thread.h" />
+    <ClInclude Include="headers\acpi_interface.h" />
+    <ClInclude Include="headers\ap_tramp.h" />
+    <ClInclude Include="headers\boot_module.h" />
+    <ClInclude Include="headers\cmd_basic.h" />
+    <ClInclude Include="headers\cmd_common.h" />
+    <ClInclude Include="headers\cmd_fs_helper.h" />
+    <ClInclude Include="headers\cmd_net_helper.h" />
+    <ClInclude Include="headers\cmd_proc_helper.h" />
+    <ClInclude Include="headers\cmd_sys_helper.h" />
+    <ClInclude Include="headers\cmd_thread_helper.h" />
+    <ClInclude Include="headers\core.h" />
+    <ClInclude Include="headers\dmp_ata.h" />
+    <ClInclude Include="headers\dmp_common.h" />
+    <ClInclude Include="headers\dmp_int15.h" />
+    <ClInclude Include="headers\dmp_io.h" />
+    <ClInclude Include="headers\dmp_disk.h" />
+    <ClInclude Include="headers\dmp_ioapic.h" />
+    <ClInclude Include="headers\dmp_lapic.h" />
+    <ClInclude Include="headers\dmp_mbr.h" />
+    <ClInclude Include="headers\dmp_memory.h" />
+    <ClInclude Include="headers\dmp_network.h" />
+    <ClInclude Include="headers\dmp_net_device.h" />
+    <ClInclude Include="headers\dmp_nt.h" />
+    <ClInclude Include="headers\dmp_pci.h" />
+    <ClInclude Include="headers\dmp_process.h" />
+    <ClInclude Include="headers\dmp_volume.h" />
+    <ClInclude Include="headers\dmp_mdl.h" />
+    <ClInclude Include="headers\process.h" />
+    <ClInclude Include="headers\process_internal.h" />
+    <ClInclude Include="headers\ex_system.h" />
+    <ClInclude Include="headers\ex_timer.h" />
+    <ClInclude Include="headers\gdtmu.h" />
+    <ClInclude Include="headers\hal_assert.h" />
+    <ClInclude Include="headers\cmd_interpreter.h" />
+    <ClInclude Include="headers\cpumu.h" />
+    <ClInclude Include="headers\display.h" />
+    <ClInclude Include="headers\dmp_cmos.h" />
+    <ClInclude Include="headers\dmp_cpu.h" />
+    <ClInclude Include="headers\dmp_multiboot.h" />
+    <ClInclude Include="headers\HAL9000.h" />
+    <ClInclude Include="headers\idt_handlers.h" />
+    <ClInclude Include="headers\ioapic_system.h" />
+    <ClInclude Include="headers\iomu.h" />
+    <ClInclude Include="headers\ipc.h" />
+    <ClInclude Include="headers\isr.h" />
+    <ClInclude Include="headers\keyboard.h" />
+    <ClInclude Include="headers\keyboard_utils.h" />
+    <ClInclude Include="headers\lapic_system.h" />
+    <ClInclude Include="headers\mdl.h" />
+    <ClInclude Include="headers\mmu.h" />
+    <ClInclude Include="headers\os_time.h" />
+    <ClInclude Include="headers\perf_framework.h" />
+    <ClInclude Include="headers\pmm.h" />
+    <ClInclude Include="headers\multiboot.h" />
+    <ClInclude Include="headers\mutex.h" />
+    <ClInclude Include="headers\os_info.h" />
+    <ClInclude Include="headers\print.h" />
+    <ClInclude Include="headers\scan_codes.h" />
+    <ClInclude Include="headers\serial_comm.h" />
+    <ClInclude Include="headers\smp.h" />
+    <ClInclude Include="headers\synch.h" />
+    <ClInclude Include="headers\syscall.h" />
+    <ClInclude Include="headers\system.h" />
+    <ClInclude Include="headers\system_driver.h" />
+    <ClInclude Include="headers\test_bitmap.h" />
+    <ClInclude Include="headers\test_common.h" />
+    <ClInclude Include="headers\test_dma.h" />
+    <ClInclude Include="headers\test_file_io.h" />
+    <ClInclude Include="headers\test_net_stack.h" />
+    <ClInclude Include="headers\test_pmm.h" />
+    <ClInclude Include="headers\test_priority_donation.h" />
+    <ClInclude Include="headers\test_priority_scheduler.h" />
+    <ClInclude Include="headers\test_process.h" />
+    <ClInclude Include="headers\test_thread.h" />
+    <ClInclude Include="headers\test_timer.h" />
+    <ClInclude Include="headers\test_vmm.h" />
+    <ClInclude Include="headers\thread_internal.h" />
+    <ClInclude Include="headers\um_application.h" />
+    <ClInclude Include="headers\vmm.h" />
+    <ClInclude Include="headers\vm_reservation_space.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_mboot32.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="HAL9000.ruleset" />
+    <YASM Include="src\_syscall.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+    <None Include="src\defines.yasm" />
+    <YASM Include="src\_thread.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+    <YASM Include="src\_trampoline.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+    <YASM Include="src\_transition.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+    <YASM Include="src\_exports.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+    <YASM Include="src\_isr.yasm">
+      <FileType>Document</FileType>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</ExcludedFromBuild>
+    </YASM>
+    <None Include="src\lib.yasm" />
+    <YASM Include="src\_low_mem.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+    <None Include="src\macros.yasm" />
+    <None Include="src\structs.yasm" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.targets" />
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/HAL9000/HAL9000.vcxproj.filters b/src_proiect/HAL9000/HAL9000.vcxproj.filters
new file mode 100644
index 0000000..0d3b52f
--- /dev/null
+++ b/src_proiect/HAL9000/HAL9000.vcxproj.filters
@@ -0,0 +1,749 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\base">
+      <UniqueIdentifier>{f1271304-3b07-40d8-bdea-06eb84e5b769}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\boot">
+      <UniqueIdentifier>{c7f61ebc-9c89-4f99-a273-29fa93345a95}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\base\yasm">
+      <UniqueIdentifier>{184b92a8-53a8-445d-861f-6af2c3261dae}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\base">
+      <UniqueIdentifier>{a5641916-6b04-4991-be68-3860e2ba28fc}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\crt">
+      <UniqueIdentifier>{eb6c84ee-07ba-4554-b698-b7f64e41efbd}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\crt">
+      <UniqueIdentifier>{1428de26-c3a7-4a5e-a709-729d85043b3d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices">
+      <UniqueIdentifier>{f2692cbf-8aa1-42a3-8480-ca09481e037d}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\devices">
+      <UniqueIdentifier>{13fe69ec-0674-480a-9655-eede94f57ae1}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\core">
+      <UniqueIdentifier>{897f9b41-b852-4086-aa4b-dec489648b00}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\debug">
+      <UniqueIdentifier>{724ad1c3-57d4-4d04-a6c8-ace1eb4a0c9c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\debug">
+      <UniqueIdentifier>{3affb06b-d43b-4a76-8c24-bb13b5d45c66}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\core">
+      <UniqueIdentifier>{d8c6bb22-159c-47f5-bbc7-0da718955e53}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\boot">
+      <UniqueIdentifier>{cbc40a89-b8d7-4d57-bfd2-2abed31ac1db}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\debug\test">
+      <UniqueIdentifier>{5b5f3da9-961a-4f9c-b0fb-d1b3b0785b9c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\debug\dump">
+      <UniqueIdentifier>{95795d53-c8d7-4fa4-855c-f7ea217d6cc4}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\debug\dump">
+      <UniqueIdentifier>{6e790c7a-9fde-493a-b573-bd8af7ca1517}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\debug\test">
+      <UniqueIdentifier>{b20c2e10-e6b8-4dbb-bb36-62be6ec6c6ea}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\abstraction">
+      <UniqueIdentifier>{2344aba6-a2ac-43ed-8ea1-ed3a2853360f}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\core\IO subsystem">
+      <UniqueIdentifier>{9a2aeca7-cc84-458d-b63f-cbda7a91a20c}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\core\IO subsystem">
+      <UniqueIdentifier>{2a565696-c37a-4394-b99b-e9d1258c7bdf}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\apps">
+      <UniqueIdentifier>{3666b9aa-ede5-47bc-867e-a859e7fdf130}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\apps">
+      <UniqueIdentifier>{338c45d9-afc5-4f91-8565-8bdc657db9fa}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\executive">
+      <UniqueIdentifier>{c0b078f5-f298-4c0d-9eee-1a5cb4c8fe76}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\executive">
+      <UniqueIdentifier>{4d0f6f7b-78a5-43ce-b127-667632eb6460}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\core\memory">
+      <UniqueIdentifier>{89a94e9e-4d34-4747-aca7-98de3dc79d76}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\core\memory">
+      <UniqueIdentifier>{218a3ee7-2c1a-457c-9a7b-c483546f342a}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\utils">
+      <UniqueIdentifier>{bd984f90-4d70-4723-aa3f-54fd3bc10388}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\network">
+      <UniqueIdentifier>{8160f6ae-2376-4c71-86f4-b97cba05efa4}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\keyboard">
+      <UniqueIdentifier>{1e59bb61-52be-4819-a821-1006c9a028d0}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\serial">
+      <UniqueIdentifier>{c3f3def2-20db-468a-a9c0-f445163fb955}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\pci">
+      <UniqueIdentifier>{adb1f87c-6214-489f-ae34-1fd16523d4ee}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\devices\keyboard">
+      <UniqueIdentifier>{c8ab8b54-dc1f-4674-b9c3-c31182a08276}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\devices\serial">
+      <UniqueIdentifier>{9d366c5d-9bf0-4518-993b-046ee8c8f7d6}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\devices\pci">
+      <UniqueIdentifier>{3e07df45-36d8-431a-858f-a5ce31449afd}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\devices\utils">
+      <UniqueIdentifier>{e2e8a53d-6ec0-4b48-8067-f9b1f79db420}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\devices\apic">
+      <UniqueIdentifier>{328116cd-1ef7-45f9-be65-0399f8cb71b1}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\devices\apic">
+      <UniqueIdentifier>{2f4a7cb1-890d-45bd-86ad-e45f7db559cc}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\core\cpu">
+      <UniqueIdentifier>{f9d6e54e-0fb1-47ff-a0a4-965ae339f892}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\core\cpu">
+      <UniqueIdentifier>{7052ba67-bd0e-44a8-b123-946ebf32006e}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\usermode">
+      <UniqueIdentifier>{1297f178-45d7-4074-b254-756c9e3048cd}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\usermode">
+      <UniqueIdentifier>{f64bf144-4d2f-435d-b4a6-eb97ad5cc35e}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\usermode\common">
+      <UniqueIdentifier>{053c5b68-9a55-44a1-b72a-1fe1c1bfd413}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\debug\test\threads">
+      <UniqueIdentifier>{7c2fc4c7-1cfd-40d5-a9af-e5db8b0f99c5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\debug\test\threads">
+      <UniqueIdentifier>{b52ea948-2566-400c-a19d-a261a9e532c5}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Header Files\debug\test\userprog">
+      <UniqueIdentifier>{4200718c-b938-4539-a550-ac19802a7103}</UniqueIdentifier>
+    </Filter>
+    <Filter Include="Source Files\debug\test\userprog">
+      <UniqueIdentifier>{fc25cd91-cea9-4299-9119-b2af14759aad}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\display.c">
+      <Filter>Source Files\base</Filter>
+    </ClCompile>
+    <ClCompile Include="src\print.c">
+      <Filter>Source Files\crt</Filter>
+    </ClCompile>
+    <ClCompile Include="src\os_info.c">
+      <Filter>Source Files\base</Filter>
+    </ClCompile>
+    <ClCompile Include="src\Entry64.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_cmos.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_multiboot.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\system.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\keyboard_utils.c">
+      <Filter>Source Files\crt</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_interpreter.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\log.c">
+      <Filter>Source Files\debug</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_cpu.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\hal_assert.c">
+      <Filter>Source Files\base</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_common.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cpumu.c">
+      <Filter>Source Files\core\cpu</Filter>
+    </ClCompile>
+    <ClCompile Include="src\gdtmu.c">
+      <Filter>Source Files\core\cpu</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_pci.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_ata.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_memory.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_mbr.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_disk.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_volume.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_io.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\iomu.c">
+      <Filter>Source Files\core\IO subsystem</Filter>
+    </ClCompile>
+    <ClCompile Include="src\io_devices.c">
+      <Filter>Source Files\core\IO subsystem</Filter>
+    </ClCompile>
+    <ClCompile Include="src\io_files.c">
+      <Filter>Source Files\core\IO subsystem</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_fs_helper.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\acpi_interface.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\acpi_osl.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\smp.c">
+      <Filter>Source Files\core\cpu</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ap_tramp.c">
+      <Filter>Source Files\boot</Filter>
+    </ClCompile>
+    <ClCompile Include="src\thread.c">
+      <Filter>Source Files\executive</Filter>
+    </ClCompile>
+    <ClCompile Include="src\mutex.c">
+      <Filter>Source Files\executive</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ex_event.c">
+      <Filter>Source Files\executive</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_thread_helper.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_bitmap.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_int15.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\vmm.c">
+      <Filter>Source Files\core\memory</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pmm.c">
+      <Filter>Source Files\core\memory</Filter>
+    </ClCompile>
+    <ClCompile Include="src\mmu.c">
+      <Filter>Source Files\core\memory</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_vmm.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_pmm.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\mdl.c">
+      <Filter>Source Files\core\memory</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_mdl.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ex.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_sys_helper.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_dma.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\perf_framework.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_nt.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\core.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_lapic.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_utils.c">
+      <Filter>Source Files\devices\utils</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_network.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_net_helper.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_net_device.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_net_stack.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\keyboard.c">
+      <Filter>Source Files\devices\keyboard</Filter>
+    </ClCompile>
+    <ClCompile Include="src\lapic_system.c">
+      <Filter>Source Files\devices\apic</Filter>
+    </ClCompile>
+    <ClCompile Include="src\serial_comm.c">
+      <Filter>Source Files\devices\serial</Filter>
+    </ClCompile>
+    <ClCompile Include="src\system_driver.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_common.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ioapic_system.c">
+      <Filter>Source Files\devices\apic</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_ioapic.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\pci_system.c">
+      <Filter>Source Files\devices\pci</Filter>
+    </ClCompile>
+    <ClCompile Include="src\os_time.c">
+      <Filter>Source Files\core</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ex_timer.c">
+      <Filter>Source Files\executive</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ex_system.c">
+      <Filter>Source Files\executive</Filter>
+    </ClCompile>
+    <ClCompile Include="src\isr.c">
+      <Filter>Source Files\core\cpu</Filter>
+    </ClCompile>
+    <ClCompile Include="src\ipc.c">
+      <Filter>Source Files\core\cpu</Filter>
+    </ClCompile>
+    <ClCompile Include="src\idt_handlers.c">
+      <Filter>Source Files\core\cpu</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_file_io.c">
+      <Filter>Source Files\debug\test</Filter>
+    </ClCompile>
+    <ClCompile Include="src\um_application.c">
+      <Filter>Source Files\usermode</Filter>
+    </ClCompile>
+    <ClCompile Include="src\process.c">
+      <Filter>Source Files\executive</Filter>
+    </ClCompile>
+    <ClCompile Include="src\vm_reservation_space.c">
+      <Filter>Source Files\core\memory</Filter>
+    </ClCompile>
+    <ClCompile Include="src\dmp_process.c">
+      <Filter>Source Files\debug\dump</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_proc_helper.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\syscall.c">
+      <Filter>Source Files\usermode</Filter>
+    </ClCompile>
+    <ClCompile Include="src\boot_module.c">
+      <Filter>Source Files\boot</Filter>
+    </ClCompile>
+    <ClCompile Include="src\cmd_basic.c">
+      <Filter>Source Files\apps</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_thread.c">
+      <Filter>Source Files\debug\test\threads</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_timer.c">
+      <Filter>Source Files\debug\test\threads</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_priority_scheduler.c">
+      <Filter>Source Files\debug\test\threads</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_priority_donation.c">
+      <Filter>Source Files\debug\test\threads</Filter>
+    </ClCompile>
+    <ClCompile Include="src\test_process.c">
+      <Filter>Source Files\debug\test\userprog</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\HAL9000.h">
+      <Filter>Header Files\base</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\display.h">
+      <Filter>Header Files\base</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\print.h">
+      <Filter>Header Files\crt</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\os_info.h">
+      <Filter>Header Files\base</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_cmos.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\multiboot.h">
+      <Filter>Header Files\boot</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_multiboot.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\system.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\keyboard_utils.h">
+      <Filter>Header Files\crt</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_interpreter.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_cpu.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\hal_assert.h">
+      <Filter>Header Files\base</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_common.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cpumu.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\gdtmu.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_pci.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_ata.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_memory.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_mbr.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_disk.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_volume.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_io.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\iomu.h">
+      <Filter>Header Files\core\IO subsystem</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_fs_helper.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\acpi_interface.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\smp.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ap_tramp.h">
+      <Filter>Header Files\boot</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\mutex.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_thread_helper.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\synch.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_bitmap.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_int15.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\vmm.h">
+      <Filter>Header Files\core\memory</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\pmm.h">
+      <Filter>Header Files\core\memory</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\mmu.h">
+      <Filter>Header Files\core\memory</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_vmm.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_pmm.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\mdl.h">
+      <Filter>Header Files\core\memory</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_mdl.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_file_io.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_sys_helper.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_dma.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\perf_framework.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_nt.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\core.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_lapic.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_network.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_net_helper.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_net_device.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_net_stack.h">
+      <Filter>Header Files\debug\test</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\keyboard.h">
+      <Filter>Header Files\devices\keyboard</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\scan_codes.h">
+      <Filter>Header Files\devices\keyboard</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\lapic_system.h">
+      <Filter>Header Files\devices\apic</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\serial_comm.h">
+      <Filter>Header Files\devices\serial</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\system_driver.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_common.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ioapic_system.h">
+      <Filter>Header Files\devices\apic</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_ioapic.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\os_time.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ex_timer.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ex_system.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\ipc.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\idt_handlers.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\isr.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\thread_internal.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\um_application.h">
+      <Filter>Header Files\usermode</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\process.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\process_internal.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\vm_reservation_space.h">
+      <Filter>Header Files\core\memory</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\dmp_process.h">
+      <Filter>Header Files\debug\dump</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_proc_helper.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\syscall.h">
+      <Filter>Header Files\usermode</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\common\process_defs.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\common\thread_defs.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\common\syscall_defs.h">
+      <Filter>Header Files\usermode\common</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\common\syscall_func.h">
+      <Filter>Header Files\usermode\common</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\common\syscall_no.h">
+      <Filter>Header Files\usermode\common</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\io.h">
+      <Filter>Header Files\core\IO subsystem</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\io_structures.h">
+      <Filter>Header Files\core\IO subsystem</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\cpu_structures.h">
+      <Filter>Header Files\core\cpu</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\ex_event.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\common\mem_structures.h">
+      <Filter>Header Files\core\memory</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\network.h">
+      <Filter>Header Files\devices\network</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\network_device.h">
+      <Filter>Header Files\devices\network</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\network_packets.h">
+      <Filter>Header Files\devices\network</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\pci_system.h">
+      <Filter>Header Files\devices\pci</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\thread.h">
+      <Filter>Header Files\executive</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\network_utils.h">
+      <Filter>Header Files\devices\utils</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\filesystem.h">
+      <Filter>Header Files\devices\abstraction</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\heap_tags.h">
+      <Filter>Header Files\crt</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\ex.h">
+      <Filter>Header Files\core</Filter>
+    </ClInclude>
+    <ClInclude Include="..\shared\kernel\log.h">
+      <Filter>Header Files\debug</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\boot_module.h">
+      <Filter>Header Files\boot</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_common.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\cmd_basic.h">
+      <Filter>Header Files\apps</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_thread.h">
+      <Filter>Header Files\debug\test\threads</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_timer.h">
+      <Filter>Header Files\debug\test\threads</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_priority_scheduler.h">
+      <Filter>Header Files\debug\test\threads</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_priority_donation.h">
+      <Filter>Header Files\debug\test\threads</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\test_process.h">
+      <Filter>Header Files\debug\test\userprog</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="src\defines.yasm">
+      <Filter>Header Files\base\yasm</Filter>
+    </None>
+    <None Include="src\lib.yasm">
+      <Filter>Header Files\base\yasm</Filter>
+    </None>
+    <None Include="src\macros.yasm">
+      <Filter>Header Files\base\yasm</Filter>
+    </None>
+    <None Include="src\structs.yasm">
+      <Filter>Header Files\base\yasm</Filter>
+    </None>
+    <None Include="HAL9000.ruleset" />
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_mboot32.yasm">
+      <Filter>Source Files\boot</Filter>
+    </YASM>
+    <YASM Include="src\_isr.yasm">
+      <Filter>Source Files\core</Filter>
+    </YASM>
+    <YASM Include="src\_exports.yasm">
+      <Filter>Source Files\core</Filter>
+    </YASM>
+    <YASM Include="src\_transition.yasm">
+      <Filter>Source Files\boot</Filter>
+    </YASM>
+    <YASM Include="src\_trampoline.yasm">
+      <Filter>Source Files\boot</Filter>
+    </YASM>
+    <YASM Include="src\_thread.yasm">
+      <Filter>Source Files\executive</Filter>
+    </YASM>
+    <YASM Include="src\_low_mem.yasm">
+      <Filter>Source Files\boot</Filter>
+    </YASM>
+    <YASM Include="src\_syscall.yasm">
+      <Filter>Source Files\usermode</Filter>
+    </YASM>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/HAL9000.h b/src_proiect/HAL9000/headers/HAL9000.h
new file mode 100644
index 0000000..0cda18d
--- /dev/null
+++ b/src_proiect/HAL9000/headers/HAL9000.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "common_lib.h"
+#include "hal.h"
+#include "msr.h"
+#include "log.h"
+#include "ex.h"
+
+extern QWORD gVirtualToPhysicalOffset;
+
+// Virtual to Physical address conversion and vice-versa
+#define VA2PA(addr)                         ((PHYSICAL_ADDRESS)((QWORD)(addr)-gVirtualToPhysicalOffset))
+#define PA2VA(addr)                         ((QWORD)(addr)+gVirtualToPhysicalOffset)
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/acpi_interface.h b/src_proiect/HAL9000/headers/acpi_interface.h
new file mode 100644
index 0000000..8f276e3
--- /dev/null
+++ b/src_proiect/HAL9000/headers/acpi_interface.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#pragma warning(push)
+#include "acpi.h"
+#pragma warning(pop)
+
+void
+AcpiInterfacePreinit(
+    void
+    );
+
+STATUS
+AcpiInterfaceInit(
+    void
+    );
+
+void
+AcpiShutdown(
+    void
+    );
+
+STATUS
+AcpiInterfaceLateInit(
+    void
+    );
+
+STATUS
+AcpiRetrieveNextCpu(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_MADT_LOCAL_APIC**      AcpiEntry
+    );
+
+STATUS
+AcpiRetrieveNextIoApic(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_MADT_IO_APIC**         AcpiEntry
+    );
+
+STATUS
+AcpiRetrieveNextInterruptOverride(
+    IN      BOOLEAN                         RestartSearch,
+    OUT_PTR ACPI_MADT_INTERRUPT_OVERRIDE**  AcpiEntry
+    );
+
+STATUS
+AcpiRetrieveNextMcfgEntry(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_MCFG_ALLOCATION**      AcpiEntry
+    );
+
+STATUS
+AcpiRetrieveNextPrtEntry(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_PCI_ROUTING_TABLE**    AcpiEntry,
+    OUT     BYTE*                       BusNumber,
+    OUT     WORD*                       SegmentNumber
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/ap_tramp.h b/src_proiect/HAL9000/headers/ap_tramp.h
new file mode 100644
index 0000000..35e3853
--- /dev/null
+++ b/src_proiect/HAL9000/headers/ap_tramp.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "list.h"
+
+STATUS
+ApTrampSetupLowerMemory(
+    IN      PLIST_ENTRY     CpuList,
+    OUT     DWORD*          ApStartAddress
+    );
+
+void
+ApTrampCleanupLowerMemory(
+    IN      PLIST_ENTRY     CpuList
+    );
+
+void
+ApInitCpu(
+    IN      struct _PCPU*   Cpu
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/boot_module.h b/src_proiect/HAL9000/headers/boot_module.h
new file mode 100644
index 0000000..e2a4acf
--- /dev/null
+++ b/src_proiect/HAL9000/headers/boot_module.h
@@ -0,0 +1,37 @@
+#pragma once
+
+_No_competing_thread_
+void
+BootModulesPreinit(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+BootModulesInit(
+    IN      PHYSICAL_ADDRESS        BootModulesStart,
+    IN      DWORD                   NumberOfModules
+    );
+
+_No_competing_thread_
+void
+BootModulesUninit(
+    void
+    );
+
+//******************************************************************************
+// Function:     BootModuleGet
+// Description:  Retrieves the base address and module length for an already
+//               mapped module.
+// Returns:      STATUS
+// Parameter:    IN_Z char * ModuleName - Name of the module
+// Parameter:    OUT PVOID * BaseAddress - Base address where the module was
+//               mapped.
+// Parameter:    OUT QWORD * ModuleLength - Length of the mapped module data.
+//******************************************************************************
+STATUS
+BootModuleGet(
+    IN_Z    char*                   ModuleName,
+    OUT     PVOID*                  BaseAddress,
+    OUT     QWORD*                  ModuleLength
+    );
diff --git a/src_proiect/HAL9000/headers/cmd_basic.h b/src_proiect/HAL9000/headers/cmd_basic.h
new file mode 100644
index 0000000..b8bbe0a
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_basic.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "cmd_common.h"
+
+FUNC_GenericCommand CmdPrintVolumeInformation;
+FUNC_GenericCommand CmdInfiniteRecursion;
+FUNC_GenericCommand CmdRtcFail;
+FUNC_GenericCommand CmdRangeFail;
+FUNC_GenericCommand CmdBiteCookie;
+FUNC_GenericCommand CmdLogSetState;
+FUNC_GenericCommand CmdSetLogLevel;
+FUNC_GenericCommand CmdSetLogComponents;
+FUNC_GenericCommand CmdClearScreen;
+FUNC_GenericCommand CmdRunAllFunctionalTests;
+FUNC_GenericCommand CmdRunAllPerformanceTests;
diff --git a/src_proiect/HAL9000/headers/cmd_common.h b/src_proiect/HAL9000/headers/cmd_common.h
new file mode 100644
index 0000000..8dd457c
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_common.h
@@ -0,0 +1,16 @@
+#pragma once
+
+// warning C28208: Function was previously defined with a different parameter list
+// warning C28250: Inconsistent annotation for Function: the prior instance has trailing unannotated parameters
+// warning C28251: Inconsistent annotation for Function: this instance has trailing unannotated parameters.
+// warning C28253: Inconsistent annotation for Function
+#pragma warning(disable:28208 28250 28251 28253)
+
+typedef
+void
+(__cdecl FUNC_GenericCommand)(
+    IN      QWORD           NumberOfParameters,
+    ...
+    );
+
+typedef FUNC_GenericCommand*    PFUNC_GenericCommand;
diff --git a/src_proiect/HAL9000/headers/cmd_fs_helper.h b/src_proiect/HAL9000/headers/cmd_fs_helper.h
new file mode 100644
index 0000000..e3753f4
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_fs_helper.h
@@ -0,0 +1,11 @@
+#pragma once
+
+#include "cmd_common.h"
+
+FUNC_GenericCommand CmdStatFile;
+FUNC_GenericCommand CmdMakeDirectory;
+FUNC_GenericCommand CmdMakeFile;
+FUNC_GenericCommand CmdListDirectory;
+FUNC_GenericCommand CmdReadFile;
+FUNC_GenericCommand CmdWriteFile;
+FUNC_GenericCommand CmdSwap;
diff --git a/src_proiect/HAL9000/headers/cmd_interpreter.h b/src_proiect/HAL9000/headers/cmd_interpreter.h
new file mode 100644
index 0000000..e018aae
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_interpreter.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void
+CmdRun(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/cmd_net_helper.h b/src_proiect/HAL9000/headers/cmd_net_helper.h
new file mode 100644
index 0000000..04360e4
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_net_helper.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "cmd_common.h"
+
+FUNC_GenericCommand CmdListNetworks;
+FUNC_GenericCommand CmdNetRecv;
+FUNC_GenericCommand CmdNetSend;
+FUNC_GenericCommand CmdChangeDevStatus;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/cmd_proc_helper.h b/src_proiect/HAL9000/headers/cmd_proc_helper.h
new file mode 100644
index 0000000..b48b63f
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_proc_helper.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "cmd_common.h"
+
+FUNC_GenericCommand CmdListProcesses;
+FUNC_GenericCommand CmdProcessDump;
+FUNC_GenericCommand CmdStartProcess;
+FUNC_GenericCommand CmdTestProcess;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/cmd_sys_helper.h b/src_proiect/HAL9000/headers/cmd_sys_helper.h
new file mode 100644
index 0000000..ea9d287
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_sys_helper.h
@@ -0,0 +1,9 @@
+#pragma once
+
+#include "cmd_common.h"
+
+FUNC_GenericCommand CmdDisplaySysInfo;
+FUNC_GenericCommand CmdSetIdle;
+FUNC_GenericCommand CmdGetIdle;
+FUNC_GenericCommand CmdResetSystem;
+FUNC_GenericCommand CmdShutdownSystem;
diff --git a/src_proiect/HAL9000/headers/cmd_thread_helper.h b/src_proiect/HAL9000/headers/cmd_thread_helper.h
new file mode 100644
index 0000000..0461ea0
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cmd_thread_helper.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "cmd_common.h"
+
+FUNC_GenericCommand CmdListCpus;
+FUNC_GenericCommand CmdListThreads;
+FUNC_GenericCommand CmdYield;
+FUNC_GenericCommand CmdRunTest;
+FUNC_GenericCommand CmdSendIpi;
+FUNC_GenericCommand CmdListCpuInterrupts;
+FUNC_GenericCommand CmdTestTimer;
+FUNC_GenericCommand CmdCpuid;
+FUNC_GenericCommand CmdRdmsr;
+FUNC_GenericCommand CmdWrmsr;
+FUNC_GenericCommand CmdCheckAd;
+FUNC_GenericCommand CmdSpawnThreads;
diff --git a/src_proiect/HAL9000/headers/core.h b/src_proiect/HAL9000/headers/core.h
new file mode 100644
index 0000000..199f795
--- /dev/null
+++ b/src_proiect/HAL9000/headers/core.h
@@ -0,0 +1,21 @@
+#pragma once
+
+void
+CorePreinit(
+    void
+    );
+
+STATUS
+CoreInit(
+    void
+    );
+
+void
+CoreUpdateIdleTime(
+    IN  BOOLEAN             IdleScheduled
+    );
+
+DWORD
+CoreSetIdlePeriod(
+    IN  DWORD               SecondsForIdle
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/cpumu.h b/src_proiect/HAL9000/headers/cpumu.h
new file mode 100644
index 0000000..1160fb6
--- /dev/null
+++ b/src_proiect/HAL9000/headers/cpumu.h
@@ -0,0 +1,168 @@
+#pragma once
+
+#include "register.h"
+#include "tss.h"
+#include "cpu.h"
+#include "list.h"
+#include "synch.h"
+#include "cpu_structures.h"
+
+#define STACK_DEFAULT_SIZE          (8*PAGE_SIZE)
+#define STACK_GUARD_SIZE            (2*PAGE_SIZE)
+
+typedef struct _THREADING_DATA
+{
+    DWORD               RunningThreadTicks;
+    struct _THREAD*     IdleThread;
+    struct _THREAD*     CurrentThread;
+    struct _THREAD*     PreviousThread;
+
+    BOOLEAN             YieldOnInterruptReturn;
+
+    QWORD               IdleTicks;
+    QWORD               KernelTicks;
+} THREADING_DATA, *PTHREADING_DATA;
+
+typedef struct _PCPU
+{
+    struct _PCPU                *Self;
+
+    PVOID                       StackTop;
+    DWORD                       StackSize;
+
+    APIC_ID                     ApicId;
+    APIC_ID                     LogicalApicId;
+    BOOLEAN                     BspProcessor;
+
+    // TSS base address
+    TSS                         Tss;
+    PVOID                       TssStacks[NO_OF_IST];
+    BYTE                        NumberOfTssStacks;
+    WORD                        TrSelector;
+
+    LIST_ENTRY                  ListEntry;
+
+    BOOLEAN                     ApicInitialized;
+
+    THREADING_DATA              ThreadData;
+
+    // IPC data
+    LIST_ENTRY                  EventList;
+    LOCK                        EventListLock;
+    DWORD                       NoOfEventsInList;
+
+    // Used to mark the fact that the VMM specialized functions for
+    // allocating or freeing a VA reservation are working with the VA reservation
+    // space metadata (if #PFs occur on these pages a mapping must be created on
+    // the spot and they must be resolved)
+    BOOLEAN                     VmmMemoryAccess;
+    QWORD                       PageFaults;
+
+    QWORD                       InterruptsTriggered[NO_OF_TOTAL_INTERRUPTS];
+} PCPU, *PPCPU;
+STATIC_ASSERT_INFO(FIELD_OFFSET(PCPU,StackTop) == 0x8, "Used by _syscall.yasm:30 on syscalls to determine the user thread's kernel stack!");
+
+// This function should only be called when interrupts are disabled, else the CPU on which
+// the thread is running may change between the moment GetCurrentPcpu() was called and the moment
+// in which the pointer returned is actually used. This is an instance of a time of check to
+// time of use race condition.
+#define GetCurrentPcpu()    ((PCPU*)__readgsqword(FIELD_OFFSET(PCPU,Self)))
+#define SetCurrentPcpu(pc)  (__writemsr(IA32_GS_BASE_MSR,(pc)))
+
+void
+CpuMuPreinit(
+    void
+    );
+
+void
+CpuMuValidateConfiguration(
+    void
+    );
+
+STATUS
+CpuMuSetMonitorFilterSize(
+    IN          WORD        FilterSize
+    );
+
+STATUS
+CpuMuAllocAndInitCpu(
+    OUT_PTR     PPCPU*      PhysicalCpu,
+    IN _Strict_type_match_
+                APIC_ID     ApicId,
+    IN          DWORD       StackSize,
+    IN          BYTE        NoOfTssStacks
+    );
+
+STATUS
+CpuMuAllocCpu(
+    OUT_PTR     PPCPU*      PhysicalCpu,
+    IN _Strict_type_match_
+                APIC_ID     ApicId,
+    IN          DWORD       StackSize,
+    IN          BYTE        NumberOfTssStacks
+    );
+
+STATUS
+CpuMuInitCpu(
+    IN          PPCPU       PhysicalCpu,
+    IN          BOOLEAN     ChangeStack
+    );
+
+void
+CpuMuChangeStack(
+    IN          PVOID       NewStack
+    );
+
+BOOLEAN
+CpuMuIsPcidFeaturePresent(
+    void
+    );
+
+STATUS
+CpuMuActivateFpuFeatures(
+    void
+    );
+
+__forceinline
+IRQL
+CpuMuRaiseIrql(
+    IN IRQL Irql
+    )
+{
+    IRQL prevIrql = __readcr8();
+
+    ASSERT_INFO(prevIrql <= Irql, "Previous IRQL: 0x%x\nCurrent IRQL: 0x%x\n",
+                prevIrql, Irql );
+
+    __writecr8(Irql);
+
+    return prevIrql;
+}
+
+__forceinline
+IRQL
+CpuMuLowerIrql(
+    IN IRQL Irql
+    )
+{
+    IRQL prevIrql = __readcr8();
+
+    ASSERT_INFO(prevIrql >= Irql, "Previous IRQL: 0x%x\nCurrent IRQL: 0x%x\n",
+                prevIrql, Irql );
+
+    __writecr8(Irql);
+
+    return prevIrql;
+}
+
+#define CURRENT_CPU_MASK        0x8000'0000'0000'0000ULL
+
+__forceinline
+extern
+PVOID
+CpuGetCurrent(void)
+{
+    // warning C4306: 'type cast': conversion from 'BYTE' to 'PVOID' of greater size
+#pragma warning(suppress:4306)
+    return (PVOID) ( CURRENT_CPU_MASK | CpuGetApicId());
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/display.h b/src_proiect/HAL9000/headers/display.h
new file mode 100644
index 0000000..fff58cb
--- /dev/null
+++ b/src_proiect/HAL9000/headers/display.h
@@ -0,0 +1,104 @@
+#pragma once
+
+#define BASE_VIDEO_ADDRESS          0xB8000UL
+#define SCREEN_SIZE                 (CHARS_PER_LINE*LINES_PER_SCREEN*BYTES_PER_CHAR)
+
+// colors for printf
+#define BRIGHT_WHITE_COLOR          0xF
+#define YELLOW_COLOR                0xE
+#define BRIGHT_MAGENTA_COLOR        0xD
+#define BRIGHT_RED_COLOR            0xC
+#define BRIGHT_CYAN_COLOR           0xB
+#define BRIGHT_GREEN_COLOR          0xA        
+#define BRIGHT_BLUE_COLOR           0x9
+#define GRAY_COLOR                  0x8
+#define WHITE_COLOR                 0x7
+#define BROWN_COLOR                 0x6
+#define MAGENTA_COLOR               0x5
+#define RED_COLOR                   0x4
+#define CYAN_COLOR                  0x3
+#define GREEN_COLOR                 0x2
+#define BLUE_COLOR                  0x1
+#define BLACK_COLOR                 0x0
+
+// screen size
+#define CHARS_PER_LINE              80
+#define BYTES_PER_LINE              160
+#define LINES_PER_SCREEN            25
+
+#define BYTES_PER_CHAR              2
+
+typedef struct _SCREEN_POSITION
+{
+    BYTE        Line;
+    BYTE        Column;
+} SCREEN_POSITION, *PSCREEN_POSITION;
+
+typedef BYTE COLOR;
+
+void
+DispPreinitScreen(
+    IN      PVOID   VideoAddress,
+    IN      BYTE    IndexOfFirstUsableRow,
+    IN      BYTE    IndexOfFirstUnusableRow
+    );
+
+void
+DispClearScreen(
+    void
+    );
+
+void
+DispSetColor(
+    IN      COLOR           Color
+    );
+
+COLOR
+DispGetColor(
+    void
+    );
+
+
+//******************************************************************************
+// Function:      DispPrintString
+// Description: Prints a buffer to the screen
+// Returns:       void
+// Parameter:     IN char* Buffer - NULL terminated buffer
+// Parameter:     IN BYTE Color   - color to use
+// NOTE:        Not MP safe.
+//******************************************************************************
+void
+DispPrintString(
+    IN_Z    char*       Buffer
+    );
+
+void
+DispPutBufferColor(
+    IN_Z    char*       Buffer,
+    IN      BYTE        Line,
+    IN      BYTE        Column,
+    IN      COLOR       Color
+    );
+
+void
+DispClearLine(
+    IN      BYTE        Line
+    );
+
+void
+DispSetCursor(
+    IN      SCREEN_POSITION     CursorPosition,
+    IN      COLOR               Color
+    );
+
+STATUS
+DispStoreBuffer(
+    OUT_WRITES_BYTES(Size)  PVOID               Buffer,
+    IN                      DWORD               Size
+    );
+
+STATUS
+DispRestoreBuffer(
+    IN_READS_BYTES(Size)    PVOID               Buffer,
+    IN                      DWORD               Size
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_ata.h b/src_proiect/HAL9000/headers/dmp_ata.h
new file mode 100644
index 0000000..fb2087f
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_ata.h
@@ -0,0 +1,9 @@
+#pragma once
+
+#include "../../Ata/headers/ata_commands.h"
+
+
+void
+DumpAtaIdentifyCommand(
+    IN      PATA_IDENTIFY_RESPONSE          Identify
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_cmos.h b/src_proiect/HAL9000/headers/dmp_cmos.h
new file mode 100644
index 0000000..b9ccd53
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_cmos.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "cmos.h"
+
+void
+DumpCmos(
+    IN      PCMOS_DATA      CmosData
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_common.h b/src_proiect/HAL9000/headers/dmp_common.h
new file mode 100644
index 0000000..4208608
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_common.h
@@ -0,0 +1,26 @@
+#pragma once
+
+void
+DumpPreinit(
+    void
+    );
+
+REQUIRES_NOT_HELD_LOCK(m_dumpLock)
+RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
+INTR_STATE
+// Warning C28285 For function 'DumpTakeLock' 'return' syntax error
+// This is because SAL does not know who m_dumpLock is
+#pragma warning(suppress: 28285)
+DumpTakeLock(
+    void
+    );
+
+REQUIRES_EXCL_LOCK(m_dumpLock)
+RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
+void
+// Warning C28285 For function 'DumpTakeLock' 'return' syntax error
+// This is because SAL does not know who m_dumpLock is
+#pragma warning(suppress: 28285)
+DumpReleaseLock(
+    IN INTR_STATE   OldIntrState
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_cpu.h b/src_proiect/HAL9000/headers/dmp_cpu.h
new file mode 100644
index 0000000..e5ba849
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_cpu.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "cpu.h"
+#include "isr.h"
+
+void
+DumpRegisterArea(
+    IN  REGISTER_AREA*                  RegisterArea
+    );
+
+void
+DumpProcessorState(
+    IN  COMPLETE_PROCESSOR_STATE*       ProcessorState
+    );
+
+void
+DumpControlRegisters(
+    void
+    );
+
+void
+DumpInterruptStack(
+    IN  PINTERRUPT_STACK_COMPLETE       InterruptStack,
+    IN  BOOLEAN                         ErrorCodeValid
+    );
+
+void
+DumpFeatureInformation(
+    IN  PCPUID_FEATURE_INFORMATION       FeatureInformation
+    );
+
+void
+DumpCpuidValues(
+    IN  DWORD               Index,
+    IN  DWORD               SubIndex,
+    IN  CPUID_INFO          Cpuid
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_disk.h b/src_proiect/HAL9000/headers/dmp_disk.h
new file mode 100644
index 0000000..0b3edd4
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_disk.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "io.h"
+#include "../../Disk/headers/disk_structures.h"
+
+void
+DumpDisk(
+    IN      PDISK_OBJECT        Disk
+    );
+
+void
+DumpPartition(
+    IN      PPARTITION_INFORMATION  Partition
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_int15.h b/src_proiect/HAL9000/headers/dmp_int15.h
new file mode 100644
index 0000000..88ddb7b
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_int15.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "int15.h"
+
+void
+DumpInt15Entry(
+    IN  PINT15_MEMORY_MAP_ENTRY     MemoryMapEntry
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_io.h b/src_proiect/HAL9000/headers/dmp_io.h
new file mode 100644
index 0000000..25932db
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_io.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "io.h"
+
+FUNC_ListFunction           DumpVpb;
+
+void
+DumpDriverList(
+    IN      PLIST_ENTRY     DriverList
+    );
+
+void
+DumpDriver(
+    IN      PDRIVER_OBJECT  Driver
+    );
+
+void
+DumpDeviceList(
+    IN      PLIST_ENTRY     DeviceList
+    );
+
+void
+DumpDevice(
+    IN      PDEVICE_OBJECT  Device
+    );
diff --git a/src_proiect/HAL9000/headers/dmp_ioapic.h b/src_proiect/HAL9000/headers/dmp_ioapic.h
new file mode 100644
index 0000000..de0fdce
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_ioapic.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void
+DumpIoApic(
+    IN      PVOID       IoApicBaseAddress
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_lapic.h b/src_proiect/HAL9000/headers/dmp_lapic.h
new file mode 100644
index 0000000..4f6dfe2
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_lapic.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void
+DumpLapic(
+    IN      PVOID       LapicBaseAddress
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_mbr.h b/src_proiect/HAL9000/headers/dmp_mbr.h
new file mode 100644
index 0000000..8dfbb59
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_mbr.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "mbr.h"
+
+void
+DumpMbr(
+    IN      PMBR        Mbr
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_mdl.h b/src_proiect/HAL9000/headers/dmp_mdl.h
new file mode 100644
index 0000000..841f61e
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_mdl.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "mdl.h"
+
+void
+DumpMdl(
+    IN      PMDL        Mdl
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_memory.h b/src_proiect/HAL9000/headers/dmp_memory.h
new file mode 100644
index 0000000..07da771
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_memory.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#define DUMP_LINE_WIDTH         0x10
+
+#define LONG_ADDRESS_DIGITS     16
+
+void
+DumpMemory(
+    IN      PVOID           LogicalAddress,
+    IN      QWORD           Offset,
+    IN      DWORD           Size,
+    IN      BOOLEAN         DisplayAddress,
+    IN      BOOLEAN         DisplayAscii
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_multiboot.h b/src_proiect/HAL9000/headers/dmp_multiboot.h
new file mode 100644
index 0000000..756cb62
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_multiboot.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "multiboot.h"
+
+void
+DumpParameters(
+    IN ASM_PARAMETERS* Parameters
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_net_device.h b/src_proiect/HAL9000/headers/dmp_net_device.h
new file mode 100644
index 0000000..b9e1876
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_net_device.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "network.h"
+
+void
+DumpNetworkDevice(
+    IN      PNETWORK_DEVICE_INFO        NetworkDevice
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_network.h b/src_proiect/HAL9000/headers/dmp_network.h
new file mode 100644
index 0000000..12b7adb
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_network.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "network.h"
+
+void
+DumpEthernetFrame(
+    IN      PETHERNET_FRAME     Frame,
+    IN      DWORD               BufferSize
+    );
+
+void
+DumpArpPacket(
+    IN      PARP_PACKET         ArpPacket,
+    IN      DWORD               BufferSize
+    );
+
+void
+DumpIp4Packet(
+    IN      PIP4_PACKET         Ip4Packet,
+    IN      DWORD               BufferSize
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_nt.h b/src_proiect/HAL9000/headers/dmp_nt.h
new file mode 100644
index 0000000..3c95403
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_nt.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "pe_parser.h"
+
+void
+DumpNtHeader(
+    IN      PPE_NT_HEADER_INFO      NtHeader
+    );
+
+void
+DumpNtSection(
+    IN      PPE_SECTION_INFO        SectionInfo
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_pci.h b/src_proiect/HAL9000/headers/dmp_pci.h
new file mode 100644
index 0000000..dfb8b13
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_pci.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "pci_device.h"
+
+void
+DumpPciDevice(
+    IN  PPCI_DEVICE_DESCRIPTION     Device
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_process.h b/src_proiect/HAL9000/headers/dmp_process.h
new file mode 100644
index 0000000..01ad872
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_process.h
@@ -0,0 +1,8 @@
+#pragma once
+
+typedef struct _PROCESS* PPROCESS;
+
+void
+DumpProcess(
+    IN  PPROCESS    Process
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/dmp_volume.h b/src_proiect/HAL9000/headers/dmp_volume.h
new file mode 100644
index 0000000..77f22a8
--- /dev/null
+++ b/src_proiect/HAL9000/headers/dmp_volume.h
@@ -0,0 +1,9 @@
+#pragma once
+
+#include "io.h"
+#include "../../Volume/headers/volume_structures.h"
+
+void
+DumpVolume(
+    IN      PVOLUME     Volume
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/ex_system.h b/src_proiect/HAL9000/headers/ex_system.h
new file mode 100644
index 0000000..0dd21c8
--- /dev/null
+++ b/src_proiect/HAL9000/headers/ex_system.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void
+ExSystemTimerTick(
+    void
+    );
diff --git a/src_proiect/HAL9000/headers/ex_timer.h b/src_proiect/HAL9000/headers/ex_timer.h
new file mode 100644
index 0000000..5893c55
--- /dev/null
+++ b/src_proiect/HAL9000/headers/ex_timer.h
@@ -0,0 +1,118 @@
+#pragma once
+
+typedef enum _EX_TIMER_TYPE
+{
+    ExTimerTypeAbsolute,
+    ExTimerTypeRelativeOnce,
+    ExTimerTypeRelativePeriodic,
+    ExTimerTypeMax = ExTimerTypeRelativePeriodic
+} EX_TIMER_TYPE;
+
+typedef struct _EX_TIMER
+{
+    // absolute time
+    QWORD               TriggerTimeUs;
+
+    // valid only if timer is periodic
+    QWORD               ReloadTimeUs;
+
+    EX_TIMER_TYPE       Type;
+
+    volatile BOOLEAN    TimerStarted;
+    BOOLEAN             TimerUninited;
+} EX_TIMER, *PEX_TIMER;
+
+//******************************************************************************
+// Function:     ExTimerInit
+// Description:  Initializes a timer to trigger to trigger at a specified time.
+//               Once this function returns, the timer can be waited by multiple
+//               threads at once. When the timer triggers - no matter its type -
+//               all the threads waiting on it must be woken up.
+// Returns:      STATUS
+// Parameter:    OUT PEX_TIMER Timer - Timer to initialize
+// Parameter:    IN EX_TIMER_TYPE Type - Defines the periodicity of the timer
+//               (one-shot or periodic) and defines the meaning of the 3rd
+//               parameter (if absolute or relative to the current time).
+// Parameter:    IN QWORD TimeUs
+//
+// Examples:
+// Initialize a one-shot timer to trigger after 1 second:
+// ExTimerInit(&timer, ExTimerTypeRelativeOnce, 1 * SEC_IN_US);
+//
+// Initialize a periodic timer to trigger every minute:
+// ExTimerInit(&timer, ExTimerTypeRleativePeriodic, 60 * SEC_IN_US);
+//
+// Initialize an absolute timer after the OS has run 2 minutes:
+// ExTimerInit(&timer, ExTimerTypeAbsolute, 120 * SEC_IN_US);
+//******************************************************************************
+STATUS
+ExTimerInit(
+    OUT     PEX_TIMER       Timer,
+    IN      EX_TIMER_TYPE   Type,
+    IN      QWORD           TimeUs
+    );
+
+//******************************************************************************
+// Function:     ExTimerStart
+// Description:  Starts the timer countdown. If the time has already elapsed all
+//               the waiting threads must be woken up.
+// Returns:      void
+// Parameter:    IN PEX_TIMER Timer
+//******************************************************************************
+void
+ExTimerStart(
+    IN      PEX_TIMER       Timer
+    );
+
+//******************************************************************************
+// Function:     ExTimerStop
+// Description:  Stops the timer countdown. All the threads waiting must be
+//               woken up.
+// Returns:      void
+// Parameter:    IN PEX_TIMER Timer
+//******************************************************************************
+void
+ExTimerStop(
+    IN      PEX_TIMER       Timer
+    );
+
+//******************************************************************************
+// Function:     ExTimerWait
+// Description:  Called by a thread to wait for the timer to trigger. If the
+//               timer already triggered and it's not periodic or if the timer
+//               is uninitialized this function must return instantly.
+// Returns:      void
+// Parameter:    INOUT PEX_TIMER Timer
+//******************************************************************************
+void
+ExTimerWait(
+    INOUT   PEX_TIMER       Timer
+    );
+
+//******************************************************************************
+// Function:     ExTimerUninit
+// Description:  Uninitialized a timer. It may not be used in the future without
+//               calling the ExTimerInit function. All threads waiting for the
+//               timer must be woken up.
+// Returns:      void
+// Parameter:    INOUT PEX_TIMER Timer
+//******************************************************************************
+void
+ExTimerUninit(
+    INOUT   PEX_TIMER       Timer
+    );
+
+//******************************************************************************
+// Function:     ExTimerCompareTimers
+// Description:  Utility function to compare to two timers.
+// Returns:      INT64 - if NEGATIVE => the first timers trigger time is earlier
+//                     - if 0 => the timers trigger time is equal
+//                     - if POSITIVE => the first timers trigger time is later
+// Parameter:    IN PEX_TIMER FirstElem
+// Parameter:    IN PEX_TIMER SecondElem
+//******************************************************************************
+INT64
+ExTimerCompareTimers(
+    IN      PEX_TIMER     FirstElem,
+    IN      PEX_TIMER     SecondElem
+    );
diff --git a/src_proiect/HAL9000/headers/gdtmu.h b/src_proiect/HAL9000/headers/gdtmu.h
new file mode 100644
index 0000000..64457a3
--- /dev/null
+++ b/src_proiect/HAL9000/headers/gdtmu.h
@@ -0,0 +1,68 @@
+#pragma once
+
+typedef struct _TSS*        PTSS;
+
+STATUS
+GdtMuInit(
+    void
+    );
+
+STATUS
+GdtMuInstallTssDescriptor(
+    OUT     PTSS            Tss,
+    IN_RANGE(1,NO_OF_IST)
+            BYTE            NumberOfStacks,
+    IN_READS(NumberOfStacks)
+            PVOID*          Stacks,
+    OUT_OPT WORD*           Selector
+    );
+
+typedef enum _SEL_OP_MODE
+{
+    SelOpMode32,
+    SelOpMode64,
+    SelOpMode16,
+    SelOpModeReserved = SelOpMode16 + 1
+} SEL_OP_MODE;
+
+typedef enum _SEL_PRIV
+{
+    SelPrivillegeSupervisor,
+    SelPrivillegeUsermode,
+    SelPrivillegeReserved = SelPrivillegeUsermode + 1
+} SEL_PRIV;
+
+typedef enum _SEL_TYPE
+{
+    SelTypeCode,
+    SelTypeData,
+    SelTypeReserved = SelTypeData + 1
+} SEL_TYPE;
+
+WORD
+GdtMuRetrieveSelectorIndex(
+    IN      SEL_PRIV        Privillege,
+    IN      SEL_OP_MODE     Mode,
+    IN      SEL_TYPE        Type
+    );
+
+void
+GdtMuReload(
+    IN          WORD            CodeSelector,
+    IN          WORD            DataSelector,
+    IN          BOOLEAN         PreserveGsBase,
+    IN          BOOLEAN         PreserveFsBase
+    );
+
+#define GdtMuGetCS64Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeCode)
+#define GdtMuGetDS64Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeData)
+#define GdtMuGetCS32Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode32, SelTypeCode)
+#define GdtMuGetDS32Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode32, SelTypeData)
+#define GdtMuGetCS16Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode16, SelTypeCode)
+#define GdtMuGetDS16Supervisor()        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode16, SelTypeData)
+#define GdtMuGetCS64Usermode()          GdtMuRetrieveSelectorIndex(SelPrivillegeUsermode, SelOpMode64, SelTypeCode)
+#define GdtMuGetDS64Usermode()          GdtMuRetrieveSelectorIndex(SelPrivillegeUsermode, SelOpMode64, SelTypeData)
+#define GdtMuGetCS32Usermode()          GdtMuRetrieveSelectorIndex(SelPrivillegeUsermode, SelOpMode32, SelTypeCode)
+#define GdtMuGetDS32Usermode()          GdtMuRetrieveSelectorIndex(SelPrivillegeUsermode, SelOpMode32, SelTypeData)
+#define GdtMuGetCS16Usermode()          GdtMuRetrieveSelectorIndex(SelPrivillegeUsermode, SelOpMode16, SelTypeCode)
+#define GdtMuGetDS16Usermode()          GdtMuRetrieveSelectorIndex(SelPrivillegeUsermode, SelOpMode16, SelTypeData)
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/hal_assert.h b/src_proiect/HAL9000/headers/hal_assert.h
new file mode 100644
index 0000000..7475de9
--- /dev/null
+++ b/src_proiect/HAL9000/headers/hal_assert.h
@@ -0,0 +1,5 @@
+#pragma once
+
+#include "assert.h"
+
+FUNC_AssertFunction                 Hal9000Assert;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/idt_handlers.h b/src_proiect/HAL9000/headers/idt_handlers.h
new file mode 100644
index 0000000..249fac9
--- /dev/null
+++ b/src_proiect/HAL9000/headers/idt_handlers.h
@@ -0,0 +1,51 @@
+#pragma once
+
+typedef enum _EXCEPTION
+{
+    ExceptionDivideError                = 0,
+    ExceptionDebugException,
+    ExceptionNMI,
+    ExceptionBreakpoint,
+    ExceptionOverflow,
+    ExceptionBoundRange,
+    ExceptionInvalidOpcode,
+    ExceptionDeviceNotAvailable,
+    ExceptionDoubleFault,
+    ExceptionCoprocOverrun,
+    ExceptionInvalidTSS,
+    ExceptionSegmentNotPresent,
+    ExceptionStackFault,
+    ExceptionGeneralProtection,
+    ExceptionPageFault                  = 14,
+    ExceptionX87FpuException            = 16,
+    ExceptionAlignmentCheck,
+    ExceptionMachineCheck,
+    ExceptionSIMDFpuException,
+    ExceptionVirtualizationException
+} EXCEPTION;
+
+typedef enum _INTERRUPT
+{
+    InterruptTimer              = 32,
+    InterruptKeyboard,
+    InterruptCascade,
+    InterruptCOM2,
+    InterruptCOM1,
+    InterruptDiskette           = 38,
+    InterruptLPT1,
+    InterruptCmosRTC,
+    InterruptCGA,
+    InterruptFPU                = 45,
+    InterruptHdController
+} INTERRUPT;
+
+#define     NO_OF_IDT_ENTRIES               MAX_BYTE
+
+#define     IVT_ENTRY_SIZE                  4
+#define     IVT_LIMIT                       0x3FF
+
+STATUS
+InitIdtHandlers(
+    IN      WORD                CodeSelector,
+    IN      BYTE                NumberOfTssStacks
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/ioapic_system.h b/src_proiect/HAL9000/headers/ioapic_system.h
new file mode 100644
index 0000000..b00679c
--- /dev/null
+++ b/src_proiect/HAL9000/headers/ioapic_system.h
@@ -0,0 +1,66 @@
+#pragma once
+
+#include "apic_common.h"
+
+_No_competing_thread_
+void
+IoApicSystemPreinit(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+IoApicSystemInit(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+IoApicLateSystemInit(
+    void
+    );
+
+_No_competing_thread_
+void
+IoApicSystemEnableRegisteredInterrupts(
+    void
+    );
+
+STATUS
+IoApicSystemSetInterrupt(
+    IN      BYTE                    Irq,
+    IN      BYTE                    Vector,
+    IN _Strict_type_match_
+            APIC_DESTINATION_MODE   DestinationMode,
+    IN _Strict_type_match_
+            APIC_DELIVERY_MODE      DeliveryMode,
+    IN _Strict_type_match_
+            APIC_PIN_POLARITY       PinPolarity,
+    IN  _Strict_type_match_
+            APIC_TRIGGER_MODE       TriggerMode,
+    IN      APIC_ID                 Destination,
+    IN      BOOLEAN                 Overwrite
+    );
+
+void
+IoApicSystemMaskInterrupt(
+    IN      BYTE                    Irq,
+    IN      BOOLEAN                 Mask
+    );
+
+STATUS
+IoApicSystemGetVectorForIrq(
+    IN      BYTE                    Irq,
+    OUT     PBYTE                   Vector
+    );
+
+DWORD
+IoApicGetInterruptLineForPciDevice(
+    IN      struct _PCI_DEVICE_DESCRIPTION* PciDevice
+    );
+
+__declspec(deprecated)
+void
+IoApicSystemSendEOI(
+    IN      BYTE                Vector
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/iomu.h b/src_proiect/HAL9000/headers/iomu.h
new file mode 100644
index 0000000..42e44bb
--- /dev/null
+++ b/src_proiect/HAL9000/headers/iomu.h
@@ -0,0 +1,126 @@
+#pragma once
+
+#include "io.h"
+
+void
+_No_competing_thread_
+IomuPreinitSystem(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+IomuInitSystem(
+    IN      WORD            CodeSelector,
+    IN      BYTE            NumberOfTssStacks
+    );
+
+STATUS
+IomuInitSystemAfterApWakeup(
+    void
+    );
+
+STATUS
+IomuInitSystemDriver(
+    void
+    );
+
+STATUS
+IomuLateInit(
+    void
+    );
+
+const char*
+IomuGetSystemPartitionPath(
+    void
+    );
+
+PFILE_OBJECT
+IomuGetSwapFile(
+    void
+    );
+
+void
+IomuAckInterrupt(
+    IN      BYTE            InterruptIndex
+    );
+
+PDRIVER_OBJECT
+IomuGetDriverByName(
+    IN_Z    char*           DriverName
+    );
+
+void
+IomuDriverInstalled(
+    IN      PDRIVER_OBJECT  Driver
+    );
+
+PLIST_ENTRY
+IomuGetPciDeviceList(
+    void
+    );
+
+STATUS
+IomuGetDevicesByType(
+    IN_RANGE_UPPER(DeviceTypeMax)
+                                    DEVICE_TYPE         DeviceType,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+                                    PDEVICE_OBJECT**    DeviceObjects,
+    OUT                             DWORD*              NumberOfDevices
+    );
+
+void
+IomuNewVpbCreated(
+    INOUT       struct _VPB*        Vpb
+    );
+
+void
+IomuExecuteForEachVpb(
+    IN          PFUNC_ListFunction  Function,
+    IN_OPT      PVOID               Context,
+    IN          BOOLEAN             Exclusive
+    );
+
+PTR_SUCCESS
+PVPB
+IomuSearchForVpb(
+    IN          char                DriveLetter
+    );
+
+STATUS
+IomuRegisterInterrupt(
+    IN          PIO_INTERRUPT           Interrupt,
+    IN_OPT      PDEVICE_OBJECT          DeviceObject,
+    OUT_OPT     PBYTE                   Vector
+    );
+
+QWORD
+IomuGetSystemTicks(
+    OUT_OPT     QWORD*                  TickFrequency
+    );
+
+QWORD
+IomuGetSystemTimeUs(
+    void
+    );
+
+QWORD
+IomuTickCountToUs(
+    IN          QWORD                   TickCount
+    );
+
+void
+IomuCmosUpdateOccurred(
+    void
+    );
+
+DWORD
+IomuGetTimerInterrupTimeUs(
+    void
+    );
+
+BOOLEAN
+IomuIsInterruptSpurious(
+    IN          BYTE                    Vector
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/ipc.h b/src_proiect/HAL9000/headers/ipc.h
new file mode 100644
index 0000000..a06bf36
--- /dev/null
+++ b/src_proiect/HAL9000/headers/ipc.h
@@ -0,0 +1,43 @@
+#pragma once
+
+#include "ref_cnt.h"
+
+typedef
+STATUS
+(__cdecl FUNC_IpcProcessEvent)(
+    IN_OPT  PVOID   Context
+    );
+
+typedef FUNC_IpcProcessEvent* PFUNC_IpcProcessEvent;
+
+typedef struct _IPC_EVENT_CPU
+{
+    LIST_ENTRY              ListEntry;
+    struct _IPC_EVENT*      Event;
+} IPC_EVENT_CPU, *PIPC_EVENT_CPU;
+
+_Ret_writes_maybenull_(NumberOfCpus)
+PTR_SUCCESS
+PIPC_EVENT_CPU
+IpcGenerateEvent(
+    IN      PFUNC_IpcProcessEvent   BroadcastFunction,
+    IN_OPT  PVOID                   Context,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   FreeContext,
+    IN      BOOLEAN                 WaitForHandling,
+    IN_RANGE_LOWER(1)      
+            DWORD                   NumberOfCpus
+    );
+
+void
+IpcWaitForEventHandling(
+    _Pre_valid_ _Post_ptr_invalid_
+            PIPC_EVENT_CPU          Event
+    );
+
+STATUS
+IpcProcessEvent(
+    _Pre_valid_ _Post_ptr_invalid_
+            PIPC_EVENT_CPU      CpuEvent,
+    OUT     STATUS*             FunctionStatus
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/isr.h b/src_proiect/HAL9000/headers/isr.h
new file mode 100644
index 0000000..15a09ba
--- /dev/null
+++ b/src_proiect/HAL9000/headers/isr.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#pragma pack(push)
+#pragma pack(1)
+typedef struct _INTERRUPT_STACK
+{
+    QWORD                       Rip;
+    QWORD                       CS;
+    QWORD                       RFLAGS;
+    QWORD                       Rsp;
+    QWORD                       SS;
+} INTERRUPT_STACK, *PINTERRUPT_STACK;
+
+typedef struct _INTERRUPT_STACK_COMPLETE
+{
+    QWORD                       ErrorCode;
+    INTERRUPT_STACK             Registers;
+} INTERRUPT_STACK_COMPLETE, *PINTERRUPT_STACK_COMPLETE;
+#pragma pack(pop)
+
+typedef
+BOOLEAN
+(__cdecl FUNC_IsrRoutine)(
+    IN_OPT  PVOID               Context
+    );
+
+typedef FUNC_IsrRoutine*        PFUNC_IsrRoutine;
+
+STATUS
+IsrInstallEx(
+    IN      BYTE                Vector,
+    IN      PFUNC_IsrRoutine    IsrRoutine,
+    IN_OPT  PVOID               Context
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/keyboard.h b/src_proiect/HAL9000/headers/keyboard.h
new file mode 100644
index 0000000..d5669c6
--- /dev/null
+++ b/src_proiect/HAL9000/headers/keyboard.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "scan_codes.h"
+
+// A Make Code is sent when a key is pressed or held down
+// A Break code is sent when a key is released
+
+STATUS
+KeyboardInitialize(
+    IN      BYTE        InterruptIrq
+    );
+
+_Success_(KEY_UNKNOWN!=return)
+KEYCODE
+KeyboardGetLastKey(
+    void
+    );
+
+_Success_(KEY_UNKNOWN != return)
+KEYCODE
+KeyboardWaitForKey(
+    void
+    );
+
+void
+KeyboardDiscardLastKey(
+    void
+    );
+
+char
+KeyboardKeyToAscii(
+    IN      KEYCODE     KeyCode
+    );
+
+void
+KeyboardResetSystem(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/keyboard_utils.h b/src_proiect/HAL9000/headers/keyboard_utils.h
new file mode 100644
index 0000000..fa1e95b
--- /dev/null
+++ b/src_proiect/HAL9000/headers/keyboard_utils.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "scan_codes.h"
+
+KEYCODE
+getch(
+    void
+    );
+
+void
+gets_s(
+    OUT_WRITES_Z(BufferSize)    char*       Buffer,
+    IN                          DWORD       BufferSize,
+    OUT                         DWORD*      UsedSize
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/lapic_system.h b/src_proiect/HAL9000/headers/lapic_system.h
new file mode 100644
index 0000000..5e3927c
--- /dev/null
+++ b/src_proiect/HAL9000/headers/lapic_system.h
@@ -0,0 +1,71 @@
+#pragma once
+
+#include "lapic.h"
+
+STATUS
+LapicSystemInit(
+    void
+    );
+
+STATUS
+LapicSystemInitializeCpu(
+    IN      BYTE                            TimerInterruptVector
+    );
+
+// Disables or enables the LAPIC in SW
+void
+LapicSystemSetState(
+    IN      BOOLEAN                         Enable
+    );
+
+BOOLEAN
+LapicSystemGetState(
+    void
+    );
+
+void
+LapicSystemSendEOI(
+    IN      BYTE                            Vector
+    );
+
+//******************************************************************************
+// Function:     LapicSystemSetTimer
+// Description:  Enables the LAPIC timer on the current CPU to trigger every
+//               Microseconds ms. If the argument is 0 the timer is stopped.
+// Parameter:    IN DWORD Microseconds - Trigger period in microseconds.
+// Parameter:    OUT_PTR PTHREAD * Thread
+// NOTE:         This only programs the LAPIC timer on the current CPU.
+//******************************************************************************
+void
+LapicSystemSetTimer(
+    IN      DWORD                           Microseconds
+    );
+
+void
+LapicSystemSendIpi(
+    _When_(ApicDestinationShorthandNone == DeliveryMode, IN)
+    _When_(ApicDestinationShorthandNone != DeliveryMode, _Reserved_)
+            APIC_ID                         ApicId,
+    IN      _Strict_type_match_
+            APIC_DELIVERY_MODE              DeliveryMode,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_SHORTHAND      DestinationShorthand,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_MODE           DestinationMode,
+    IN_OPT  BYTE*                           Vector
+    );
+
+BYTE
+LapicSystemGetPpr(
+    void
+    );
+
+QWORD
+LapicSystemGetTimerElapsedUs(
+    void
+    );
+
+BOOLEAN
+LapicSystemIsInterruptServiced(
+    IN      BYTE                            Vector
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/mdl.h b/src_proiect/HAL9000/headers/mdl.h
new file mode 100644
index 0000000..f8229bf
--- /dev/null
+++ b/src_proiect/HAL9000/headers/mdl.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#define MdlAllocate(...)            MdlAllocateEx(__VA_ARGS__, __readcr3(), NULL)
+
+typedef struct _PAGING_LOCK_DATA*   PPAGING_LOCK_DATA;
+
+PTR_SUCCESS
+PMDL
+MdlAllocateEx(
+    IN          PVOID               VirtualAddress,
+    IN          DWORD               Length,
+    IN_OPT      PHYSICAL_ADDRESS    Cr3,
+    IN_OPT      PPAGING_LOCK_DATA   PagingData
+    );
+
+void
+MdlFree(
+    INOUT       PMDL            Mdl
+    );
+
+DWORD
+MdlGetNumberOfPairs(
+    IN          PMDL            Mdl
+    );
+
+PTR_SUCCESS
+PMDL_TRANSLATION_PAIR
+MdlGetTranslationPair(
+    IN          PMDL            Mdl,
+    IN          DWORD           Index
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/mmu.h b/src_proiect/HAL9000/headers/mmu.h
new file mode 100644
index 0000000..2b5aa87
--- /dev/null
+++ b/src_proiect/HAL9000/headers/mmu.h
@@ -0,0 +1,442 @@
+#pragma once
+
+#include "mem_structures.h"
+#include "lock_common.h"
+
+typedef struct _PROCESS* PPROCESS;
+typedef struct _PE_NT_HEADER_INFO *PPE_NT_HEADER_INFO;
+
+/// TODO: Move BasePhysicalAddress and KernelSpace outside protected region
+typedef struct _PAGING_DATA
+{
+    PHYSICAL_ADDRESS        BasePhysicalAddress;
+
+    // because we don't have any functions to unmap
+    // paging structures (and we probably won't need to)
+    // there is no use in using a bitmap
+    DWORD                   NumberOfFrames;
+    DWORD                   CurrentIndex;
+
+    BOOLEAN                 KernelSpace;
+} PAGING_DATA, *PPAGING_DATA;
+
+typedef struct _PAGING_LOCK_DATA
+{
+    /// TODO: investigate if we really need a recursive lock here
+    REC_RW_SPINLOCK                 Lock;
+
+    _Guarded_by_(Lock)
+    PAGING_DATA                     Data;
+} PAGING_LOCK_DATA, *PPAGING_LOCK_DATA;
+
+// These map/unmap memory only in the context of the system process
+#define MmuMapSystemMemory(Pa,Sz)   MmuMapMemoryEx((Pa),(Sz),PAGE_RIGHTS_READWRITE, FALSE, FALSE, NULL)
+#define MmuUnmapSystemMemory(Va,Sz) MmuUnmapMemoryEx((Va),(Sz),FALSE, NULL)
+
+_No_competing_thread_
+void
+MmuPreinitSystem(
+    void
+    );
+
+//******************************************************************************
+// Function:     MmuInitSystem
+// Description:  Initializes the PMM, VMM, creates a new set of paging tables
+//               and performs a CR3 switch to them. Initializes the heaps and
+//               switches to a new stack.
+// Returns:      STATUS
+// Parameter:    IN PVOID KernelBaseAddress
+// Parameter:    IN DWORD KernelSize
+// Parameter:    IN PHYSICAL_ADDRESS MemoryEntries
+// Parameter:    IN DWORD NumberOfMemoryEntries
+//******************************************************************************
+_No_competing_thread_
+STATUS
+MmuInitSystem(
+    IN          PVOID                   KernelBaseAddress,
+    IN          DWORD                   KernelSize,
+    IN          PHYSICAL_ADDRESS        MemoryEntries,
+    IN          DWORD                   NumberOfMemoryEntries
+    );
+
+//******************************************************************************
+// Function:     MmuDiscardIdentityMappings
+// Description:  Discards the identitiy memmory mapped regions required for AP
+//               initialization.
+// Returns:      void
+//******************************************************************************
+_No_competing_thread_
+void
+MmuDiscardIdentityMappings(
+    void
+    );
+
+
+//******************************************************************************
+// Function:     MmuInitThreadingSystem
+// Description:  Creates the worker thread responsible for zero-ing physical
+//               frames after they have been released.
+// Returns:      STATUS
+//******************************************************************************
+STATUS
+MmuInitThreadingSystem(
+    void
+    );
+
+//******************************************************************************
+// Function:     MmuGetTotalSystemMemory
+// Description:  Returns the number of bytes of physical memory available in the
+//               system.
+// Returns:      QWORD
+// NOTE:         This is the initial value on system boot. It is not updated as
+//               more memory is reserved by the OS.
+//******************************************************************************
+QWORD
+MmuGetTotalSystemMemory(
+    void
+    );
+
+//******************************************************************************
+// Function:     MmuGetHighestPhysicalMemoryAddressPresent
+// Description:  Returns the largest physical address present on the system.
+// Returns:      PHYSICAL_ADDRESS
+// NOTE:         This also includes already reserved device memory.
+//******************************************************************************
+PHYSICAL_ADDRESS
+MmuGetHighestPhysicalMemoryAddressPresent(
+    void
+    );
+
+//******************************************************************************
+// Function:     MmuMapMemoryEx
+// Description:  Maps a physical address range into virtual address space.
+// Returns:      PVOID - Resulting mapping for PhysicalAddress
+// Parameter:    IN PHYSICAL_ADDRESS PhysicalAddress
+// Parameter:    IN DWORD Size
+// Parameter:    IN PAGE_RIGHTS PageRights
+// Parameter:    IN BOOLEAN Invalidate - If TRUE modifies paging structure even
+//               if it was already mapped.
+// Parameter:    IN BOOLEAN Uncacheable
+// Parameter:    IN_OPT PPAGING_LOCK_DATA PagingData - Paging structures to use,
+//               if NULL maps only to kernel space.
+//******************************************************************************
+PTR_SUCCESS
+PVOID
+MmuMapMemoryEx(
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    );
+
+//******************************************************************************
+// Function:     MmuMapMemoryInternal
+// Description:  Maps a physical address range into the specified virtual
+//               address space.
+// Returns:      void
+// Parameter:    IN PHYSICAL_ADDRESS PhysicalAddress
+// Parameter:    IN DWORD Size
+// Parameter:    IN PAGE_RIGHTS PageRights
+// Parameter:    IN PVOID VirtualAddress
+// Parameter:    IN BOOLEAN Invalidate
+// Parameter:    IN BOOLEAN Uncacheable
+/// NOTE:        This should only be used by ap_tramp, vmm and no other modules.
+//******************************************************************************
+void
+MmuMapMemoryInternal(
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      PVOID                   VirtualAddress,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    );
+
+//******************************************************************************
+// Function:     MmuUnmapMemory
+// Description:  Unmaps a previously mapped memory region.
+// Returns:      void
+// Parameter:    IN PVOID VirtualAddress
+// Parameter:    IN DWORD Size
+//******************************************************************************
+void
+MmuUnmapMemoryEx(
+    IN      PVOID                   VirtualAddress,
+    IN      QWORD                   Size,
+    IN      BOOLEAN                 ReleaseMemory,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    );
+
+//******************************************************************************
+// Function:     MmuReleaseMemory
+// Description:  Schedules NoOfFrames frames of physical memory to be released
+//               by the zero worker thread after being zeroed.
+// Returns:      void
+// Parameter:    IN PHYSICAL_ADDRESS PhysicalAddr
+// Parameter:    IN DWORD NoOfFrames
+//******************************************************************************
+void
+MmuReleaseMemory(
+    IN          PHYSICAL_ADDRESS        PhysicalAddr,
+    IN          DWORD                   NoOfFrames
+    );
+
+//******************************************************************************
+// Function:     MmuGetPhysicalAddress
+// Description:  Returns the physical address mapping for VirtualAddress using
+//               the current CR3 paging structures.
+// Returns:      PHYSICAL_ADDRESS
+// Parameter:    IN PVOID VirtualAddress
+//******************************************************************************
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+MmuGetPhysicalAddress(
+    IN      PVOID                   VirtualAddress
+    );
+
+//******************************************************************************
+// Function:     MmuGetPhysicalAddressEx
+// Description:  Returns the physical address mapping for VirtualAddress using
+//               either the PagingData parameter or the Cr3Base parameter.
+// Returns:      PTR_SUCCESS
+// Parameter:    IN PVOID VirtualAddress
+// Parameter:    IN_OPT PPAGING_LOCK_DATA PagingData
+// Parameter:    IN_OPT PHYSICAL_ADDRESS Cr3Base
+// NOTE:         PagingData and Cr3Base cannot both be non-NULL.
+//******************************************************************************
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+MmuGetPhysicalAddressEx(
+    IN      PVOID                   VirtualAddress,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData,
+    IN_OPT  PHYSICAL_ADDRESS        Cr3Base
+    );
+
+//******************************************************************************
+// Function:     MmuAllocatePoolWithTag
+// Description:  Allocates AllocationSize bytes of memory aligned at
+//               AllocationAlignment bytes.
+// Returns:      PVOID
+// Parameter:    IN DWORD Flags - if PoolAllocateZeroMemory is specified then
+//               memory will be initialized to zero before returning from this
+//               function.
+// Parameter:    IN DWORD AllocationSize
+// Parameter:    IN DWORD Tag - Used to validate memory de-allocation does not
+//               free random, unwanted memory addresses. Also, useful for
+//               debugging, when tracing leaks.
+// Parameter:    IN DWORD AllocationAlignment - If zero => the address will
+//               be use the NATURAL_ALIGNMENT constant for determining the
+//               alignment.
+//******************************************************************************
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+MmuAllocatePoolWithTag(
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    );
+
+//******************************************************************************
+// Function:     MmuFreePoolWithTag
+// Description:  Frees a previously allocated memory region.
+// Returns:      void
+// Parameter:    PVOID MemoryAddress
+// Parameter:    IN DWORD Tag - Must match the tag used for allocating the
+//               memory region.
+//******************************************************************************
+void
+MmuFreePoolWithTag(
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    );
+
+//******************************************************************************
+// Function:     MmuProbeMemory
+// Description:  Ensures the virtual memory described by the Buffer is mapped
+//               to physical addresses.
+// Returns:      void
+// Parameter:    IN PVOID Buffer
+// Parameter:    IN DWORD NumberOfBytes
+//******************************************************************************
+void
+MmuProbeMemory(
+    IN      PVOID                   Buffer,
+    IN      DWORD                   NumberOfBytes
+    );
+
+//******************************************************************************
+// Function:     MmuSolvePageFault
+// Description:  Attempts to handle the page fault ocurrred when accessing
+//               FaultingAddress.
+// Returns:      BOOLEAN
+// Parameter:    IN PVOID FaultingAddress
+// Parameter:    IN DWORD ErrorCode
+//******************************************************************************
+BOOLEAN
+MmuSolvePageFault(
+    IN      PVOID                   FaultingAddress,
+    IN      DWORD                   ErrorCode
+    );
+
+//******************************************************************************
+// Function:     MmuLoadPe
+// Description:  Maps a PE eagerly to a VA using the paging structures specified
+//               as a parameter. Currently the file alignment and the section
+//               alignment need to be equal for this to be possible.
+// Returns:      STATUS
+// Parameter:    IN PPE_NT_HEADER_INFO NtHeader - The parsed PE header
+// Parameter:    IN PPAGING_LOCK_DATA PagingData - The paging data of the process
+//               in which to map.
+//******************************************************************************
+STATUS
+MmuLoadPe(
+    IN      PPE_NT_HEADER_INFO      NtHeader,
+    IN      PPAGING_LOCK_DATA       PagingData
+    );
+
+//******************************************************************************
+// Function:     MmuCreateAddressSpaceForProcess
+// Description:  Creates both the physical paging structures and the VAS for a
+//               process.
+// Returns:      STATUS
+// Parameter:    INOUT PPROCESS Process
+//******************************************************************************
+STATUS
+MmuCreateAddressSpaceForProcess(
+    INOUT   PPROCESS                Process
+    );
+
+//******************************************************************************
+// Function:     MmuDestroyAddressSpaceForProcess
+// Description:  Destroys a previously created address space.
+// Returns:      void
+// Parameter:    INOUT PPROCESS Process
+//******************************************************************************
+void
+MmuDestroyAddressSpaceForProcess(
+    INOUT   PPROCESS                Process
+    );
+
+//******************************************************************************
+// Function:     MmuInitVirtualSpaceForSystemProcess
+// Description:  Initializes the address space for the system process.
+// Returns:      void
+//******************************************************************************
+_No_competing_thread_
+void
+MmuInitAddressSpaceForSystemProcess(
+    void
+    );
+
+//******************************************************************************
+// Function:     MmuActivateProcessIds
+// Description:  Activates PCIDs for the current CPU and reloads the CR3 with
+//               the running processes's ID.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+MmuActivateProcessIds(
+    void
+    );
+
+//******************************************************************************
+// Function:     MmuActivateProcessIds
+// Description:  Switches to the address space of a different process.
+// Returns:      void
+// Parameter:    IN PPROCESS Process
+//******************************************************************************
+void
+MmuChangeProcessSpace(
+    IN          PPROCESS            Process
+    );
+
+//******************************************************************************
+// Function:     MmuAllocStack
+// Description:  Allocates a stack of StackSize bytes.
+// Returns:      PVOID
+// Parameter:    IN DWORD StackSize
+// Parameter:    IN BOOLEAN ProtectStack - if TRUE STACK_GUARD_SIZE of additional
+//               bytes will be reserved in the virtual space at the end of the
+//               stack to detect stack overflows.
+// Parameter:    IN BOOLEAN LazyMap
+// Parameter:    IN_OPT PPROCESS Process - if non-NULL a user-mode stack will
+//               be allocated.
+//******************************************************************************
+PTR_SUCCESS
+PVOID
+MmuAllocStack(
+    IN          DWORD               StackSize,
+    IN          BOOLEAN             ProtectStack,
+    IN          BOOLEAN             LazyMap,
+    IN_OPT      PPROCESS            Process
+    );
+
+//******************************************************************************
+// Function:     MmuFreeStack
+// Description:  Frees a previously allocated stack with MmuAllocStack.
+// Returns:      void
+// Parameter:    IN PVOID Stack
+// Parameter:    IN_OPT PPROCESS Process
+//******************************************************************************
+void
+MmuFreeStack(
+    IN          PVOID               Stack,
+    IN_OPT      PPROCESS            Process
+    );
+
+//******************************************************************************
+// Function:     MmuIsBufferValid
+// Description:  Verifies if Buffer of size BufferSize can be accessed with
+//               RightsRequested access rights by the Process process.
+// Returns:      STATUS
+// Parameter:    IN PVOID Buffer
+// Parameter:    IN QWORD BufferSize
+// Parameter:    IN PAGE_RIGHTS RightsRequested
+// Parameter:    IN PPROCESS Process
+//******************************************************************************
+STATUS
+MmuIsBufferValid(
+    IN          PVOID               Buffer,
+    IN          QWORD               BufferSize,
+    IN          PAGE_RIGHTS         RightsRequested,
+    IN          PPROCESS            Process
+    );
+
+//******************************************************************************
+// Function:     MmuGetSystemVirtualAddressForUserBuffer
+// Description:  Maps the physical memory which backs UserAddress from the
+//               Process process into kernel space with PageRights rights
+// Returns:      STATUS
+// Parameter:    IN PVOID UserAddress
+// Parameter:    IN QWORD Size
+// Parameter:    IN PAGE_RIGHTS PageRights
+// Parameter:    IN PPROCESS Process
+// Parameter:    OUT PVOID * KernelAddress
+//******************************************************************************
+STATUS
+MmuGetSystemVirtualAddressForUserBuffer(
+    IN          PVOID               UserAddress,
+    IN          QWORD               Size,
+    IN          PAGE_RIGHTS         PageRights,
+    IN          PPROCESS            Process,
+    OUT         PVOID*              KernelAddress
+    );
+
+//******************************************************************************
+// Function:     MmuFreeSystemVirtualAddressForUserBuffer
+// Description:  Frees previously a mapped user address with
+//               MmuGetSystemVirtualAddressForUserBuffer.
+// Returns:      void
+// Parameter:    IN PVOID KernelAddress
+//******************************************************************************
+void
+MmuFreeSystemVirtualAddressForUserBuffer(
+    IN          PVOID               KernelAddress
+    );
diff --git a/src_proiect/HAL9000/headers/multiboot.h b/src_proiect/HAL9000/headers/multiboot.h
new file mode 100644
index 0000000..475b3b1
--- /dev/null
+++ b/src_proiect/HAL9000/headers/multiboot.h
@@ -0,0 +1,127 @@
+#pragma once
+
+#pragma pack(push,1)
+
+#define MULTIBOOT_FLAG_BOOT_MODULES_PRESENT         (1<<3)
+#define MULTIBOOT_FLAG_LOADER_NAME_PRESENT          (1<<9)
+
+/*
++-------------------+
+0       | flags             |    (required)
++-------------------+
+4       | mem_lower         |    (present if flags[0] is set)
+8       | mem_upper         |    (present if flags[0] is set)
++-------------------+
+12      | boot_device       |    (present if flags[1] is set)
++-------------------+
+16      | cmdline           |    (present if flags[2] is set)
++-------------------+
+20      | mods_count        |    (present if flags[3] is set)
+24      | mods_addr         |    (present if flags[3] is set)
++-------------------+
+28 - 40 | syms              |    (present if flags[4] or
+|                   |                flags[5] is set)
++-------------------+
+44      | mmap_length       |    (present if flags[6] is set)
+48      | mmap_addr         |    (present if flags[6] is set)
++-------------------+
+52      | drives_length     |    (present if flags[7] is set)
+56      | drives_addr       |    (present if flags[7] is set)
++-------------------+
+60      | config_table      |    (present if flags[8] is set)
++-------------------+
+64      | boot_loader_name  |    (present if flags[9] is set)
++-------------------+
+68      | apm_table         |    (present if flags[10] is set)
++-------------------+
+72      | vbe_control_info  |    (present if flags[11] is set)
+76      | vbe_mode_info     |
+80      | vbe_mode          |
+82      | vbe_interface_seg |
+84      | vbe_interface_off |
+86      | vbe_interface_len |
++-------------------+
+*/
+typedef struct _MULTIBOOT_MODULE_INFORMATION
+{
+    DWORD       ModuleStartPhysAddr;
+    DWORD       ModuleEndPhysAddr;
+
+    DWORD       StringPhysAddr;
+    DWORD       __Reserved;
+} MULTIBOOT_MODULE_INFORMATION, *PMULTIBOOT_MODULE_INFORMATION;
+
+typedef struct _MULTIBOOT_INFORMATION
+{
+    // indicates the presence of the other fields
+    DWORD       Flags;                          // 0x0
+
+                                                // number of KB's of lower/higher memory size
+
+                                                // starts at address 0
+    DWORD       LowerMemorySize;                // 0x4
+
+                                                // starts at address 1MB
+    DWORD       HigherMemorySize;               // 0x8
+
+
+                                                /// should be modified to a struct in the future
+
+                                                // information about the boot device
+    DWORD       BootDevice;                     // 0xC
+
+                                                // C-style zero-terminated string
+    DWORD       CommandLine;                    // 0x10
+
+                                                // number of modules loaded
+    DWORD       ModuleCount;                    // 0x14
+
+                                                // pointer to array of module structure
+    DWORD       ModuleAddress;                  // 0x18
+
+                                                /// currently not interested in this field
+    BYTE        Reserved[16];                   // 0x1C
+
+                                                // Memory map address
+    DWORD       MemoryMapSize;                  // 0x30
+
+                                                // Memory map - size of buffer
+    DWORD       MemoryMapAddress;               // 0x3C
+
+                                                // Drive Structures start address
+    DWORD       DriveStructuresAddress;         // 0x34
+
+                                                // Drive Structures size
+    DWORD       DriveStructuresSize;            // 0x38
+
+                                                // address of ROM configuration table
+    DWORD       ConfigTableAddress;             // 0x3C
+
+                                                // pointer to C-style zero terminated string
+    DWORD       BootLoaderName;                 // 0x40
+
+                                                // pointer to APM table
+    DWORD       ApmTable;                       // 0x44
+
+                                                // we don't care about no graphics
+    BYTE        GraphicsData[20];               // 0x48
+} MULTIBOOT_INFORMATION, *PMULTIBOOT_INFORMATION;
+
+// it is not physically possible to have more than 4
+// in the BDA
+#define     BIOS_MAX_NO_OF_SERIAL_PORTS     4
+
+// parameter structure
+typedef struct _ASM_PARAMETERS
+{
+    MULTIBOOT_INFORMATION*      MultibootInformation;
+    PVOID                       KernelBaseAddress;
+    QWORD                       KernelSize;
+    QWORD                       VirtualToPhysicalOffset;
+
+    PHYSICAL_ADDRESS            MemoryMapAddress;
+    DWORD                       MemoryMapEntries;
+
+    WORD                        BiosSerialPorts[BIOS_MAX_NO_OF_SERIAL_PORTS];
+} ASM_PARAMETERS, *PASM_PARAMETERS;
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/mutex.h b/src_proiect/HAL9000/headers/mutex.h
new file mode 100644
index 0000000..57b9d02
--- /dev/null
+++ b/src_proiect/HAL9000/headers/mutex.h
@@ -0,0 +1,62 @@
+#pragma once
+
+#include "list.h"
+#include "synch.h"
+
+typedef struct _MUTEX
+{
+    LOCK                MutexLock;
+
+    BYTE                CurrentRecursivityDepth;
+    BYTE                MaxRecursivityDepth;
+
+    _Guarded_by_(MutexLock)
+    LIST_ENTRY          WaitingList;
+    struct _THREAD*     Holder;
+} MUTEX, *PMUTEX;
+
+//******************************************************************************
+// Function:     MutexInit
+// Description:  Initializes a mutex.
+// Returns:      void
+// Parameter:    OUT PMUTEX Mutex
+// Parameter:    IN BOOLEAN Recursive - if TRUE the mutex may be acquired
+//               several times by the same thread, else only once.
+// NOTE:         A recursive mutex must be released as many times as it has been
+//               acquired.
+//******************************************************************************
+_No_competing_thread_
+void
+MutexInit(
+    OUT         PMUTEX      Mutex,
+    IN          BOOLEAN     Recursive
+    );
+
+//******************************************************************************
+// Function:     MutexAcquire
+// Description:  Acquires a mutex. If the mutex is currently held the thread
+//               is placed in a waiting list and its execution is blocked.
+// Returns:      void
+// Parameter:    INOUT PMUTEX Mutex
+//******************************************************************************
+ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Mutex)
+REQUIRES_NOT_HELD_LOCK(*Mutex)
+void
+MutexAcquire(
+    INOUT       PMUTEX      Mutex
+    );
+
+//******************************************************************************
+// Function:     MutexRelease
+// Description:  Releases a mutex. If there is a thread on the waiting list it
+//               will be unblocked and placed as the lock's holder - this will
+//               ensure fairness.
+// Returns:      void
+// Parameter:    INOUT PMUTEX Mutex
+//******************************************************************************
+RELEASES_EXCL_AND_REENTRANT_LOCK(*Mutex)
+REQUIRES_EXCL_LOCK(*Mutex)
+void
+MutexRelease(
+    INOUT       PMUTEX      Mutex
+    );
diff --git a/src_proiect/HAL9000/headers/os_info.h b/src_proiect/HAL9000/headers/os_info.h
new file mode 100644
index 0000000..9be9f0a
--- /dev/null
+++ b/src_proiect/HAL9000/headers/os_info.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "io.h"
+
+void
+OsInfoPreinit(
+    void
+    );
+
+STATUS
+OsInfoInit(
+    void
+    );
+
+const
+char*
+OsInfoGetName(
+    void
+    );
+
+const
+char*
+OsGetBuildDate(
+    void
+    );
+
+const
+char*
+OsGetBuildType(
+    void
+    );
+
+const
+char*
+OsGetVersion(
+    void
+    );
+
+FUNC_InterruptFunction         OsInfoTimeUpdateIsr;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/os_time.h b/src_proiect/HAL9000/headers/os_time.h
new file mode 100644
index 0000000..065c6d8
--- /dev/null
+++ b/src_proiect/HAL9000/headers/os_time.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "time.h"
+
+DATETIME
+OsTimeGetCurrentDateTime(
+    void
+    );
+
+STATUS
+OsTimeGetStringFormattedTime(
+    IN_OPT                      PDATETIME       DateTime,
+    OUT_WRITES_Z(BufferSize)    char*           Buffer,
+    IN                          DWORD           BufferSize
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/perf_framework.h b/src_proiect/HAL9000/headers/perf_framework.h
new file mode 100644
index 0000000..6716845
--- /dev/null
+++ b/src_proiect/HAL9000/headers/perf_framework.h
@@ -0,0 +1,34 @@
+#pragma once
+
+typedef struct _PERFORMANCE_STATS
+{
+    QWORD               Mean;
+    QWORD               Min;
+    QWORD               Max;
+} PERFORMANCE_STATS, *PPERFORMANCE_STATS;
+
+typedef
+void
+(__cdecl FUNC_TestPerformance)(
+    IN_OPT  PVOID       Context
+    );
+
+typedef FUNC_TestPerformance*   PFUNC_TestPerformance;
+
+void
+RunPerformanceFunction(
+    IN      PFUNC_TestPerformance   Function,
+    IN_OPT  PVOID                   Context,
+    IN      DWORD                   IterationCount,
+    IN      BOOLEAN                 MeasureInUs,
+    OUT     PPERFORMANCE_STATS      PerfStats
+    );
+
+void
+DisplayPerformanceStats(
+    IN_READS(NumberOfStats)
+            PPERFORMANCE_STATS      PerfStats,
+    IN      DWORD                   NumberOfStats,
+    IN_READS(NumberOfStats)
+            char**                  StatNames
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/pmm.h b/src_proiect/HAL9000/headers/pmm.h
new file mode 100644
index 0000000..000d507
--- /dev/null
+++ b/src_proiect/HAL9000/headers/pmm.h
@@ -0,0 +1,73 @@
+#pragma once
+
+#include "mmu.h"
+
+#define PmmReserveMemory(Frames)        PmmReserveMemoryEx((Frames), NULL )
+
+_No_competing_thread_
+void
+PmmPreinitSystem(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+PmmInitSystem(
+    IN          PVOID                   BaseAddress,
+    IN          PHYSICAL_ADDRESS        MemoryEntries,
+    IN          DWORD                   NumberOfMemoryEntries,
+    OUT         DWORD*                  SizeReserved
+    );
+
+//******************************************************************************
+// Function:     PmmRequestMemoryEx
+// Description:  Reserves the first free frames available after MinPhysAddr.
+// Returns:      PHYSICAL_ADDRESS - start address of physical address reserved
+// Parameter:    IN DWORD NoOfFrames - frames to reserved.
+// Parameter:    IN_OPT PHYSICAL_ADDRESS MinPhysAddr - physical address from
+//               which to start searching for free frames.
+//******************************************************************************
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+PmmReserveMemoryEx(
+    IN          DWORD                   NoOfFrames,
+    IN_OPT      PHYSICAL_ADDRESS        MinPhysAddr
+    );
+
+//******************************************************************************
+// Function:     PmmReleaseMemory
+// Description:  Releases previously reserved memory
+// Returns:      void
+// Parameter:    IN PHYSICAL_ADDRESS PhysicalAddr
+// Parameter:    IN DWORD NoOfFrames
+//******************************************************************************
+void
+PmmReleaseMemory(
+    IN          PHYSICAL_ADDRESS        PhysicalAddr,
+    IN          DWORD                   NoOfFrames
+    );
+
+//******************************************************************************
+// Function:     PmmGetTotalSystemMemory
+// Description:
+// Returns:      QWORD - Returns the number of bytes of physical memory
+//               available in the system.
+// Parameter:    void
+//******************************************************************************
+QWORD
+PmmGetTotalSystemMemory(
+    void
+    );
+
+// Note: This address may reserved by the firmware or some other device.
+// If you want to retrieve the highest available physical address for software
+// usage use PmmGetHighestPhysicalMemoryAddressAvailable
+PHYSICAL_ADDRESS
+PmmGetHighestPhysicalMemoryAddressPresent(
+    void
+    );
+
+PHYSICAL_ADDRESS
+PmmGetHighestPhysicalMemoryAddressAvailable(
+    void
+    );
diff --git a/src_proiect/HAL9000/headers/print.h b/src_proiect/HAL9000/headers/print.h
new file mode 100644
index 0000000..1cc060c
--- /dev/null
+++ b/src_proiect/HAL9000/headers/print.h
@@ -0,0 +1,40 @@
+#pragma once
+
+typedef
+void
+(__cdecl FUNC_PrintFunction)(
+    IN_Z    char*   Format,
+    ...
+    );
+
+typedef FUNC_PrintFunction*     PFUNC_PrintFunction;
+
+void
+printSystemPreinit(
+    IN_OPT  PVOID   DisplayAddress
+    );
+
+void
+perror(
+    IN_Z    char*   Format,
+    ...
+    );
+
+void
+pwarn(
+    IN_Z    char*   Format,
+    ...
+    );
+
+void
+printf(
+    IN_Z    char*   Format,
+    ...
+    );
+
+void
+printColor(
+    IN      BYTE    Color,
+    IN_Z    char*   Format,
+    ...
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/process.h b/src_proiect/HAL9000/headers/process.h
new file mode 100644
index 0000000..4d01ca8
--- /dev/null
+++ b/src_proiect/HAL9000/headers/process.h
@@ -0,0 +1,114 @@
+#pragma once
+
+#include "process_defs.h"
+
+typedef struct _PROCESS* PPROCESS;
+
+//******************************************************************************
+// Function:     ProcessCreate
+// Description:  Creates a new process to execute the application found at
+//               PathToExe with Arguments (may be NULL). The function returns a
+//               pointer (handle) to the process structure.
+// Returns:      STATUS
+// Parameter:    IN_Z char * PathToExe
+// Parameter:    IN_OPT_Z char * Arguments
+// Parameter:    OUT_PTR PPROCESS * Process
+// NOTE:         All the processes's threads may terminate, but the process data
+//               structure will not be un-allocated until the handle receive in
+//               Process is closed with ProcessCloseHandle.
+//******************************************************************************
+STATUS
+ProcessCreate(
+    IN_Z        char*       PathToExe,
+    IN_OPT_Z    char*       Arguments,
+    OUT_PTR     PPROCESS*   Process
+    );
+
+//******************************************************************************
+// Function:     ProcessWaitForTermination
+// Description:  Blocks until the process received as a parameter terminates
+//               execution.
+// Returns:      void
+// Parameter:    IN PPROCESS Process
+// Parameter:    OUT STATUS* TerminationStatus - Corresponds to the status of
+//               the last exiting thread.
+//******************************************************************************
+void
+ProcessWaitForTermination(
+    IN          PPROCESS    Process,
+    OUT         STATUS*     TerminationStatus
+    );
+
+//******************************************************************************
+// Function:     ProcessCloseHandle
+// Description:  Closes a process handle received from ProcessCreate. This is
+//               necessary for the structure to be destroyed when it is no
+//               longer needed.
+// Returns:      void
+// Parameter:    PPROCESS    Process
+//******************************************************************************
+void
+ProcessCloseHandle(
+    _Pre_valid_ _Post_invalid_
+                PPROCESS    Process
+    );
+
+//******************************************************************************
+// Function:     ProcessGetName
+// Description:  Returns the name of the currently executing process (if the
+//               parameter is NULL) or of the specified process
+// Returns:      const char*
+// Parameter:    IN_OPT PPROCESS Process
+//******************************************************************************
+const
+char*
+ProcessGetName(
+    IN_OPT      PPROCESS    Process
+    );
+
+//******************************************************************************
+// Function:     ProcessGetName
+// Description:  Returns the PID of the currently executing process (if the
+//               parameter is NULL) or of the specified process
+// Returns:      PID
+// Parameter:    IN_OPT PPROCESS Process
+//******************************************************************************
+PID
+ProcessGetId(
+    IN_OPT      PPROCESS    Process
+    );
+
+//******************************************************************************
+// Function:     ProcessIsSystem
+// Description:  Checks if a process or the currently executing process (if the
+//               parameter is NULL) is the system process.
+// Returns:      BOOLEAN
+// Parameter:    IN_OPT PPROCESS Process
+//******************************************************************************
+BOOLEAN
+ProcessIsSystem(
+    IN_OPT      PPROCESS    Process
+    );
+
+//******************************************************************************
+// Function:     ProcessTerminate
+// Description:  Signals a process for termination (the current process will be
+//               terminated if the parameter is NULL).
+// Returns:      void
+// Parameter:    INOUT PPROCESS Process
+//******************************************************************************
+void
+ProcessTerminate(
+    INOUT       PPROCESS    Process
+    );
+
+//******************************************************************************
+// Function:     GetCurrentProcess
+// Description:  Retrieves the executing process.
+// Returns:      PPROCESS
+// Parameter:    void
+//******************************************************************************
+PPROCESS
+GetCurrentProcess(
+    void
+    );
diff --git a/src_proiect/HAL9000/headers/process_internal.h b/src_proiect/HAL9000/headers/process_internal.h
new file mode 100644
index 0000000..e9af376
--- /dev/null
+++ b/src_proiect/HAL9000/headers/process_internal.h
@@ -0,0 +1,165 @@
+#pragma once
+
+#include "list.h"
+#include "ref_cnt.h"
+#include "process.h"
+#include "synch.h"
+#include "ex_event.h"
+
+#define PROCESS_MAX_PHYSICAL_FRAMES     16
+#define PROCESS_MAX_OPEN_FILES          16
+
+typedef struct _PROCESS
+{
+    REF_COUNT                       RefCnt;
+
+    // The PIDs will also be used for the CR3 PCID
+    PID                             Id;
+
+    char*                           ProcessName;
+
+    // Command line related
+
+    // The command line also contains the ProcessName
+    char*                           FullCommandLine;
+    DWORD                           NumberOfArguments;
+
+    // Signaled when the last thread is removed from the
+    // process list
+    EX_EVENT                        TerminationEvt;
+
+    // Valid only if TerminationEvt is signaled. The status
+    // of the process is given by the status of the last
+    // exiting thread from the process.
+    STATUS                          TerminationStatus;
+
+    LOCK                            ThreadListLock;
+
+    _Guarded_by_(ThreadListLock)
+    LIST_ENTRY                      ThreadList;
+
+    _Guarded_by_(ThreadListLock)
+    volatile DWORD                  NumberOfThreads;
+
+    // The difference between NumberOfThreads and ActiveThreads is the following
+    // ActiveThreads represents number of threads in process which have not died have
+    // NumberOfThreads includes the threads which died but have not yet been destroyed
+    _Interlocked_
+    volatile DWORD                  ActiveThreads;
+
+    // Links all the processes in the global process list
+    LIST_ENTRY                      NextProcess;
+
+    // Pointer to the process' paging structures
+    struct _PAGING_LOCK_DATA*       PagingData;
+
+    // Pointer to the process' NT header information
+    struct _PE_NT_HEADER_INFO*      HeaderInfo;
+
+    // VaSpace used only for UM virtual memory allocations
+    struct _VMM_RESERVATION_SPACE*  VaSpace;
+} PROCESS, *PPROCESS;
+
+//******************************************************************************
+// Function:     ProcessSystemPreinit
+// Description:  Basic global initialization. Initializes the PID bitmap, the
+//               process list and their associated locks.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+_No_competing_thread_
+void
+ProcessSystemPreinit(
+    void
+    );
+
+//******************************************************************************
+// Function:     ProcessSystemInitSystemProcess
+// Description:  Initializes the System process.
+// Returns:      STATUS
+// Parameter:    void
+//******************************************************************************
+_No_competing_thread_
+STATUS
+ProcessSystemInitSystemProcess(
+    void
+    );
+
+//******************************************************************************
+// Function:     ProcessRetrieveSystemProcess
+// Description:  Retrieves a pointer to the system process.
+// Returns:      PPROCESS
+// Parameter:    void
+//******************************************************************************
+PPROCESS
+ProcessRetrieveSystemProcess(
+    void
+    );
+
+//******************************************************************************
+// Function:     ProcessInsertThreadInList
+// Description:  Inserts the Thread in the Process thread list.
+// Returns:      void
+// Parameter:    INOUT PPROCESS Process
+// Parameter:    INOUT struct _THREAD * Thread
+//******************************************************************************
+void
+ProcessInsertThreadInList(
+    INOUT   PPROCESS            Process,
+    INOUT   struct _THREAD*     Thread
+    );
+
+//******************************************************************************
+// Function:     ProcessNotifyThreadTermination
+// Description:  Called when a thread terminates execution. If this was the last
+//               active thread in the process it will signal the processes's
+//               termination event.
+// Returns:      void
+// Parameter:    IN struct _THREAD * Thread
+//******************************************************************************
+void
+ProcessNotifyThreadTermination(
+    IN      struct _THREAD*     Thread
+    );
+
+//******************************************************************************
+// Function:     ProcessRemoveThreadFromList
+// Description:  Removes the Thread from its container process thread list.
+//               Called when a thread is destroyed.
+// Returns:      void
+// Parameter:    INOUT struct _THREAD * Thread
+//******************************************************************************
+void
+ProcessRemoveThreadFromList(
+    INOUT   struct _THREAD*     Thread
+    );
+
+//******************************************************************************
+// Function:     ProcessExecuteForEachProcessEntry
+// Description:  Iterates over the all threads list and invokes Function on each
+//               entry passing an additional optional Context parameter.
+// Returns:      STATUS
+// Parameter:    IN PFUNC_ListFunction Function
+// Parameter:    IN_OPT PVOID Context
+//******************************************************************************
+STATUS
+ProcessExecuteForEachProcessEntry(
+    IN      PFUNC_ListFunction  Function,
+    IN_OPT  PVOID               Context
+    );
+
+//******************************************************************************
+// Function:     ProcessActivatePagingTables
+// Description:  Performs a switch to the Process paging tables.
+// Returns:      void
+// Parameter:    IN PPROCESS Process
+// Parameter:    IN BOOLEAN InvalidateAddressSpace - if TRUE all the cached
+//               translations for the Process PCID will be flushed. This option
+//               is useful when a process terminates and its PCID will be
+//               later used by another process.
+//******************************************************************************
+void
+ProcessActivatePagingTables(
+    IN      PPROCESS            Process,
+    IN      BOOLEAN             InvalidateAddressSpace
+    );
diff --git a/src_proiect/HAL9000/headers/scan_codes.h b/src_proiect/HAL9000/headers/scan_codes.h
new file mode 100644
index 0000000..fcb5e65
--- /dev/null
+++ b/src_proiect/HAL9000/headers/scan_codes.h
@@ -0,0 +1,156 @@
+#pragma once
+
+typedef enum _KEYCODE 
+{
+
+    // Alphanumeric keys ////////////////
+
+    KEY_SPACE = ' ',
+    KEY_0 = '0',
+    KEY_1 = '1',
+    KEY_2 = '2',
+    KEY_3 = '3',
+    KEY_4 = '4',
+    KEY_5 = '5',
+    KEY_6 = '6',
+    KEY_7 = '7',
+    KEY_8 = '8',
+    KEY_9 = '9',
+
+    KEY_A = 'a',
+    KEY_B = 'b',
+    KEY_C = 'c',
+    KEY_D = 'd',
+    KEY_E = 'e',
+    KEY_F = 'f',
+    KEY_G = 'g',
+    KEY_H = 'h',
+    KEY_I = 'i',
+    KEY_J = 'j',
+    KEY_K = 'k',
+    KEY_L = 'l',
+    KEY_M = 'm',
+    KEY_N = 'n',
+    KEY_O = 'o',
+    KEY_P = 'p',
+    KEY_Q = 'q',
+    KEY_R = 'r',
+    KEY_S = 's',
+    KEY_T = 't',
+    KEY_U = 'u',
+    KEY_V = 'v',
+    KEY_W = 'w',
+    KEY_X = 'x',
+    KEY_Y = 'y',
+    KEY_Z = 'z',
+
+    KEY_RETURN = '\r',
+    KEY_ESCAPE = 0x1001,
+    KEY_BACKSPACE = '\b',
+
+    // Arrow keys ////////////////////////
+
+    KEY_UP = 0x1100,
+    KEY_DOWN = 0x1101,
+    KEY_LEFT = 0x1102,
+    KEY_RIGHT = 0x1103,
+
+    // Function keys /////////////////////
+
+    KEY_F1 = 0x1201,
+    KEY_F2 = 0x1202,
+    KEY_F3 = 0x1203,
+    KEY_F4 = 0x1204,
+    KEY_F5 = 0x1205,
+    KEY_F6 = 0x1206,
+    KEY_F7 = 0x1207,
+    KEY_F8 = 0x1208,
+    KEY_F9 = 0x1209,
+    KEY_F10 = 0x120a,
+    KEY_F11 = 0x120b,
+    KEY_F12 = 0x120b,
+    KEY_F13 = 0x120c,
+    KEY_F14 = 0x120d,
+    KEY_F15 = 0x120e,
+
+    KEY_DOT = '.',
+    KEY_COMMA = ',',
+    KEY_COLON = ':',
+    KEY_SEMICOLON = ';',
+    KEY_SLASH = '/',
+    KEY_BACKSLASH = '\\',
+    KEY_PLUS = '+',
+    KEY_MINUS = '-',
+    KEY_ASTERISK = '*',
+    KEY_EXCLAMATION = '!',
+    KEY_QUESTION = '?',
+    KEY_QUOTEDOUBLE = '\"',
+    KEY_QUOTE = '\'',
+    KEY_EQUAL = '=',
+    KEY_HASH = '#',
+    KEY_PERCENT = '%',
+    KEY_AMPERSAND = '&',
+    KEY_UNDERSCORE = '_',
+    KEY_LEFTPARENTHESIS = '(',
+    KEY_RIGHTPARENTHESIS = ')',
+    KEY_LEFTBRACKET = '[',
+    KEY_RIGHTBRACKET = ']',
+    KEY_LEFTCURL = '{',
+    KEY_RIGHTCURL = '}',
+    KEY_DOLLAR = '$',
+    KEY_POUND = '',
+    KEY_EURO = '$',
+    KEY_LESS = '<',
+    KEY_GREATER = '>',
+    KEY_BAR = '|',
+    KEY_GRAVE = '`',
+    KEY_TILDE = '~',
+    KEY_AT = '@',
+    KEY_CARRET = '^',
+
+    // Numeric keypad //////////////////////
+
+    KEY_KP_0 = '0',
+    KEY_KP_1 = '1',
+    KEY_KP_2 = '2',
+    KEY_KP_3 = '3',
+    KEY_KP_4 = '4',
+    KEY_KP_5 = '5',
+    KEY_KP_6 = '6',
+    KEY_KP_7 = '7',
+    KEY_KP_8 = '8',
+    KEY_KP_9 = '9',
+    KEY_KP_PLUS = '+',
+    KEY_KP_MINUS = '-',
+    KEY_KP_DECIMAL = '.',
+    KEY_KP_DIVIDE = '/',
+    KEY_KP_ASTERISK = '*',
+    KEY_KP_NUMLOCK = 0x300f,
+    KEY_KP_ENTER = 0x3010,
+
+    KEY_TAB = 0x4000,
+    KEY_CAPSLOCK = 0x4001,
+
+    // Modify keys ////////////////////////////
+
+    KEY_LSHIFT = 0x4002,
+    KEY_LCTRL = 0x4003,
+    KEY_LALT = 0x4004,
+    KEY_LWIN = 0x4005,
+    KEY_RSHIFT = 0x4006,
+    KEY_RCTRL = 0x4007,
+    KEY_RALT = 0x4008,
+    KEY_RWIN = 0x4009,
+
+    KEY_INSERT = 0x400a,
+    KEY_DELETE = 0x400b,
+    KEY_HOME = 0x400c,
+    KEY_END = 0x400d,
+    KEY_PAGEUP = 0x400e,
+    KEY_PAGEDOWN = 0x400f,
+    KEY_SCROLLLOCK = 0x4010,
+    KEY_PAUSE = 0x4011,
+
+    KEY_UNKNOWN,
+    KEY_NUMKEYCODES
+} KEYCODE;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/serial_comm.h b/src_proiect/HAL9000/headers/serial_comm.h
new file mode 100644
index 0000000..d75efe2
--- /dev/null
+++ b/src_proiect/HAL9000/headers/serial_comm.h
@@ -0,0 +1,17 @@
+#pragma once
+
+STATUS
+SerialCommunicationInitialize(
+    IN_READS(NoOfPorts)     WORD*           Ports,
+    IN                      DWORD           NoOfPorts
+    );
+
+STATUS
+SerialCommunicationReinitialize(
+    void
+    );
+
+void
+SerialCommWriteBuffer(
+    IN_Z char*  Buffer
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/smp.h b/src_proiect/HAL9000/headers/smp.h
new file mode 100644
index 0000000..768396f
--- /dev/null
+++ b/src_proiect/HAL9000/headers/smp.h
@@ -0,0 +1,142 @@
+#pragma once
+
+#include "list.h"
+#include "ipc.h"
+
+typedef BYTE CPU_AFFINITY;
+
+typedef union _SMP_DESTINATION
+{
+    struct
+    {
+        // Used for SmpIpiSendToCpu
+        _Strict_type_match_ APIC_ID ApicId;
+    } Cpu;
+    struct
+    {
+        // Used for SmpIpiSendToGroup
+        _Strict_type_match_ CPU_AFFINITY Affinity;
+    } Group;
+
+    // for SmpIpiSendToAllExcludingSelf
+    // SmpIpiSendToAllIncludingSelf and
+    // SmpIpiSendToSelf
+    BYTE        __Reserved;
+} SMP_DESTINATION, *PSMP_DESTINATION;
+
+typedef enum _SMP_IPI_SEND_MODE
+{
+    // uses physical address
+    SmpIpiSendToCpu,
+
+    // sends to running CPU
+    SmpIpiSendToSelf,
+    SmpIpiSendToAllIncludingSelf,
+    SmpIpiSendToAllExcludingSelf,
+
+    // uses logical address
+    SmpIpiSendToGroup,
+
+    SmpIpiSendMax = SmpIpiSendToGroup
+} SMP_IPI_SEND_MODE;
+
+_No_competing_thread_
+void
+SmpPreinit(
+    void
+    );
+
+STATUS
+_No_competing_thread_
+SmpInit(
+    void
+    );
+
+STATUS
+_No_competing_thread_
+SmpSetupLowerMemory(
+    IN          BYTE        NumberOfTssStacks
+    );
+
+void
+_No_competing_thread_
+SmpWakeupAps(
+    void
+    );
+
+void
+_No_competing_thread_
+SmpCleanupLowerMemory(
+    void
+    );
+
+void
+SmpSendPanic(
+    void
+    );
+
+// Calls SmpSendGenericIpiEx with SmpIpiSendToAllExcludingSelf causing the
+// BroadcastFunction to be executed on each CPU except the one that is calling
+// the function.
+STATUS
+SmpSendGenericIpi(
+    IN      PFUNC_IpcProcessEvent   BroadcastFunction,
+    IN_OPT  PVOID                   Context,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   FreeContext,
+    IN      BOOLEAN                 WaitForHandling
+    );
+
+//******************************************************************************
+// Function:     SmpSendGenericIpiEx
+// Description:  The current CPU sends an IPI to the processors specified by
+//               SendMode and Destination to execute the BroadcastFunction.
+// Returns:      STATUS
+// Parameter:    IN PFUNC_IpcProcessEvent BroadcastFunction - Function to execute
+//               on each destination CPU.
+// Parameter:    IN_OPT PVOID Context - The context to be passed to the
+//               BroadcastFunction.
+// Parameter:    IN_OPT PFUNC_FreeFunction FreeFunction - The function to free
+//               the context sent to the BroadcastFunction.
+// Parameter:    IN_OPT PVOID FreeContext - The context to be sent to the
+//               FreeFunction.
+// Parameter:    IN BOOLEAN WaitForHandling - if TRUE waits until each CPU
+//               executes the  BroadcastFunction.
+// Parameter:    IN SMP_IPI_SEND_MODE SendMode - together with Destination
+//               specifies the target processors for IPI delivery.
+// Parameter:    IN SMP_DESTINATION Destination - species the destination
+//               processor(s).
+//******************************************************************************
+STATUS
+SmpSendGenericIpiEx(
+    IN      PFUNC_IpcProcessEvent   BroadcastFunction,
+    IN_OPT  PVOID                   Context,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   FreeContext,
+    IN      BOOLEAN                 WaitForHandling,
+    IN _Strict_type_match_
+            SMP_IPI_SEND_MODE       SendMode,
+    _When_(SendMode == SmpIpiSendToCpu || SendMode == SmpIpiSendToGroup, IN)
+            SMP_DESTINATION         Destination
+    );
+
+STATUS
+SmpCpuInit(
+    void
+    );
+
+void
+_No_competing_thread_
+SmpGetCpuList(
+    OUT_PTR      PLIST_ENTRY*     CpuList
+    );
+
+DWORD
+SmpGetNumberOfActiveCpus(
+    void
+    );
+
+void
+SmpNotifyCpuWakeup(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/synch.h b/src_proiect/HAL9000/headers/synch.h
new file mode 100644
index 0000000..bde3de9
--- /dev/null
+++ b/src_proiect/HAL9000/headers/synch.h
@@ -0,0 +1,4 @@
+#pragma once
+
+#include "lock_common.h"
+#include "event.h"
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/syscall.h b/src_proiect/HAL9000/headers/syscall.h
new file mode 100644
index 0000000..601d97b
--- /dev/null
+++ b/src_proiect/HAL9000/headers/syscall.h
@@ -0,0 +1,21 @@
+#pragma once
+
+void
+SyscallPreinitSystem(
+    void
+    );
+
+STATUS
+SyscallInitSystem(
+    void
+    );
+
+STATUS
+SyscallUninitSystem(
+    void
+    );
+
+void
+SyscallCpuInit(
+    void
+    );
diff --git a/src_proiect/HAL9000/headers/system.h b/src_proiect/HAL9000/headers/system.h
new file mode 100644
index 0000000..f212ed2
--- /dev/null
+++ b/src_proiect/HAL9000/headers/system.h
@@ -0,0 +1,16 @@
+#pragma once
+
+void
+SystemPreinit(
+    void
+    );
+
+STATUS
+SystemInit(
+    IN  ASM_PARAMETERS*     Parameters
+    );
+
+void
+SystemUninit(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/system_driver.h b/src_proiect/HAL9000/headers/system_driver.h
new file mode 100644
index 0000000..a8e0d64
--- /dev/null
+++ b/src_proiect/HAL9000/headers/system_driver.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry    SystemDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_bitmap.h b/src_proiect/HAL9000/headers/test_bitmap.h
new file mode 100644
index 0000000..508ff5d
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_bitmap.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void
+TestBitmap(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_common.h b/src_proiect/HAL9000/headers/test_common.h
new file mode 100644
index 0000000..60bc8f2
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_common.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "HAL9000.h"
+#include "print.h"
+
+#define TEST_MAX_NO_OF_HEAP_ALLOCATIONS     50
+
+#define LOG_TEST_LOG(buf,...)               LogEx(LogLevelTrace, LogComponentTest, "[TEST]"##buf, __VA_ARGS__)
+#define LOG_TEST_PASS                       LOG_TEST_LOG("\n[PASS]\n");
+
+void
+TestRunAllFunctional(
+    void
+    );
+
+void
+TestRunAllPerformance(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_dma.h b/src_proiect/HAL9000/headers/test_dma.h
new file mode 100644
index 0000000..4abc044
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_dma.h
@@ -0,0 +1,6 @@
+#pragma once
+
+void
+TestDmaPerformance(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_file_io.h b/src_proiect/HAL9000/headers/test_file_io.h
new file mode 100644
index 0000000..8d3751d
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_file_io.h
@@ -0,0 +1,11 @@
+#pragma once
+
+BOOLEAN
+TestFileRead(
+    void
+    );
+
+void
+TestFileReadPerformance(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_net_stack.h b/src_proiect/HAL9000/headers/test_net_stack.h
new file mode 100644
index 0000000..8de5c40
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_net_stack.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "network.h"
+
+_No_competing_thread_
+BOOLEAN
+TestNetwork(
+        IN      BOOLEAN         Transmit,
+    _When_(Transmit, _Reserved_)
+    _When_(!Transmit, IN)
+        IN      BOOLEAN         ResendRequets
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_pmm.h b/src_proiect/HAL9000/headers/test_pmm.h
new file mode 100644
index 0000000..6454394
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_pmm.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "pmm.h"
+
+void
+TestPmmReserveAndReleaseFunctions(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_priority_donation.h b/src_proiect/HAL9000/headers/test_priority_donation.h
new file mode 100644
index 0000000..40d091b
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_priority_donation.h
@@ -0,0 +1,13 @@
+#pragma once
+
+typedef enum _TEST_PRIORITY_DONATION_MULTIPLE
+{
+    TestPriorityDonationMultipleOneThreadPerLock                    = 0b00,
+    TestPriorityDonationMultipleOneThreadPerLockInverseRelease      = 0b01,
+    TestPriorityDonationMultipleTwoThreadsPerLock                   = 0b10,
+    TestPriorityDonationMultipleTwoThreadsPerLockInverseRelease     = 0b11,
+} TEST_PRIORITY_DONATION_MULTIPLE;
+
+FUNC_ThreadStart            TestThreadPriorityDonationBasic;
+FUNC_ThreadStart            TestThreadPriorityDonationMultiple;
+FUNC_ThreadStart            TestThreadPriorityDonationChain;
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_priority_scheduler.h b/src_proiect/HAL9000/headers/test_priority_scheduler.h
new file mode 100644
index 0000000..ec68474
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_priority_scheduler.h
@@ -0,0 +1,15 @@
+#pragma once
+
+FUNC_ThreadStart            TestThreadPriorityMutex;
+FUNC_ThreadPrepareTest      TestPrepareMutex;
+FUNC_ThreadPostCreate       TestThreadPostCreateMutex;
+FUNC_ThreadPostFinish       TestThreadPostFinishMutex;
+
+FUNC_ThreadStart            TestThreadPriorityWakeup;
+FUNC_ThreadPrepareTest      TestThreadPrepareWakeupEvent;
+FUNC_ThreadPostCreate       TestThreadPostCreateWakeup;
+FUNC_ThreadPostFinish       TestThreadPostFinishWakeup;
+
+FUNC_ThreadStart            TestThreadPriorityExecution;
+FUNC_ThreadPrepareTest      TestThreadPreparePriorityExecution;
+FUNC_ThreadPostFinish       TestThreadPostPriorityExecution;
diff --git a/src_proiect/HAL9000/headers/test_process.h b/src_proiect/HAL9000/headers/test_process.h
new file mode 100644
index 0000000..a2b1865
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_process.h
@@ -0,0 +1,23 @@
+#pragma once
+
+typedef struct _PROCESS_TEST
+{
+    char*                       TestName;
+    char*                       ProcessName;
+    char*                       ProcessCommandLine;
+    DWORD                       NumberOfProcesses;
+} PROCESS_TEST, *PPROCESS_TEST;
+
+extern const PROCESS_TEST PROCESS_TESTS[];
+
+extern const DWORD PROCESS_TOTAL_NO_OF_TESTS;
+
+void
+TestProcessFunctionality(
+    IN      PROCESS_TEST*               ProcessTest
+    );
+
+void
+TestAllProcessFunctionalities(
+    void
+    );
diff --git a/src_proiect/HAL9000/headers/test_thread.h b/src_proiect/HAL9000/headers/test_thread.h
new file mode 100644
index 0000000..3774243
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_thread.h
@@ -0,0 +1,62 @@
+#pragma once
+
+#include "thread.h"
+
+typedef
+void
+(__cdecl FUNC_ThreadPrepareTest)(
+    OUT_OPT_PTR     PVOID*              Context,
+    IN              DWORD               NumberOfThreads,
+    IN              PVOID               PrepareContext
+    );
+
+typedef     FUNC_ThreadPrepareTest*             PFUNC_ThreadPrepareTest;
+
+typedef
+void
+(__cdecl FUNC_ThreadPostCreate)(
+    IN              PVOID               Context
+    );
+
+typedef     FUNC_ThreadPostCreate*              PFUNC_ThreadPostCreate;
+
+typedef
+void
+(__cdecl FUNC_ThreadPostFinish)(
+    IN              PVOID               Context,
+    IN              DWORD               NumberOfThreads
+    );
+
+typedef     FUNC_ThreadPostFinish*              PFUNC_ThreadPostFinish;
+
+typedef struct _THREAD_TEST
+{
+    char*                       TestName;
+    PFUNC_ThreadStart           ThreadFunction;
+    PFUNC_ThreadPrepareTest     ThreadPrepareFunction;
+    PVOID                       PrepareFunctionContext;
+    PFUNC_ThreadPostCreate      ThreadPostCreateFunction;
+    PFUNC_ThreadPostFinish      ThreadPostFinishFunction;
+    THREAD_PRIORITY             BasePriority;
+    BOOLEAN                     IncrementPriorities;
+
+    BOOLEAN                     IgnoreThreadCount;
+    BOOLEAN                     ArrayOfContexts;
+} THREAD_TEST, *PTHREAD_TEST;
+
+
+extern const THREAD_TEST THREADS_TEST[];
+
+extern const DWORD THREADS_TOTAL_NO_OF_TESTS;
+
+void
+TestThreadFunctionality(
+    IN      THREAD_TEST*                ThreadTest,
+    IN_OPT  PVOID                       ContextForTestFunction,
+    IN      DWORD                       NumberOfThreads
+    );
+
+void
+TestAllThreadFunctionalities(
+    IN      DWORD                       NumberOfThreads
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/test_timer.h b/src_proiect/HAL9000/headers/test_timer.h
new file mode 100644
index 0000000..c8d4f07
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_timer.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "ex_timer.h"
+
+#define TIMER_TEST_SLEEP_TIME_IN_US     (50 * MS_IN_US)
+#define TIMER_TEST_SLEEP_INCREMENT      (10 * MS_IN_US)
+#define TIMER_TEST_NO_OF_ITERATIONS     10
+
+#define SLEEP_TIME_BIT_OFFSET           0x10
+#define TIMER_TYPE_BIT_OFFSET           (SLEEP_TIME_BIT_OFFSET + 0x20)
+
+#define DEFINE_TEST(Type,Us,Times)      ( ( ((QWORD)(Type)) << TIMER_TYPE_BIT_OFFSET) \
+                                          | ((QWORD)((Us) & MAX_DWORD) << SLEEP_TIME_BIT_OFFSET) \
+                                          | ((Times) & MAX_WORD))
+
+#define TEST_TIMER_ABSOLUTE             DEFINE_TEST(ExTimerTypeAbsolute, TIMER_TEST_SLEEP_TIME_IN_US, 1)
+#define TEST_TIMER_ABSOLUTE_PASSED      DEFINE_TEST(ExTimerTypeAbsolute, -TIMER_TEST_SLEEP_TIME_IN_US, 1)
+#define TEST_TIMER_PERIODIC_MULTIPLE    DEFINE_TEST(ExTimerTypeRelativePeriodic, TIMER_TEST_SLEEP_TIME_IN_US, TIMER_TEST_NO_OF_ITERATIONS)
+#define TEST_TIMER_PERIODIC_ONCE        DEFINE_TEST(ExTimerTypeRelativePeriodic, TIMER_TEST_SLEEP_TIME_IN_US, 1)
+#define TEST_TIMER_PERIODIC_ZERO        DEFINE_TEST(ExTimerTypeRelativePeriodic, 0, 1)
+#define TEST_TIMER_RELATIVE             DEFINE_TEST(ExTimerTypeRelativeOnce, TIMER_TEST_SLEEP_TIME_IN_US, 1)
+#define TEST_TIMER_RELATIVE_ZERO        DEFINE_TEST(ExTimerTypeRelativeOnce, 0, 1)
+
+FUNC_ThreadStart                        TestThreadTimerSleep;
+FUNC_ThreadStart                        TestThreadTimerMultiple;
+
+FUNC_ThreadPrepareTest                  TestThreadTimerPrepare;
+FUNC_ThreadPostFinish                   TestThreadTimerMultipleTimersPostFinish;
+FUNC_ThreadPostFinish					TestThreadTimerMultipleThreadsPostFinish;
diff --git a/src_proiect/HAL9000/headers/test_vmm.h b/src_proiect/HAL9000/headers/test_vmm.h
new file mode 100644
index 0000000..7c0f426
--- /dev/null
+++ b/src_proiect/HAL9000/headers/test_vmm.h
@@ -0,0 +1,8 @@
+#pragma once
+
+#include "vmm.h"
+
+void
+TestVmmAllocAndFreeFunctions(
+    void
+    );
\ No newline at end of file
diff --git a/src_proiect/HAL9000/headers/thread_internal.h b/src_proiect/HAL9000/headers/thread_internal.h
new file mode 100644
index 0000000..789fe68
--- /dev/null
+++ b/src_proiect/HAL9000/headers/thread_internal.h
@@ -0,0 +1,284 @@
+#pragma once
+
+#include "list.h"
+#include "ref_cnt.h"
+#include "ex_event.h"
+#include "thread.h"
+
+typedef enum _THREAD_STATE
+{
+    // currently executing on a CPU
+    ThreadStateRunning,
+
+    // in ready list, i.e. it is ready to be executed
+    // when it will be scheduled
+    ThreadStateReady,
+
+    // it is waiting for a resource (mutex, ex event, ex timer)
+    // and cannot be scheduled until it is unblocked by another
+    // thread
+    ThreadStateBlocked,
+
+    // the thread has already executed its last quanta - it will
+    // be destroyed before the next thread in the ready list resumes
+    // execution
+    ThreadStateDying,
+    ThreadStateReserved = ThreadStateDying + 1
+} THREAD_STATE;
+
+typedef DWORD           THREAD_FLAGS;
+
+#define THREAD_FLAG_FORCE_TERMINATE_PENDING         0x1
+#define THREAD_FLAG_FORCE_TERMINATED                0x2
+
+typedef struct _THREAD
+{
+    REF_COUNT               RefCnt;
+
+    struct _THREAD          *Self;
+
+    TID                     Id;
+    char*                   Name;
+
+    // Currently the thread priority is not used for anything
+    THREAD_PRIORITY         Priority;
+    THREAD_STATE            State;
+
+    // valid only if State == ThreadStateTerminated
+    STATUS                  ExitStatus;
+    EX_EVENT                TerminationEvt;
+
+    volatile THREAD_FLAGS   Flags;
+
+    // Lock which ensures there are no race conditions between a thread that
+    // blocks and a thread on another CPU which wants to unblock it
+    LOCK                    BlockLock;
+
+    // List of all the threads in the system (including those blocked or dying)
+    LIST_ENTRY              AllList;
+
+    // List of the threads ready to run
+    LIST_ENTRY              ReadyList;
+
+    // List of the threads in the same process
+    LIST_ENTRY              ProcessList;
+
+    // Incremented on each clock tick for the running thread
+    QWORD                   TickCountCompleted;
+
+    // Counts the number of ticks the thread has currently run without being
+    // de-scheduled, i.e. if the thread yields the CPU to another thread the
+    // count will be reset to 0, else if the thread yields, but it will
+    // scheduled again the value will be incremented.
+    QWORD                   UninterruptedTicks;
+
+    // Incremented if the thread yields the CPU before the clock
+    // ticks, i.e. by yielding or by blocking
+    QWORD                   TickCountEarly;
+
+    // The highest valid address for the kernel stack (its initial value)
+    PVOID                   InitialStackBase;
+
+    // The size of the kernel stack
+    DWORD                   StackSize;
+
+    // The current kernel stack pointer (it gets updated on each thread switch,
+    // its used when resuming thread execution)
+    PVOID                   Stack;
+
+    // MUST be non-NULL for all threads which belong to user-mode processes
+    PVOID                   UserStack;
+
+    struct _PROCESS*        Process;
+} THREAD, *PTHREAD;
+
+//******************************************************************************
+// Function:     ThreadSystemPreinit
+// Description:  Basic global initialization. Initializes the all threads list,
+//               the ready list and all the locks protecting the global
+//               structures.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+_No_competing_thread_
+ThreadSystemPreinit(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadSystemInitMainForCurrentCPU
+// Description:  Call by each CPU to initialize the main execution thread. Has a
+//               different flow than any other thread creation because some of
+//               the thread information already exists and it is currently
+//               running.
+// Returns:      STATUS
+// Parameter:    void
+//******************************************************************************
+STATUS
+ThreadSystemInitMainForCurrentCPU(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadSystemInitIdleForCurrentCPU
+// Description:  Called by each CPU to spawn the idle thread. Execution will not
+//               continue until after the idle thread is first scheduled on the
+//               CPU. This function is also responsible for enabling interrupts
+//               on the processor.
+// Returns:      STATUS
+// Parameter:    void
+//******************************************************************************
+STATUS
+ThreadSystemInitIdleForCurrentCPU(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadCreateEx
+// Description:  Same as ThreadCreate except it also takes an additional
+//               parameter, the process to which the thread should belong. This
+//               function must be called for creating user-mode threads.
+// Returns:      STATUS
+// Parameter:    IN_Z char * Name
+// Parameter:    IN THREAD_PRIORITY Priority
+// Parameter:    IN PFUNC_ThreadStart Function
+// Parameter:    IN_OPT PVOID Context
+// Parameter:    OUT_PTR PTHREAD * Thread
+// Parameter:    INOUT struct _PROCESS * Process
+//******************************************************************************
+STATUS
+ThreadCreateEx(
+    IN_Z        char*               Name,
+    IN          THREAD_PRIORITY     Priority,
+    IN          PFUNC_ThreadStart   Function,
+    IN_OPT      PVOID               Context,
+    OUT_PTR     PTHREAD*            Thread,
+    INOUT       struct _PROCESS*    Process
+    );
+
+//******************************************************************************
+// Function:     ThreadTick
+// Description:  Called by the timer interrupt at each timer tick. It keeps
+//               track of thread statistics and triggers the scheduler when a
+//               time slice expires.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+ThreadTick(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadBlock
+// Description:  Transitions the running thread into the blocked state. The
+//               thread will not run again until it is unblocked (ThreadUnblock)
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+ThreadBlock(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadUnblock
+// Description:  Transitions thread, which must be in the blocked state, to the
+//               ready state, allowing it to resume running. This is called when
+//               the resource on which the thread is waiting for becomes
+//               available.
+// Returns:      void
+// Parameter:    IN PTHREAD Thread
+//******************************************************************************
+void
+ThreadUnblock(
+    IN      PTHREAD              Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadYieldOnInterrupt
+// Description:  Returns TRUE if the thread must yield the CPU at the end of
+//               this interrupt. FALSE otherwise.
+// Returns:      BOOLEAN
+// Parameter:    void
+//******************************************************************************
+BOOLEAN
+ThreadYieldOnInterrupt(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadTerminate
+// Description:  Signals a thread to terminate.
+// Returns:      void
+// Parameter:    INOUT PTHREAD Thread
+// NOTE:         This function does not cause the thread to instantly terminate,
+//               if you want to wait for the thread to terminate use
+//               ThreadWaitForTermination.
+// NOTE:         This function should be used only in EXTREME cases because it
+//               will not free the resources acquired by the thread.
+//******************************************************************************
+void
+ThreadTerminate(
+    INOUT   PTHREAD             Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadTakeBlockLock
+// Description:  Takes the block lock for the executing thread. This is required
+//               to avoid a race condition which would happen if a thread is
+//               unblocked while in the process of being blocked (thus still
+//               running on the CPU).
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+ThreadTakeBlockLock(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadExecuteForEachThreadEntry
+// Description:  Iterates over the all threads list and invokes Function on each
+//               entry passing an additional optional Context parameter.
+// Returns:      STATUS
+// Parameter:    IN PFUNC_ListFunction Function
+// Parameter:    IN_OPT PVOID Context
+//******************************************************************************
+STATUS
+ThreadExecuteForEachThreadEntry(
+    IN      PFUNC_ListFunction  Function,
+    IN_OPT  PVOID               Context
+    );
+
+
+//******************************************************************************O
+// Function:     GetCurrentThread
+// Description:  Returns the running thread.
+// Returns:      void
+//******************************************************************************
+#define GetCurrentThread()      ((THREAD*)__HALreadfsqword(FIELD_OFFSET(THREAD, Self)))
+
+//******************************************************************************
+// Function:     SetCurrentThread
+// Description:  Sets the current running thread.
+// Returns:      void
+// Parameter:    IN PTHREAD Thread
+//******************************************************************************
+void
+SetCurrentThread(
+    IN      PTHREAD     Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadSetPriority
+// Description:  Sets the thread's priority to new priority. If the
+//               current thread no longer has the highest priority, yields.
+// Returns:      void
+// Parameter:    IN THREAD_PRIORITY NewPriority
+//******************************************************************************
+void
+ThreadSetPriority(
+    IN      THREAD_PRIORITY     NewPriority
+    );
diff --git a/src_proiect/HAL9000/headers/um_application.h b/src_proiect/HAL9000/headers/um_application.h
new file mode 100644
index 0000000..f613a95
--- /dev/null
+++ b/src_proiect/HAL9000/headers/um_application.h
@@ -0,0 +1,17 @@
+#pragma once
+
+typedef struct _PROCESS* PPROCESS;
+typedef struct _PE_NT_HEADER_INFO* PPE_NT_HEADER_INFO;
+
+STATUS
+UmApplicationRetrieveHeader(
+    IN_Z        char*                   Path,
+    OUT         PPE_NT_HEADER_INFO      NtHeaderInfo
+    );
+
+STATUS
+UmApplicationRun(
+    IN          PPROCESS                Process,
+    IN          BOOLEAN                 WaitForExecution,
+    OUT_OPT     STATUS*                 CompletionStatus
+    );
diff --git a/src_proiect/HAL9000/headers/vm_reservation_space.h b/src_proiect/HAL9000/headers/vm_reservation_space.h
new file mode 100644
index 0000000..5dd17c4
--- /dev/null
+++ b/src_proiect/HAL9000/headers/vm_reservation_space.h
@@ -0,0 +1,131 @@
+#pragma once
+
+#include "mem_structures.h"
+#include "vmm.h"
+
+typedef struct _FILE_OBJECT *PFILE_OBJECT;
+
+typedef struct _VMM_RESERVATION_SPACE
+{
+    // Because we have an effectively infinite virtual address space
+    // we will never decrement this pointer and the virtual addresses
+    // allocated will be strictly monotonically increasing
+    volatile PVOID      FreeVirtualAddressPointer;
+
+    // Space from which we can allocate virtual addresses
+    PVOID               StartOfVirtualAddressSpace;
+
+    PVOID               BitmapAddressStart;
+    QWORD               ReservedAreaSize;
+
+    QWORD               TotalMetadataSize;
+
+    RW_SPINLOCK         ReservationLock;
+
+    _Guarded_by_(ReservationLock)
+    PBYTE               FreeBitmapAddress;
+
+    _Guarded_by_(ReservationLock)
+    struct _VMM_RESERVATION*    ReservationList;
+} VMM_RESERVATION_SPACE, *PVMM_RESERVATION_SPACE;
+
+//******************************************************************************
+// Function:     VmReservationSpaceInit
+// Description:  
+// Returns:      void
+// Parameter:    IN PVOID ReservationMetadataBaseAddress - represents the virtual
+//               address where the metadata describing the virtual reservations
+//               will be placed
+// Parameter:    IN_OPT PVOID ReservationBaseAddress - the address from which the
+//               allocations should start, if NULL they start at the end of the
+//               metadata.
+// Parameter:    IN QWORD ReservationMetadataSize - size of VA space to reserve
+//               for the metadata.
+//******************************************************************************
+_No_competing_thread_
+void
+VmReservationSpaceInit(
+    IN                      PVOID                   ReservationMetadataBaseAddress,
+    IN_OPT                  PVOID                   ReservationBaseAddress,
+    IN                      QWORD                   ReservationMetadataSize,
+    OUT                     PVMM_RESERVATION_SPACE  ReservationSpace
+    );
+
+_No_competing_thread_
+void
+VmReservationSpaceFinishInit(
+    INOUT                   PVMM_RESERVATION_SPACE  ReservationSpace
+    );
+
+__forceinline
+RET_NOT_NULL
+PVOID
+VmReservationSpaceDetermineNextFreeVirtualAddress(
+    INOUT                   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN                      QWORD                   Size
+    )
+{
+    ASSERT(ReservationSpace != NULL);
+
+    return (PVOID) _InterlockedExchangeAdd64(&ReservationSpace->FreeVirtualAddressPointer, Size);
+}
+
+//******************************************************************************
+// Function:     VmReservationCanAddressBeAccessed
+// Description:  Checks if an Address belonging to a VA reservation space is
+//               valid for access with the RightsRequested.
+// Returns:      BOOLEAN - TRUE the address can be accessed with the requested
+//               rights.
+//                       - FALSE the address is either not committed or the
+//               rights requested exceed those of the commitment.
+// Parameter:    INOUT PVMM_RESERVATION_SPACE ReservationSpace
+// Parameter:    IN PVOID FaultingAddress
+// Parameter:    IN PAGE_RIGHTS RightsRequested
+// Parameter:    OUT PAGE_RIGHTS * MemoryRights
+// Parameter:    OUT BOOLEAN * Uncacheable
+// Parameter:    OUT_PTR_MAYBE_NULL PFILE_OBJECT * BackingFile
+// Parameter:    OUT QWORD * FileOffset
+//******************************************************************************
+BOOLEAN
+VmReservationCanAddressBeAccessed(
+    INOUT                   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN                      PVOID                   FaultingAddress,
+    IN                      PAGE_RIGHTS             RightsRequested,
+    OUT                     PAGE_RIGHTS*            MemoryRights,
+    OUT                     BOOLEAN*                Uncacheable,
+    OUT_PTR_MAYBE_NULL      PFILE_OBJECT*           BackingFile,
+    OUT                     QWORD*                  FileOffset
+    );
+
+STATUS
+VmReservationSpaceAllocRegion(
+    IN                      PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN_OPT                  PVOID                   BaseAddress,
+    IN                      QWORD                   Size,
+    IN                      VMM_ALLOC_TYPE          AllocType,
+    IN                      PAGE_RIGHTS             Rights,
+    IN                      BOOLEAN                 Uncacheable,
+    IN_OPT                  PFILE_OBJECT            FileObject,
+    OUT                     PVOID*                  MappedAddress,
+    OUT                     QWORD*                  MappedSize
+    );
+
+void
+VmReservationSpaceFreeRegion(
+    INOUT                   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN                      PVOID                   Address,
+    _When_(VMM_FREE_TYPE_RELEASE == FreeType, IN_OPT)
+    _When_(VMM_FREE_TYPE_RELEASE != FreeType, IN)
+                            QWORD                   Size,
+    IN                      VMM_FREE_TYPE           FreeType,
+    OUT                     PVOID*                  AlignedAddress,
+    OUT                     QWORD*                  AlignedSize
+    );
+
+STATUS
+VmReservationReturnRightsForAddress(
+    IN                      PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN                      PVOID                   Address,
+    IN                      QWORD                   Size,
+    OUT                     PAGE_RIGHTS*            Rights
+    );
diff --git a/src_proiect/HAL9000/headers/vmm.h b/src_proiect/HAL9000/headers/vmm.h
new file mode 100644
index 0000000..bc3f4a6
--- /dev/null
+++ b/src_proiect/HAL9000/headers/vmm.h
@@ -0,0 +1,309 @@
+#pragma once
+
+#include "mmu.h"
+#include "pte.h"
+
+typedef struct _FILE_OBJECT* PFILE_OBJECT;
+
+typedef struct _VMM_RESERVATION_SPACE* PVMM_RESERVATION_SPACE;
+
+typedef struct _MDL *PMDL;
+
+_No_competing_thread_
+void
+VmmPreinit(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+VmmInit(
+    IN      PVOID                   BaseAddress
+    );
+
+//******************************************************************************
+// Function:     VmmMapMemoryEx
+// Description:  Maps a PA using the received paging data into virtual space.
+// Returns:      PVOID - Virtual Address to which PhysicalAddress was mapped
+// Parameter:    IN PPAGING_DATA PagingData - Paging tables to use
+// Parameter:    IN PHYSICAL_ADDRESS PhysicalAddress - address to map
+// Parameter:    IN DWORD Size - PAGE_SIZE aligned number of bytes to map
+// Parameter:    IN PAGE_RIGHTS PageRights
+// Parameter:    IN BOOLEAN Invalidate
+// Parameter:    IN BOOLEAN Uncacheable
+//******************************************************************************
+PTR_SUCCESS
+PVOID
+VmmMapMemoryEx(
+    IN      PPAGING_DATA            PagingData,
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable
+    );
+
+//******************************************************************************
+// Function:     VmmMapMemoryInternal
+// Description:  Same as VmmMapMemoryEx except it maps the address to an
+//               explicit virtual address.
+/// NOTE:        This should be used used only in the vmm and mmu files
+//******************************************************************************
+void
+VmmMapMemoryInternal(
+    IN      PPAGING_DATA            PagingData,
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PVOID                   BaseAddress,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable
+    );
+
+//******************************************************************************
+// Function:     VmmUnmapMemoryEx
+// Description:  Unmaps a previously mapped VA with VmmMapMemoryEx or
+//               VmmMapMemoryInternal
+// Returns:      void
+// Parameter:    IN PML4 Cr3 - paging tables
+// Parameter:    IN PVOID VirtualAddress
+// Parameter:    IN DWORD Size - PAGE_SIZE aligned number of bytes to unmap
+//******************************************************************************
+void
+VmmUnmapMemoryEx(
+    IN      PML4                    Cr3,
+    IN      PVOID                   VirtualAddress,
+    IN      QWORD                   Size,
+    IN      BOOLEAN                 ReleaseMemory
+    );
+
+#define VmmGetPhysicalAddress(Cr3,Va)   VmmGetPhysicalAddressEx((Cr3),(Va),NULL,NULL)
+
+//******************************************************************************
+// Function:     VmmGetPhysicalAddressEx
+// Description:  Retrieves the physical address corresponding to VirtualAddress
+//               given Cr3 and optionally retrieves the accessed and dirty
+//               bits for the address.
+// Returns:      PHYSICAL_ADDRESS - If NULL the virtual addressed is not mapped
+// Parameter:    IN PML4 Cr3
+// Parameter:    IN PVOID VirtualAddress
+// Parameter:    OUT_OPT BOOLEAN* Accessed
+// Parameter:    OUT_OPT BOOLEAN* Dirty
+// NOTE:         If the Accessed or Dirty parameter is non-NULL the
+//               corresponding bit will be cleared after the value is saved.
+//******************************************************************************
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+VmmGetPhysicalAddressEx(
+    IN      PML4                    Cr3,
+    IN      PVOID                   VirtualAddress,
+    OUT_OPT BOOLEAN*                Accessed,
+    OUT_OPT BOOLEAN*                Dirty
+    );
+
+//******************************************************************************
+// Function:     VmmPreparePagingData
+// Description:  Retrieves the PAT indices required for mapping uncacheable and
+//               writeback memory.
+// Returns:      STATUS
+// Parameter:    void
+//******************************************************************************
+_No_competing_thread_
+STATUS
+VmmPreparePagingData(
+    void
+    );
+
+//******************************************************************************
+// Function:     VmmSetupPageTables
+// Description:  Setups the structures required for managing the paging tables
+//               with CR3 BasePhysicalAddress and FramesReserved in PagingData.
+//               This data will be available from the PagingDataWhereToMap space.
+// Returns:      STATUS
+// Parameter:    INOUT PPAGING_DATA PagingDataWhereToMap - Structures which will
+//               described the PagingData created.
+// Parameter:    OUT PPAGING_DATA PagingData - Structure describing the paging
+//               structures.
+// Parameter:    IN PHYSICAL_ADDRESS BasePhysicalAddress - CR3 physical address
+// Parameter:    IN DWORD FramesReserved - Number of frames to use
+//******************************************************************************
+STATUS
+VmmSetupPageTables(
+    INOUT   PPAGING_DATA            PagingDataWhereToMap,
+    OUT     PPAGING_DATA            PagingData,
+    IN      PHYSICAL_ADDRESS        BasePhysicalAddress,
+    IN      DWORD                   FramesReserved,
+    IN      BOOLEAN                 KernelStructures
+    );
+
+//******************************************************************************
+// Function:     VmmChangeCr3
+// Description:  Performs a CR3 switch to Pml4Base using PCID Pcid.
+// Returns:      void
+// Parameter:    IN PHYSICAL_ADDRESS Pml4Base
+// Parameter:    IN PCID Pcid
+// Parameter:    IN BOOLEAN Invalidate - if TRUE invalidates CPU caching
+//               translations made with Pcid.
+//******************************************************************************
+void
+VmmChangeCr3(
+    IN      PHYSICAL_ADDRESS        Pml4Base,
+    IN_RANGE(PCID_FIRST_VALID_VALUE, PCID_TOTAL_NO_OF_VALUES - 1)
+            PCID                    Pcid,
+    IN      BOOLEAN                 Invalidate
+    );
+
+_No_competing_thread_
+void
+VmmInitReservationSystem(
+    void
+    );
+
+#define VmmAllocRegion(Addr,Size,Type,Rights)       VmmAllocRegionEx((Addr),(Size),(Type),(Rights),FALSE, NULL, NULL, NULL, NULL)
+
+//******************************************************************************
+// Function:     VmmAllocRegion
+// Description:  Allocates a region of virtual memory.
+// Returns:      PVOID - Virtual address of the memory allocated
+// Parameter:    IN_OPT PVOID BaseAddress
+// Parameter:    IN QWORD Size
+// Parameter:    IN VMM_ALLOC_TYPE AllocType - a mask of the following values:
+//               VMM_ALLOC_TYPE_RESERVED - reserves the virtual address space
+//               VMM_ALLOC_TYPE_COMMIT - commits the virtual address
+//               VMM_ALLOC_TYPE_NOT_LAZY - if set the mapping will be valid
+//               after the function returns (without #PF occurrence) and the
+//               mapping will be to CONTINUOUS physical frames.
+// Parameter:    IN PAGE_RIGHTS Rights
+// Parameter:    IN BOOLEAN Uncacheable
+// Parameter:    IN_OPT PFILE_OBJECT FileObject -if non-NULL, represents the
+//               file which backs up the newly allocated memory.
+// Parameter:    IN_OPT PVMM_RESERVATION_SPACE VaSpace
+// Parameter:    IN_OPT PPAGING_LOCK_DATA PagingData
+// Parameter:    IN_OPT PMDL Mdl - if non-NULL, describes the physical memory
+//               to which the newly allocated virtual addresses will map to.
+/// NOTE:        When an address is committed it is not mapped to physical
+///              memory, it will be mapped on the first #PF
+//******************************************************************************
+PTR_SUCCESS
+PVOID
+VmmAllocRegionEx(
+    IN_OPT  PVOID                   BaseAddress,
+    IN      QWORD                   Size,
+    IN      VMM_ALLOC_TYPE          AllocType,
+    IN      PAGE_RIGHTS             Rights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject,
+    IN_OPT  PVMM_RESERVATION_SPACE  VaSpace,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData,
+    IN_OPT  PMDL                    Mdl
+    );
+
+#define VmmFreeRegion(...)          VmmFreeRegionEx(__VA_ARGS__,TRUE, NULL, NULL)
+
+//******************************************************************************
+// Function:     VmmFreeRegionEx
+// Description:  Frees a region of memory previously allocated.
+// Returns:      void
+// Parameter:    IN PVOID Address
+// Parameter:    IN QWORD Size
+// Parameter:    IN VMM_FREE_TYPE FreeType - can have one of two values (xor):
+//               VMM_FREE_TYPE_DECOMMIT - de-commits the virtual address
+//               VMM_FREE_TYPE_RELEASE - releases the whole reservation
+// Parameter:    IN BOOLEAN ReleaseMemory - if TRUE => the physical frames are
+//               released - else they will still be reserved. NOTE: You should
+//               really know what you're doing if you're setting this parameter
+//               to FALSE.
+// Parameter:    IN_OPT PVMM_RESERVATION_SPACE VaSpace
+// Parameter:    IN_OPT PPAGING_LOCK_DATA PagingData
+//******************************************************************************
+void
+VmmFreeRegionEx(
+    IN      PVOID                   Address,
+    _When_(VMM_FREE_TYPE_RELEASE == FreeType, _Reserved_)
+    _When_(VMM_FREE_TYPE_RELEASE != FreeType, IN)
+            QWORD                   Size,
+    IN      VMM_FREE_TYPE           FreeType,
+    IN      BOOLEAN                 Release,
+    IN_OPT  PVMM_RESERVATION_SPACE  VaSpace,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    );
+
+//******************************************************************************
+// Function:     VmmSolvePageFault
+// Description:
+// Returns:      BOOLEAN - TRUE => The current process has RightsRequested for
+//               the FaultingAddress and the address was successfully mapped.
+//                       - FALSE => The address is not commited or the process
+//               doesn't have RightsRequested for the FaultingAddress.
+// Parameter:    IN PVOID FaultingAddress - Address which incurred the #PF (CR2)
+// Parameter:    IN PAGE_RIGHTS RightsRequested - The rights requested by the
+//               access (taken from the Error Code pushed on the stack)
+// Parameter     IN PPAGING_LOCK_DATA PagingData - The paging structures
+//               used when the page-fault was generated.
+//******************************************************************************
+BOOLEAN
+VmmSolvePageFault(
+    IN      PVOID                   FaultingAddress,
+    IN      PAGE_RIGHTS             RightsRequested,
+    IN      PPAGING_LOCK_DATA       PagingData
+    );
+
+//******************************************************************************
+// Function:     VmmRetrieveReservationSpaceForSystemProcess
+// Description:  Retrieves a pointer to the system's reservation space.
+// Returns:      PVMM_RESERVATION_SPACE
+//******************************************************************************
+PVMM_RESERVATION_SPACE
+VmmRetrieveReservationSpaceForSystemProcess(
+    void
+    );
+
+//******************************************************************************
+// Function:     VmmCreateVirtualAddressSpace
+// Description:  Creates a virtual address space beginning at
+//               StartOfVirtualAddressSpace with metadata describing the space
+//               of ReservationMetadataSize bytes.
+// Returns:      STATUS
+// Parameter:    OUT_PTR PVMM_RESERVATION_SPACE * ReservationSpace
+// Parameter:    IN QWORD ReservationMetadataSize
+// Parameter:    IN PVOID StartOfVirtualAddressSpace
+//******************************************************************************
+STATUS
+VmmCreateVirtualAddressSpace(
+    OUT_PTR PVMM_RESERVATION_SPACE*         ReservationSpace,
+    IN      QWORD                           ReservationMetadataSize,
+    IN      PVOID                           StartOfVirtualAddressSpace
+    );
+
+//******************************************************************************
+// Function:     VmmDestroyVirtualAddressSpace
+// Description:  Destroys a previously created VAS by VmmCreateVirtualAddressSpace
+// Returns:      void
+// Parameter:    PVMM_RESERVATION_SPACE ReservationSpace
+//******************************************************************************
+void
+VmmDestroyVirtualAddressSpace(
+    _Pre_valid_ _Post_ptr_invalid_
+            PVMM_RESERVATION_SPACE          ReservationSpace
+    );
+
+//******************************************************************************
+// Function:     VmmIsBufferValid
+// Description:  Checks if the buffer described by Buffer and BufferSize is
+//               committed in ReservationSpace and if the RightsRequested
+//               access rights are available.
+// Returns:      STATUS
+// Parameter:    IN PVOID Buffer
+// Parameter:    IN QWORD BufferSize
+// Parameter:    IN PAGE_RIGHTS RightsRequested
+// Parameter:    IN PVMM_RESERVATION_SPACE ReservationSpace
+// Parameter:    IN BOOLEAN KernelAccess
+//******************************************************************************
+STATUS
+VmmIsBufferValid(
+    IN          PVOID                               Buffer,
+    IN          QWORD                               BufferSize,
+    IN          PAGE_RIGHTS                         RightsRequested,
+    IN          PVMM_RESERVATION_SPACE              ReservationSpace,
+    IN          BOOLEAN                             KernelAccess
+    );
diff --git a/src_proiect/HAL9000/src/Entry64.c b/src_proiect/HAL9000/src/Entry64.c
new file mode 100644
index 0000000..a9ccc37
--- /dev/null
+++ b/src_proiect/HAL9000/src/Entry64.c
@@ -0,0 +1,79 @@
+#include "HAL9000.h"
+
+#include "multiboot.h"
+#include "dmp_multiboot.h"
+
+#include "system.h"
+#include "cmd_interpreter.h"
+#include "common_lib.h"
+#include "hal_assert.h"
+#include "synch.h"
+#include "cpumu.h"
+
+//#define TST
+
+#ifdef TST
+#include "test_common.h"
+#include "keyboard.h"
+#endif
+
+int _fltused = 1;
+
+void
+Entry64(
+    IN  int                 argc,
+    IN  ASM_PARAMETERS*     argv
+    )
+{
+    STATUS status;
+    COMMON_LIB_INIT initSettings;
+
+    // We don't have commonlib support yet, as a result we have no way of asserting at this point
+    if (!IS_STACK_ALIGNED) __halt();
+
+    status = STATUS_SUCCESS;
+    memzero(&initSettings, sizeof(COMMON_LIB_INIT));
+
+    initSettings.Size = sizeof(COMMON_LIB_INIT);
+    initSettings.AssertFunction = Hal9000Assert;
+
+    CpuMuPreinit();
+
+    status = CpuMuSetMonitorFilterSize(sizeof(MONITOR_LOCK));
+    initSettings.MonitorSupport = SUCCEEDED(status);
+
+    status = CommonLibInit(&initSettings);
+    if (!SUCCEEDED(status))
+    {
+        // not good lads
+        __halt();
+    }
+
+    ASSERT_INFO(1 == argc, "We are always expecting a single parameter\n");
+    ASSERT_INFO(NULL != argv, "We are expecting a non-NULL pointer\n");
+
+    gVirtualToPhysicalOffset = argv->VirtualToPhysicalOffset;
+    SystemPreinit();
+
+    DumpParameters(argv);
+
+    status = SystemInit(argv);
+    ASSERT(SUCCEEDED(status));
+
+    LOGL("InitSystem executed successfully\n");
+
+#ifdef TST
+    TestRunAllFunctional();
+    TestRunAllPerformance();
+    KeyboardResetSystem();
+#endif
+
+    // will run until exit command
+    CmdRun();
+
+    // uninitialize system
+    // at the end of this routine interrupts should be disabled
+    SystemUninit();
+
+    __halt();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/_exports.yasm b/src_proiect/HAL9000/src/_exports.yasm
new file mode 100644
index 0000000..caf0144
--- /dev/null
+++ b/src_proiect/HAL9000/src/_exports.yasm
@@ -0,0 +1,39 @@
+%include "lib.yasm"
+
+global RestoreRegisters
+
+align 0x10, db 0
+[bits 64]
+; void __cdecl* RestoreRegisters( PROCESSOR_STATE* ProcessorState )
+RestoreRegisters:
+    mov     rbx,    rcx
+
+    AlignAddressUpper   rbx, XSAVE_AREA_REQUIRED_ALIGNMENT
+
+%if INCLUDE_FP_SUPPORT
+    mov     edx,    0xFFFFFFFF
+    mov     eax,    edx
+
+    xrstor  QWORD   [rbx]
+%endif
+
+    mov     Rax,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rax]
+    mov     Rdx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx]
+    mov     Rbx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx]
+    mov     Rbp,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbp]
+    mov     Rsi,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rsi]
+    mov     Rdi,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi]
+
+    mov     R8,     [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R8]
+    mov     R9,     [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R9]
+    mov     R10,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R10]
+    mov     R11,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R11]
+    mov     R12,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R12]
+    mov     R13,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R13]
+    mov     R14,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R14]
+    mov     R15,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R15]
+
+    ; we leave rcx at the very end so we will still have a valid pointer
+    mov     Rcx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx]
+
+    ret
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/_isr.yasm b/src_proiect/HAL9000/src/_isr.yasm
new file mode 100644
index 0000000..073a29c
--- /dev/null
+++ b/src_proiect/HAL9000/src/_isr.yasm
@@ -0,0 +1,206 @@
+%include "lib.yasm"
+
+extern RestoreRegisters
+
+%macro call_handler 2
+%if %2 == 0
+    sub             rsp,        0x8
+%endif
+
+    sub             rsp,        0x10
+    mov             [rsp],      DWORD %1      ; interrupt index
+    mov             [rsp+8],    DWORD %2      ; if 1 => Error code on stack
+
+    jmp             PreIsrHandler
+%endmacro
+
+extern IsrCommonHandler
+
+; exceptions
+global DivideError
+global DebugException
+global NMIInterrupt
+global BreakpointException
+global OverflowException
+global BoundRangeExceededException
+global InvalidOpcode
+global DeviceNotAvailable
+global DoubleFault
+global CoprocessorSegmentOverrun
+global InvalidTSS
+global SegmentNotPresent
+global StackFault
+global GeneralProtection
+global PageFault
+global FloatingPointX87Error
+global AlignmentCheck
+global MachineCheck
+global FloatingPointSIMD
+global VirtualizationException
+
+; Interrupt 0 - Divide Error Exception (#DE)
+align 0x10, db 0
+[bits 64]
+DivideError:
+    call_handler    0, 0
+
+; Interrupt 1 - Debug Exception (#DB)
+align 0x10, db 0
+[bits 64]
+DebugException:
+    call_handler    1, 0
+
+; Interrupt 2 - NMI Interrupt
+align 0x10, db 0
+[bits 64]
+NMIInterrupt:
+    call_handler    2, 0
+
+; Interrupt 3 - Breakpoint Exception (#BP)
+align 0x10, db 0
+[bits 64]
+BreakpointException:
+    call_handler    3, 0
+
+; Interrupt 4 - Overflow Exception (#OF)
+align 0x10, db 0
+[bits 64]
+OverflowException:
+    call_handler    4, 0
+
+; Interrupt 5 - BOUND Range Exceeded Exception (#BR)
+align 0x10, db 0
+[bits 64]
+BoundRangeExceededException:
+    call_handler    5, 0
+
+; Interrupt 6 - Invalid Opcode Exception (#UD)
+align 0x10, db 0
+[bits 64]
+InvalidOpcode:
+    call_handler    6, 0
+
+; Interrupt 7 - Device Not Available Exception (#NM)
+align 0x10, db 0
+[bits 64]
+DeviceNotAvailable:
+    call_handler    7, 0
+
+; Interrupt 8 - Double Fault Exception (#DF)
+align 0x10, db 0
+[bits 64]
+DoubleFault:
+    call_handler    8, 1
+
+; Interrupt 9 - Coprocessor Segment Overrun
+align 0x10, db 0
+[bits 64]
+CoprocessorSegmentOverrun:
+    call_handler    9, 0
+
+; Interrupt 10 - Invalid TSS Exception (#TS)
+align 0x10, db 0
+[bits 64]
+InvalidTSS:
+    call_handler    10, 1
+
+; Interrupt 11 - Segment Not Present (#NP)
+align 0x10, db 0
+[bits 64]
+SegmentNotPresent:
+    call_handler    11, 1
+
+; Interrupt 12 - Stack Fault (#SS)
+align 0x10, db 0
+[bits 64]
+StackFault:
+    call_handler    12, 1
+
+; Interrupt 13 - General Protection Exception (#GP)
+align 0x10, db 0
+[bits 64]
+GeneralProtection:
+    call_handler    13, 1
+
+; Interrupt 14 - Page Fault Exception (#PF)
+align 0x10, db 0
+[bits 64]
+PageFault:
+    call_handler    14, 1
+
+; Interrupt 16 - x87 FPU Floating-Point Error (#MF)
+align 0x10, db 0
+[bits 64]
+FloatingPointX87Error:
+    call_handler    16, 0
+
+; Interrupt 17 - Alignment Check Exception (#AC)
+align 0x10, db 0
+[bits 64]
+AlignmentCheck:
+    call_handler    17, 1
+
+; Interrupt 18 - Machine-Check Exception (#MC)
+align 0x10, db 0
+[bits 64]
+MachineCheck:
+    call_handler    18, 0
+
+; Interrupt 19 - SIMD Floating-Point Exception (#XM)
+align 0x10, db 0
+[bits 64]
+FloatingPointSIMD:
+    call_handler    19, 0
+
+; Interrupt 20 - Virtualization Exception (#VE)
+align 0x10, db 0
+[bits 64]
+VirtualizationException:
+    call_handler    20, 0
+
+align 0x10, db 0
+[bits 64]
+PreIsrHandler:
+    save_proc_state
+
+    ; 4th argument - pointer to processor state
+    mov             r9, rsp
+
+    ; 3rd argument - BOOLEAN, error code available
+    ; we only read a DWORD because that's what we wrote
+    ; because operand size is 32-bit on x64 upper half of
+    ; register will be zeroed
+    mov             r8d, [rsp + COMPLETE_PROCESSOR_STATE_size + 8]
+
+    ; 2nd argument - pointer to interrupt stack
+    ; need to add an additional +0x10 because we use 2 bytes
+    ; from the stack for the arguments received
+    lea             rdx, [rsp + COMPLETE_PROCESSOR_STATE_size + 0x10]
+
+    ; 1st argument - interrupt index
+    mov             ecx, [rsp + COMPLETE_PROCESSOR_STATE_size]
+
+    call_func_64    IsrCommonHandler, rcx, rdx, r8, r9
+
+    mov             rcx, rsp
+    call            RestoreRegisters
+
+    ; restore stack
+    add             rsp, COMPLETE_PROCESSOR_STATE_size
+
+    ; we also have the 2 arguments passed to us on the stack
+    ; and the error code
+    add             rsp, 0x18
+
+    iretq
+
+%assign     i       0x20
+%rep        224
+global      GenericIsr %+ i
+
+align 0x10, db 0
+[bits 64]
+GenericIsr %+ i:
+    call_handler    i, 0
+%assign     i   i + 0x1
+%endrep
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/_low_mem.yasm b/src_proiect/HAL9000/src/_low_mem.yasm
new file mode 100644
index 0000000..1d049c8
--- /dev/null
+++ b/src_proiect/HAL9000/src/_low_mem.yasm
@@ -0,0 +1,246 @@
+%include "lib.yasm"
+
+global CallToRM
+global LowGdtBase
+
+LowGdtBase:
+.gdt_size           dw  ( LowGdtTable.end - LowGdtTable - 1 )
+.gdt_address        dq  LOW_GDT_BASE_ADDRESS + 0x10
+
+align               0x8,    db 'a'
+
+LowGdtTable:                                                ; GDT with 1+6 entries
+.null               dq  0
+.data64             dq  GDT_DESC_DATA64                     ; Data segment
+.code64             dq  GDT_DESC_CODE64                     ; Code segment, 64 bit, execute / read, present
+.data32             dq  GDT_DESC_DATA32
+.code32             dq  GDT_DESC_CODE32
+.data16             dq  GDT_DESC_DATA16
+.code16             dq  GDT_DESC_CODE16
+.end
+
+times               (0x100 - ( LowGdtTable.end - LowGdtBase ) ) db 'z'
+; this function goes from 32 bit PM to 16 bit RM  ( will be copied in LOW_PM32_RM16_ADDRESS )
+PM32_to_RM16:
+    [bits 32]       
+    cli                     ; disable interrupts
+
+    lgdt    [LOW_GDT_BASE_ADDRESS]
+    
+    mov     eax,        'TTTT'
+    mov     [0xB8024],  eax
+    
+    jmp     GDT_DESC(LowGdtTable,code16):( LOW_PM32_RM16_ADDRESS + ( PM32_to_RM16.bits16 - PM32_to_RM16 ) )
+.bits16:
+    [bits 16]   
+    mov     ax,     GDT_DESC(LowGdtTable,data16)
+    mov     ds,     ax
+    mov     es,     ax          ;   set the data descriptors
+    mov     ss,     ax
+    mov     fs,     ax
+    mov     gs,     ax
+
+    push    DWORD   REAL_MODE_IVT_BASE
+    push    WORD    REAL_MODE_IVT_LIMIT
+
+    lidt    [esp]
+
+    add     esp,    0x6
+
+    mov     eax,    cr0 
+    and     eax,    ~(CR0_CD | CR0_NW | CR0_PE ) ; protection, CD and NW will now be disabled
+    mov     cr0,    eax
+    
+    jmp     ( 0x0 ):( LOW_PM32_RM16_ADDRESS + ( PM32_to_RM16.seg0 - PM32_to_RM16 ) )
+.seg0:
+
+    xor     ax,     ax
+    mov     ds,     ax
+    mov     es,     ax          ;   set the data descriptors
+    mov     ss,     ax
+    mov     fs,     ax
+    mov     gs,     ax
+
+    ; the ret now only take the RA as 2 bytes and we need to
+    ; free the next 2 bytes too(HIGH WORD of the RA)
+    ret     2               
+.end
+
+times               (0x100 - ( PM32_to_RM16.end - PM32_to_RM16 ) ) db 'p'
+; this function goes from 16 bit RM to 32 bit PM
+; ( will be copied in LOWER_MEMORY_ADDRESS + (PM32_to_RM16.end - PM32_to_RM16 ) )
+; LOW_RM16_PM32_ADDRESS
+; void __stdcall RM16_to_PM32( DWORD OldStack )
+RM16_to_PM32:
+    [bits 16]       
+    ;   use PUSHFD
+    ;   because flags is only 16 bit while EFLAGS will be 32bit
+    pushfd                      ;   save current flags
+    cli
+    
+    lgdt    [LOW_GDT_BASE_ADDRESS]      ;   set the GDT
+
+    mov     eax,    cr0
+    or      al,     (CR0_PE|CR0_NE)     ;   set PE and NE flag 
+    and     eax,    ~(CR0_CD|CR0_NW)    ;   and clear CD and NW
+    mov     cr0,    eax
+    
+    jmp     GDT_DESC(LowGdtTable,code32):( LOW_RM16_PM32_ADDRESS + ( RM16_to_PM32.bits32 - RM16_to_PM32 ) )
+    
+.bits32:
+    [bits 32]                   ;   we're in 32 bits
+    mov     ax,     GDT_DESC(LowGdtTable,data32)
+    mov     ds,     ax
+    mov     es,     ax          ;   set the data descriptors
+    mov     ss,     ax
+    mov     fs,     ax
+    mov     gs,     ax
+
+    popfd                       ;   restore flags
+    
+    ; we should first restore old stack
+    movzx   edx,    WORD [esp]
+    mov     ebx,    [esp+2]
+    mov     esp,    ebx         ; we have the old stack
+    
+    mov     [esp],  edx         ; we don't do a push because we still have
+                                ; the RA from PM32_to_RM16 function
+    
+    ret
+.end
+
+times               (0x100 - ( RM16_to_PM32.end - RM16_to_PM32 ) ) db 'r'
+; __cdecl void proc16 RetrieveInt15Map( WORD BufferSelector, WORD BufferAddress, WORD* NumberOfEntries )
+[bits 16]
+RetrieveInt15Map:
+    push    bp
+    mov     bp,         sp
+    sub     sp,         2
+
+    xor     ax,         ax
+    mov     [esp],      ax
+
+    xor     ebx,        ebx                             ; continuation code
+    
+    mov     ax,         [p16(0)]
+    mov     es,         ax
+
+    mov     ax,         [p16(1)]
+    mov     di,         ax
+
+.loop:
+    mov     eax,        INT15_E820_CODE
+    
+    mov     ecx,        INT15_MEMORY_MAP_ENTRY_size
+    mov     edx,        INT15_E820_SIGNATURE
+
+    sti
+    int     15h
+    jc      .finished
+
+    cmp     eax,        INT15_E820_SIGNATURE
+    jne     .error
+
+    cmp     ecx,        INT15_MEMORY_MAP_ENTRY_MIN_SIZE
+    jl      .error
+
+    cmp     ecx,        INT15_MEMORY_MAP_ENTRY_size
+    jnl     .next_entry
+
+    mov     si,         di
+    add     si,         INT15_MEMORY_MAP_ENTRY_MIN_SIZE
+
+    ; extended attribute
+    mov     eax,        1
+
+    mov     [es:si],    eax
+
+.next_entry:
+    mov     ax,         [esp]
+    inc     ax
+    mov     [esp],      ax
+
+    add     di,         INT15_MEMORY_MAP_ENTRY_size
+
+    test    ebx, ebx
+    jz      .finished
+    jmp     .loop
+.error:
+    mov     ax,         0xB800
+    mov     fs,         ax
+    mov     si,         0x230
+    mov     ax,         'KK'
+    mov     [fs:si],    ax
+
+    cli
+    hlt
+           
+.finished:
+    mov     ax,     [esp]
+    test    ax,     ax
+    jz      .error
+
+    mov     si,     [p16(2)]
+    mov     [si],   ax
+
+    add     sp,     2
+    pop     bp
+
+    cli
+
+    ret     2*3
+.end:
+
+times               (0x100 - ( RetrieveInt15Map.end - RetrieveInt15Map ) ) db 'k'
+CallToRM:
+    [bits 32]
+    push        ebp
+    mov         ebp,     esp
+    pusha
+
+    push    LOW_CALL_TO_RM_ADDRESS + ( CallToRM.bits16 - CallToRM )
+    push    LOW_PM32_RM16_ADDRESS
+    ret
+    [bits 16]
+.bits16:
+    ; here's where all the work will happen
+    mov        cx,     WORD [bp + 3 * 4]        ; cx <- NumberOfParameters
+    
+    xor        si,     si                       ; i = 0
+.setare_param:
+    cmp        si,     cx                       ; i >= NumberOfParameters?
+    jae        .final_bucla                     ; if TRUE end loop
+    
+    dec        cx
+    
+    mov        si,     cx                       ; si <- si * 4
+    shl        si,     2
+    
+    mov        ax,     WORD [bp + 4 * 4 + si]   ; get the (n-i)th parameter
+    
+    xor        si,     si                       ; si <- si / 4
+
+    push    ax                                  ; set parameter (n-i) on the stack
+    
+    jmp        .setare_param
+    
+.final_bucla:
+    call    [bp + 8]                        ; call Proc
+
+    mov     ax,         sp
+    sub     ax,         4
+    push    0x0
+    push    ax        ; we need to substract 4 so after the RET we'll have LOW_MEMORY_STACK_TOP
+
+    push    LOW_CALL_TO_RM_ADDRESS + ( CallToRM.bits32 - CallToRM )
+    jmp     0:LOW_RM16_PM32_ADDRESS
+    [bits 32]
+.bits32:
+    mov     eax,        'TTTT'
+    mov     [0xB8048],  eax
+
+    popa
+
+    pop        ebp
+    ret
+.end:
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/_mboot32.yasm b/src_proiect/HAL9000/src/_mboot32.yasm
new file mode 100644
index 0000000..037f381
--- /dev/null
+++ b/src_proiect/HAL9000/src/_mboot32.yasm
@@ -0,0 +1,236 @@
+%include "lib.yasm"
+
+;; IMPORTS
+extern HalActivateFpu
+extern Entry64
+
+extern PM32_to_PM64
+extern PM64_to_PM32
+extern CallToRM
+extern LowGdtBase
+
+;; EXPORTS
+global __EntryMultiboot
+
+%define GDT_DESCRIPTOR_ADDRESS                      ( GDT_BASE_ADDRESS + __gdt_base.end - __gdt_base )
+
+; The Multiboot header must be contained completely within the first 8192 bytes of the OS image
+SECTION .mboot
+;;
+;; KERNEL_BASE + 0x400 (this must be the first stuff to be linked into the code segment)
+;;
+multiboot_header:                                       ; check out '3.1.1 The layout of Multiboot header'
+magic           dd MULTIBOOT_HEADER_MAGIC                                   ; 0x0
+flags           dd MULTIBOOT_HEADER_FLAGS                                   ; 0x4
+checksum        dd 0-(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)      ; 0x8
+header_addr     dd MULTIBOOT_BASE                                           ; 0xc
+load_addr       dd KERNEL_BASE                                              ; 0x10
+load_end_addr   dd 0                                                        ; 0x14
+bss_end_addr    dd 0                                                        ; 0x18
+entry_addr      dd MULTIBOOT_ENTRY_POINT                                    ; 0x1c
+mode_type       dd 0
+width           dd 0
+height          dd 0
+depth           dd 0
+
+gMultiBootStruct:                                       ; reserve space for the multiboot info structure (will copy here)
+times MULTIBOOT_INFO_STRUCT_SIZE db 'M'                 ; check out '3.3 Boot information format'
+
+;; pad until 0x100
+times ( MULTIBOOT_SECTION_SIZE - MULTIBOOT_HEADER_SIZE - MULTIBOOT_INFO_STRUCT_SIZE ) db 'A'
+
+;;
+;; KERNEL_BASE + 0x500
+;;
+__gdt_base:                                             ; GDT with 1+6+2 entries
+.null               dq      0
+.data64             dq      GDT_DESC_DATA64                 ; Data segment
+.code64             dq      GDT_DESC_CODE64                 ; Code segment, 64 bit, execute / read, present
+.data32             dq      GDT_DESC_DATA32
+.code32             dq      GDT_DESC_CODE32
+.data16             dq      GDT_DESC_DATA16
+.code16             dq      GDT_DESC_CODE16
+.end
+
+; size and address of __gdt_base
+__gdtr:
+.gdt_size        dw  ( __gdt_base.end - __gdt_base - 1 )
+.gdt_address     dq  GDT_BASE_ADDRESS
+.end
+
+times ( GDT_SECTION_SIZE - ( __gdtr.end - __gdt_base) ) db 'G'
+
+;;
+;; KERNEL_BASE + 0x700
+;;
+data:
+gAsmParameters          times    ASM_PARAMETERS_size db 'P'
+
+data_end:
+
+times ( DATA_SECTION_SIZE - ( data_end- data )) db 'D'
+
+;;
+;; KERNEL_BASE + 0x2000
+;; PML4
+__pml4_table:
+dq              PDP_TABLE_BASE | P_BIT | RW_BIT   ; entry for 0 - 512G, PDP
+times KERNEL_PML4_INDEX - 1 dq 0
+dq              PDP_TABLE_BASE | P_BIT | RW_BIT   ; entry for 1T - 1,5T, PDP
+times PTE_PER_TABLE - KERNEL_PML4_INDEX - 1 dq 0
+
+;; KERNEL_BASE + 0x3000
+;; PDPT
+__pdp_table_1t:
+dq              PD_TABLE_LOW_1GB_BASE | P_BIT | RW_BIT
+times 511 dq 0
+
+;; KERNEL_BASE + 0x4000
+;; PDT
+__pd_table:
+dq              PT_TABLE_LOW_2MB_BASE | P_BIT | RW_BIT   ; entry for 0 - 2M, PT, using PT to avoid mapping first 4K (do NOT map NULL pointer)
+times KERNEL_NO_OF_PAGES_BEFORE dq 0
+dq              KERNEL_BASE | PS_BIT | P_BIT | RW_BIT
+
+%assign     i   KERNEL_BASE + PD_ENTRY_LENGTH
+%rep KERNEL_NO_OF_PAGES_AFTER - 1
+dq          i | XD_BIT | PS_BIT | P_BIT | RW_BIT
+%assign     i   i + PD_ENTRY_LENGTH
+%endrep
+
+;; KERNEL_BASE + 0x5000
+;; PT for first 2 MB of memory
+__pt_table_low_2mb:
+times 1     dq 0                        ; P = 0, NOT preset, to avoid NULL pointers
+                                        ; will be dynamically generated
+%assign     i   0x1000
+%rep 511
+dq          i | P_BIT | RW_BIT
+%assign     i   i + PAGE_SIZE
+%endrep
+
+;; KERNEL_BASE + 0x6000
+;;
+[bits 32]
+__EntryMultiboot:
+    ; make sure interrupts are disabled
+    cli
+
+    ; simply echo something to the screen, by direct memory write to 80x25 text mode VGA video mem (0xB8000)
+    mov     [0x000B8000], DWORD '1111'      ; signal our presence
+
+    ; setup initial ESP, to have stack
+    mov     esp, INITIAL_TOP_OF_STACK
+
+    ; check if we were loaded by multiboot
+    cmp     eax, MULTIBOOT_LOADER_MAGIC
+    jz      .mb_load
+
+    ; if we get here it means we were not loaded by the MB loader
+    ; we don't know any other way of loading
+    mov     eax, 'EEEE'                     ; signal error
+    mov     [0x000B8000], eax
+    cli
+    hlt
+
+.mb_load:
+
+    ; multiboot loaded us
+    mov     [0x000B8004], DWORD '2222'      ; signal our presence
+
+    ; it is best to load our own GDT
+    lgdt    [GDT_DESCRIPTOR_ADDRESS]
+
+    ; reload CS
+    jmp     GDT_DESC(__gdt_base,code32):MULTIBOOT_ENTRY_POINT + ( __EntryMultiboot.new_gdt - __EntryMultiboot )
+.new_gdt:
+    mov     ax,         GDT_DESC(__gdt_base,data32)
+    mov     ss,         ax
+    mov     ds,         ax
+    mov     es,         ax
+    mov     fs,         ax
+    mov     gs,         ax
+
+    ; we copy the structure passed to us by the multiboot loader
+    mov     esi, ebx
+    mov     edi, MULTIBOOT_INFO_ADDRESS
+    mov     ecx, MULTIBOOT_INFO_STRUCT_SIZE
+    cld
+    rep     movsb
+
+    mov     [0x000B8008], DWORD '3333'      ; signal our presence
+
+    ; we place code under 1MB
+    ; our trampoline
+    mov     esi, MULTIBOOT_BASE + ( LowGdtBase - multiboot_header )
+    mov     edi, LOW_GDT_BASE_ADDRESS
+    mov     ecx, LOW_MEMORY_LENGTH
+    cld
+    rep     movsb
+
+    mov     esp, LOW_MEMORY_STACK_TOP
+
+    callproc    CallToRM, LOW_RETRIEVE_INT15_MAP_ADDRESS, 3, 0, LOW_MEMORY_MAP_ENTRIES_ADDRESS, LOW_MEMORY_MAP_NUMBER_ADDRESS
+
+    ; retrieve BDA serial port entries
+    lea     edi,    [DATA_BASE_ADDRESS + ASM_PARAMETERS_DATA_OFFSET + ASM_PARAMETERS.BiosSerialPorts]
+    mov     esi,    BIOS_SERIAL_PORT_ADDRESS
+    mov     ecx,    BIOS_NO_OF_SERIAL_PORTS
+    cld
+    rep     movsw
+
+    sub     esp,                                                TRANSITION_CONFIG_size
+    mov     ecx,                                                esp
+
+    setup_transition_config_32 ecx, GDT_DESCRIPTOR_ADDRESS, INITIAL_TOP_OF_STACK, GDT_DESC(__gdt_base,code64), GDT_DESC(__gdt_base,data64), INITIAL_TOP_OF_STACK_1T & 0xFFFFFFFF, INITIAL_TOP_OF_STACK_1T >> 32, PML4_TABLE_BASE
+
+; after this function call we'll be in 64 bit mode
+    call    PM32_to_PM64
+[bits 64]
+;
+; now we are using final 1T virtual addresses, full x64, have an 8K stack in place, so are ready to jump to our C code
+;
+call_final:
+    call_func_64    HalActivateFpu
+
+    call            PlaceInformationInParameters
+
+    call_func_64    Entry64, QWORD 1, QWORD gAsmParameters
+
+.never:
+    cli
+    hlt
+    jmp     .never
+
+
+[bits 64]
+PlaceInformationInParameters:
+; we set the pointer to the multiboot information structure
+    mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.MultibootInformation
+    mov     rbx,    MULTIBOOT_INFO_ADDRESS
+    mov     [rax],  rbx
+
+    mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.KernelBaseAddress
+    mov     rbx,    QWORD KERNEL_BASE_VIRTUAL
+    mov     [rax],  rbx
+
+    mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.KernelSize
+    mov     rbx,    QWORD KERNEL_LENGTH
+    mov     [rax],  rbx
+
+    mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.VirtualToPhysicalOffset
+    mov     rbx,    QWORD PA_2_VA_DIFFERENCE
+    mov     [rax],  rbx
+
+    mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.MemoryMapEntries
+    xor     ebx,    ebx
+    mov     bx,     [LOW_MEMORY_MAP_NUMBER_ADDRESS]
+    mov     [rax],  ebx
+
+    mov     rax,    QWORD gAsmParameters + ASM_PARAMETERS.MemoryMapAddress
+    mov     rbx,    LOW_MEMORY_MAP_ENTRIES_ADDRESS
+    mov     [rax],  rbx
+
+    ret
+
+.end:
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/_syscall.yasm b/src_proiect/HAL9000/src/_syscall.yasm
new file mode 100644
index 0000000..0d67e7f
--- /dev/null
+++ b/src_proiect/HAL9000/src/_syscall.yasm
@@ -0,0 +1,49 @@
+%include "lib.yasm"
+
+global SyscallEntry
+
+extern SyscallHandler
+extern RestoreRegisters
+
+align 0x10, db 0x0
+[bits 64]
+SyscallEntry:
+    ; RCX <- Will contain UM RIP
+    ; R11 <- Will contain UM RFLAGS
+    ; RFLAGS <- UM RFLAGS & ~(IA32_FMASK)
+    ; CS.Selector = IA32_STAR[47:32]
+    ; SS.Selector = IA32_STAR[47:32] + 0x8
+
+    ; Save RIP in RDI (non-volatile register)
+    mov     rdi, rcx
+
+    mov     ecx, IA32_GS_BASE_MSR
+    rdmsr
+
+    shl     rdx, 0x20
+    or      rdx, rax
+
+    ; Store user-stack in RCX
+    mov     rcx, rsp
+
+    ; => we have KM stack
+    mov     rsp, [rdx + 0x8]
+
+    ; save current UM state (w/ RAX and RSP clobbered)
+    save_proc_state
+
+    mov             rcx, rsp
+    call_func_64    SyscallHandler
+
+    mov             rcx, rsp
+    call            RestoreRegisters
+
+    ; restore user stack in RSP
+    mov             rsp, rcx
+
+    ; RCX <- RIP
+    mov             rcx, rdi
+
+    ; sysretq (YASM seems to be incapable of adding the REX.W prefix)
+    db 0x48
+    sysret
diff --git a/src_proiect/HAL9000/src/_thread.yasm b/src_proiect/HAL9000/src/_thread.yasm
new file mode 100644
index 0000000..9ad2886
--- /dev/null
+++ b/src_proiect/HAL9000/src/_thread.yasm
@@ -0,0 +1,44 @@
+%include "lib.yasm"
+
+global ThreadSwitch
+global ThreadStart
+
+extern RestoreRegisters
+extern ThreadCleanupPostSchedule
+
+align 0x10, db 0
+[bits 64]
+; void __cdecl* ThreadSwitch( OUT_PTR PVOID* OldStack, IN PVOID NewStack )
+ThreadSwitch:
+    save_proc_state
+
+    mov     rax,        rcx
+    mov     [rcx],      rsp
+    sfence
+
+    mov     rsp,        rdx
+    mov     rcx,        rsp
+
+    call    RestoreRegisters
+
+    ; restore stack
+    add     rsp,        COMPLETE_PROCESSOR_STATE_size
+
+    ret
+
+align 0x10, db 0
+[bits 64]
+; void __cdecl* ThreadStart( IN PVOID Function, IN_OPT PVOID Context)
+ThreadStart:
+    ; rsi and rdi are non-volatile registers, save the parameters there
+    mov     rsi, rcx
+    mov     rdi, rdx
+
+    call_func_64    ThreadCleanupPostSchedule
+
+    mov     rcx, rsi
+    mov     rdx, rdi
+
+    ; This iretq will lead us to _ThreadKernelFunction for kernel-mode code
+    ; and to the __start or __start_thread functions for user-mode code
+    iretq
diff --git a/src_proiect/HAL9000/src/_trampoline.yasm b/src_proiect/HAL9000/src/_trampoline.yasm
new file mode 100644
index 0000000..665a827
--- /dev/null
+++ b/src_proiect/HAL9000/src/_trampoline.yasm
@@ -0,0 +1,124 @@
+%include "lib.yasm"
+
+global TrampolineStart
+global PM32_to_PM64_PlaceHolder
+global LowGdtTable
+global LowGdtTableEnd
+
+extern PM32_to_PM64
+
+LowGdtTable:                                                ; GDT to be filled by C code
+    times        0x80 db 'G'
+LowGdtTableEnd
+
+[bits 16]
+TrampolineStart:
+    wbinvd      ; invalidate caches
+    cli         ; disable interrupts
+
+    cld         ; we don't want any surprises
+
+    jmp     0:TRAMPOLINE_MEMORY_TRAMP_START + ( TrampolineStart.reloadCs - TrampolineStart )
+.reloadCs:
+    ; this is where the jump will take us
+    xor     ax, ax
+    mov     ds, ax
+    mov     es, ax
+    mov     gs, ax
+    mov     fs, ax
+
+    retrieve_config_addresses
+
+    xor     ax, ax
+    mov     ah, [edx + AP_CONFIG_ENTRY.StackPhysicalAddress + 2]
+    mov     ss, ax
+    mov     sp, [edx + AP_CONFIG_ENTRY.StackPhysicalAddress]
+
+    sub     sp, TRANSITION_CONFIG_size
+    mov     cx, sp
+
+    mov     esi, ebx
+    add     esi, SYSTEM_CONFIG.LowGdt
+
+    setup_transition_config_16 ecx, esi, [edx + AP_CONFIG_ENTRY.StackPhysicalAddress], [ebx + SYSTEM_CONFIG.Code32Selector], [ebx + SYSTEM_CONFIG.Data32Selector]
+
+.callPreBits32:
+    ; here we call PM16_to_PM32
+    call    $+(TrampolineStart.end - TrampolineStart.callPreBits32)
+.bits32:
+[bits 32]
+    retrieve_config_addresses
+
+    ; we are in 32-bits
+    sub     esp,                                                TRANSITION_CONFIG_size
+    mov     ecx,                                                esp
+
+    mov     esi,                                                ebx
+    add     esi,                                                SYSTEM_CONFIG.HighGdt
+
+    setup_transition_config_32 ecx, esi, [edx + AP_CONFIG_ENTRY.StackPhysicalAddress], [ebx + SYSTEM_CONFIG.Code64Selector], [ebx + SYSTEM_CONFIG.Data64Selector], [edx + AP_CONFIG_ENTRY.StackVirtualAddress], [edx + AP_CONFIG_ENTRY.StackVirtualAddress + 4], [ebx + SYSTEM_CONFIG.Pml4PhysicalAddress]
+.callPreBits64:
+    call    $+(RM16_to_PM32.end - TrampolineStart.callPreBits64)
+[bits 64]
+    ; we are in 64-bits
+    ; the stack will be set up by the C code
+    ; so all that we'll do is a return
+    ; after we placed the first (and only) function parameter in rcx
+    mov     rcx,            [rsp + 0x10]
+    ret
+
+    hlt
+.end:
+
+; this function goes from 16 bit RM to 32 bit PM
+; ( will be copied in LOWER_MEMORY_ADDRESS + (PM32_to_RM16.end - PM32_to_RM16 ) )
+; LOW_RM16_PM32_ADDRESS
+; void __cdecl RM16_to_PM32(TRANSITION_CONFIG* transitionConfig)
+RM16_to_PM32:
+    [bits 16]
+    ;   use PUSHFD
+    ;   because flags is only 16 bit while EFLAGS will be 32bit
+    pushfd                      ;   save current flags
+    cli
+
+    mov     ebx,    ecx
+
+    mov     eax,    [ebx + TRANSITION_CONFIG.GdtrPhysicalAddress]
+
+    lgdt    [eax]                       ;   set the GDT
+
+    mov     eax,    cr0
+    or      al,     (CR0_PE|CR0_NE)     ;   set PE and NE flag
+    and     eax,    ~(CR0_CD|CR0_NW)    ;   and clear CD and NW
+    mov     cr0,    eax
+
+    mov     ax, [ebx + TRANSITION_CONFIG.CodeSelector]
+
+    push    ax
+    mov     eax, TRAMPOLINE_MEMORY_TRAMP_START + ( RM16_to_PM32.bits32 - TrampolineStart )
+    push    ax
+
+    retf ; We'll return to the next instruction at .bits32
+.bits32:
+    [bits 32]                   ;   we're in 32 bits
+    mov     ax,     [ebx + TRANSITION_CONFIG.DataSelector]
+    mov     ds,     ax
+    mov     es,     ax          ;   set the data descriptors
+    mov     ss,     ax
+    mov     fs,     ax
+    mov     gs,     ax
+
+    popfd                       ;   restore flags
+
+    ; save RA
+    movzx   edx,    WORD [esp]
+    mov     esp,    [ebx + TRANSITION_CONFIG.StackPhysicalAddress]         ; we set new stack
+
+    push    edx
+
+    ret
+.end
+
+[bits 64]
+PM32_to_PM64_PlaceHolder:
+    db 'ARNOLD'
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/_transition.yasm b/src_proiect/HAL9000/src/_transition.yasm
new file mode 100644
index 0000000..bc497b0
--- /dev/null
+++ b/src_proiect/HAL9000/src/_transition.yasm
@@ -0,0 +1,205 @@
+%include "lib.yasm"
+
+global PM32_to_PM64
+global PM32_to_PM64End
+global PM64_to_PM32
+global ApAsmStub
+
+; This function is the one to which HalActivateFpu returns to,
+; it's responsibility is to get rid of the shadow space and of
+; setting the return functions first (and only) parameter in RCX
+align 0x10, db 0
+ApAsmStub:
+    [bits 64]
+    add     rsp, 0x20
+
+    mov     rcx, [rsp + 0x10]
+
+    ret
+
+; this function takes the processor from 32 bit PM to 64 bit PM
+; we must be in PM32 with Paging disabled when we call this function
+; step1 : disable paging was already done when function was called
+; void __cdecl PM32_to_PM64 (TRANSITION_CONFIG* transitionConfig)
+align 0x10, db 0
+PM32_to_PM64:
+    [bits 32]
+    push        0
+    pushfd
+
+    cli                     ; disable interrupts
+
+    mov     ebx,    ecx
+
+    ; step 2
+    ; enable PAE CR4.PAE = 1
+    mov     eax,    cr4
+    or      eax,    CR4_PAE
+    mov     cr4,    eax
+
+    ; step 3
+    ; load CR3 with phycal base address of PML4
+    mov     eax,    [ebx + TRANSITION_CONFIG.Pml4PhysicalAddress]
+    mov     cr3,    eax
+
+    ; step 4
+    ; Set IA32_EFER.LME = 1
+    ; also enable NX functionality
+    mov     ecx, IA32_EFER
+    rdmsr
+    or      eax, ( IA32_EFER_LME | IA32_EFER_NXE )
+    wrmsr
+
+    mov     eax, [ebx + TRANSITION_CONFIG.GdtrPhysicalAddress]
+
+    ; load the new GDT and go to real 64-bit mode
+    lgdt    [eax]
+
+    ; step 5
+    ; enable paging
+    mov     eax, cr0
+    or      eax, (CR0_PG | CR0_WP | CR0_NE) ; use WP, also clear CD and NW in case
+    and     eax, ~(CR0_CD | CR0_NW )        ; those flags are set
+    mov     cr0, eax
+
+    ; Vol 3B 8.3
+    ; When an instruction is executed that enables or disables paging (that is,
+    ; changes the PG flag in control register CR0), the instruction should be
+    ; followed by a jump instruction
+
+    ; The Pentium 4, Intel Xeon, and P6 family processors do not require
+    ; the jump operation following the move to register CR0 (because any use of the MOV instruction in a Pentium 4,
+    ; Intel Xeon, or P6 family processor to write to CR0 is completely serializing). However, to maintain backwards
+    ; and forward compatibility with code written to run on other IA-32 processors, it is recommended that the jump
+    ; operation be performed.
+
+    ; CONCLUSION: because we will be running on new processors, we DON't need a jump
+
+;
+; now we should be in 64-bit compatibility mode
+;
+[BITS 64]
+    mov     rcx, [rsp]              ; we save the flags
+    mov     edx, DWORD [rsp+8]      ; we need to add the VA address base
+
+    ; set the cs
+    mov     esp, [rbx + TRANSITION_CONFIG.StackPhysicalAddress]
+    sub     esp, TRANSITION_CONFIG_size
+
+    xor     eax, eax
+    mov     ax,  [rbx + TRANSITION_CONFIG.CodeSelector]
+    push    rax                     ; this is a MUST, because retf will pop out 4 bytes for CS (OPE found out this ;-)
+                                    ; and 'push rax' actually means 'push eax', because we still run in 32 bit compat mode
+    call    $ + 5                   ; place return EIP onto the stack
+    mov     eax, 10                 ; instrux length to continue right after 'retf'
+    add     [rsp], eax
+    retf                            ; actually a retfq ( also uses CS saved on stack besides RA )
+
+;
+; we are in true 64-bit code, but still using the identity mappings, NOT the final 1T VA
+;
+    ; set also fs, gs
+    ; NOTE: ds, es, ss are NOT used on x64
+    mov     ax, [rbx + TRANSITION_CONFIG.DataSelector]
+    mov     fs, ax
+    mov     gs, ax
+
+    ; TOFIND: should SS be 0 in x64?
+[bits 32]
+    mov     ss, ax
+[bits 64]
+    mov     rsp, [rbx + TRANSITION_CONFIG.StackVirtualAddress]
+    sub     rsp, TRANSITION_CONFIG_size
+
+    ; switch to final 1T virtual addresses (0x0000`0100`0000`0000)
+    call    $ + 5                   ; place return RIP onto the stack
+    mov     rax, KERNEL_BASE_VIRTUAL - KERNEL_BASE
+    add     qword [rsp], rax
+    add     qword [rsp], 0x14       ; instrux length to continue right after 'retn'
+    retn
+
+    push    rcx
+    popfq                           ; we restore the original flags
+
+    mov     rcx, rdx                            ; PA's 32Mb-64Mb are mapped to 1T+
+    sub     rcx, KERNEL_BASE                    ; that's why we subtract the KERNEL_BASE
+    mov     rdx, QWORD KERNEL_BASE_VIRTUAL      ; so that we get the VA pointing to the same
+    add     rdx, rcx                            ; PA
+
+    add     rsp, TRANSITION_CONFIG_size
+    push    rdx
+
+    ret
+PM32_to_PM64End:
+
+; void __cdecl PM64_to_PM32 (CPU_CONFIG_ENTRY* cpuConfigEntry)
+align 0x10, db 0
+PM64_to_PM32:
+[bits 64]
+    ; we are in true 64 bit mode using 1T+ VA's
+    mov     rbx,    rcx
+
+    ; first step we should go back to the identity mappings
+    mov     rbp,    [rsp]       ; we save original RA
+    mov     esp,    [rbx + TRANSITION_CONFIG.StackPhysicalAddress]
+    sub     esp,    TRANSITION_CONFIG_size
+
+    ; now we are using identity mappings
+    xor     eax, eax
+    mov     ax, [rbx + TRANSITION_CONFIG.CodeSelector]
+    push    rax                     ; this is a MUST, because retf will pop out 4 bytes for CS (OPE found out this ;-)
+                                    ; and 'push rax' actually means 'push eax', because we still run in 32 bit compat mode
+
+    call    $ + 5                   ; place return EIP onto the stack
+
+    mov     rax,  ( KERNEL_BASE - KERNEL_BASE_VIRTUAL ) + 15                ; instrux length to continue right after 'retf'
+    add     [rsp], eax
+    retf                            ; actually a retfq ( also uses CS saved on stack besides RA )
+
+    ; now we are in compatibility mode
+
+    mov     rax,    cr0
+    and     eax,    ~( CR0_CD | CR0_NW | CR0_PG )       ; disable Paging, CD and NW
+    mov     cr0,    rax
+
+    ; Set IA32_EFER.LME = 0
+    mov     ecx, IA32_EFER
+    rdmsr
+    and      eax, ~IA32_EFER_LME
+    wrmsr
+
+    ; We also need to disable PAE
+    mov     rax,    cr4
+    and     eax,    ~( CR4_PAE )
+    mov     cr4,    rax
+
+    xor     eax, eax
+    mov     ax, [rbx + TRANSITION_CONFIG.CodeSelector]
+    push    rax                     ; this is a MUST, because retf will pop out 4 bytes for CS (OPE found out this ;-)
+                                    ; and 'push rax' actually means 'push eax', because we still run in 32 bit compat mode
+    call    $ + 5                   ; place return EIP onto the stack
+    mov     eax, 10                 ; instrux length to continue right after 'retf'
+    add     [rsp], eax
+    retf                            ; actually a retfq ( also uses CS saved on stack besides RA )
+[bits 32]
+    .bits32:
+
+    ; set the data descriptors
+    mov     ax, [ebx + TRANSITION_CONFIG.DataSelector]
+    mov     ds, ax
+    mov     es, ax
+    mov     ss, ax
+    mov     fs, ax
+    mov     gs, ax
+
+    xor     eax,    eax             ; According to Vol3 9.9.2 placing a zero in CR3
+    mov     cr3,    eax             ; forces a TLB flush
+
+    add     esp,    TRANSITION_CONFIG_size
+    push    ebp
+
+    ; we must subtract the difference (it will only substract the low DWORD)
+    mov     eax,    DWORD( KERNEL_BASE - KERNEL_BASE_VIRTUAL )
+    add     [esp],  eax                                     ; VA to the appropriate PA
+
+    ret
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/acpi_interface.c b/src_proiect/HAL9000/src/acpi_interface.c
new file mode 100644
index 0000000..04892d2
--- /dev/null
+++ b/src_proiect/HAL9000/src/acpi_interface.c
@@ -0,0 +1,807 @@
+#include "HAL9000.h"
+#include "acpi_interface.h"
+#include "cpumu.h"
+#include "list.h"
+
+#include "accommon.h"
+#include "io.h"
+
+#define APIC_PROCESSOR_ACTIVE                   0x1
+
+#define APIC_PIC_METHOD_APIC                    0x1
+
+#define ACPI_INIT_FLAGS     (       ACPI_NO_HARDWARE_INIT   \
+                                |   ACPI_NO_EVENT_INIT      \
+                                |   ACPI_NO_HANDLER_INIT    \
+                                |   ACPI_NO_ACPI_ENABLE     \
+                                )
+
+typedef struct _ACPI_CPU_ENTRY
+{
+    ACPI_MADT_LOCAL_APIC        Data;
+    LIST_ENTRY                  ListEntry;
+} ACPI_CPU_ENTRY, *PACPI_CPU_ENTRY;
+
+typedef struct _ACPI_IO_APIC_ENTRY
+{
+    ACPI_MADT_IO_APIC           Data;
+    LIST_ENTRY                  ListEntry;
+} ACPI_IO_APIC_ENTRY, *PACPI_IO_APIC_ENTRY;
+
+typedef struct _ACPI_INTERRUPT_OVERRIDE_ENTRY
+{
+    ACPI_MADT_INTERRUPT_OVERRIDE    Data;
+    LIST_ENTRY                      ListEntry;
+} ACPI_INTERRUPT_OVERRIDE_ENTRY, *PACPI_INTERRUPT_OVERRIDE_ENTRY;
+
+typedef struct _ACPI_MCFG_ENTRY
+{
+    ACPI_MCFG_ALLOCATION        Data;
+    LIST_ENTRY                  ListEntry;
+} ACPI_MCFG_ENTRY, *PACPI_MCFG_ENTRY;
+
+typedef struct _ACPI_PRT_ENTRY
+{
+    ACPI_PCI_ROUTING_TABLE      Data;
+    WORD                        SegmentNumber;
+    BYTE                        BusNumber;
+    LIST_ENTRY                  ListEntry;
+} ACPI_PRT_ENTRY, *PACPI_PRT_ENTRY;
+
+typedef struct _ACPI_INTERFACE_DATA
+{
+    LIST_ENTRY                  CpuList;
+    LIST_ENTRY                  IoApicList;
+    LIST_ENTRY                  IntOverrideList;
+    LIST_ENTRY                  McfgList;
+    LIST_ENTRY                  PrtList;
+} ACPI_INTERFACE_DATA, *PACPI_INTERFACE_DATA;
+
+static ACPI_INTERFACE_DATA      m_acpiData;
+
+static
+STATUS
+_AcpiInterfaceParseMadt(
+    void
+    );
+
+static
+STATUS
+_AcpiInterfaceParseMcfg(
+    void
+    );
+
+static
+STATUS
+_AcpiInterfaceParsePrts(
+    void
+    );
+
+static
+ACPI_STATUS
+_AcpiInterfaceDeviceWalkCallback(
+    ACPI_HANDLE                     Object,
+    UINT32                          NestingLevel,
+    void                            *Context,
+    void                            **ReturnValue
+    );
+
+static
+STATUS
+_AcpiRetrieveBusAndSegmentNumber(
+    IN      ACPI_HANDLE         Object,
+    OUT     BYTE*               BusNumber,
+    OUT     WORD*               SegmentNumber,
+    OUT     BOOLEAN*            FoundInParent
+    );
+
+void
+AcpiInterfacePreinit(
+    void
+    )
+{
+    InitializeListHead(&m_acpiData.CpuList);
+    InitializeListHead(&m_acpiData.IoApicList);
+    InitializeListHead(&m_acpiData.IntOverrideList);
+    InitializeListHead(&m_acpiData.McfgList);
+    InitializeListHead(&m_acpiData.PrtList);
+}
+
+STATUS
+AcpiInterfaceInit(
+    void
+    )
+{
+    ACPI_STATUS acpiStatus;
+    STATUS status;
+
+    LOG_FUNC_START;
+
+
+    acpiStatus = AcpiInitializeTables(NULL, 16, TRUE);
+    if (ACPI_FAILURE(acpiStatus))
+    {
+        LOG_FUNC_ERROR("AcpiInitializeTables", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+    LOG("Successfully initialized ACPI tables\n");
+
+
+
+    status = _AcpiInterfaceParseMadt();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_AcpiInterfaceParseMadt", status );
+        return status;
+    }
+    LOGL("Successfully parsed MADT\n");
+
+    status = _AcpiInterfaceParseMcfg();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_AcpiInterfaceParseMcfg", status);
+        if( status != STATUS_DEVICE_DOES_NOT_EXIST )
+        {
+            // we can get along without PCI Express support
+            return status;
+        }
+
+        status = STATUS_SUCCESS;
+    }
+    else
+    {
+        LOGL("Successfully parsed MCFG\n");
+    }
+
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+void
+AcpiShutdown(
+    void
+    )
+{
+    ACPI_STATUS acpiStatus;
+
+    CpuIntrDisable();
+
+    // Prepare to enter a system sleep state. This function should be 
+    // called before a call to AcpiEnterSleepState.
+    acpiStatus = AcpiEnterSleepStatePrep(5);
+    ASSERT_INFO(AE_OK == acpiStatus,
+                "AcpiEnterSleepStatePrep failed with ACPI status 0x%x\n",
+                acpiStatus
+                );
+    LOGL("Successfully entered prep sleep\n");
+
+    // This function must be called with interrupts disabled.
+    // Enter S5 sleep state a.k.a shutdown
+    acpiStatus = AcpiEnterSleepState(5);
+    ASSERT_INFO(AE_OK == acpiStatus,
+                "AcpiEnterSleepState failed with ACPI status 0x%x\n",
+                acpiStatus
+                );
+    LOGL("We should never get here\n");
+
+    NOT_REACHED;
+}
+
+STATUS
+AcpiInterfaceLateInit(
+    void
+    )
+{
+    STATUS status;
+    ACPI_STATUS acpiStatus;
+
+    // see 10.1.2.1 of ACPICA documentation
+    acpiStatus = AcpiInitializeSubsystem();
+    if (AE_OK != acpiStatus)
+    {
+        LOG_FUNC_ERROR("AcpiInitializeTables", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+    LOG("Successfully initialized ACPI subsystem\n");
+
+    acpiStatus = AcpiLoadTables();
+    if (AE_OK != acpiStatus)
+    {
+        LOG_FUNC_ERROR("AcpiLoadTables", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+    LOG("Successfully loaded ACPI tables\n");
+
+    acpiStatus = AcpiEnableSubsystem(ACPI_INIT_FLAGS);
+    if (AE_OK != acpiStatus)
+    {
+        LOG_FUNC_ERROR("AcpiEnableSubsystem", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+    LOG("Successfully enabled ACPI subsystem\n");
+
+    acpiStatus = AcpiInitializeObjects(ACPI_INIT_FLAGS);
+    if (ACPI_FAILURE(acpiStatus))
+    {
+        LOG_FUNC_ERROR("AcpiInitializeObjects", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+    LOG("Successfully initialized ACPI objects\n");
+
+    status = _AcpiInterfaceParsePrts();
+    if (!SUCCEEDED(status))
+    {
+        LOG_WARNING("_AcpiInterfaceParsePrts failed with status 0x%x\n", status);
+    }
+    LOGL("Successfully parsed PRTs\n");
+
+    return status;
+}
+
+STATUS
+AcpiRetrieveNextCpu(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_MADT_LOCAL_APIC**      AcpiEntry
+    )
+{
+    PACPI_CPU_ENTRY pEntry;
+
+    static PLIST_ENTRY __pCurEntry = NULL;
+
+    if (NULL == AcpiEntry)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (RestartSearch)
+    {
+        __pCurEntry = m_acpiData.CpuList.Flink;
+    }
+
+    if (__pCurEntry == &m_acpiData.CpuList)
+    {
+        return STATUS_NO_MORE_OBJECTS;
+    }
+
+    pEntry = CONTAINING_RECORD(__pCurEntry, ACPI_CPU_ENTRY, ListEntry);
+    __pCurEntry = __pCurEntry->Flink;
+
+    *AcpiEntry = &pEntry->Data;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+AcpiRetrieveNextIoApic(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_MADT_IO_APIC**         AcpiEntry
+    )
+{
+    PACPI_IO_APIC_ENTRY pEntry;
+
+    static PLIST_ENTRY __pCurEntry = NULL;
+
+    if (NULL == AcpiEntry)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (RestartSearch)
+    {
+        __pCurEntry = m_acpiData.IoApicList.Flink;
+    }
+
+    if (__pCurEntry == &m_acpiData.IoApicList)
+    {
+        return STATUS_NO_MORE_OBJECTS;
+    }
+
+    pEntry = CONTAINING_RECORD(__pCurEntry, ACPI_IO_APIC_ENTRY , ListEntry);
+    __pCurEntry = __pCurEntry->Flink;
+
+    *AcpiEntry = &pEntry->Data;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+AcpiRetrieveNextInterruptOverride(
+    IN      BOOLEAN                         RestartSearch,
+    OUT_PTR ACPI_MADT_INTERRUPT_OVERRIDE**  AcpiEntry
+    )
+{
+    PACPI_INTERRUPT_OVERRIDE_ENTRY pEntry;
+
+    static PLIST_ENTRY __pCurEntry = NULL;
+
+    if (NULL == AcpiEntry)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (RestartSearch)
+    {
+        __pCurEntry = m_acpiData.IntOverrideList.Flink;
+    }
+
+    if (__pCurEntry == &m_acpiData.IntOverrideList)
+    {
+        return STATUS_NO_MORE_OBJECTS;
+    }
+
+    pEntry = CONTAINING_RECORD(__pCurEntry, ACPI_INTERRUPT_OVERRIDE_ENTRY, ListEntry);
+    __pCurEntry = __pCurEntry->Flink;
+
+    *AcpiEntry = &pEntry->Data;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+AcpiRetrieveNextMcfgEntry(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_MCFG_ALLOCATION**      AcpiEntry
+    )
+{
+    PACPI_MCFG_ENTRY pEntry;
+
+    static PLIST_ENTRY __pCurEntry = NULL;
+
+    if (NULL == AcpiEntry)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (RestartSearch)
+    {
+        __pCurEntry = m_acpiData.McfgList.Flink;
+    }
+
+    if (__pCurEntry == &m_acpiData.McfgList)
+    {
+        return STATUS_NO_MORE_OBJECTS;
+    }
+
+    pEntry = CONTAINING_RECORD(__pCurEntry, ACPI_MCFG_ENTRY, ListEntry);
+    __pCurEntry = __pCurEntry->Flink;
+
+    *AcpiEntry = &pEntry->Data;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+AcpiRetrieveNextPrtEntry(
+    IN      BOOLEAN                     RestartSearch,
+    OUT_PTR ACPI_PCI_ROUTING_TABLE**    AcpiEntry,
+    OUT     BYTE*                       BusNumber,
+    OUT     WORD*                       SegmentNumber
+    )
+{
+    PACPI_PRT_ENTRY pEntry;
+
+    static PLIST_ENTRY __pCurEntry = NULL;
+
+    if (NULL == AcpiEntry)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (RestartSearch)
+    {
+        __pCurEntry = m_acpiData.PrtList.Flink;
+    }
+
+    if (__pCurEntry == &m_acpiData.PrtList)
+    {
+        return STATUS_NO_MORE_OBJECTS;
+    }
+
+    pEntry = CONTAINING_RECORD(__pCurEntry, ACPI_PRT_ENTRY, ListEntry);
+    __pCurEntry = __pCurEntry->Flink;
+
+    *AcpiEntry = &pEntry->Data;
+    *BusNumber = pEntry->BusNumber;
+    *SegmentNumber = pEntry->SegmentNumber;
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_AcpiInterfaceParseMadt(
+    void
+    )
+{
+    ACPI_TABLE_HEADER* table;
+    ACPI_STATUS acpiStatus;
+    DWORD actualTableLength;
+    DWORD offsetInTable;
+    ACPI_SUBTABLE_HEADER* pHeader;
+    PBYTE pData;
+
+    acpiStatus = AcpiGetTable(ACPI_SIG_MADT, 1, &table);
+    if (AE_OK != acpiStatus)
+    {
+        LOG_FUNC_ERROR("AcpiGetTable", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    offsetInTable = 0;
+    actualTableLength = table->Length - sizeof(ACPI_TABLE_MADT);
+    pData = (BYTE*)table + sizeof(ACPI_TABLE_MADT);
+    while (offsetInTable < actualTableLength)
+    {
+        pHeader = (ACPI_SUBTABLE_HEADER*)&(pData[offsetInTable]);
+        if (ACPI_MADT_TYPE_LOCAL_APIC == pHeader->Type)
+        {
+            ACPI_MADT_LOCAL_APIC* pProc = (ACPI_MADT_LOCAL_APIC*)pHeader;
+            if (pProc->LapicFlags & APIC_PROCESSOR_ACTIVE)
+            {
+                PACPI_CPU_ENTRY pEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(ACPI_CPU_ENTRY), HEAP_ACPIIF_TAG, 0);
+                if (NULL == pEntry)
+                {
+                    LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(ACPI_CPU_ENTRY));
+                    return STATUS_HEAP_NO_MORE_MEMORY;
+                }
+
+                memcpy(&pEntry->Data, pProc, sizeof(ACPI_MADT_LOCAL_APIC));
+
+                InsertTailList(&m_acpiData.CpuList, &pEntry->ListEntry);
+            }
+        }
+        else if (ACPI_MADT_TYPE_IO_APIC == pHeader->Type)
+        {
+            ACPI_MADT_IO_APIC* pIoapic = (ACPI_MADT_IO_APIC*)pHeader;
+            PACPI_IO_APIC_ENTRY pEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(ACPI_IO_APIC_ENTRY), HEAP_ACPIIF_TAG, 0);
+            if (NULL == pEntry)
+            {
+                LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(ACPI_IO_APIC_ENTRY));
+                return STATUS_HEAP_NO_MORE_MEMORY;
+            }
+
+            LOG("\nIO APIC\n");
+            LOG("IOAPIC at phys address: 0x%x\n", pIoapic->Address);
+            LOG("IRQ base: 0x%x\n", pIoapic->GlobalIrqBase);
+            LOG("ID: 0x%x\n", pIoapic->Id);
+
+            memcpy(&pEntry->Data, pIoapic, sizeof(ACPI_MADT_IO_APIC));
+
+            InsertTailList(&m_acpiData.IoApicList, &pEntry->ListEntry);
+        }
+        else if (ACPI_MADT_TYPE_INTERRUPT_OVERRIDE == pHeader->Type)
+        {
+            ACPI_MADT_INTERRUPT_OVERRIDE* pIntOverride = (ACPI_MADT_INTERRUPT_OVERRIDE*)pHeader;
+            PACPI_INTERRUPT_OVERRIDE_ENTRY pEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(ACPI_INTERRUPT_OVERRIDE_ENTRY), HEAP_ACPIIF_TAG, 0);
+            if (NULL == pEntry)
+            {
+                LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(ACPI_INTERRUPT_OVERRIDE_ENTRY));
+                return STATUS_HEAP_NO_MORE_MEMORY;
+            }
+
+            LOG("\nInterrupt override\n");
+            LOG("Bus: 0x%x\n", pIntOverride->Bus);  
+            LOG("SourceIrq: 0x%x\n", pIntOverride->SourceIrq);
+            LOG("GlobalIrq: 0x%x\n", pIntOverride->GlobalIrq); 
+            LOG("IntiFlags: 0x%x\n", pIntOverride->IntiFlags);
+
+            memcpy(&pEntry->Data, pIntOverride, sizeof(ACPI_MADT_INTERRUPT_OVERRIDE));
+
+            InsertTailList(&m_acpiData.IntOverrideList, &pEntry->ListEntry);
+        }
+        else if (ACPI_MADT_TYPE_LOCAL_APIC_NMI == pHeader->Type)
+        {
+            ACPI_MADT_LOCAL_APIC_NMI* pApicNmi = (ACPI_MADT_LOCAL_APIC_NMI*)pHeader;
+
+            LOG("\nLocal NMI\n");
+            LOG("Processor id: 0x%x\n", pApicNmi->ProcessorId);
+            LOG("IntiFlags id: 0x%x\n", pApicNmi->IntiFlags);
+            LOG("Lint id: 0x%x\n", pApicNmi->Lint);
+        }
+        else
+        {
+            LOG("pProc->Header.Type: 0x%x\n", pHeader->Type);
+        }
+
+        offsetInTable = offsetInTable + pHeader->Length;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_AcpiInterfaceParseMcfg(
+    void
+    )
+{
+    ACPI_TABLE_HEADER* table;
+    ACPI_STATUS acpiStatus;
+    DWORD actualTableLength;
+    DWORD offsetInTable;
+    ACPI_MCFG_ALLOCATION* pMcfgEntry;
+    PBYTE pData;
+
+    acpiStatus = AcpiGetTable(ACPI_SIG_MCFG, 1, &table);
+    if (AE_OK != acpiStatus)
+    {
+        LOG_FUNC_ERROR("AcpiGetTable", acpiStatus);
+        return acpiStatus == AE_NOT_FOUND ? STATUS_DEVICE_DOES_NOT_EXIST : STATUS_UNSUCCESSFUL;
+    }
+
+    actualTableLength = table->Length - sizeof(ACPI_TABLE_MCFG);
+    pData = (BYTE*)table + sizeof(ACPI_TABLE_MCFG);
+    for (offsetInTable = 0; offsetInTable < actualTableLength; offsetInTable += sizeof(ACPI_MCFG_ALLOCATION))
+    {
+        PACPI_MCFG_ENTRY pEntry;
+
+        pMcfgEntry = (ACPI_MCFG_ALLOCATION*) &pData[offsetInTable];
+
+        pEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(ACPI_MCFG_ENTRY), HEAP_ACPIIF_TAG, 0);
+        if (NULL == pEntry)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(ACPI_MCFG_ENTRY));
+            return STATUS_HEAP_NO_MORE_MEMORY;
+        }
+
+        memcpy(&pEntry->Data, pMcfgEntry, sizeof(ACPI_MCFG_ALLOCATION));
+
+        InsertTailList(&m_acpiData.McfgList, &pEntry->ListEntry);
+
+        LOG("MCFG entry:\n");
+        LOG("Base address: 0x%X\n", pMcfgEntry->Address );
+        LOG("Segment: 0x%x\n", pMcfgEntry->PciSegment );
+        LOG("Bus: %u -> %u\n", pMcfgEntry->StartBusNumber, pMcfgEntry->EndBusNumber );
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_AcpiInterfaceParsePrts(
+    void
+    )
+{
+    ACPI_STATUS         acpiStatus;
+    ACPI_OBJECT_LIST    argList;
+    ACPI_OBJECT         arg;
+
+    acpiStatus = AE_OK;
+    memzero(&argList, sizeof(ACPI_OBJECT_LIST));
+    memzero(&arg, sizeof(ACPI_OBJECT));
+
+    LOG_FUNC_START;
+
+    // One argument, IntegerArgument; No return value expected
+    argList.Count = 1;
+    argList.Pointer = &arg;
+    arg.Type = ACPI_TYPE_INTEGER;
+    arg.Integer.Value = (UINT64)APIC_PIC_METHOD_APIC;       // place in APIC mode
+
+    acpiStatus = AcpiEvaluateObject(NULL, "\\_PIC", &argList, NULL);
+    if (ACPI_FAILURE(acpiStatus))
+    {
+        LOG_WARNING("AcpiEvaluateObject failed with status 0x%x - Couldn't locate ACPI \\\\_PIC method\n", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    acpiStatus = AcpiWalkNamespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT, ACPI_UINT32_MAX, _AcpiInterfaceDeviceWalkCallback, NULL, NULL, NULL);
+    if (AE_OK != acpiStatus)
+    {
+        LOG_FUNC_ERROR("AcpiWalkNamespace", acpiStatus);
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+static
+ACPI_STATUS
+_AcpiInterfaceDeviceWalkCallback(
+    ACPI_HANDLE                     Object,
+    UINT32                          NestingLevel,
+    void                            *Context,
+    void                            **ReturnValue
+    )
+{
+    ACPI_STATUS acpiStatus;
+    ACPI_HANDLE prtHandle;
+    ACPI_BUFFER buffer;
+    DWORD noOfPrtEntries;
+    BYTE busNumber;
+    WORD segNumber;
+    STATUS status;
+    BOOLEAN bBusSourceInParent;
+
+    ASSERT( NULL != Object );
+    ASSERT( NULL == Context );
+    ASSERT( NULL == ReturnValue );
+
+    acpiStatus = AE_OK;
+    prtHandle = NULL;
+    memzero(&buffer, sizeof(ACPI_BUFFER));
+    noOfPrtEntries = 0;
+    busNumber = 0;
+    segNumber = 0;
+    status = STATUS_SUCCESS;
+    bBusSourceInParent = FALSE;
+
+    LOG_FUNC_START;
+
+    __try
+    {
+        LOG_TRACE_ACPI("Nesting level %u\n", NestingLevel);
+
+        acpiStatus = AcpiGetHandle(Object, METHOD_NAME__PRT, &prtHandle);
+        if (AE_OK != acpiStatus)
+        {
+            LOG_TRACE_ACPI("No PRT method for device!\n");
+            acpiStatus = AE_OK;
+            __leave;
+        }
+        ASSERT(NULL != prtHandle);
+
+        LOG_TRACE_ACPI("Found PRT method for object at 0x%X\n", Object);
+
+        status = _AcpiRetrieveBusAndSegmentNumber(Object, &busNumber, &segNumber, &bBusSourceInParent);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_AcpiRetrieveBusAndSegmentNumber", status);
+            acpiStatus = AE_NOT_FOUND;
+            __leave;
+        }
+        LOG_TRACE_ACPI("Object 0x%X is on segment:bus 0x%x:0x%x found in parent: 0x%x\n",
+             Object, segNumber, busNumber, bBusSourceInParent);
+
+        buffer.Length = ACPI_ALLOCATE_BUFFER;
+        buffer.Pointer = NULL;
+        acpiStatus = AcpiGetIrqRoutingTable(Object, &buffer);
+        if (AE_OK != acpiStatus)
+        {
+            LOG_FUNC_ERROR("AcpiGetIrqRoutingTable", acpiStatus);
+            __leave;
+        }
+
+        if (bBusSourceInParent)
+        {
+            // If the BUS BASE NUMBER was found in a parent device =>
+            // this is a secondary bridge device => its PRT entries will
+            // correspond to the devices connected on its secondary bus
+            QWORD addr;
+            PCI_DEVICE_LOCATION pciLocation;
+
+            acpiStatus = AcpiUtEvaluateNumericObject(METHOD_NAME__ADR, Object, &addr);
+            if (AE_OK != acpiStatus)
+            {
+                LOG_FUNC_ERROR("AcpiUtEvaluateNumericObject", acpiStatus);
+                __leave;
+            }
+
+            memzero(&pciLocation, sizeof(PCI_DEVICE_LOCATION));
+            pciLocation.Bus = busNumber;
+            pciLocation.Device = WORD_LOW(DWORD_HIGH(addr));
+            pciLocation.Function = WORD_LOW(addr);
+
+            status = IoGetPciSecondaryBusForBridge(pciLocation, &busNumber);
+            if (!SUCCEEDED(status))
+            {
+                if (STATUS_ELEMENT_NOT_FOUND != status)
+                {
+                    LOG_FUNC_ERROR("IoGetPciDevicesMatchingLocation", status);
+                    acpiStatus = AE_BAD_DATA;
+                }
+                else
+                {
+                    acpiStatus = AE_OK;
+                }
+
+                __leave;
+            }
+        }
+
+        for (ACPI_PCI_ROUTING_TABLE* prtEntry = ACPI_CAST_PTR(ACPI_PCI_ROUTING_TABLE, buffer.Pointer);
+             prtEntry->Length != 0;
+             prtEntry = ACPI_ADD_PTR(ACPI_PCI_ROUTING_TABLE, prtEntry, prtEntry->Length))
+        {
+            PACPI_PRT_ENTRY pEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(ACPI_PRT_ENTRY), HEAP_ACPIIF_TAG, 0);
+            if (NULL == pEntry)
+            {
+                LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(ACPI_PRT_ENTRY));
+                acpiStatus = AE_NO_MEMORY;
+                __leave;
+            }
+
+            memcpy(&pEntry->Data, prtEntry, sizeof(ACPI_PCI_ROUTING_TABLE));
+
+            pEntry->BusNumber = busNumber;
+            pEntry->SegmentNumber = segNumber;
+            InsertTailList(&m_acpiData.PrtList, &pEntry->ListEntry);
+
+            LOG_TRACE_ACPI("\nPRT address is 0x%X\n", prtEntry->Address);
+            LOG_TRACE_ACPI("Bus number is 0x%x\n", busNumber);
+            LOG_TRACE_ACPI("PIN is [%c]\n", 'A' + prtEntry->Pin);
+            LOG_TRACE_ACPI("Source index 0x%x\n", prtEntry->SourceIndex);
+
+            noOfPrtEntries++;
+        }
+
+        LOG("Number of PRT entries is %u\n", noOfPrtEntries);
+    }
+    __finally
+    {
+        if(NULL != buffer.Pointer)
+        {
+            AcpiOsFree(buffer.Pointer);
+            buffer.Pointer = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return acpiStatus;
+}
+
+static
+STATUS
+_AcpiRetrieveBusAndSegmentNumber(
+    IN      ACPI_HANDLE         Object,
+    OUT     BYTE*               BusNumber,
+    OUT     WORD*               SegmentNumber,
+    OUT     BOOLEAN*            FoundInParent
+    )
+{
+    QWORD busValue;
+    ACPI_STATUS acpiStatus;
+    ACPI_HANDLE currentObj;
+    BOOLEAN bFoundInParent;
+
+    ASSERT( NULL != Object );
+    ASSERT( NULL != BusNumber );
+    ASSERT( NULL != FoundInParent );
+
+    acpiStatus = AE_NOT_FOUND;
+    currentObj = Object;
+    bFoundInParent = FALSE;
+
+#pragma warning(suppress:4127)
+    while(TRUE)
+    {
+        acpiStatus = AcpiUtEvaluateNumericObject(METHOD_NAME__BBN, currentObj, &busValue);
+        if(ACPI_SUCCESS(acpiStatus))
+        {
+            break;
+        }
+
+        bFoundInParent = TRUE;
+        acpiStatus = AcpiGetParent(currentObj, &currentObj);
+        if(!ACPI_SUCCESS(acpiStatus))
+        {
+            LOG_ERROR("Failed to retrieve parent!\n");
+            break;
+        }
+    }
+
+    if (ACPI_SUCCESS(acpiStatus))
+    {
+        QWORD segmentValue;
+
+        // ACPICA 6.5.6
+        // If _SEG does not exist, OSPM assumes that all PCI bus segments are in PCI Segment Group 0.
+        acpiStatus = AcpiUtEvaluateNumericObject(METHOD_NAME__SEG, currentObj, &segmentValue);
+        *SegmentNumber = ACPI_SUCCESS(acpiStatus) ? (segmentValue & MAX_WORD) : 0;
+
+        ASSERT(busValue <= MAX_BYTE);
+        *BusNumber = (BYTE)busValue;
+
+        *FoundInParent = bFoundInParent;
+
+        acpiStatus = AE_OK;
+    }
+
+    return ACPI_FAILURE(acpiStatus) ? STATUS_UNSUCCESSFUL : STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/acpi_osl.c b/src_proiect/HAL9000/src/acpi_osl.c
new file mode 100644
index 0000000..0e7eb1b
--- /dev/null
+++ b/src_proiect/HAL9000/src/acpi_osl.c
@@ -0,0 +1,1369 @@
+// ACPICA OSL implementation
+
+#include "HAL9000.h"
+
+#pragma warning(push)
+#include "acpi.h"
+#pragma warning(pop)
+#include "mmu.h"
+#include "synch.h"
+#include "thread.h"
+#include "pci_system.h"
+#include "pit.h"
+#include "iomu.h"
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsInitialize
+ACPI_STATUS
+AcpiOsInitialize (
+    void)
+{
+    LOG_FUNC_START;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsTerminate
+ACPI_STATUS
+AcpiOsTerminate (
+    void)
+{
+    LOG_FUNC_START;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetRootPointer
+ACPI_PHYSICAL_ADDRESS
+AcpiOsGetRootPointer (
+    void)
+{
+    ACPI_SIZE Ret;
+
+    LOG_FUNC_START;
+
+    AcpiFindRootPointer(&Ret);
+
+    LOG_FUNC_END;
+
+    return Ret;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPredefinedOverride
+ACPI_STATUS
+AcpiOsPredefinedOverride (
+    const ACPI_PREDEFINED_NAMES *InitVal,
+    ACPI_STRING                 *NewVal)
+{
+    UNREFERENCED_PARAMETER(InitVal);
+
+    if (NULL == NewVal)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    *NewVal = NULL;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsTableOverride
+ACPI_STATUS
+AcpiOsTableOverride (
+    ACPI_TABLE_HEADER       *ExistingTable,
+    ACPI_TABLE_HEADER       **NewTable)
+{
+    UNREFERENCED_PARAMETER(ExistingTable);
+
+    if (NULL == NewTable)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    *NewTable = NULL;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPhysicalTableOverride
+ACPI_STATUS
+AcpiOsPhysicalTableOverride (
+    ACPI_TABLE_HEADER       *ExistingTable,
+    ACPI_PHYSICAL_ADDRESS   *NewAddress,
+    UINT32                  *NewTableLength)
+{
+    UNREFERENCED_PARAMETER(ExistingTable);
+
+    if (NULL == NewAddress)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    if (NULL == NewTableLength)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    *NewAddress = 0;
+    *NewTableLength = 0;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateLock
+ACPI_STATUS
+AcpiOsCreateLock (
+    ACPI_SPINLOCK           *OutHandle)
+{
+    PLOCK lock;
+
+    if (NULL == OutHandle)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    lock = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                 sizeof(LOCK),
+                                 HEAP_ACPICA_TAG,
+                                 0
+                                 );
+    if (NULL == lock)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(LOCK));
+        return AE_NO_MEMORY;
+    }
+
+    LockInit(lock);
+
+    LOG_TRACE_ACPI("Lock at: 0x%X\n", lock );
+
+    *OutHandle = lock;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteLock
+void
+AcpiOsDeleteLock (
+    ACPI_SPINLOCK           Handle)
+{
+    ASSERT(NULL != Handle);
+
+    LOG_FUNC_START;
+
+    ExFreePoolWithTag(Handle, HEAP_ACPICA_TAG);
+
+    LOG_FUNC_END;
+
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireLock
+ACPI_CPU_FLAGS
+AcpiOsAcquireLock (
+    ACPI_SPINLOCK           Handle)
+{
+    INTR_STATE intrState;
+
+    ASSERT(NULL != Handle);
+
+    LockAcquire((PLOCK) Handle, &intrState);
+
+    // Warning C26165 Possibly failing to release lock
+    // Because we can't modify the ACPICA headers we have nothing to do but suppress the warning
+#pragma warning(suppress: 26165)
+    return intrState;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseLock
+void
+AcpiOsReleaseLock (
+    ACPI_SPINLOCK           Handle,
+    ACPI_CPU_FLAGS          Flags)
+{
+    ASSERT( NULL != Handle );
+
+    // Warning C26110 Caller failing to hold lock before calling function
+    // Because we can't modify the ACPICA headers we have nothing to do but suppress the warning
+#pragma warning(suppress: 26110)
+    LockRelease(Handle, (INTR_STATE) Flags);
+
+    // Warning C26167 Possibly releasing unheld lock
+    // Because we can't modify the ACPICA headers we have nothing to do but suppress the warning
+#pragma warning(suppress: 26167)
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateSemaphore
+ACPI_STATUS
+AcpiOsCreateSemaphore (
+    UINT32                  MaxUnits,
+    UINT32                  InitialUnits,
+    ACPI_SEMAPHORE          *OutHandle)
+{
+    PEVENT event;
+    STATUS status;
+
+    if (NULL == OutHandle)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_ACPI("Initial/max units: %u/%u\n", InitialUnits, MaxUnits );
+
+    ASSERT(MaxUnits == 1);
+    ASSERT(InitialUnits <= 1);
+
+    event = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(EVENT), HEAP_ACPICA_TAG, 0 );
+    if (NULL == event)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(EVENT));
+        return AE_NO_MEMORY;
+    }
+
+    status = EvtInitialize(event, EventTypeSynchronization, (BOOLEAN) InitialUnits);
+    if (!SUCCEEDED(status))
+    {
+        LOG_ERROR("EvtInitialize", status );
+        return AE_NO_HANDLER;
+    }
+
+    LOG_TRACE_ACPI("Semaphore at: 0x%X\n", event );
+
+    *OutHandle = event;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteSemaphore
+ACPI_STATUS
+AcpiOsDeleteSemaphore (
+    ACPI_SEMAPHORE          Handle)
+{
+    if (NULL == Handle)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    ExFreePoolWithTag(Handle, HEAP_ACPICA_TAG);
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWaitSemaphore
+ACPI_STATUS
+AcpiOsWaitSemaphore (
+    ACPI_SEMAPHORE          Handle,
+    UINT32                  Units,
+    UINT16                  Timeout)
+{
+    ACPI_STATUS acpiStatus;
+
+    if (NULL == Handle)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    acpiStatus = AE_OK;
+
+    ASSERT(1 == Units);
+
+    acpiStatus = EvtIsSignaled(Handle) ? AE_OK : AE_TIME;
+
+    if (AE_TIME == acpiStatus && Timeout != 0)
+    {
+        if (MAX_WORD != Timeout)
+        {
+            LOG_TRACE_ACPI("Will sleep %u ms\n", Timeout);
+            ASSERT(Timeout <= MAX_DWORD / MS_IN_US);
+
+            // Because we don't have a mechanism to wait for an event
+            // for a period of time (Timeout) we will first wait for the
+            // timeout interval to pass and after we'll check th event again
+            PitSleep((DWORD)Timeout * MS_IN_US);
+
+            // check after sleep if event is still not signaled
+            acpiStatus = EvtIsSignaled(Handle) ? AE_OK : AE_TIME;
+        }
+        else
+        {
+            // MAX_WORD
+
+            // This is very dangerous because we may never return
+            // if something is not configured properly
+            LOG_TRACE_ACPI("Will wait indefinetely!\n");
+            EvtWaitForSignal(Handle);
+            acpiStatus = AE_OK;
+        }
+    }
+
+    return acpiStatus;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSignalSemaphore
+ACPI_STATUS
+AcpiOsSignalSemaphore (
+    ACPI_SEMAPHORE          Handle,
+    UINT32                  Units)
+{
+    if (NULL == Handle)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    ASSERT( 1 == Units );
+    EvtSignal(Handle);
+
+    return AE_OK;
+}
+#endif
+
+#if (ACPI_MUTEX_TYPE != ACPI_BINARY_SEMAPHORE)
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateMutex
+ACPI_STATUS
+AcpiOsCreateMutex (
+    ACPI_MUTEX              *OutHandle)
+{
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteMutex
+void
+AcpiOsDeleteMutex (
+    ACPI_MUTEX              Handle)
+{
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireMutex
+ACPI_STATUS
+AcpiOsAcquireMutex (
+    ACPI_MUTEX              Handle,
+    UINT16                  Timeout)
+{
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseMutex
+void
+AcpiOsReleaseMutex (
+    ACPI_MUTEX              Handle)
+{
+    return;
+}
+#endif
+
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAllocate
+void *
+AcpiOsAllocate (
+    ACPI_SIZE               Size)
+{
+    PVOID pResult;
+
+    if (0 == Size)
+    {
+        return NULL;
+    }
+
+    ASSERT( Size <= MAX_DWORD );
+
+    // Mid July: ACPICA is stupid, it states in the documentation that the AcpiOsAllocate does not expect
+    // the memory to be initialized, when in fact there seem to be problems when not zero-initializing the memory
+    /// TODO: Mid September: investigate if this still happens - I'm not able to reproduce the problem
+    pResult = ExAllocatePoolWithTag(PoolAllocateZeroMemory, (DWORD)Size, HEAP_ACPICA_TAG, 0);
+
+    LOG_TRACE_ACPI("Allocated %U bytes of memory at 0x%X\n", Size, pResult );
+
+    return pResult;
+}
+#endif
+
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsFree
+void
+AcpiOsFree (
+    void*                   Memory)
+{
+    if (NULL == Memory)
+    {
+        return;
+    }
+
+    //LOG_TRACE_ACPI( "AcpiOsFree about to free memory at address 0x%X\n", Memory );
+
+    ExFreePoolWithTag( Memory, HEAP_ACPICA_TAG );
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsMapMemory
+void *
+AcpiOsMapMemory (
+    ACPI_PHYSICAL_ADDRESS   Where,
+    ACPI_SIZE               Length)
+{
+    PVOID pMappedAddress;
+
+    LOG_FUNC_START;
+
+    //LOG_TRACE_ACPI( "AcpiOsMapMemory about to map 0x%X bytes starting at PA 0x%X\n", Length, Where );
+
+    pMappedAddress = MmuMapSystemMemory( (PHYSICAL_ADDRESS) Where, Length );
+
+    LOG_FUNC_END;
+
+    return pMappedAddress;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsUnmapMemory
+void
+AcpiOsUnmapMemory (
+    void                    *LogicalAddress,
+    ACPI_SIZE               Size)
+{
+    LOG_FUNC_START;
+
+    LOG_TRACE_ACPI( "AcpiOsUnmapMemory about to unmap 0x%X bytes starting at VA 0x%X PA 0x%X\n",
+        Size, LogicalAddress, MmuGetPhysicalAddress(LogicalAddress) );
+
+    MmuUnmapSystemMemory( LogicalAddress, ( DWORD ) Size );
+
+    LOG_FUNC_END;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetPhysicalAddress
+ACPI_STATUS
+AcpiOsGetPhysicalAddress (
+    void                    *LogicalAddress,
+    ACPI_PHYSICAL_ADDRESS   *PhysicalAddress)
+{
+    if (PhysicalAddress == NULL)
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    *PhysicalAddress = (ACPI_PHYSICAL_ADDRESS) MmuGetPhysicalAddress(LogicalAddress);
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Memory/Object Cache
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCreateCache
+ACPI_STATUS
+AcpiOsCreateCache (
+    char                    *CacheName,
+    UINT16                  ObjectSize,
+    UINT16                  MaxDepth,
+    ACPI_CACHE_T            **ReturnCache)
+{
+    WORD* pCache;
+
+    UNREFERENCED_PARAMETER(CacheName);
+    UNREFERENCED_PARAMETER(MaxDepth);
+
+    if ((0 == ObjectSize) || ( NULL == ReturnCache ))
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_TRACE_ACPI("Object size: 0x%x\n", ObjectSize);
+
+    pCache = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(WORD), HEAP_ACPICA_TAG, 0);
+    if (NULL == pCache)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(WORD));
+        return AE_NO_MEMORY;
+    }
+
+    *pCache = ObjectSize;
+
+    *ReturnCache = (ACPI_CACHE_T*) pCache;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsDeleteCache
+ACPI_STATUS
+AcpiOsDeleteCache (
+    ACPI_CACHE_T            *Cache)
+{
+    LOG_FUNC_START;
+
+    ExFreePoolWithTag(Cache, HEAP_ACPICA_TAG);
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPurgeCache
+ACPI_STATUS
+AcpiOsPurgeCache (
+    ACPI_CACHE_T            *Cache)
+{
+    UNREFERENCED_PARAMETER(Cache);
+
+    LOG_FUNC_START;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsAcquireObject
+void *
+AcpiOsAcquireObject (
+    ACPI_CACHE_T            *Cache)
+{
+    PVOID pResult;
+
+    pResult = ExAllocatePoolWithTag(PoolAllocateZeroMemory, * (WORD*)Cache, HEAP_ACPICA_TAG, 0 );
+    if (NULL == pResult)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", *(WORD*)Cache);
+        return NULL;
+    }
+
+    return pResult;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReleaseObject
+ACPI_STATUS
+AcpiOsReleaseObject (
+    ACPI_CACHE_T            *Cache,
+    void                    *Object)
+{
+    if ((NULL == Cache) || (NULL == Object))
+    {
+        return AE_BAD_PATHNAME;
+    }
+
+    ExFreePoolWithTag(Object, HEAP_ACPICA_TAG);
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Interrupt handlers
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsInstallInterruptHandler
+ACPI_STATUS
+AcpiOsInstallInterruptHandler (
+    UINT32                  InterruptNumber,
+    ACPI_OSD_HANDLER        ServiceRoutine,
+    void                    *Context)
+{
+    UNREFERENCED_PARAMETER(InterruptNumber);
+    UNREFERENCED_PARAMETER(ServiceRoutine);
+    UNREFERENCED_PARAMETER(Context);
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_ACPI("Interrupt 0x%x\n", InterruptNumber );
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsRemoveInterruptHandler
+ACPI_STATUS
+AcpiOsRemoveInterruptHandler (
+    UINT32                  InterruptNumber,
+    ACPI_OSD_HANDLER        ServiceRoutine)
+{
+    UNREFERENCED_PARAMETER(InterruptNumber);
+    UNREFERENCED_PARAMETER(ServiceRoutine);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Threads and Scheduling
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetThreadId
+ACPI_THREAD_ID
+AcpiOsGetThreadId (
+    void)
+{
+    ACPI_THREAD_ID id;
+
+    id = ThreadGetId(NULL) + 4;
+
+    return id;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsExecute
+ACPI_STATUS
+AcpiOsExecute (
+    ACPI_EXECUTE_TYPE       Type,
+    ACPI_OSD_EXEC_CALLBACK  Function,
+    void                    *Context)
+{
+    UNREFERENCED_PARAMETER(Type);
+    UNREFERENCED_PARAMETER(Function);
+    UNREFERENCED_PARAMETER(Context);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWaitEventsComplete
+void
+AcpiOsWaitEventsComplete (
+    void)
+{
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSleep
+void
+AcpiOsSleep (
+    UINT64                  Milliseconds)
+{
+    UNREFERENCED_PARAMETER(Milliseconds);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsStall
+void
+AcpiOsStall (
+    UINT32                  Microseconds)
+{
+    UNREFERENCED_PARAMETER(Microseconds);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return;
+}
+#endif
+
+
+/*
+* Platform and hardware-independent I/O interfaces
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadPort
+ACPI_STATUS
+AcpiOsReadPort (
+    ACPI_IO_ADDRESS         Address,
+    UINT32                  *Value,
+    UINT32                  Width)
+{
+    WORD port;
+
+    LOG_FUNC_START;
+
+    ASSERT(Address <= MAX_WORD);
+    port = (WORD)Address;
+
+    LOG("Will read port: 0x%X\n", Address );
+
+    switch (Width)
+    {
+    case 8:
+        *Value = __inbyte(port);
+        break;
+    case 16:
+        *Value = __inword(port);
+        break;
+    case 32:
+        *Value = __indword(port);
+        break;
+    }
+
+    LOG("Read value: 0x%x\n", *Value);
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritePort
+ACPI_STATUS
+AcpiOsWritePort (
+    ACPI_IO_ADDRESS         Address,
+    UINT32                  Value,
+    UINT32                  Width)
+{
+    WORD port;
+
+    LOG_FUNC_START;
+
+    ASSERT(Address <= MAX_WORD);
+    port = (WORD)Address;
+
+    LOG("Will write to port 0x%X value 0x%x\n", Address, Value);
+
+    switch (Width)
+    {
+    case 8:
+        __outbyte(port, Value);
+        break;
+    case 16:
+        __outword(port, Value);
+        break;
+    case 32:
+        __outdword(port, Value);
+        break;
+    }
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Platform and hardware-independent physical memory interfaces
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadMemory
+ACPI_STATUS
+AcpiOsReadMemory (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT64                  *Value,
+    UINT32                  Width)
+{
+    UNREFERENCED_PARAMETER(Address);
+    UNREFERENCED_PARAMETER(Value);
+    UNREFERENCED_PARAMETER(Width);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWriteMemory
+ACPI_STATUS
+AcpiOsWriteMemory (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    UINT64                  Value,
+    UINT32                  Width)
+{
+    UNREFERENCED_PARAMETER(Address);
+    UNREFERENCED_PARAMETER(Value);
+    UNREFERENCED_PARAMETER(Width);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Platform and hardware-independent PCI configuration space access
+* Note: Can't use "Register" as a parameter, changed to "Reg" --
+* certain compilers complain.
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadPciConfiguration
+ACPI_STATUS
+AcpiOsReadPciConfiguration (
+    ACPI_PCI_ID             *PciId,
+    UINT32                  Reg,
+    UINT64                  *Value,
+    UINT32                  Width)
+{
+    PCI_DEVICE_LOCATION pciDevice;
+    STATUS status;
+
+    if ((NULL == PciId) || (Reg > MAX_WORD) || (NULL == Value) || (Width > BITS_FOR_STRUCTURE(QWORD)))
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_FUNC_START;
+
+    ASSERT( 0 == PciId->Segment );
+    ASSERT(IsAddressAligned(Reg, Width/BITS_PER_BYTE));
+
+    LOG_TRACE_ACPI("(%u.%u.%u) Register: 0x%x\n", PciId->Bus,
+                   PciId->Device, PciId->Function, Reg );
+
+    pciDevice.Bus = (BYTE)PciId->Bus;
+    pciDevice.Device = (BYTE)PciId->Device;
+    pciDevice.Function = (BYTE)PciId->Function;
+
+    status = PciSystemReadConfigurationSpaceGeneric(pciDevice,
+                                                    (WORD)Reg,
+                                                    (BYTE)Width,
+                                                    Value);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemReadConfigurationSpaceGeneric", status);
+        return AE_ERROR;
+    }
+
+    LOG_TRACE_ACPI("Placed value: 0x%X [%u]\n", *Value, Width );
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritePciConfiguration
+ACPI_STATUS
+AcpiOsWritePciConfiguration (
+    ACPI_PCI_ID             *PciId,
+    UINT32                  Reg,
+    UINT64                  Value,
+    UINT32                  Width)
+{
+    PCI_DEVICE_LOCATION pciDevice;
+    STATUS status;
+
+    if ((NULL == PciId) || (Reg > MAX_WORD) || (Width > BITS_FOR_STRUCTURE(QWORD)))
+    {
+        return AE_BAD_PARAMETER;
+    }
+
+    ASSERT(0 == PciId->Segment);
+    ASSERT(IsAddressAligned(Reg, Width / BITS_PER_BYTE));
+
+    memzero(&pciDevice, sizeof(PCI_DEVICE_LOCATION));
+    status = STATUS_SUCCESS;
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_ACPI("(%u.%u.%u) Register: 0x%x\n", PciId->Bus,
+                   PciId->Device, PciId->Function, Reg);
+    LOG_TRACE_ACPI("Value to write: 0x%X [%u]\n", Value, Width );
+
+    pciDevice.Bus       = (BYTE) PciId->Bus;
+    pciDevice.Device    = (BYTE) PciId->Device;
+    pciDevice.Function  = (BYTE) PciId->Function;
+
+    status = PciSystemWriteConfigurationSpaceGeneric(pciDevice,
+                                                     (WORD)Reg,
+                                                     (BYTE)Width,
+                                                     Value);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemWriteConfigurationSpaceGeneric", status);
+        return AE_ERROR;
+    }
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Miscellaneous
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadable
+BOOLEAN
+AcpiOsReadable (
+    void                    *Pointer,
+    ACPI_SIZE               Length)
+{
+    UNREFERENCED_PARAMETER(Pointer);
+    UNREFERENCED_PARAMETER(Length);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+    return TRUE;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWritable
+BOOLEAN
+AcpiOsWritable (
+    void                    *Pointer,
+    ACPI_SIZE               Length)
+{
+    UNREFERENCED_PARAMETER(Pointer);
+    UNREFERENCED_PARAMETER(Length);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return TRUE;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTimer
+UINT64
+AcpiOsGetTimer (
+    void)
+{
+    UINT64 time;
+
+    // RETURN VALUE
+    // The current value of the system timer in 100-nanosecond
+    // units.
+    time = IomuGetSystemTimeUs() * ( US_IN_NS / 100);
+    LOGL("Get time 0x%X\n", time );
+
+    return time;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSignal
+ACPI_STATUS
+AcpiOsSignal (
+    UINT32                  Function,
+    void                    *Info)
+{
+    UNREFERENCED_PARAMETER(Function);
+    UNREFERENCED_PARAMETER(Info);
+
+    NOT_REACHED;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Debug print routines
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsPrintf
+void ACPI_INTERNAL_VAR_XFACE
+AcpiOsPrintf (
+    const char              *Format,
+    ...)
+{
+    va_list Args;
+    char buffer[MAX_PATH];
+
+    va_start(Args,Format);
+    vsnprintf(buffer, MAX_PATH, Format, Args );
+    LOG_TRACE_ACPI("%s\n", buffer);
+
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsVprintf
+void
+AcpiOsVprintf (
+    const char              *Format,
+    va_list                 Args)
+{
+    char buffer[MAX_PATH];
+
+    vsnprintf(buffer, MAX_PATH, Format, Args );
+    LOG_TRACE_ACPI("%s\n", buffer);
+
+    return;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsRedirectOutput
+void
+AcpiOsRedirectOutput (
+    void                    *Destination)
+{
+    UNREFERENCED_PARAMETER(Destination);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return;
+}
+#endif
+
+
+/*
+* Debug input
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetLine
+ACPI_STATUS
+AcpiOsGetLine (
+    char                    *Buffer,
+    UINT32                  BufferLength,
+    UINT32                  *BytesRead)
+{
+    UNREFERENCED_PARAMETER(Buffer);
+    UNREFERENCED_PARAMETER(BufferLength);
+    UNREFERENCED_PARAMETER(BytesRead);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Obtain ACPI table(s)
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByName
+ACPI_STATUS
+AcpiOsGetTableByName (
+    char                    *Signature,
+    UINT32                  Instance,
+    ACPI_TABLE_HEADER       **Table,
+    ACPI_PHYSICAL_ADDRESS   *Address)
+{
+    UNREFERENCED_PARAMETER(Signature);
+    UNREFERENCED_PARAMETER(Instance);
+    UNREFERENCED_PARAMETER(Table);
+    UNREFERENCED_PARAMETER(Address);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByIndex
+ACPI_STATUS
+AcpiOsGetTableByIndex (
+    UINT32                  Index,
+    ACPI_TABLE_HEADER       **Table,
+    UINT32                  *Instance,
+    ACPI_PHYSICAL_ADDRESS   *Address)
+{
+    UNREFERENCED_PARAMETER(Index);
+    UNREFERENCED_PARAMETER(Instance);
+    UNREFERENCED_PARAMETER(Table);
+    UNREFERENCED_PARAMETER(Address);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetTableByAddress
+ACPI_STATUS
+AcpiOsGetTableByAddress (
+    ACPI_PHYSICAL_ADDRESS   Address,
+    ACPI_TABLE_HEADER       **Table)
+{
+    UNREFERENCED_PARAMETER(Address);
+    UNREFERENCED_PARAMETER(Table);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+
+/*
+* Directory manipulation
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsOpenDirectory
+void *
+AcpiOsOpenDirectory (
+    char                    *Pathname,
+    char                    *WildcardSpec,
+    char                    RequestedFileType)
+{
+    UNREFERENCED_PARAMETER(Pathname);
+    UNREFERENCED_PARAMETER(WildcardSpec);
+    UNREFERENCED_PARAMETER(RequestedFileType);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return NULL;
+}
+#endif
+
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetNextFilename
+char *
+AcpiOsGetNextFilename (
+    void                    *DirHandle)
+{
+    UNREFERENCED_PARAMETER(DirHandle);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return NULL;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCloseDirectory
+void
+AcpiOsCloseDirectory (
+    void                    *DirHandle)
+{
+    UNREFERENCED_PARAMETER(DirHandle);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return;
+}
+#endif
+
+
+/*
+* File I/O and related support
+*/
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsOpenFile
+ACPI_FILE
+AcpiOsOpenFile (
+    const char              *Path,
+    UINT8                   Modes)
+{
+    UNREFERENCED_PARAMETER(Path);
+    UNREFERENCED_PARAMETER(Modes);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return NULL;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsCloseFile
+void
+AcpiOsCloseFile (
+    ACPI_FILE               File);
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsReadFile
+int
+AcpiOsReadFile (
+    ACPI_FILE               File,
+    void                    *Buffer,
+    ACPI_SIZE               Size,
+    ACPI_SIZE               Count)
+{
+    UNREFERENCED_PARAMETER(File);
+    UNREFERENCED_PARAMETER(Buffer);
+    UNREFERENCED_PARAMETER(Size);
+    UNREFERENCED_PARAMETER(Count);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return 0;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsWriteFile
+int
+AcpiOsWriteFile (
+    ACPI_FILE               File,
+    void                    *Buffer,
+    ACPI_SIZE               Size,
+    ACPI_SIZE               Count)
+{
+    UNREFERENCED_PARAMETER(File);
+    UNREFERENCED_PARAMETER(Buffer);
+    UNREFERENCED_PARAMETER(Size);
+    UNREFERENCED_PARAMETER(Count);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return 0;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsGetFileOffset
+long
+AcpiOsGetFileOffset (
+    ACPI_FILE               File)
+{
+    UNREFERENCED_PARAMETER(File);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return 0;
+}
+#endif
+
+#ifndef ACPI_USE_ALTERNATE_PROTOTYPE_AcpiOsSetFileOffset
+ACPI_STATUS
+AcpiOsSetFileOffset (
+    ACPI_FILE               File,
+    long                    Offset,
+    UINT8                   From)
+{
+    UNREFERENCED_PARAMETER(File);
+    UNREFERENCED_PARAMETER(Offset);
+    UNREFERENCED_PARAMETER(From);
+
+    LOG_FUNC_START;
+
+    NOT_REACHED;
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+}
+#endif
+
+#undef memset
+#ifdef NDEBUG
+#pragma function(memset)
+#endif
+_At_buffer_(address, i, size, _Post_satisfies_(((PBYTE)address)[i] == value))
+void*
+memset(
+    OUT_WRITES_BYTES_ALL(size)  PVOID address,
+    IN                          BYTE value,
+    IN                          DWORD size
+)
+{
+    cl_memset(address, value, size);
+
+    return address;
+}
diff --git a/src_proiect/HAL9000/src/ap_tramp.c b/src_proiect/HAL9000/src/ap_tramp.c
new file mode 100644
index 0000000..7031965
--- /dev/null
+++ b/src_proiect/HAL9000/src/ap_tramp.c
@@ -0,0 +1,298 @@
+#include "HAL9000.h"
+#include "cpumu.h"
+#include "synch.h"
+#include "ap_tramp.h"
+#include "mmu.h"
+#include "gdtmu.h"
+#include "idt.h"
+#include "thread_internal.h"
+
+#define LOW_MEMORY_CONFIG_START         0x1000
+#define LOW_MEMORY_CONFIG_SIZE          0x1000
+
+#define LOW_MEMORY_CODE_START           0x2000
+#define LOW_MEMORY_CODE_SIZE            0x1000
+
+#define LOW_MEMORY_STACK_START          0x3000
+#define LOW_MEMORY_STACK_SIZE           0x1000
+
+#define PREDEFINED_SYSTEM_CONFIG_SIZE   0x1C
+#define PREDEFINED_AP_CONFIG_ENTRY_SIZE 0x10
+
+extern void PM32_to_PM64();
+extern void PM32_to_PM64End();
+
+extern void TrampolineStart();
+extern void PM32_to_PM64_PlaceHolder();
+
+extern void LowGdtTable();
+extern void LowGdtTableEnd();
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+
+typedef struct _SYSTEM_CONFIG
+{
+    GDT32               LowGdt;
+    GDT                 HighGdt;
+    DWORD               Pml4PhysicalAddress;
+    WORD                Code32Selector;
+    WORD                Data32Selector;
+    WORD                Code64Selector;
+    WORD                Data64Selector;
+} SYSTEM_CONFIG, *PSYSTEM_CONFIG;
+STATIC_ASSERT(sizeof(SYSTEM_CONFIG) == PREDEFINED_SYSTEM_CONFIG_SIZE);
+
+typedef struct _AP_CONFIG_ENTRY
+{
+    DWORD               StackPhysicalAddress;
+    DWORD               __Reserved0;
+    QWORD               StackVirtualAddress;
+} AP_CONFIG_ENTRY, *PAP_CONFIG_ENTRY;
+STATIC_ASSERT(sizeof(AP_CONFIG_ENTRY) == PREDEFINED_AP_CONFIG_ENTRY_SIZE);
+
+typedef struct _LOW_MEMORY_CONFIG
+{
+    SYSTEM_CONFIG       SystemConfig;
+    AP_CONFIG_ENTRY     ApConfig[0];
+} LOW_MEMORY_CONFIG, *PLOW_MEMORY_CONFIG;
+#pragma warning(pop)
+#pragma pack(pop)
+
+STATUS
+ApTrampSetupLowerMemory(
+    IN      PLIST_ENTRY     CpuList,
+    OUT     DWORD*          ApStartAddress
+    )
+{
+    STATUS status;
+    PBYTE pLowMemoryCode;
+    QWORD initialCodeSize;
+    QWORD placeholderCodeSize;
+    QWORD lowGdtSize;
+    PLOW_MEMORY_CONFIG pConfig;
+    PLIST_ENTRY pCurEntry;
+    PHYSICAL_ADDRESS cr3;
+    GDT highGdt;
+
+    ASSERT(NULL != CpuList);
+
+    status = STATUS_SUCCESS;
+    pLowMemoryCode = NULL;
+    initialCodeSize = 0;
+    placeholderCodeSize = 0;
+    lowGdtSize = 0;
+    pConfig = NULL;
+    pCurEntry = NULL;
+    cr3 = NULL;
+    __sgdt(&highGdt);
+
+    pLowMemoryCode = (PBYTE) LOW_MEMORY_CODE_START;
+    MmuMapMemoryInternal((PHYSICAL_ADDRESS) LOW_MEMORY_CODE_START,
+                         LOW_MEMORY_CODE_SIZE,
+                         PAGE_RIGHTS_ALL,
+                         pLowMemoryCode,
+                         TRUE,
+                         FALSE,
+                         NULL
+                         );
+
+    MmuMapMemoryInternal((PHYSICAL_ADDRESS)LOW_MEMORY_CODE_START,
+                         LOW_MEMORY_CODE_SIZE,
+                         PAGE_RIGHTS_ALL,
+                         (PVOID) PA2VA(pLowMemoryCode),
+                         TRUE,
+                         FALSE,
+                         NULL
+                         );
+
+    initialCodeSize = (QWORD) PM32_to_PM64_PlaceHolder - (QWORD) TrampolineStart;
+    ASSERT(initialCodeSize <= LOW_MEMORY_CODE_SIZE);
+
+    // warning C4152: nonstandard extension, function/data pointer conversion in expression
+#pragma warning(suppress:4152)
+    memcpy(pLowMemoryCode, TrampolineStart, initialCodeSize);
+
+    placeholderCodeSize = (QWORD)PM32_to_PM64End - (QWORD)PM32_to_PM64;
+    ASSERT(initialCodeSize + placeholderCodeSize <= LOW_MEMORY_CODE_SIZE);
+
+    // warning C4152: nonstandard extension, function/data pointer conversion in expression
+#pragma warning(suppress:4152)
+    memcpy(pLowMemoryCode + initialCodeSize, PM32_to_PM64, placeholderCodeSize);
+
+    __try
+    {
+        // setup SYSTEM_CONFIG
+        pConfig = MmuMapSystemMemory((PVOID)LOW_MEMORY_CONFIG_START, LOW_MEMORY_CONFIG_SIZE);
+        if (NULL == pConfig)
+        {
+            status = STATUS_MEMORY_CANNOT_BE_MAPPED;
+            __leave;
+        }
+
+        // Determine how much memory we have reserved for the LowGdt
+        lowGdtSize = (QWORD)LowGdtTableEnd - (QWORD)LowGdtTable;
+        ASSERT(IsAddressAligned(lowGdtSize, sizeof(SEGMENT_DESCRIPTOR)));
+        ASSERT(lowGdtSize <= MAX_WORD + 1);
+        ASSERT(initialCodeSize + placeholderCodeSize + lowGdtSize <= LOW_MEMORY_CODE_SIZE);
+
+        memcpy(&pConfig->SystemConfig.HighGdt, &highGdt, sizeof(GDT));
+#pragma warning(suppress:4152)
+        memcpy(pLowMemoryCode + initialCodeSize + placeholderCodeSize, pConfig->SystemConfig.HighGdt.Base, min(lowGdtSize, pConfig->SystemConfig.HighGdt.Limit + 1));
+
+        pConfig->SystemConfig.LowGdt.Base = (DWORD)((QWORD)pLowMemoryCode + initialCodeSize + placeholderCodeSize);
+        pConfig->SystemConfig.LowGdt.Limit = (WORD)(lowGdtSize - 1);
+        cr3 = __readcr3();
+        ASSERT((QWORD)cr3 <= MAX_DWORD);
+
+        // warning C4311: 'type cast': pointer truncation from 'PHYSICAL_ADDRESS' to 'DWORD'
+#pragma warning(suppress:4311)
+        pConfig->SystemConfig.Pml4PhysicalAddress = (DWORD)cr3;
+
+        LOGL("CR3: 0x%X\n", cr3);
+        LOGL("Low GDT base: 0x%x\n", pConfig->SystemConfig.LowGdt.Base);
+        LOGL("Low GDT limit: 0x%x\n", pConfig->SystemConfig.LowGdt.Limit);
+        LOGL("High GDT base: 0x%X\n", pConfig->SystemConfig.HighGdt.Base);
+        LOGL("High GDT limit: 0x%x\n", pConfig->SystemConfig.HighGdt.Limit);
+
+        pConfig->SystemConfig.Code64Selector = GdtMuGetCS64Supervisor();
+        pConfig->SystemConfig.Data64Selector = GdtMuGetDS64Supervisor();
+
+        pConfig->SystemConfig.Code32Selector = GdtMuGetCS32Supervisor();
+        pConfig->SystemConfig.Data32Selector = GdtMuGetDS32Supervisor();
+
+        // setup AP_CONFIG_ENTRY for each CPU
+        for (pCurEntry = CpuList->Flink;
+             pCurEntry != CpuList;
+             pCurEntry = pCurEntry->Flink)
+        {
+            PPCPU pCpu = CONTAINING_RECORD(pCurEntry, PCPU, ListEntry);
+
+            if (!pCpu->BspProcessor)
+            {
+                APIC_ID apicId = pCpu->ApicId;
+
+                pConfig->ApConfig[apicId].StackPhysicalAddress = LOW_MEMORY_STACK_START + LOW_MEMORY_STACK_SIZE * apicId;
+
+                // warning C4312: 'type cast': conversion from 'DWORD' to 'PHYSICAL_ADDRESS' of greater size
+#pragma warning(suppress:4312)
+                MmuMapMemoryInternal((PHYSICAL_ADDRESS)(pConfig->ApConfig[apicId].StackPhysicalAddress - LOW_MEMORY_STACK_SIZE),
+                                     LOW_MEMORY_STACK_SIZE,
+                                     PAGE_RIGHTS_READWRITE,
+                                     (PVOID)((QWORD)pConfig->ApConfig[apicId].StackPhysicalAddress - LOW_MEMORY_STACK_SIZE),
+                                     TRUE,
+                                     FALSE,
+                                     NULL
+                );
+
+                pConfig->ApConfig[apicId].StackVirtualAddress = (QWORD)pCpu->StackTop;
+
+                LOGL("Cpu at: 0x%X\n", pCpu);
+                LOGL("Setup AP config for apic id 0x%x\n", apicId);
+                LOGL("Physical Stack PA: 0x%x\n", pConfig->ApConfig[apicId].StackPhysicalAddress);
+                LOGL("Virtual Stack VA: 0x%X\n", pConfig->ApConfig[apicId].StackVirtualAddress);
+            }
+        }
+    }
+    __finally
+    {
+        // there is no need of a cleanup because after all APs will be started
+        // all unnecessary memory will be unmapped
+        *ApStartAddress = LOW_MEMORY_CODE_START;
+    }
+
+    return status;
+}
+
+void
+ApTrampCleanupLowerMemory(
+    IN      PLIST_ENTRY     CpuList
+    )
+{
+    PLIST_ENTRY pCurEntry;
+
+    ASSERT( NULL != CpuList );
+
+    MmuUnmapSystemMemory((PVOID) LOW_MEMORY_CODE_START,
+                   LOW_MEMORY_CODE_SIZE
+                   );
+
+    MmuUnmapSystemMemory((PVOID) PA2VA(LOW_MEMORY_CODE_START),
+                   LOW_MEMORY_CODE_SIZE
+                   );
+
+    // setup AP_CONFIG_ENTRY for each CPU
+    for(pCurEntry = CpuList->Flink;
+        pCurEntry != CpuList;
+        pCurEntry = pCurEntry->Flink)
+    {
+        PPCPU pCpu = CONTAINING_RECORD(pCurEntry, PCPU, ListEntry);
+
+        if (!pCpu->BspProcessor)
+        {
+            APIC_ID apicId = pCpu->ApicId;
+            QWORD stackVirtualAddress = LOW_MEMORY_STACK_START + LOW_MEMORY_STACK_SIZE * apicId;
+
+            MmuUnmapSystemMemory((PVOID) ( stackVirtualAddress - LOW_MEMORY_STACK_SIZE ),
+                           LOW_MEMORY_STACK_SIZE
+                           );
+        }
+    }
+}
+
+void    
+ApInitCpu(
+    IN      struct _PCPU*   Cpu
+    )
+{
+    STATUS status;
+
+    CHECK_STACK_ALIGNMENT;
+
+    status = STATUS_SUCCESS;
+
+    LOGPL("Hello C!, CPU at: 0x%X\n", Cpu);
+
+    // we need to reload GDT with new one
+    GdtMuReload(GdtMuGetCS64Supervisor(), GdtMuGetDS64Supervisor(), FALSE, FALSE);
+
+    __try
+    {
+        status = CpuMuActivateFpuFeatures();
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("CpuMuActivateFpuFeatures", status);
+            __leave;
+        }
+
+    // reload IDT
+    IdtReload();
+
+    status = CpuMuInitCpu( (PCPU*) Cpu, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("CpuMuInitCpu", status );
+            __leave;
+    }
+
+    MmuActivateProcessIds();
+
+    status = ThreadSystemInitIdleForCurrentCPU();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
+            __leave;
+    }
+
+    // exit main thread
+    ThreadExit(STATUS_SUCCESS);
+    }
+    __finally
+    {
+    NOT_REACHED;
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/boot_module.c b/src_proiect/HAL9000/src/boot_module.c
new file mode 100644
index 0000000..e7969bc
--- /dev/null
+++ b/src_proiect/HAL9000/src/boot_module.c
@@ -0,0 +1,350 @@
+#include "HAL9000.h"
+#include "boot_module.h"
+#include "mmu.h"
+#include "multiboot.h"
+
+#define BOOT_MODULE_MAX_NAME_LEN        100
+
+typedef struct _BOOT_MODULE_INFORMATION
+{
+    PVOID                           BaseAddress;
+    QWORD                           Length;
+
+    char*                           Name;
+} BOOT_MODULE_INFORMATION, *PBOOT_MODULE_INFORMATION;
+
+typedef struct _BOOT_MODULE_SYSTEM_DATA
+{
+    PBOOT_MODULE_INFORMATION        Modules;
+
+    DWORD                           NumberOfModules;
+} BOOT_MODULE_SYSTEM_DATA, *PBOOT_MODULE_SYSTEM_DATA;
+
+static BOOT_MODULE_SYSTEM_DATA m_bootModuleInformation;
+
+static
+STATUS
+_MapSingleModule(
+    OUT     PBOOT_MODULE_INFORMATION            MappedModule,
+    IN      PMULTIBOOT_MODULE_INFORMATION       MultibootModule
+    );
+
+static
+void
+_BootModuleUninitialize(
+    _Pre_valid_ _Post_invalid_
+            PBOOT_MODULE_INFORMATION            BootModule
+    );
+
+static
+void
+_BootModulesUninitialize(
+    _Pre_valid_ _Post_ptr_invalid_
+            PBOOT_MODULE_INFORMATION            BootModules,
+    IN      DWORD                               NumberOfModules
+    );
+
+_No_competing_thread_
+void
+BootModulesPreinit(
+    void
+    )
+{
+    memzero(&m_bootModuleInformation, sizeof(BOOT_MODULE_SYSTEM_DATA));
+}
+
+_No_competing_thread_
+STATUS
+BootModulesInit(
+    IN      PHYSICAL_ADDRESS        BootModulesStart,
+    IN      DWORD                   NumberOfModules
+    )
+{
+    STATUS status;
+    PBOOT_MODULE_INFORMATION pModuleInformation;
+    PMULTIBOOT_MODULE_INFORMATION pMultibootModules;
+
+    if (NumberOfModules == 0)
+    {
+        // nothing to map
+        return STATUS_SUCCESS;
+    }
+
+    if (BootModulesStart == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+    pModuleInformation = NULL;
+    pMultibootModules = NULL;
+
+    __try
+    {
+        pModuleInformation = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                                   NumberOfModules * sizeof(BOOT_MODULE_INFORMATION),
+                                                   HEAP_BOOT_TAG,
+                                                   0);
+        if (pModuleInformation == NULL)
+        {
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", NumberOfModules * sizeof(BOOT_MODULE_INFORMATION));
+            __leave;
+        }
+
+        pMultibootModules = MmuMapSystemMemory(BootModulesStart, NumberOfModules * sizeof(MULTIBOOT_MODULE_INFORMATION));
+        if (pMultibootModules == NULL)
+        {
+            status = STATUS_MEMORY_CANNOT_BE_MAPPED;
+            LOG_FUNC_ERROR_ALLOC("MmuMapSystemMemory",NumberOfModules * sizeof(MULTIBOOT_MODULE_INFORMATION));
+            __leave;
+        }
+
+        for (DWORD i = 0; i < NumberOfModules; ++i)
+        {
+            status = _MapSingleModule(&pModuleInformation[i], &pMultibootModules[i]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_WARNING("_MapSingleModule failed with status 0x%x\n", status);
+
+                // This component (boot_module.c) doesn't know which modules are essential and which are not
+                // so we do our best effort to map as many modules as possible even if some fail
+                // Some component higher than us in the hierarchy will decide which components are mandatory and which
+                // are not
+                status = STATUS_SUCCESS;
+                continue;
+            }
+        }
+    }
+    __finally
+    {
+        if (pMultibootModules != NULL)
+        {
+            MmuUnmapSystemMemory(pMultibootModules, NumberOfModules * sizeof(MULTIBOOT_MODULE_INFORMATION));
+            pMultibootModules = NULL;
+        }
+
+        if (!SUCCEEDED(status))
+        {
+            _BootModulesUninitialize(pModuleInformation, NumberOfModules);
+            pModuleInformation = NULL;
+        }
+        else
+        {
+            m_bootModuleInformation.NumberOfModules = NumberOfModules;
+            m_bootModuleInformation.Modules = pModuleInformation;
+        }
+    }
+
+    return status;
+}
+
+_No_competing_thread_
+void
+BootModulesUninit(
+    void
+    )
+{
+    if (m_bootModuleInformation.Modules != NULL)
+    {
+        _BootModulesUninitialize(m_bootModuleInformation.Modules,
+                                 m_bootModuleInformation.NumberOfModules);
+    }
+
+    BootModulesPreinit();
+}
+
+STATUS
+BootModuleGet(
+    IN_Z    char*                   ModuleName,
+    OUT     PVOID*                  BaseAddress,
+    OUT     QWORD*                  ModuleLength
+    )
+{
+    if (ModuleName == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (BaseAddress == NULL)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (ModuleLength == NULL)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    for (DWORD i = 0; i < m_bootModuleInformation.NumberOfModules; ++i)
+    {
+        if (stricmp(ModuleName, m_bootModuleInformation.Modules[i].Name) == 0)
+        {
+            *BaseAddress = m_bootModuleInformation.Modules[i].BaseAddress;
+            *ModuleLength = m_bootModuleInformation.Modules[i].Length;
+
+            return STATUS_SUCCESS;
+        }
+    }
+
+    return STATUS_ELEMENT_NOT_FOUND;
+}
+
+static
+STATUS
+_MapSingleModule(
+    OUT     PBOOT_MODULE_INFORMATION            MappedModule,
+    IN      PMULTIBOOT_MODULE_INFORMATION       MultibootModule
+    )
+{
+    STATUS status;
+    DWORD modNameLen;
+    PVOID pModuleData;
+    PVOID pMappedString;
+    BOOT_MODULE_INFORMATION bootMod;
+
+    ASSERT(MappedModule != NULL);
+    ASSERT(MultibootModule != NULL);
+
+    status = STATUS_SUCCESS;
+    pModuleData = NULL;
+    pMappedString = NULL;
+    memzero(&bootMod, sizeof(BOOT_MODULE_INFORMATION));
+
+    __try
+    {
+        // The string field may be 0 if there is no string associated with the module.
+        if (MultibootModule->StringPhysAddr != 0)
+        {
+            pMappedString = MmuMapSystemMemory((PHYSICAL_ADDRESS)(QWORD)MultibootModule->StringPhysAddr,
+                                               BOOT_MODULE_MAX_NAME_LEN);
+            if (pMappedString == NULL)
+            {
+                status = STATUS_MEMORY_CANNOT_BE_MAPPED;
+                LOG_FUNC_ERROR_ALLOC("MmuMapSystemMemory", BOOT_MODULE_MAX_NAME_LEN);
+                __leave;
+            }
+
+            // The string field provides an arbitrary string to be associated with that particular boot module;
+            // it is a zero-terminated ASCII string
+            modNameLen = strlen_s(pMappedString, BOOT_MODULE_MAX_NAME_LEN);
+            ASSERT(modNameLen != INVALID_STRING_SIZE);
+
+            // It seems that the MB loader gives us an extra space (' ') character at the end of each module name,
+            // we will replace this space with a NULL terminator => no reason to allocate an extra byte
+            bootMod.Name = ExAllocatePoolWithTag(0, modNameLen, HEAP_BOOT_TAG, 0);
+            if (bootMod.Name == NULL)
+            {
+                status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", modNameLen);
+                __leave;
+            }
+            memcpy(bootMod.Name, pMappedString, modNameLen - 1);
+            bootMod.Name[modNameLen - 1] = '\0';
+        }
+
+        bootMod.Length = MultibootModule->ModuleEndPhysAddr - MultibootModule->ModuleStartPhysAddr;
+
+        if (bootMod.Length == 0)
+        {
+            LOG_WARNING("There's nothing we can do with a module with size 0!\n");
+            status = STATUS_NO_DATA_AVAILABLE;
+            __leave;
+        }
+
+        LOG("Will try to map module between 0x%x -> 0x%x with name [%s] of size 0x%x\n",
+            MultibootModule->ModuleStartPhysAddr, MultibootModule->ModuleEndPhysAddr,
+            bootMod.Name, bootMod.Length);
+
+        pModuleData = MmuMapSystemMemory((PHYSICAL_ADDRESS)(QWORD)MultibootModule->ModuleStartPhysAddr,
+                                         bootMod.Length);
+        if (pModuleData == NULL)
+        {
+            status = STATUS_MEMORY_CANNOT_BE_MAPPED;
+            LOG_FUNC_ERROR_ALLOC("MmuMapSystemMemory", bootMod.Length);
+            __leave;
+        }
+        ASSERT(bootMod.Length + 1 <= MAX_DWORD);
+
+        bootMod.BaseAddress = ExAllocatePoolWithTag(0, (DWORD) bootMod.Length, HEAP_BOOT_TAG, 0);
+        if (bootMod.BaseAddress == NULL)
+        {
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", bootMod.Length);
+            __leave;
+        }
+
+        memcpy(bootMod.BaseAddress, pModuleData, bootMod.Length);
+    }
+    __finally
+    {
+        if (pModuleData != NULL)
+        {
+            ASSERT(bootMod.Length != 0);
+
+            MmuUnmapSystemMemory(pModuleData, bootMod.Length);
+            pModuleData = NULL;
+        }
+
+        if (pMappedString != NULL)
+        {
+            MmuUnmapSystemMemory(pMappedString, BOOT_MODULE_MAX_NAME_LEN);
+            pMappedString = NULL;
+        }
+
+        if (!SUCCEEDED(status))
+        {
+            _BootModuleUninitialize(&bootMod);
+        }
+        else
+        {
+            memcpy(MappedModule, &bootMod, sizeof(BOOT_MODULE_INFORMATION));
+        }
+    }
+
+    return status;
+}
+
+static
+void
+_BootModuleUninitialize(
+    _Pre_valid_ _Post_invalid_
+            PBOOT_MODULE_INFORMATION            BootModule
+    )
+{
+    ASSERT(BootModule != NULL);
+
+    if (BootModule->Name != NULL)
+    {
+        ExFreePoolWithTag(BootModule->Name, HEAP_BOOT_TAG);
+        BootModule->Name = NULL;
+    }
+
+    if (BootModule->BaseAddress != NULL)
+    {
+        ASSERT(BootModule->Length != 0);
+
+        ExFreePoolWithTag(BootModule->BaseAddress, HEAP_BOOT_TAG);
+        BootModule->BaseAddress = NULL;
+    }
+
+    BootModule->Length = 0;
+}
+
+static
+void
+_BootModulesUninitialize(
+    _Pre_valid_ _Post_ptr_invalid_
+            PBOOT_MODULE_INFORMATION            BootModules,
+    IN      DWORD                               NumberOfModules
+    )
+{
+    ASSERT(BootModules != NULL);
+
+    for (DWORD i = 0; i < NumberOfModules; ++i)
+    {
+        _BootModuleUninitialize(&BootModules[i]);
+    }
+
+    ExFreePoolWithTag(BootModules, HEAP_BOOT_TAG);
+}
diff --git a/src_proiect/HAL9000/src/cmd_basic.c b/src_proiect/HAL9000/src/cmd_basic.c
new file mode 100644
index 0000000..33859c5
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_basic.c
@@ -0,0 +1,155 @@
+#include "HAL9000.h"
+#include "cmd_fs_helper.h"
+#include "display.h"
+#include "dmp_io.h"
+#include "print.h"
+#include "iomu.h"
+#include "test_common.h"
+#include "strutils.h"
+
+void
+CmdPrintVolumeInformation(
+    IN      QWORD           NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    printColor(MAGENTA_COLOR, "%7s", "Letter|");
+    printColor(MAGENTA_COLOR, "%17s", "Type|");
+    printColor(MAGENTA_COLOR, "%10s", "Mounted|");
+    printColor(MAGENTA_COLOR, "%10s", "Bootable|");
+    printColor(MAGENTA_COLOR, "%17s", "Offset|");
+    printColor(MAGENTA_COLOR, "%17s", "Size|");
+    printColor(MAGENTA_COLOR, "\n");
+
+    IomuExecuteForEachVpb(DumpVpb, NULL, FALSE);
+}
+
+#pragma warning(push)
+
+// warning C4717: '_CmdInfiniteRecursion': recursive on all control paths, function will cause runtime stack overflow
+#pragma warning(disable:4717)
+void
+CmdInfiniteRecursion(
+    IN      QWORD           NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    CmdInfiniteRecursion(NumberOfParameters);
+}
+#pragma warning(pop)
+
+void
+CmdRtcFail(
+    IN      QWORD           NumberOfParameters
+    )
+{
+    char buffer[] = "Alex is a smart boy!\n";
+
+    ASSERT(NumberOfParameters == 0);
+
+    strcpy(buffer, "Alex is a very dumb boy!\n");
+}
+
+void
+CmdRangeFail(
+    IN      QWORD           NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    perror("Cannot implement! :(\n");
+}
+
+void
+(__cdecl CmdBiteCookie)(
+    IN      QWORD           NumberOfParameters
+    )
+{
+    char buffer[] = "Alex is a smart boy!\n";
+
+    ASSERT(NumberOfParameters == 0);
+
+    strcpy(buffer + sizeof(buffer) + sizeof(PVOID), "Alex is a very dumb boy!\n");
+}
+
+void
+(__cdecl CmdLogSetState)(
+    IN      QWORD           NumberOfParameters,
+    IN      char*           LogState
+    )
+{
+    ASSERT(NumberOfParameters == 1);
+
+    LogSetState(stricmp(LogState, "ON") == 0);
+}
+
+void
+(__cdecl CmdSetLogLevel)(
+    IN      QWORD           NumberOfParameters,
+    IN      char*           LogLevelString
+    )
+{
+    LOG_LEVEL logLevel;
+
+    ASSERT(NumberOfParameters == 1);
+
+    atoi32(&logLevel, LogLevelString, BASE_TEN);
+
+    if (logLevel > LogLevelError)
+    {
+        perror("Invalid log level %u specified!\n", logLevel);
+        return;
+    }
+
+    printf("Will set logging level to %u\n", logLevel);
+    LogSetLevel(logLevel);
+}
+
+void
+(__cdecl CmdSetLogComponents)(
+    IN      QWORD           NumberOfParameters,
+    IN      char*           LogComponentsString
+    )
+{
+    LOG_COMPONENT logComponents;
+
+    ASSERT(NumberOfParameters == 1);
+
+    atoi32(&logComponents, LogComponentsString, BASE_HEXA);
+
+    printf("Will set logging components to 0x%x\n", logComponents);
+
+    LogSetTracedComponents(logComponents);
+}
+
+void
+(__cdecl CmdClearScreen)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    DispClearScreen();
+}
+
+void
+(__cdecl CmdRunAllFunctionalTests)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    TestRunAllFunctional();
+}
+
+void
+(__cdecl CmdRunAllPerformanceTests)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    TestRunAllPerformance();
+}
diff --git a/src_proiect/HAL9000/src/cmd_fs_helper.c b/src_proiect/HAL9000/src/cmd_fs_helper.c
new file mode 100644
index 0000000..96ffb9e
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_fs_helper.c
@@ -0,0 +1,796 @@
+#include "HAL9000.h"
+#include "cmd_fs_helper.h"
+
+#include "display.h"
+#include "print.h"
+#include "io.h"
+#include "os_time.h"
+
+#include "dmp_memory.h"
+#include "strutils.h"
+#include "iomu.h"
+
+#pragma warning(push)
+
+// warning C4212: nonstandard extension used: function declaration used ellipsis
+#pragma warning(disable:4212)
+
+#define CMD_READFILE_BYTES_TO_READ_AT_A_TIME            (32*KB_SIZE)
+
+static
+void
+_DisplayDirectoryInformation(
+    IN_Z    char*                           Directory,
+    IN      PFILE_DIRECTORY_INFORMATION     FileInformation,
+    IN      BOOLEAN                         Recursive,
+    IN      DWORD                           CurrentRecursionLevel
+    );
+
+static
+void
+_ListDirectory(
+    IN_Z    char*       File,
+    IN      BOOLEAN     Recursive,
+    IN      DWORD       CurrentRecursionLevel
+    );
+
+void
+(__cdecl CmdStatFile)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       File
+    )
+{
+    STATUS status;
+    PFILE_OBJECT pFileObject;
+    FILE_INFORMATION fileInformation;
+    char tempBuffer[MAX_PATH];
+    char* pFileType;
+
+    ASSERT(NumberOfParameters == 1);
+
+    if (NULL == File)
+    {
+        return;
+    }
+
+    status = STATUS_SUCCESS;
+    pFileObject = NULL;
+    memzero(&fileInformation, sizeof(FILE_INFORMATION));
+    pFileType = NULL;
+
+    printf("Will open file %s\n", File);
+
+    status = IoCreateFile(&pFileObject,
+                          File,
+                          FALSE,
+                          FALSE,
+                          FALSE
+                          );
+    if (!SUCCEEDED(status))
+    {
+        // try to open path as a directory
+        status = IoCreateFile(&pFileObject,
+                              File,
+                              TRUE,
+                              FALSE,
+                              FALSE
+                              );
+        if (!SUCCEEDED(status))
+        {
+            perror("IoCreateFile failed with status: 0x%x\n", status);
+            return;
+        }
+    }
+
+    printf("IoCreateFile succeeded\n");
+
+    __try
+    {
+        status = IoQueryInformationFile(pFileObject,
+                                        &fileInformation
+        );
+        if (!SUCCEEDED(status))
+        {
+            perror("IoQueryInformationFile failed with status: 0x%x\n", status);
+            __leave;
+        }
+
+        printf("IoQueryInformationFile succeeded\n");
+
+        if (IsBooleanFlagOn(fileInformation.FileAttributes, FILE_ATTRIBUTE_VOLUME))
+        {
+            pFileType = "VOLUME";
+        }
+        else if (IsBooleanFlagOn(fileInformation.FileAttributes, FILE_ATTRIBUTE_DIRECTORY))
+        {
+            pFileType = "DIRECTORY";
+        }
+        else
+        {
+            pFileType = "FILE";
+        }
+
+        printf("File type is: %s\n", pFileType);
+        printf("File size: %D KB\n", fileInformation.FileSize / KB_SIZE);
+        OsTimeGetStringFormattedTime(&fileInformation.CreationTime, tempBuffer, MAX_PATH);
+        printf("Creation time: %s\n", tempBuffer);
+
+        OsTimeGetStringFormattedTime(&fileInformation.LastWriteTime, tempBuffer, MAX_PATH);
+        printf("Last write time: %s\n", tempBuffer);
+    }
+    __finally
+    {
+        if (NULL != pFileObject)
+        {
+            status = IoCloseFile(pFileObject);
+            if (!SUCCEEDED(status))
+            {
+                perror("IoCloseFIle failed with status: 0x%x\n", status);
+            }
+            else
+            {
+                printf("IoCloseFile succeeded\n");
+            }
+
+            pFileObject = NULL;
+        }
+    }
+}
+
+void
+(__cdecl CmdMakeDirectory)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       File
+    )
+{
+    STATUS status;
+    PFILE_OBJECT pFileObject;
+
+    ASSERT(NumberOfParameters == 1);
+
+    if (NULL == File)
+    {
+        return;
+    }
+
+    status = STATUS_SUCCESS;
+    pFileObject = NULL;
+
+    printf("Will create directory %s\n", File);
+
+    status = IoCreateFile(&pFileObject,
+                          File,
+                          TRUE,
+                          TRUE,
+                          FALSE
+                          );
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCreateFile failed with status: 0x%x\n", status);
+        return;
+    }
+
+    printf("IoCreateFile succeeded\n");
+
+    status = IoCloseFile(pFileObject);
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCloseFIle failed with status: 0x%x\n", status);
+        return;
+    }
+    pFileObject = NULL;
+
+    printf("IoCloseFile succeeded\n");
+}
+
+void
+(__cdecl CmdMakeFile)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       File
+    )
+{
+    STATUS status;
+    PFILE_OBJECT pFileObject;
+
+    ASSERT(NumberOfParameters == 1);
+
+    if (NULL == File)
+    {
+        return;
+    }
+
+    status = STATUS_SUCCESS;
+    pFileObject = NULL;
+
+    printf("Will create file %s\n", File);
+
+    status = IoCreateFile(&pFileObject,
+                          File,
+                          FALSE,
+                          TRUE,
+                          FALSE
+                          );
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCreateFile failed with status: 0x%x\n", status);
+        return;
+    }
+    else
+    {
+        printf("IoCreateFile succeeded\n");
+    }
+
+    status = IoCloseFile(pFileObject);
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCloseFIle failed with status: 0x%x\n", status);
+        return;
+    }
+    pFileObject = NULL;
+
+    printf("IoCloseFile succeeded\n");
+}
+
+void
+(__cdecl CmdListDirectory)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       File,
+    IN_Z    char*       Recursive
+    )
+{
+    printf("Directory [%s] contents:\n", File );
+    _ListDirectory(File,
+                   NumberOfParameters >= 2 ? (stricmp(Recursive, "-R") == 0) : FALSE,
+                   0);
+}
+
+void
+(__cdecl CmdReadFile)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       File,
+    IN_Z    char*       Async
+    )
+{
+    STATUS status;
+    PFILE_OBJECT pFileObject;
+    QWORD bytesRead;
+    FILE_INFORMATION fileInformation;
+    PBYTE pData;
+    QWORD bytesRemaining;
+    DWORD allocationSize;
+    DWORD bytesToRead;
+    QWORD fileOffset;
+    BOOLEAN bAsync;
+
+    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 2);
+
+    if (NULL == File)
+    {
+        return;
+    }
+
+    status = STATUS_SUCCESS;
+    pFileObject = NULL;
+    bytesRead = 0;
+    memzero(&fileInformation, sizeof(FILE_INFORMATION));
+    pData = NULL;
+    bytesRemaining = 0;
+    allocationSize = 0;
+    bytesToRead = 0;
+    fileOffset = 0;
+    bAsync = (NumberOfParameters >= 2) ? (stricmp(Async, "async") == 0) : FALSE;
+
+    printf("Will open file %s\n", File);
+
+    status = IoCreateFile(&pFileObject,
+                          File,
+                          FALSE,
+                          FALSE,
+                          bAsync
+                          );
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCreateFile failed with status: 0x%x\n", status);
+        return;
+    }
+
+    printf("IoCreateFile succeeded\n");
+
+    __try
+    {
+        status = IoQueryInformationFile(pFileObject,
+                                        &fileInformation
+        );
+        if (!SUCCEEDED(status))
+        {
+            perror("IoQueryInformationFile failed with status: 0x%x\n", status);
+            __leave;
+        }
+
+        printf("IoQueryInformationFile succeeded\n");
+
+        bytesRemaining = fileInformation.FileSize;
+        allocationSize = (DWORD)min(fileInformation.FileSize, CMD_READFILE_BYTES_TO_READ_AT_A_TIME);
+
+        pData = ExAllocatePoolWithTag(0, allocationSize, HEAP_TEMP_TAG, 0);
+        if (NULL == pData)
+        {
+            perror("HeapAllocatePoolWithTag failed for file size: %D KB\n", allocationSize / KB_SIZE);
+            __leave;
+        }
+
+        printf("HeapAllocatePoolWithTag succeeded\n");
+
+        while (0 != bytesRemaining)
+        {
+            bytesToRead = (DWORD)min(bytesRemaining, allocationSize);
+
+            status = IoReadFile(pFileObject,
+                                bytesToRead,
+                                &fileOffset,
+                                pData,
+                                &bytesRead
+            );
+            if (!SUCCEEDED(status))
+            {
+                perror("IoReadFile failed with status: 0x%x\n", status);
+                __leave;
+            }
+            ASSERT(bytesToRead == bytesRead);
+
+            DumpMemory(pData, fileOffset, (DWORD)bytesRead, TRUE, TRUE);
+
+            bytesRemaining = bytesRemaining - bytesRead;
+            fileOffset = fileOffset + bytesRead;
+        }
+    }
+    __finally
+    {
+        if (NULL != pFileObject)
+        {
+            status = IoCloseFile(pFileObject);
+            if (!SUCCEEDED(status))
+            {
+                perror("IoCloseFIle failed with status: 0x%x\n", status);
+            }
+            else
+            {
+                printf("IoCloseFile succeeded\n");
+            }
+
+            pFileObject = NULL;
+        }
+
+        if (NULL != pData)
+        {
+            ExFreePoolWithTag(pData, HEAP_TEMP_TAG);
+            pData = NULL;
+        }
+    }
+}
+
+void
+(__cdecl CmdWriteFile)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       File,
+    IN_Z    char*       CharToWrite,
+    IN_Z    char*       Extend,
+    IN_Z    char*       Async
+    )
+{
+    STATUS status;
+    PFILE_OBJECT pFileObject;
+    QWORD bytesWritten;
+    FILE_INFORMATION fileInformation;
+    PBYTE pData;
+    QWORD bytesRemaining;
+    DWORD allocationSize;
+    DWORD bytesToWrite;
+    QWORD fileOffset;
+    char  charToWrite;
+    BOOLEAN bExtend;
+    BOOLEAN bAsync;
+
+    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 4);
+
+    if (NULL == File)
+    {
+        return;
+    }
+
+    status = STATUS_SUCCESS;
+    pFileObject = NULL;
+    bytesWritten = 0;
+    memzero(&fileInformation, sizeof(FILE_INFORMATION));
+    pData = NULL;
+    bytesRemaining = 0;
+    allocationSize = 0;
+    bytesToWrite = 0;
+    fileOffset = 0;
+    charToWrite = (NumberOfParameters >= 2) ? CharToWrite[0] : 'x';
+    bExtend = (NumberOfParameters >= 3) ? (stricmp(Extend, "ext") == 0) : FALSE;
+    bAsync = (NumberOfParameters >= 4) ? (stricmp(Async, "async") == 0) : FALSE;
+
+    printf("Will open file %s\n", File);
+
+    status = IoCreateFile(&pFileObject,
+        File,
+        FALSE,
+        FALSE,
+        bAsync
+    );
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCreateFile failed with status: 0x%x\n", status);
+        return;
+    }
+
+    printf("IoCreateFile succeeded\n");
+
+    __try
+    {
+        status = IoQueryInformationFile(pFileObject,
+            &fileInformation
+        );
+        if (!SUCCEEDED(status))
+        {
+            perror("IoQueryInformationFile failed with status: 0x%x\n", status);
+            __leave;
+        }
+
+        printf("IoQueryInformationFile succeeded\n");
+
+        bytesRemaining = fileInformation.FileSize;
+        bytesRemaining += bExtend ? 9 * 0x200 : 0;
+        allocationSize = (DWORD)min(fileInformation.FileSize, CMD_READFILE_BYTES_TO_READ_AT_A_TIME);
+        allocationSize = (DWORD)min(fileInformation.FileSize, 1 * 0x200);
+
+        pData = ExAllocatePoolWithTag(0, allocationSize, HEAP_TEMP_TAG, 0);
+        if (NULL == pData)
+        {
+            perror("HeapAllocatePoolWithTag failed for file size: %D KB\n", allocationSize / KB_SIZE);
+            __leave;
+        }
+
+        printf("HeapAllocatePoolWithTag succeeded\n");
+
+        memset(pData, charToWrite, allocationSize);
+        DWORD i = 0;
+        while (0 != bytesRemaining)
+        {
+            sprintf((char*)pData, "%02dsector", i++);
+            bytesToWrite = (DWORD)min(bytesRemaining, allocationSize);
+
+            status = IoWriteFile(pFileObject,
+                bytesToWrite,
+                &fileOffset,
+                pData,
+                &bytesWritten
+            );
+            if (!SUCCEEDED(status))
+            {
+                perror("IoWriteFile failed with status: 0x%x\n", status);
+                __leave;
+            }
+            printf("bytesWritten = %X\n", bytesWritten);
+            ASSERT(bytesToWrite == bytesWritten);
+
+            //DumpMemory(pData, fileOffset, (DWORD)bytesWritten, TRUE, TRUE);
+
+            bytesRemaining = bytesRemaining - bytesWritten;
+            fileOffset = fileOffset + bytesWritten;
+        }
+    }
+    __finally
+    {
+        if (NULL != pFileObject)
+        {
+            status = IoCloseFile(pFileObject);
+            if (!SUCCEEDED(status))
+            {
+                perror("IoCloseFIle failed with status: 0x%x\n", status);
+            }
+            else
+            {
+                printf("IoCloseFile succeeded\n");
+            }
+
+            pFileObject = NULL;
+        }
+
+        if (NULL != pData)
+        {
+            ExFreePoolWithTag(pData, HEAP_TEMP_TAG);
+            pData = NULL;
+        }
+    }
+}
+
+void
+(__cdecl CmdSwap)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       Operation,
+    IN_Z    char*       OffsetString
+    )
+{
+    BOOLEAN bPerformWrite;
+    QWORD offset;
+    PFILE_OBJECT pSwapFile;
+    STATUS status;
+    QWORD bytesTransmitted;
+    PBYTE pData;
+    QWORD swapFileSize;
+
+    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 2);
+
+    bPerformWrite = (strcmp(Operation, "W") == 0);
+    offset = 0;
+    pSwapFile = NULL;
+    status = STATUS_SUCCESS;
+    bytesTransmitted = 0;
+    pData = NULL;
+
+    if (NumberOfParameters == 2)
+    {
+        atoi64(&offset, OffsetString, BASE_HEXA);
+    }
+
+    pSwapFile = IomuGetSwapFile();
+    if (pSwapFile == NULL)
+    {
+        LOG_ERROR("System has no swap file!\n");
+        return;
+    }
+
+    status = IoGetFileSize(pSwapFile, &swapFileSize);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetFileSize", status);
+        return;
+    }
+
+    LOG("System has a swap file of size %U KB [%U MB]\n",
+        swapFileSize / KB_SIZE, swapFileSize / MB_SIZE);
+
+    __try
+    {
+        pData = ExAllocatePoolWithTag(0, PAGE_SIZE, HEAP_TEMP_TAG, 0);
+        if (pData == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatedPoolWithTag", PAGE_SIZE);
+            status = STATUS_INSUFFICIENT_MEMORY;
+            __leave;
+        }
+
+        if (bPerformWrite)
+        {
+            PQWORD pOffsets = (PQWORD) pData;
+            for (DWORD i = 0; i < PAGE_SIZE / sizeof(QWORD); ++i)
+            {
+                pOffsets[i] = offset + i * sizeof(QWORD);
+            }
+
+            status = IoWriteFile(pSwapFile,
+                                 PAGE_SIZE,
+                                 &offset,
+                                 pData,
+                                 &bytesTransmitted);
+        }
+        else
+        {
+            status = IoReadFile(pSwapFile,
+                                PAGE_SIZE,
+                                &offset,
+                                pData,
+                                &bytesTransmitted);
+        }
+        if (!SUCCEEDED(status))
+        {
+            LOG_ERROR("[%s] Operation failed with status 0x%x at offset 0x%X\n",
+                      bPerformWrite ? "WRITE" : "READ",
+                      status,
+                      offset);
+            __leave;
+        }
+        ASSERT(bytesTransmitted == PAGE_SIZE);
+
+        if (!bPerformWrite)
+        {
+            DumpMemory(pData, 0, PAGE_SIZE, FALSE, TRUE);
+        }
+    }
+    __finally
+    {
+        if (pData != NULL)
+        {
+            ExFreePoolWithTag(pData, HEAP_TEMP_TAG);
+            pData = NULL;
+        }
+    }
+}
+
+static
+void
+_DisplayDirectoryInformation(
+    IN_Z    char*                           Directory,
+    IN      PFILE_DIRECTORY_INFORMATION     FileInformation,
+    IN      BOOLEAN                         Recursive,
+    IN      DWORD                           CurrentRecursionLevel
+    )
+{
+    PFILE_DIRECTORY_INFORMATION pCurEntry;
+    char fileName[MAX_PATH];
+    DWORD i;
+    char timeBuffer[32];
+    BOOLEAN lastIteration;
+    COLOR color;
+
+    ASSERT(NULL != FileInformation);
+
+    lastIteration = FALSE;
+    color = WHITE_COLOR;
+
+    for (pCurEntry = FileInformation;
+    !lastIteration;
+        pCurEntry = (PFILE_DIRECTORY_INFORMATION)((PBYTE)pCurEntry + pCurEntry->NextEntryOffset)
+        )
+    {
+        ASSERT(pCurEntry->FilenameLength < MAX_PATH - 1);
+
+        lastIteration = 0 == pCurEntry->NextEntryOffset;
+
+        memcpy(fileName, pCurEntry->Filename, pCurEntry->FilenameLength);
+        fileName[pCurEntry->FilenameLength] = '\0';
+
+        for (i = 0; i < CurrentRecursionLevel; ++i)
+        {
+            printf("\t");
+        }
+
+        OsTimeGetStringFormattedTime(&pCurEntry->BasicFileInformation.LastWriteTime, timeBuffer, 32);
+        if (IsBooleanFlagOn(pCurEntry->BasicFileInformation.FileAttributes, FILE_ATTRIBUTE_VOLUME))
+        {
+            color = MAGENTA_COLOR;
+            printColor(color, "%8s", "<VOL>");
+        }
+        else if (IsBooleanFlagOn(pCurEntry->BasicFileInformation.FileAttributes, FILE_ATTRIBUTE_DIRECTORY))
+        {
+            color = BLUE_COLOR;
+            printColor(color, "%8s", "<DIR>");
+        }
+        else
+        {
+            color = WHITE_COLOR;
+            printColor(color, "%5d KB", pCurEntry->BasicFileInformation.FileSize / KB_SIZE);
+        }
+
+        printf("\t");
+
+
+        printColor(color, "%s\t", timeBuffer);
+        printColor(color, "%s\n", fileName);
+
+        if (Recursive)
+        {
+            if (IsBooleanFlagOn(pCurEntry->BasicFileInformation.FileAttributes, FILE_ATTRIBUTE_DIRECTORY))
+            {
+                char temp[MAX_PATH];
+                BOOLEAN skip = FALSE;
+
+                if ((0 == strcmp(fileName, ".")) ||
+                    (0 == strcmp(fileName, ".."))
+                    )
+                {
+                    // we don't go into dot or dot dot
+                    skip = TRUE;
+                }
+
+                if (!skip)
+                {
+                    if (Directory[strlen(Directory) - 1] == '\\')
+                    {
+                        snprintf(temp, MAX_PATH, "%s%s", Directory, fileName);
+                    }
+                    else
+                    {
+                        snprintf(temp, MAX_PATH, "%s\\%s", Directory, fileName);
+                    }
+
+                    _ListDirectory(temp, Recursive, CurrentRecursionLevel + 1);
+                }
+            }
+        }
+    }
+}
+
+static
+void
+_ListDirectory(
+    IN_Z    char*       File,
+    IN      BOOLEAN     Recursive,
+    IN      DWORD       CurrentRecursionLevel
+    )
+{
+    STATUS status;
+    PFILE_OBJECT pFileObject;
+    PFILE_DIRECTORY_INFORMATION pDirectoryInformation;
+    DWORD sizeOfStructure;
+
+    if (NULL == File)
+    {
+        return;
+    }
+
+    status = STATUS_SUCCESS;
+    pFileObject = NULL;
+    pDirectoryInformation = NULL;
+    sizeOfStructure = 0;
+
+    status = IoCreateFile(&pFileObject,
+                          File,
+                          TRUE,
+                          FALSE,
+                          FALSE
+                          );
+    if (!SUCCEEDED(status))
+    {
+        perror("IoCreateFile failed with status: 0x%x\n", status);
+        return;
+    }
+
+    __try
+    {
+        do
+        {
+            if (0 != sizeOfStructure)
+            {
+                if (NULL != pDirectoryInformation)
+                {
+                    ExFreePoolWithTag(pDirectoryInformation, HEAP_TEMP_TAG);
+                    pDirectoryInformation = NULL;
+                }
+
+                pDirectoryInformation = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeOfStructure, HEAP_TEMP_TAG, 0);
+                if (NULL == pDirectoryInformation)
+                {
+                    __leave;
+                }
+            }
+
+            status = IoQueryDirectoryFile(pFileObject,
+                                          sizeOfStructure,
+                                          pDirectoryInformation,
+                                          &sizeOfStructure
+            );
+        } while (STATUS_BUFFER_TOO_SMALL == status);
+        if (!SUCCEEDED(status))
+        {
+            perror("IoQueryDirectoryFile failed with status: 0x%x\n", status);
+            __leave;
+        }
+
+        _Analysis_assume_(NULL != pDirectoryInformation);
+        _DisplayDirectoryInformation(File, pDirectoryInformation, Recursive, CurrentRecursionLevel);
+    }
+    __finally
+    {
+        if (NULL != pDirectoryInformation)
+        {
+            ExFreePoolWithTag(pDirectoryInformation, HEAP_TEMP_TAG);
+            pDirectoryInformation = NULL;
+        }
+
+        if (NULL != pFileObject)
+        {
+            status = IoCloseFile(pFileObject);
+            if (!SUCCEEDED(status))
+            {
+                perror("IoCloseFIle failed with status: 0x%x\n", status);
+            }
+
+            pFileObject = NULL;
+        }
+    }
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/cmd_interpreter.c b/src_proiect/HAL9000/src/cmd_interpreter.c
new file mode 100644
index 0000000..d987fe9
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_interpreter.c
@@ -0,0 +1,332 @@
+#include "HAL9000.h"
+#include "cmd_interpreter.h"
+
+#include "keyboard_utils.h"
+#include "display.h"
+#include "print.h"
+
+#include "cmd_common.h"
+#include "cmd_fs_helper.h"
+#include "cmd_thread_helper.h"
+#include "cmd_proc_helper.h"
+#include "cmd_sys_helper.h"
+#include "cmd_net_helper.h"
+#include "cmd_basic.h"
+#include "boot_module.h"
+
+#pragma warning(push)
+
+// warning C4029: declared formal parameter list different from definition
+#pragma warning(disable:4029)
+
+#define CMD_MAX_ARGS        10
+
+#define CMD_EXIT            "exit"
+
+static FUNC_GenericCommand  _CmdPrintHelp;
+
+// warning C4212: nonstandard extension used: function declaration used ellipsis
+#pragma warning(push)
+#pragma warning(disable:4212)
+
+typedef struct _COMMAND_DEFINITION
+{
+    char*                   CommandName;
+    char*                   Description;
+
+    PFUNC_GenericCommand    CommandFunction;
+
+    QWORD                   MinParameters;
+    QWORD                   MaxParameters;
+} COMMAND_DEFINITION, *PCOMMAND_DEFINITION;
+
+static const COMMAND_DEFINITION COMMANDS[] =
+{
+    { "reset", "Restarts the system", CmdResetSystem, 0, 0},
+    { "shutdown", "Shuts the system down", CmdShutdownSystem, 0, 0},
+
+    { "log", "[ON|OFF] - enables or disables logging", CmdLogSetState, 1, 1},
+    { "loglevel", "$LOG_LEVEL - decimal value from enum", CmdSetLogLevel, 1, 1},
+    { "logcomp", "$LOG_COMPONENT - hexadecimal value from enum", CmdSetLogComponents, 1, 1},
+
+    { "cls", "Clears screen", CmdClearScreen, 0, 0},
+
+    { "vol", "Displays volumes", CmdPrintVolumeInformation, 0, 0},
+    { "less", "$FILENAME [async]\n\tdisplay $FILENAME contents\n\tasync - use DMA read instead of polling", CmdReadFile, 1, 2 },
+    { "fwrite", "$FILENAME [char] [ext] [async]\n\twrite predefined buffer into $FILENAME\n\text - if 'ext' then extend file size\n\tasync - use DMA read instead of polling", CmdWriteFile, 1, 4},
+    { "stat", "$FILENAME\n\tdisplays $FILENAME information", CmdStatFile, 1, 1},
+    { "mkdir", "$DIRECTORY\n\tcreates a new directory", CmdMakeDirectory, 1, 1},
+    { "touch", "$FILENAME\n\tcreates a new file", CmdMakeFile, 1, 1},
+    { "ls", "$DIRECTORY [-R]\n\tlists directory contents\n\tif -R specified goes recursively", CmdListDirectory, 1, 2},
+
+    { "swap", "R|W [0x$OFFSET]\n\t$OFFSET - offset inside swap where to perform operation", CmdSwap, 1, 2},
+
+    { "cpu", "Displays CPU related information", CmdListCpus, 0, 0},
+    { "int", "List interrupts received", CmdListCpuInterrupts, 0, 0},
+    { "yield", "Yields processor", CmdYield, 0, 0},
+    { "timer", "$MODE [$TIME_IN_US] [$TIMES]\n\tSee EX_TIMER_TYPE for timer types\n\t$TIME_IN_US time in uS until timer fires"
+                "\n\t$TIMES - number of times to wait for timer, valid only if periodic", CmdTestTimer, 1, 3},
+
+    { "threads", "Displays all threads", CmdListThreads, 0, 0},
+    { "run", "$TEST [$NO_OF_THREADS]\n\tRuns the $TEST specified"
+             "\n\t$NO_OF_THREADS the number of threads for running the test,"
+             "if the number is not specified then it will run on 2 * NumberOfProcessors",
+             CmdRunTest, 1, 2},
+
+    { "processes", "Displays all processes", CmdListProcesses, 0, 0},
+    { "procstat", "0x$PID - displays information about a process", CmdProcessDump, 1, 1},
+    { "procstart", "$PATH_TO_EXE - starts a process", CmdStartProcess, 1, 1},
+    { "proctest", "$TEST_NAME - runs a process test", CmdTestProcess, 1, 1},
+
+    { "sysinfo", "Retrieves system information", CmdDisplaySysInfo, 0, 0},
+    { "getidle", "Retrieves idle timeout", CmdGetIdle, 0, 0},
+    { "setidle", "$PERIOD_IN_SECONDS - Sets idle timeout", CmdSetIdle, 1, 1},
+
+    { "rdmsr", "0x$INDEX\n\t$INDEX is the MSR to read", CmdRdmsr, 1, 1},
+    { "wrmsr", "0x$INDEX 0x$VALUE\n\t$INDEX is the MSR to write\n\t$VALUE is the value to place in the MSR", CmdWrmsr, 2, 2},
+    { "chkad", "Check if paging accessed/dirty bits mechanism is working", CmdCheckAd, 0, 0},
+    { "spawn", "$CPU_BOUND $IO_BOUND\n\tNumber of CPU bound threads to spawn\n\tNumber of IO bound threads to spawn", CmdSpawnThreads, 2, 2},
+    { "cpuid", "[0x$INDEX] [0x$SUBINDEX]\n\tIf index is not specified lists all available CPUID values"
+                "\n\tIf subindex is specified displays subleaf information", CmdCpuid, 0, 2},
+    { "ipi", "$MODE [$DEST] {$WAIT]\n\tSee SMP_IPI_SEND_MODE for destination mode\n\t$DEST - processor IDs"
+              "\n\tIf last parameter is specified will wait until all CPUs acknowledge IPI", CmdSendIpi, 1, 3},
+
+    { "networks", "Displays network information", CmdListNetworks, 0, 0},
+    { "netrecv", "[YES|NO] - receive network packets\n\tIf yes will resend the packets received, if no it will not", CmdNetRecv, 0, 1},
+    { "netsend", "Send network packets", CmdNetSend, 0, 0},
+    { "netstatus", "$DEV_ID $RX_EN $TX_EN - changes the state of a network device"
+                   "\n\tDevice ID\n\tIf $RX_EN is 1 => will enable receive on device\n\tIf $TX_EN is 1 => will enable send on device",
+                    CmdChangeDevStatus, 3, 3},
+
+    { "tests", "Runs functional tests", CmdRunAllFunctionalTests, 0, 0},
+    { "perf", "Runs performance tests", CmdRunAllPerformanceTests, 0, 0},
+
+    { "recursion", "Generates an infinite recursion", CmdInfiniteRecursion, 0, 0},
+    { "rtcfail", "Causes an RTC check stack to assert", CmdRtcFail, 0, 0},
+    { "rangefail", "Causes a range check failure to assert", CmdRangeFail, 0, 0},
+    { "bitecookie", "Causes a GS cookie corruption to assert", CmdBiteCookie, 0, 0},
+
+    { "help", "Displays this help menu", _CmdPrintHelp, 0, 0}
+};
+
+#define NO_OF_COMMANDS      ARRAYSIZE(COMMANDS)
+
+
+static
+BOOLEAN
+_CmdExecLine(
+    _Inout_updates_z_(Length)
+                    char*   CommandLine,
+    IN              DWORD   Length
+    );
+
+static
+BOOLEAN
+_CmdExecuteModuleCommands(
+    void
+    );
+
+// SAL simply doesn't want to let me tell him that each pointer in argv is NULL terminated
+// _At_buffer_(argv, i, argc,
+//             _Pre_satisfies_(argv[i] _Null_terminated_))
+BOOLEAN
+ExecCmd(
+    IN      DWORD       argc,
+    IN_READS(CMD_MAX_ARGS)
+            char**      argv
+    )
+{
+    char* pCommand;
+    BOOLEAN bFoundCommand;
+    DWORD noOfParameters;
+
+    ASSERT(1 <= argc && argc <= CMD_MAX_ARGS);
+    ASSERT(NULL != argv);
+
+    pCommand = (char*) argv[0];
+    bFoundCommand = FALSE;
+    noOfParameters = argc - 1;
+
+    ASSERT(NULL != pCommand);
+
+    // check for exit command
+    if (0 == stricmp(pCommand, CMD_EXIT))
+    {
+        return TRUE;
+    }
+
+    for (DWORD i = 0; i < NO_OF_COMMANDS; ++i)
+    {
+        if (stricmp(pCommand, COMMANDS[i].CommandName) == 0)
+        {
+            bFoundCommand = TRUE;
+
+            if (COMMANDS[i].MinParameters <= noOfParameters && noOfParameters <= COMMANDS[i].MaxParameters)
+            {
+                COMMANDS[i].CommandFunction(noOfParameters,
+                                            argv[1],
+                                            argv[2],
+                                            argv[3],
+                                            argv[4],
+                                            argv[5],
+                                            argv[6],
+                                            argv[7],
+                                            argv[8],
+                                            argv[CMD_MAX_ARGS - 1]);
+
+                break;
+            }
+            else
+            {
+                LOG_ERROR("Tried to call command [%s] which requires between %u and %u parameters with %u parameters!\n",
+                          COMMANDS[i].CommandName, COMMANDS[i].MinParameters, COMMANDS[i].MaxParameters, noOfParameters);
+                LOG("%s\n", COMMANDS[i].Description);
+            }
+        }
+    }
+
+    if (!bFoundCommand)
+    {
+        _CmdPrintHelp(0);
+    }
+
+    return FALSE;
+}
+
+void
+CmdRun(
+    void
+    )
+{
+    BOOLEAN exit;
+    char buffer[CHARS_PER_LINE];
+    DWORD bytesRead;
+
+    bytesRead = 0;
+
+    exit = _CmdExecuteModuleCommands();
+    while (!exit)
+    {
+        gets_s(buffer, CHARS_PER_LINE, &bytesRead);
+
+        exit = _CmdExecLine(buffer, bytesRead);
+    }
+
+    return;
+}
+
+static
+BOOLEAN
+_CmdExecLine(
+    _Inout_updates_z_(Length)
+                    char*   CommandLine,
+    IN              DWORD   Length
+    )
+{
+    BOOLEAN bExit;
+    char* pCmdArgs[CMD_MAX_ARGS];
+
+    bExit = FALSE;
+
+    if (CommandLine[0] == '/')
+    {
+        char* context;
+        char* pCurArg;
+        DWORD argIndex;
+
+        memzero(pCmdArgs, sizeof(char*) * CMD_MAX_ARGS);
+        context = NULL;
+        pCurArg = NULL;
+        argIndex = 0;
+
+        if (Length <= 1)
+        {
+            pwarn("A command must succeed the '/' character\n");
+            return FALSE;
+        }
+
+        // warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+        while (TRUE)
+        {
+            pCurArg = (char*)strtok_s(&CommandLine[1], " ", &context);
+            if (pCurArg == NULL)
+            {
+                break;
+            }
+
+            ASSERT(argIndex < CMD_MAX_ARGS);
+
+            pCmdArgs[argIndex] = pCurArg;
+            argIndex = argIndex + 1;
+        }
+
+        // we have a command
+        bExit = ExecCmd(argIndex, pCmdArgs);
+    }
+    else
+    {
+        // just plain old text
+        printf("%s\n", CommandLine);
+    }
+
+    return bExit;
+}
+
+static
+void
+(__cdecl _CmdPrintHelp)(
+    IN      QWORD           NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    LOG("All commands are prefixed with the '/' character and are case insensitive\n");
+    LOG("Available commands:\n");
+    LOG("exit - stops the OS\n");
+    for (DWORD i = 0; i < NO_OF_COMMANDS; ++i)
+    {
+        LOG("%s - %s\n", COMMANDS[i].CommandName, COMMANDS[i].Description);
+    }
+}
+
+static
+BOOLEAN
+_CmdExecuteModuleCommands(
+    void
+    )
+{
+    STATUS status;
+    char* pBaseAddress;
+    QWORD modLen;
+    char* pCurrentLine;
+    char* context;
+    BOOLEAN bExit;
+
+    context = NULL;
+    bExit = FALSE;
+
+    status = BootModuleGet("Tests", &pBaseAddress, &modLen);
+    if (!SUCCEEDED(status))
+    {
+        LOG_WARNING("BootModuleGet failed with status 0x%x for Tests module\n", status);
+        return FALSE;
+    }
+
+    do
+    {
+        pCurrentLine = (char*)strtok_s(pBaseAddress, "\n\r", &context);
+
+        if (pCurrentLine != NULL && strlen(pCurrentLine) != 0)
+        {
+            LOG("Current line is [%s] of length 0x%x\n", pCurrentLine,
+                strlen(pCurrentLine));
+            bExit = _CmdExecLine(pCurrentLine, strlen(pCurrentLine));
+        }
+
+    } while (pCurrentLine != NULL && !bExit);
+
+    return bExit;
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/cmd_net_helper.c b/src_proiect/HAL9000/src/cmd_net_helper.c
new file mode 100644
index 0000000..2ab1c0a
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_net_helper.c
@@ -0,0 +1,155 @@
+#include "HAL9000.h"
+#include "network.h"
+#include "cmd_net_helper.h"
+#include "print.h"
+#include "dmp_net_device.h"
+#include "test_net_stack.h"
+#include "strutils.h"
+
+#pragma warning(push)
+
+// warning C4212: nonstandard extension used: function declaration used ellipsis
+#pragma warning(disable:4212)
+
+// warning C4029: declared formal parameter list different from definition
+#pragma warning(disable:4029)
+
+void
+CmdListNetworks(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    PNETWORK_DEVICE_INFO pNetDevices;
+    DWORD noOfDevices;
+    STATUS status;
+    DWORD temp;
+
+    ASSERT(NumberOfParameters == 0);
+
+    pNetDevices = NULL;
+    noOfDevices = 0;
+    status = STATUS_SUCCESS;
+
+    status = NetGetNetworkDevices(NULL, &noOfDevices);
+    if (!SUCCEEDED(status))
+    {
+        perror("NetGetNetworkDevices failed with status: 0x%x\n", status);
+        return;
+    }
+
+    if( 0 == noOfDevices )
+    {
+        pwarn("There are no network devices\n");
+        return;
+    }
+
+    __try
+    {
+        pNetDevices = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(NETWORK_DEVICE_INFO) * noOfDevices, HEAP_TEMP_TAG, 0);
+        if (NULL == pNetDevices)
+        {
+            perror("ExAllocatePoolWithTag failed for size: 0x%x\n", sizeof(NETWORK_DEVICE_INFO) * noOfDevices);
+            __leave;
+        }
+
+        temp = noOfDevices;
+
+        status = NetGetNetworkDevices(pNetDevices, &temp);
+        if (!SUCCEEDED(status))
+        {
+            perror("NetGetNetworkDevices failed with status: 0x%x\n", status);
+            __leave;
+        }
+        ASSERT(temp == noOfDevices);
+
+        for (DWORD i = 0; i < noOfDevices; ++i)
+        {
+            DumpNetworkDevice(&pNetDevices[i]);
+            LOG("\n");
+        }
+    }
+    __finally
+    {
+        if (NULL != pNetDevices)
+        {
+            ExFreePoolWithTag(pNetDevices, HEAP_TEMP_TAG);
+            pNetDevices = NULL;
+        }
+    }
+}
+
+void
+CmdNetRecv(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       ResendString
+    )
+{
+    BOOLEAN bResend;
+
+    ASSERT(0 <= NumberOfParameters && NumberOfParameters <= 1);
+
+    if (1 == NumberOfParameters)
+    {
+        bResend = (0 == stricmp(ResendString, "YES"));
+    }
+    else
+    {
+        bResend = FALSE;
+    }
+
+    TestNetwork(FALSE, bResend );
+}
+
+void
+CmdNetSend(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    TestNetwork(TRUE, FALSE);
+}
+
+void
+CmdChangeDevStatus(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       DeviceString,
+    IN_Z    char*       RxEnableString,
+    IN_Z    char*       TxEnableString
+    )
+{
+    STATUS status;
+    NETWORK_DEVICE_STATUS devStatus;
+    DEVICE_ID devId;
+    DWORD tmp;
+    BOOLEAN rxEnable;
+    BOOLEAN txEnable;
+
+    ASSERT(NumberOfParameters == 3);
+
+    atoi32(&devId, DeviceString, BASE_HEXA);
+
+    atoi32(&tmp, RxEnableString, BASE_TEN);
+    rxEnable = (BOOLEAN)tmp;
+
+    atoi32(&tmp, TxEnableString, BASE_TEN);
+    txEnable = (BOOLEAN)tmp;
+
+    printf("Device ID: 0x%x, enable RX: %u, enable TX: %u\n",
+           devId, rxEnable, txEnable);
+
+    status = STATUS_SUCCESS;
+    memzero(&devStatus, sizeof(NETWORK_DEVICE_STATUS));
+
+    devStatus.RxEnabled = rxEnable;
+    devStatus.TxEnabled = txEnable;
+
+    status = NetChangeDeviceStatus(devId, &devStatus);
+    if (!SUCCEEDED(status))
+    {
+        perror("NetChangeDeviceStatus failed with status: 0x%x\n", status);
+        return;
+    }
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/cmd_proc_helper.c b/src_proiect/HAL9000/src/cmd_proc_helper.c
new file mode 100644
index 0000000..c6e824a
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_proc_helper.c
@@ -0,0 +1,184 @@
+#include "HAL9000.h"
+#include "cmd_proc_helper.h"
+#include "thread_internal.h"
+#include "process_internal.h"
+#include "print.h"
+#include "display.h"
+#include "dmp_process.h"
+#include "strutils.h"
+#include "test_process.h"
+
+typedef struct _PROC_STAT_CTX
+{
+    PID             ProcessPid;
+    BOOLEAN         FoundProcess;
+} PROC_STAT_CTX, *PPROC_STAT_CTX;
+
+#pragma warning(push)
+
+// warning C4212: nonstandard extension used: function declaration used ellipsis
+#pragma warning(disable:4212)
+
+// warning C4029: declared formal parameter list different from definition
+#pragma warning(disable:4029)
+
+__forceinline
+static
+void
+_CmdHelperPrintProcessFunctions(
+    void
+    )
+{
+    DWORD i;
+
+    for (i = 0; i < PROCESS_TOTAL_NO_OF_TESTS; ++i)
+    {
+        printf("%2u. %s\n", i, PROCESS_TESTS[i].TestName);
+    }
+}
+
+static FUNC_ListFunction _CmdProcessPrint;
+
+void
+(__cdecl CmdListProcesses)(
+    IN      QWORD       NumberOfParameters
+    )
+{
+    STATUS status;
+
+    ASSERT(NumberOfParameters == 0);
+
+    printColor(MAGENTA_COLOR, "%10s", "PID|");
+    printColor(MAGENTA_COLOR, "%10s", "Arg count|");
+    printColor(MAGENTA_COLOR, "%39s", "Command line|");
+    printColor(MAGENTA_COLOR, "%9s", "Threads|");
+    printColor(MAGENTA_COLOR, "%12s", "References|");
+
+    status = ProcessExecuteForEachProcessEntry(_CmdProcessPrint, NULL);
+    ASSERT(SUCCEEDED(status));
+}
+
+void
+(__cdecl CmdProcessDump)(
+    IN      QWORD       NumberOfParameters,
+    IN      char*       PidString
+    )
+{
+    PROC_STAT_CTX statCtx = { 0 };
+    STATUS status;
+    PID pid;
+
+    ASSERT(NumberOfParameters == 1);
+    atoi64(&pid, PidString, BASE_HEXA);
+
+    statCtx.ProcessPid = pid;
+
+    status = ProcessExecuteForEachProcessEntry(_CmdProcessPrint, &statCtx);
+    ASSERT(SUCCEEDED(status));
+
+    if (!statCtx.FoundProcess)
+    {
+        pwarn("Process with PID 0x%X does not exist!\n", statCtx.ProcessPid);
+    }
+}
+
+void
+(__cdecl CmdStartProcess)(
+    IN          QWORD   NumberOfParameters,
+    IN_Z        char*   ProcessPath
+    )
+{
+    STATUS status;
+    PPROCESS pProcess;
+
+    ASSERT(NumberOfParameters == 1);
+
+    status = ProcessCreate(ProcessPath,
+                           NULL,
+                           &pProcess);
+    if (!SUCCEEDED(status))
+    {
+        perror("ProcessCreate failed with status 0x%x\n", status);
+        return;
+    }
+
+    printf("Successfully created process [%s] with PID 0x%X\n", ProcessPath, pProcess->Id);
+
+    ProcessCloseHandle(pProcess);
+}
+
+static
+STATUS
+(__cdecl _CmdProcessPrint) (
+    IN      PLIST_ENTRY     ListEntry,
+    IN_OPT  PVOID           FunctionContext
+    )
+{
+    PPROCESS pProcess;
+
+    ASSERT(NULL != ListEntry);
+
+    pProcess = CONTAINING_RECORD(ListEntry, PROCESS, NextProcess);
+
+    if (FunctionContext == NULL)
+    {
+        DWORD cmdLineLength = strlen(pProcess->FullCommandLine);
+        ASSERT(cmdLineLength != INVALID_STRING_SIZE);
+
+        printf("%9x%c", pProcess->Id, '|');
+        printf("%9u%c", pProcess->NumberOfArguments, '|');
+        printf(cmdLineLength > 38 ? "%35S...%c" : "%38S%c", pProcess->FullCommandLine, '|');
+        printf("%8U%c", pProcess->NumberOfThreads, '|');
+        printf("%11U%c", pProcess->RefCnt.ReferenceCount, '|');
+    }
+    else
+    {
+        PPROC_STAT_CTX pCtx = (PPROC_STAT_CTX) FunctionContext;
+
+        if (pCtx->ProcessPid == pProcess->Id)
+        {
+            pCtx->FoundProcess = TRUE;
+
+            DumpProcess(pProcess);
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
+
+#include "test_common.h"
+
+void
+(__cdecl CmdTestProcess)(
+    IN          QWORD       NumberOfParameters,
+    IN_Z        char*       TestName
+    )
+{
+    BOOLEAN bFoundTest;
+
+    ASSERT(NumberOfParameters == 1);
+
+    bFoundTest = FALSE;
+
+    for (DWORD i = 0; i < PROCESS_TOTAL_NO_OF_TESTS; ++i)
+    {
+        if (0 == stricmp(PROCESS_TESTS[i].TestName, TestName))
+        {
+            TestProcessFunctionality(&PROCESS_TESTS[i]);
+            bFoundTest = TRUE;
+            break;
+        }
+    }
+
+    if (!bFoundTest)
+    {
+        LOG_WARNING("Test [%s] does not exist. Try one of the following tests:\n", TestName);
+        _CmdHelperPrintProcessFunctions();
+    }
+    else
+    {
+        printf("Finished running test [%s]\n", TestName);
+    }
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/cmd_sys_helper.c b/src_proiect/HAL9000/src/cmd_sys_helper.c
new file mode 100644
index 0000000..ed8f828
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_sys_helper.c
@@ -0,0 +1,97 @@
+#include "HAL9000.h"
+#include "cmd_sys_helper.h"
+#include "ex.h"
+#include "print.h"
+#include "core.h"
+#include "strutils.h"
+#include "keyboard.h"
+#include "acpi_interface.h"
+
+#pragma warning(push)
+
+// warning C4212: nonstandard extension used: function declaration used ellipsis
+#pragma warning(disable:4212)
+
+// warning C4029: declared formal parameter list different from definition
+#pragma warning(disable:4029)
+
+void
+(__cdecl CmdDisplaySysInfo)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    SYSTEM_INFORMATION sysInfo;
+    QWORD sizeInKB;
+    QWORD frequencyMhz;
+    QWORD uptimeInMs;
+
+    ASSERT(NumberOfParameters == 0);
+
+    ExGetSystemInformation(&sysInfo);
+
+    sizeInKB = sysInfo.TotalPhysicalMemory / KB_SIZE;
+    frequencyMhz = sysInfo.CpuFrequency / SEC_IN_US;
+    uptimeInMs = sysInfo.SystemUptimeUs / MS_IN_US;
+
+    printf("System memory: %U KB (%U MB)\n", sizeInKB, sizeInKB / KB_SIZE );
+    printf("Highest physical memory: 0x%X\n", sysInfo.HighestPhysicalAddress );
+    printf("CPU frequency: %u.%02u GHz\n", frequencyMhz / 1000, frequencyMhz % 1000 );
+    printf("Uptime: %u.%03u sec\n", uptimeInMs / 1000, uptimeInMs % 1000 );
+}
+
+void
+(__cdecl CmdSetIdle)(
+    IN          QWORD       NumberOfParameters,
+    IN_Z        char*       SecondsString
+    )
+{
+    DWORD noOfSeconds;
+
+    ASSERT(NumberOfParameters == 1);
+
+    atoi32(&noOfSeconds, SecondsString, BASE_TEN);
+
+    if (0 == noOfSeconds)
+    {
+        pwarn("Idle period must differ from 0\n");
+        return;
+    }
+
+    printf("Setting idle period to %u seconds\n", noOfSeconds);
+    CoreSetIdlePeriod(noOfSeconds);
+}
+
+void
+(__cdecl CmdGetIdle)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    DWORD idlePeriod;
+
+    ASSERT(NumberOfParameters == 0);
+
+    idlePeriod = CoreSetIdlePeriod(0);
+    printf("Idle period: %u seconds\n", idlePeriod );
+}
+
+void
+(__cdecl CmdResetSystem)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    KeyboardResetSystem();
+}
+
+void
+(__cdecl CmdShutdownSystem)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    AcpiShutdown();
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/cmd_thread_helper.c b/src_proiect/HAL9000/src/cmd_thread_helper.c
new file mode 100644
index 0000000..56e69af
--- /dev/null
+++ b/src_proiect/HAL9000/src/cmd_thread_helper.c
@@ -0,0 +1,777 @@
+#include "HAL9000.h"
+#include "cmd_thread_helper.h"
+#include "thread_internal.h"
+#include "process_internal.h"
+#include "print.h"
+#include "smp.h"
+#include "list.h"
+#include "cpumu.h"
+#include "display.h"
+#include "test_thread.h"
+#include "isr.h"
+#include "iomu.h"
+#include "dmp_cpu.h"
+#include "strutils.h"
+#include "smp.h"
+#include "ex_timer.h"
+#include "vmm.h"
+#include "pit.h"
+
+
+#pragma warning(push)
+
+// warning C4212: nonstandard extension used: function declaration used ellipsis
+#pragma warning(disable:4212)
+
+// warning C4029: declared formal parameter list different from definition
+#pragma warning(disable:4029)
+
+static FUNC_IpcProcessEvent _CmdIpiCmd;
+
+#define CPU_BOUND_CPU_USAGE         (100 * MS_IN_US)
+#define IO_BOUND_CPU_USAGE          (0 * MS_IN_US)
+#define IO_BOUND_EVENT_TIMES        25
+
+typedef struct _BOUND_THREAD_CTX
+{
+    DWORD                   CpuUsage;
+
+    // Valid only for IO bound threads
+    DWORD                   EventWaitTimes;
+    EX_EVENT                Event;
+} BOUND_THREAD_CTX, *PBOUND_THREAD_CTX;
+
+static FUNC_ThreadStart     _ThreadCpuBound;
+static FUNC_ThreadStart     _ThreadIoBound;
+
+static
+void
+_CmdHelperPrintThreadFunctions(
+    void
+    );
+
+__forceinline
+static
+const char*
+_CmdThreadStateToName(
+    IN      THREAD_STATE        State
+    )
+{
+    static const char __stateNames[ThreadStateReserved][10] = { "Running", "Ready", "Blocked", "Dying" };
+
+    ASSERT( State < ThreadStateReserved);
+
+    return __stateNames[State];
+}
+
+static
+void
+_CmdReadAndDumpCpuid(
+    IN      DWORD               Index,
+    IN      DWORD               SubIndex
+    );
+
+static FUNC_ListFunction _CmdThreadPrint;
+
+void
+(__cdecl CmdListCpus)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    PLIST_ENTRY pCpuListHead;
+    PLIST_ENTRY pCurEntry;
+
+    ASSERT(NumberOfParameters == 0);
+
+    pCpuListHead = NULL;
+
+    SmpGetCpuList(&pCpuListHead);
+
+    printf("\n");
+
+    printColor(MAGENTA_COLOR, "%8s", "Apic ID|");
+    printColor(MAGENTA_COLOR, "%4s", "BSP|");
+    printColor(MAGENTA_COLOR, "%13s", "Idle|");
+    printColor(MAGENTA_COLOR, "%13s", "Kernel|");
+    printColor(MAGENTA_COLOR, "%13s", "Total|");
+    printColor(MAGENTA_COLOR, "%7s", "%|");
+    printColor(MAGENTA_COLOR, "%7s", "#PF|");
+    printColor(MAGENTA_COLOR, "%15s", "Current Thread|");
+
+    for(pCurEntry = pCpuListHead->Flink;
+        pCurEntry != pCpuListHead;
+        pCurEntry = pCurEntry->Flink)
+    {
+        PPCPU pCpu = CONTAINING_RECORD( pCurEntry, PCPU, ListEntry);
+        QWORD totalTicks = pCpu->ThreadData.IdleTicks + pCpu->ThreadData.KernelTicks;
+
+        // we can't do division by 0 => we only divide by totalTicks if the tick count is different
+        // from 0
+        QWORD percentage = 0 != totalTicks ? ( pCpu->ThreadData.IdleTicks * 10000 ) / totalTicks : 0;
+
+        printf("%7x%c", pCpu->ApicId, '|' );
+        printf("%3s%c", pCpu->BspProcessor ? "YES" : "NO", '|');
+        printf("%12U%c", pCpu->ThreadData.IdleTicks, '|');
+        printf("%12U%c", pCpu->ThreadData.KernelTicks, '|');
+        printf("%12U%c", totalTicks, '|');
+        printf("%3d.%02d%c", percentage / 100, percentage % 100, '|');
+        printf("%6U%c", pCpu->PageFaults, '|' );
+        printf("%14s%c", pCpu->ThreadData.CurrentThread->Name, '|');
+    }
+}
+
+void
+(__cdecl CmdListThreads)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    STATUS status;
+
+    ASSERT(NumberOfParameters == 0);
+
+    LOG("%7s", "TID|");
+    LOG("%20s", "Name|");
+    LOG("%5s", "Prio|");
+    LOG("%8s", "State|");
+    LOG("%10s", "Cmp ticks|");
+    LOG("%10s", "Prt ticks|");
+    LOG("%10s", "Ttl ticks|");
+    LOG("%10s", "Process|");
+    LOG("\n");
+
+    status = ThreadExecuteForEachThreadEntry(_CmdThreadPrint, NULL );
+    ASSERT( SUCCEEDED(status));
+}
+
+void
+(__cdecl CmdYield)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    ASSERT(NumberOfParameters == 0);
+
+    printf("Will yield CPU\n");
+
+    ThreadYield();
+}
+
+void
+(__cdecl CmdRunTest)(
+    IN          QWORD       NumberOfParameters,
+    IN_Z        char*       TestName,
+    IN_Z        char*       NumberOfThreadsString
+    )
+{
+    BOOLEAN bFoundTest;
+    DWORD noOfThreads;
+
+    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 2);
+    bFoundTest = FALSE;
+
+    if (NumberOfParameters >= 2)
+    {
+        atoi32(&noOfThreads, NumberOfThreadsString, BASE_TEN);
+    }
+    else
+    {
+        noOfThreads = SmpGetNumberOfActiveCpus() * 2;
+    }
+
+    for (DWORD i = 0; i < THREADS_TOTAL_NO_OF_TESTS; ++i)
+    {
+        if (0 == stricmp(THREADS_TEST[i].TestName, TestName))
+        {
+            printf("Will run test [%s] on %d threads\n", TestName, noOfThreads);
+            TestThreadFunctionality(&THREADS_TEST[i], NULL, noOfThreads);
+            bFoundTest = TRUE;
+            break;
+        }
+    }
+
+    if (!bFoundTest)
+    {
+        pwarn("Test [%s] does not exist. Try one of the following tests:\n", TestName);
+        _CmdHelperPrintThreadFunctions();
+    }
+    else
+    {
+        printf("Finished running test [%s]\n", TestName);
+    }
+}
+
+void
+(__cdecl CmdSendIpi)(
+    IN          QWORD               NumberOfParameters,
+    IN_Z        char*               SendModeString,
+    IN_Z        char*               DestinationString,
+    IN_Z        char*               WaitForTerminationString
+    )
+{
+    STATUS status;
+    SMP_IPI_SEND_MODE sendMode;
+    SMP_DESTINATION destination;
+    BOOLEAN bWaitForAll;
+
+    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 3);
+
+    UNREFERENCED_PARAMETER(WaitForTerminationString);
+
+    atoi32(&sendMode, SendModeString, BASE_TEN);
+    memzero(&destination, sizeof(SMP_DESTINATION));
+    bWaitForAll = FALSE;
+
+    if (NumberOfParameters >= 2)
+    {
+        DWORD temp;
+
+        atoi32(&temp, DestinationString, BASE_HEXA);
+        if (temp > MAX_BYTE)
+        {
+            perror("Destination must be between 0 and FF\n");
+            return;
+        }
+
+        destination.Group.Affinity = (CPU_AFFINITY)temp;
+        bWaitForAll = (NumberOfParameters == 3);
+    }
+
+    status = SmpSendGenericIpiEx(_CmdIpiCmd, NULL, NULL, NULL, bWaitForAll, sendMode, destination);
+    if (!SUCCEEDED(status))
+    {
+        perror("SmpSendGenericIpiEx failed with status 0x%x\n", status);
+    }
+    else
+    {
+        printf("SmpSendGenericIpiEx finished successfully!\n");
+    }
+}
+
+void
+(__cdecl CmdListCpuInterrupts)(
+    IN          QWORD       NumberOfParameters
+    )
+{
+    PLIST_ENTRY pCpuListHead;
+    PLIST_ENTRY pCurEntry;
+
+    /// 2K on stack
+    QWORD grandTotal[NO_OF_TOTAL_INTERRUPTS] = { 0 };
+    QWORD total = 0;
+
+    ASSERT(NumberOfParameters == 0);
+
+    pCpuListHead = NULL;
+
+    SmpGetCpuList(&pCpuListHead);
+
+    for (pCurEntry = pCpuListHead->Flink;
+         pCurEntry != pCpuListHead;
+         pCurEntry = pCurEntry->Flink)
+    {
+        PPCPU pCpu = CONTAINING_RECORD(pCurEntry, PCPU, ListEntry);
+
+        LOG("Interrupts on CPU 0x%02x\n", pCpu->ApicId );
+        for (DWORD i = 0; i < NO_OF_TOTAL_INTERRUPTS; ++i)
+        {
+            if (0 != pCpu->InterruptsTriggered[i])
+            {
+                LOG("%12u [0x%02x]\n", pCpu->InterruptsTriggered[i], i, pCpu->ApicId );
+                grandTotal[i] = grandTotal[i] + pCpu->InterruptsTriggered[i];
+                total = total + pCpu->InterruptsTriggered[i];
+            }
+        }
+
+        LOG("\n");
+    }
+
+    LOG("Total interrupts:\n");
+    for (DWORD i = 0; i < NO_OF_TOTAL_INTERRUPTS; ++i)
+    {
+        if (0 != grandTotal[i])
+        {
+            LOG("%12u [0x%02x]\n", grandTotal[i], i);
+        }
+    }
+    LOG("%12u [TOTAL]\n", total );
+}
+
+void
+(__cdecl CmdTestTimer)(
+    IN          QWORD               NumberOfParameters,
+    IN_Z        char*               TimerTypeString,
+    IN_Z        char*               RelativeTimeString,
+    IN_Z        char*               NumberOfTimesString
+    )
+{
+    STATUS status;
+    EX_TIMER timer;
+    QWORD timeToWaitUs;
+    DWORD i;
+    DWORD noOfTimesToWait;
+    DATETIME systemTimeBeginning;
+    DATETIME systemTimeEnd;
+    char tmpBuffer[MAX_PATH];
+    EX_TIMER_TYPE timerMode;
+    QWORD relativeTimeUs;
+    DWORD noOfTimesToExecute;
+
+    ASSERT(1 <= NumberOfParameters && NumberOfParameters <= 3);
+
+    atoi32(&timerMode, TimerTypeString, BASE_TEN);
+    relativeTimeUs = 10 * SEC_IN_US;
+    noOfTimesToExecute = 1;
+
+    if (NumberOfParameters >= 2)
+    {
+        atoi64(&relativeTimeUs, RelativeTimeString, BASE_TEN);
+
+        if (NumberOfParameters >= 3)
+        {
+            atoi32(&noOfTimesToExecute, NumberOfTimesString, BASE_TEN);
+        }
+    }
+
+    status = STATUS_SUCCESS;
+
+    printf("Will start a timer of type %u, relative time %U for %u times\n",
+           timerMode, relativeTimeUs, noOfTimesToExecute);
+
+    timeToWaitUs = (timerMode == ExTimerTypeAbsolute) ? IomuGetSystemTimeUs() + relativeTimeUs : relativeTimeUs;
+    noOfTimesToWait = (timerMode == ExTimerTypeRelativePeriodic) ? noOfTimesToExecute : 1;
+
+    status = ExTimerInit(&timer,
+                         timerMode,
+                         timeToWaitUs
+                         );
+    if (!SUCCEEDED(status))
+    {
+        perror("ExTimerInit failed with status 0x%x\n", status);
+        return;
+    }
+
+    systemTimeBeginning = IoGetCurrentDateTime();
+
+    ExTimerStart(&timer);
+
+    for (i = 0; i < noOfTimesToExecute; ++i)
+    {
+        ExTimerWait(&timer);
+        printf("Tick at %U us\n", IomuGetSystemTimeUs());
+    }
+
+    systemTimeEnd = IoGetCurrentDateTime();
+
+    ExTimerUninit(&timer);
+    printf("Timer finished\n");
+
+    TimeGetStringFormattedBuffer(systemTimeBeginning, tmpBuffer, MAX_PATH);
+    printf("Timer started at [%s]\n", tmpBuffer);
+    TimeGetStringFormattedBuffer(systemTimeEnd, tmpBuffer, MAX_PATH);
+    printf("Timer ended at [%s]\n", tmpBuffer);
+}
+
+void
+(__cdecl CmdCpuid)(
+    IN          QWORD               NumberOfParameters,
+    IN_Z        char*               IndexString,
+    IN_Z        char*               SubIndexString
+    )
+{
+    ASSERT(0 <= NumberOfParameters && NumberOfParameters <= 2);
+
+    if ( NumberOfParameters >= 1 )
+    {
+        DWORD index;
+        DWORD subIdx;
+
+        atoi32(&index, IndexString, BASE_HEXA);
+        if (NumberOfParameters >= 2)
+        {
+            atoi32(&subIdx, SubIndexString, BASE_HEXA);
+        }
+        else
+        {
+            subIdx = 0;
+        }
+
+        _CmdReadAndDumpCpuid(index, subIdx);
+    }
+    else
+    {
+        CPUID_INFO cpuId;
+
+        __cpuid(cpuId.values, CpuidIdxBasicInformation);
+
+        for( DWORD i = 0; i <= cpuId.BasicInformation.MaxValueForBasicInfo; ++i )
+        {
+            _CmdReadAndDumpCpuid(i, 0);
+        }
+
+        __cpuid( cpuId.values, CpuidIdxFeatureInformation );
+
+        if (cpuId.FeatureInformation.ecx.HV)
+        {
+            for (DWORD i = 0x4000'0000; i <= 0x4000'0020; ++i)
+            {
+                _CmdReadAndDumpCpuid(i, 0);
+            }
+        }
+
+        __cpuid(cpuId.values, CpuidIdxExtendedMaxFunction);
+
+        for( DWORD i = 0x8000'0000; i <= cpuId.ExtendedInformation.MaxValueForExtendedInfo; ++i )
+        {
+            _CmdReadAndDumpCpuid(i, 0);
+        }
+    }
+}
+
+void
+(__cdecl CmdRdmsr)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       IndexString
+    )
+{
+    DWORD index;
+
+    ASSERT(NumberOfParameters == 1);
+
+    atoi32(&index, IndexString, BASE_HEXA);
+
+    QWORD value = __readmsr(index);
+
+    LOG("RDMSR[%x] = 0x%X\n", index, value );
+}
+
+void
+(__cdecl CmdWrmsr)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       IndexString,
+    IN_Z    char*       ValueString
+    )
+{
+    DWORD index;
+    QWORD value;
+
+    ASSERT(NumberOfParameters == 2);
+
+    atoi32(&index, IndexString, BASE_HEXA);
+    atoi64(&value, ValueString, BASE_HEXA);
+
+    LOG("WRMSR[%x] = 0x%X\n", index, value);
+
+    __writemsr(index, value );
+}
+
+void
+(__cdecl CmdCheckAd)(
+    IN      QWORD       NumberOfParameters
+    )
+{
+    DWORD dirtyCount;
+    DWORD accessedCount;
+    volatile BYTE* pData;
+    PML4 cr3;
+
+    ASSERT(NumberOfParameters == 0);
+
+    dirtyCount = 0;
+    accessedCount = 0;
+    pData = NULL;
+    cr3.Raw = (QWORD) __readcr3();
+
+    pData = ExAllocatePoolWithTag(PoolAllocateZeroMemory, PAGE_SIZE, HEAP_TEMP_TAG, PAGE_SIZE);
+    if (pData == NULL)
+    {
+        return;
+    }
+
+    __try
+    {
+        for (DWORD i = 0; i < PAGE_SIZE; ++i)
+        {
+            BOOLEAN bAccessed = FALSE;
+            BOOLEAN bDirty = FALSE;
+
+            PHYSICAL_ADDRESS pAddr = VmmGetPhysicalAddressEx(cr3,
+                                                             (PVOID) pData,
+                                                             &bAccessed,
+                                                             &bDirty);
+            ASSERT(pAddr != NULL);
+
+            accessedCount += (bAccessed == TRUE);
+            dirtyCount += (bDirty == TRUE);
+
+        }
+    }
+    __finally
+    {
+        ASSERT(pData != NULL);
+            ExFreePoolWithTag((PVOID)pData, HEAP_TEMP_TAG);
+            pData = NULL;
+        }
+
+    LOG("A/D: %u/%u\n", accessedCount, dirtyCount);
+}
+
+void
+(__cdecl CmdSpawnThreads)(
+    IN      QWORD       NumberOfParameters,
+    IN_Z    char*       CpuBoundString,
+    IN_Z    char*       IoBoundString
+    )
+{
+    DWORD cpuBound;
+    DWORD ioBound;
+    PTHREAD* pThreads;
+    PBOUND_THREAD_CTX pCtx;
+    STATUS status;
+
+    ASSERT(NumberOfParameters == 2);
+
+    atoi32(&cpuBound, CpuBoundString, BASE_TEN);
+    atoi32(&ioBound, IoBoundString, BASE_TEN);
+
+    pThreads = NULL;
+    pCtx = NULL;
+
+    LOG("Will spawn %u CPU bound threads and %u IO bound threads\n",
+        cpuBound, ioBound);
+
+    if (cpuBound == 0 || ioBound == 0)
+    {
+        return;
+    }
+
+    __try
+    {
+        pThreads = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                         sizeof(PTHREAD) * (cpuBound + ioBound),
+                                         HEAP_TEST_TAG,
+                                         0);
+        if (pThreads == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PTHREAD) * (cpuBound + ioBound));
+            __leave;
+        }
+
+        pCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                     sizeof(BOUND_THREAD_CTX) * (cpuBound + ioBound),
+                                     HEAP_TEST_TAG,
+                                     0);
+        if (pCtx == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(BOUND_THREAD_CTX) * (cpuBound + ioBound));
+            __leave;
+        }
+
+        // Create the CPU bound threads to execute the _ThreadCpuBound function
+        // Each thread will keep the processor busy for CPU_BOUND_CPU_USAGE us (currently 100 ms)
+        for (DWORD i = 0; i < cpuBound; ++i)
+        {
+            char thName[MAX_PATH];
+
+            snprintf(thName, MAX_PATH, "CPU-bound-%u", i);
+
+            pCtx[i].CpuUsage = CPU_BOUND_CPU_USAGE;
+
+            status = ThreadCreate(thName,
+                                  ThreadPriorityDefault,
+                                  _ThreadCpuBound,
+                                  &pCtx[i],
+                                  &pThreads[i]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("ThreadCreate", status);
+                __leave;
+            }
+        }
+
+        // Create the IO bound threads to execute the _ThreadIoBound function
+        // These threads will block waiting for an executive event IO_BOUND_EVENT_TIMES times (currently 25 seconds)
+        // After they will be woken up they will also keep the CPU busy for IO_BOUND_CPU_USAGE us (currently 0 ms)
+        for (DWORD i = 0; i < ioBound; ++i)
+        {
+            char thName[MAX_PATH];
+
+            snprintf(thName, MAX_PATH, "IO-bound-%u", i);
+
+            pCtx[i+cpuBound].EventWaitTimes = IO_BOUND_EVENT_TIMES;
+            pCtx[i+cpuBound].CpuUsage = IO_BOUND_CPU_USAGE;
+            ExEventInit(&pCtx[i+cpuBound].Event, ExEventTypeSynchronization, FALSE);
+
+            status = ThreadCreate(thName,
+                                  ThreadPriorityDefault,
+                                  _ThreadIoBound,
+                                  &pCtx[i+cpuBound],
+                                  &pThreads[i+cpuBound]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("ThreadCreate", status);
+                __leave;
+            }
+        }
+
+        // The main thread will signal all the IO bound events every 50 ms thus waking the IO bound threads
+        for (DWORD i = 0; i < IO_BOUND_EVENT_TIMES; ++i)
+        {
+            PitSleep(50 * MS_IN_US);
+            for (DWORD j = 0; j < ioBound; ++j)
+            {
+                ExEventSignal(&pCtx[j+cpuBound].Event);
+            }
+        }
+
+        // Wait for all the threads to finish their execution
+        for (DWORD i = 0; i < cpuBound + ioBound; ++i)
+        {
+            ThreadWaitForTermination(pThreads[i],
+                                     &status);
+        }
+
+        // List the threads statistics
+        CmdListThreads(0);
+
+        // Actually close the thread handles so the thread structures can be destroyed
+        for (DWORD i = 0; i < cpuBound + ioBound; ++i)
+        {
+            ThreadCloseHandle(pThreads[i]);
+        }
+    }
+    __finally
+    {
+        if (pCtx != NULL)
+        {
+            ExFreePoolWithTag(pCtx, HEAP_TEST_TAG);
+            pCtx = NULL;
+        }
+
+        if (pThreads != NULL)
+        {
+            ExFreePoolWithTag(pThreads, HEAP_TEST_TAG);
+            pThreads = NULL;
+        }
+    }
+
+
+
+}
+
+static
+void
+_CmdHelperPrintThreadFunctions(
+    void
+    )
+{
+    DWORD i;
+
+    for (i = 0; i < THREADS_TOTAL_NO_OF_TESTS; ++i)
+    {
+        printf("%2u. %s\n", i, THREADS_TEST[i].TestName);
+    }
+}
+
+static
+STATUS
+(__cdecl _CmdThreadPrint) (
+    IN      PLIST_ENTRY     ListEntry,
+    IN_OPT  PVOID           FunctionContext
+    )
+{
+    PTHREAD pThread;
+
+    ASSERT( NULL != ListEntry );
+    ASSERT( NULL == FunctionContext );
+
+    pThread = CONTAINING_RECORD(ListEntry, THREAD, AllList );
+
+    LOG("%6x%c", pThread->Id, '|');
+    LOG("%19s%c", pThread->Name, '|');
+    LOG("%4U%c", pThread->Priority, '|');
+    LOG("%7s%c", _CmdThreadStateToName(pThread->State), '|');
+    LOG("%9U%c", pThread->TickCountCompleted, '|');
+    LOG("%9U%c", pThread->TickCountEarly, '|');
+    LOG("%9U%c", pThread->TickCountCompleted + pThread->TickCountEarly, '|');
+    LOG("%9x%c", pThread->Process->Id, '|');
+    LOG("\n");
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+_CmdReadAndDumpCpuid(
+    IN      DWORD               Index,
+    IN      DWORD               SubIndex
+    )
+{
+    CPUID_INFO cpuidInfo;
+
+    __cpuidex(cpuidInfo.values, Index, SubIndex );
+
+    DumpCpuidValues(Index, SubIndex, cpuidInfo );
+}
+
+static
+STATUS
+(__cdecl _CmdIpiCmd)(
+    IN_OPT  PVOID   Context
+    )
+{
+    PCPU* pCpu;
+
+    ASSERT(NULL == Context);
+
+    pCpu = GetCurrentPcpu();
+    ASSERT( NULL != pCpu );
+
+    printf("Hello from CPU 0x%02x [0x%02x]\n", pCpu->ApicId, pCpu->LogicalApicId);
+
+    return STATUS_SUCCESS;
+}
+
+static
+__forceinline
+void
+_ThreadBusyWait(
+    IN      QWORD       Microseconds
+    )
+{
+    QWORD start = IomuGetSystemTimeUs();
+
+    while (IomuGetSystemTimeUs() < start + Microseconds);
+}
+
+STATUS
+(__cdecl _ThreadCpuBound)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PBOUND_THREAD_CTX pCtx = (PBOUND_THREAD_CTX) Context;
+
+    ASSERT(Context != NULL);
+
+    _ThreadBusyWait(pCtx->CpuUsage);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _ThreadIoBound)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PBOUND_THREAD_CTX pCtx = (PBOUND_THREAD_CTX) Context;
+
+    ASSERT(Context != NULL);
+
+    for (DWORD i = 0; i < pCtx->EventWaitTimes; ++i)
+    {
+        ExEventWaitForSignal(&pCtx->Event);
+        _ThreadBusyWait(pCtx->CpuUsage);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/core.c b/src_proiect/HAL9000/src/core.c
new file mode 100644
index 0000000..0d53207
--- /dev/null
+++ b/src_proiect/HAL9000/src/core.c
@@ -0,0 +1,169 @@
+#include "HAL9000.h"
+#include "core.h"
+#include "iomu.h"
+#include "display.h"
+#include "cpumu.h"
+
+#define DEFAULT_SECONDS_TO_IDLE_STATE           60
+
+typedef struct _CORE_DATA
+{
+    QWORD               MicrosecondsToIdle;
+
+    volatile QWORD      ReadyThreadUs;
+    volatile BYTE       SystemIdle;
+
+    PVOID               DisplayBuffer;
+    DWORD               DisplayBufferSize;
+} CORE_DATA, *PCORE_DATA;
+STATIC_ASSERT(FIELD_OFFSET(CORE_DATA, ReadyThreadUs) % sizeof(QWORD) == 0 );
+
+static CORE_DATA m_coreData;
+
+static
+void
+_CoreSystemIdle(
+    void
+    );
+
+static
+void
+_CoreSystemRevertFromIdle(
+    IN      QWORD       IdlePeriodUs
+    );
+
+void
+CorePreinit(
+    void
+    )
+{
+    memzero(&m_coreData, sizeof(CORE_DATA));
+}
+
+STATUS
+CoreInit(
+    void
+    )
+{
+    QWORD systemTimeUs;
+
+    systemTimeUs = IomuGetSystemTimeUs();
+
+    CoreSetIdlePeriod(DEFAULT_SECONDS_TO_IDLE_STATE);
+    m_coreData.ReadyThreadUs = systemTimeUs;
+
+    m_coreData.DisplayBufferSize = SCREEN_SIZE;
+    m_coreData.DisplayBuffer = ExAllocatePoolWithTag(PoolAllocateZeroMemory, m_coreData.DisplayBufferSize, HEAP_CORE_TAG, 0);
+    if (NULL == m_coreData.DisplayBuffer)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", m_coreData.DisplayBufferSize );
+        return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+void
+CoreUpdateIdleTime(
+    IN  BOOLEAN             IdleScheduled
+    )
+{
+    QWORD systemTimeUs;
+
+    ASSERT( INTR_OFF == CpuIntrGetState() );
+    
+    systemTimeUs = IomuGetSystemTimeUs();
+
+    if (IdleScheduled)
+    {
+        if (GetCurrentPcpu()->BspProcessor)
+        {
+            QWORD lastActivityUs = m_coreData.ReadyThreadUs;
+
+            if (systemTimeUs < lastActivityUs)
+            {
+                ASSERT_INFO( systemTimeUs + IomuGetTimerInterrupTimeUs() >= lastActivityUs,
+                            "System time is %U us\nLast activity time is %U us\n", 
+                            systemTimeUs, lastActivityUs );
+                return;
+            }
+
+            if (systemTimeUs - lastActivityUs >= m_coreData.MicrosecondsToIdle)
+            {
+                if (FALSE == _InterlockedCompareExchange8(&m_coreData.SystemIdle, TRUE, FALSE))
+                {
+                    _CoreSystemIdle();
+                }
+            }
+        }
+    }
+    else
+    {
+        QWORD lastActivityUs = m_coreData.ReadyThreadUs;
+
+        // Do not use strict comparison, there is no benefit in doing interlocked exchange operations
+        // to change the old value with the same new value
+        if (systemTimeUs <= lastActivityUs)
+        {
+            // the time from each processor to another might differ by up to
+            // SmpGetTimerInterruptTimeUs() (scheduler clock tick), this is not a problem 
+            // => simply do not lower last activity time
+            return;
+        }
+
+        _InterlockedExchange64(&m_coreData.ReadyThreadUs, systemTimeUs);
+        if (TRUE == _InterlockedExchange8(&m_coreData.SystemIdle, FALSE))
+        {
+            _CoreSystemRevertFromIdle(systemTimeUs - lastActivityUs);
+        }
+        
+    }
+}
+
+DWORD
+CoreSetIdlePeriod(
+    IN  DWORD               SecondsForIdle
+    )
+{
+    QWORD previousIdlePeriod = m_coreData.MicrosecondsToIdle / SEC_IN_US;
+    ASSERT( previousIdlePeriod <= MAX_DWORD );
+
+    if (0 == SecondsForIdle)
+    {
+        return (DWORD) previousIdlePeriod;
+    }
+
+    m_coreData.MicrosecondsToIdle = SEC_IN_US * SecondsForIdle;
+    return (DWORD) previousIdlePeriod;
+}
+
+static
+void
+_CoreSystemIdle(
+    void
+    )
+{
+    STATUS status;
+
+    status = DispStoreBuffer(m_coreData.DisplayBuffer, m_coreData.DisplayBufferSize);
+    ASSERT(SUCCEEDED(status));
+
+    DispClearScreen();
+
+    LOGL("System is IDLE!\n");
+}
+
+static
+void
+_CoreSystemRevertFromIdle(
+    IN      QWORD       IdlePeriodUs
+    )
+{
+    STATUS status;
+    QWORD uptimeInMs = IdlePeriodUs / MS_IN_US;
+
+    status = DispRestoreBuffer(m_coreData.DisplayBuffer, m_coreData.DisplayBufferSize);
+    ASSERT(SUCCEEDED(status));
+
+    LOGL("System is no longer IDLE after %u.%03u sec!\n", uptimeInMs / 1000, uptimeInMs % 1000 );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/cpumu.c b/src_proiect/HAL9000/src/cpumu.c
new file mode 100644
index 0000000..7d6712f
--- /dev/null
+++ b/src_proiect/HAL9000/src/cpumu.c
@@ -0,0 +1,467 @@
+#include "HAL9000.h"
+#include "thread_internal.h"
+#include "cpumu.h"
+#include "mmu.h"
+#include "gdtmu.h"
+#include "smp.h"
+#include "vmm.h"
+#include "gs_utils.h"
+#include "syscall.h"
+
+#define STACK_MINIMUM_SIZE          PAGE_SIZE
+#define STACK_MAXIMUM_SIZE          (16*PAGE_SIZE)
+
+#define TSS_STACK_DEFAULT_SIZE      (3*PAGE_SIZE)
+
+#define IA32_EXPECTED_PAT_VALUES    0x0007'0406'0007'0406ULL
+
+#define HAL9000_USED_XCR0_FEATURES           (XCR0_SAVED_STATE_x87_MMX | XCR0_SAVED_STATE_SSE)
+
+typedef struct _CPUMU_DATA
+{
+    CPUID_BASIC_INFORMATION                         BasicInformation;
+    CPUID_FEATURE_INFORMATION                       FeatureInformation;
+    CPUID_MONITOR_LEAF                              MonitorLeaf;
+    CPUID_STRUCTURED_EXTENDED_FEATURE_FLAGS_LEAF    StructuredExtendedFeatures;
+    CPUID_EXTENDED_CPUID_INFORMATION                ExtendedCpuidInformation;
+    CPUID_EXTENDED_FEATURE_INFORMATION              ExtendedFeatureInformation;
+    CPUID_EXTENDED_STATE_ENUMERATION_MAIN_LEAF      ExtendedStateMainLeaf;
+} CPUMU_DATA, *PCPMU_DATA;
+
+static CPUMU_DATA m_cpuMuData;
+
+static
+void
+_CpuValidateCurrentCpu(
+    void
+    );
+
+static
+__forceinline
+void
+_CpuActivateAvailableFeatures(
+    void
+    )
+{
+    QWORD cr4FlagsToActivate;
+    QWORD eferFlagsToActivate;
+
+    cr4FlagsToActivate = 0;
+    eferFlagsToActivate = 0;
+
+    // CR4
+    cr4FlagsToActivate |= ((m_cpuMuData.StructuredExtendedFeatures.ebx.SMEP) ? CR4_SMEP : 0);
+
+    __writecr4(__readcr4() | cr4FlagsToActivate);
+
+    LOGL("CR4 is 0x%X\n", __readcr4());
+
+    // EFER
+    eferFlagsToActivate |= ((m_cpuMuData.ExtendedFeatureInformation.edx.Syscall) ? IA32_EFER_SCE : 0);
+
+    __writemsr(IA32_EFER, __readmsr(IA32_EFER) | eferFlagsToActivate);
+
+    LOG("EFER is 0x%X\n", __readmsr(IA32_EFER));
+}
+
+__forceinline
+static
+void
+_CpuMuCollectBasicInformation(
+    void
+    )
+{
+    __cpuid((int*) &m_cpuMuData.BasicInformation, CpuidIdxBasicInformation);
+
+    if (m_cpuMuData.BasicInformation.MaxValueForBasicInfo >= CpuidIdxFeatureInformation)
+    {
+        __cpuid((int*)&m_cpuMuData.FeatureInformation, CpuidIdxFeatureInformation);
+    }
+
+    if (m_cpuMuData.BasicInformation.MaxValueForBasicInfo >= CpuidIdxMonitorLeaf)
+    {
+        __cpuid((int*)&m_cpuMuData.MonitorLeaf, CpuidIdxMonitorLeaf);
+    }
+
+    if (m_cpuMuData.BasicInformation.MaxValueForBasicInfo >= CpuidIdxStructuredExtendedFeaturesLeaf)
+    {
+        __cpuid((int*)&m_cpuMuData.StructuredExtendedFeatures, CpuidIdxStructuredExtendedFeaturesLeaf);
+    }
+
+    if (m_cpuMuData.BasicInformation.MaxValueForBasicInfo >= CpuidIdxExtendedStateEnumerationMainLeaf)
+    {
+        __cpuidex((int*)&m_cpuMuData.ExtendedStateMainLeaf, CpuidIdxExtendedStateEnumerationMainLeaf, 0x0);
+    }
+}
+
+__forceinline
+static
+void
+_CpuMuCollectExtendedInformation(
+    void
+    )
+{
+    __cpuid((int*) &m_cpuMuData.ExtendedCpuidInformation, CpuidIdxExtendedMaxFunction);
+
+    if (m_cpuMuData.ExtendedCpuidInformation.MaxValueForExtendedInfo >= CpuidIdxExtendedFeatureInformation)
+    {
+        __cpuid((int*) &m_cpuMuData.ExtendedFeatureInformation, CpuidIdxExtendedFeatureInformation);
+    }
+}
+
+// this has nothing to do with the thread system, it is a `hack` used to
+// have the same consistency through GetCurrentThread() calls since
+// `CpuMuPreInit` was called until the first thread is setup on the CPU in
+// `ThreadSystemInitMainForCurrentCPU`
+// This DUMMY_THREAD will be the thread of both the DUMMY_CPU and the real CPU until
+// the threading system is set up
+
+// PS: next year we might want to create a real `THREAD_HEADER` structure in `thread_internal.h` to have a cleaner solution
+// However, as not to confuse people by updating the `THREAD` structure after the semester has started this is the current solution
+typedef struct _DUMMY_THREAD
+{
+    REF_COUNT               RefCnt;
+
+    struct _THREAD* Self;
+} DUMMY_THREAD;
+static_assert(sizeof(DUMMY_THREAD) == FIELD_OFFSET(THREAD, Id) && FIELD_OFFSET(DUMMY_THREAD, Self) == FIELD_OFFSET(THREAD, Self),
+    "Safety measure, if someone modified the THREAD structure we may need to modify this DUMMY_THREAD as well");
+
+// mark .Self as NULL such that GetCurrentThread will return always NULL until we setup the first real thread later in the boot
+// set up both for dummy CPU and for the real CPU structure until threading system is initialized
+static DUMMY_THREAD __dummySelfThread = { .Self = NULL };
+
+void
+CpuMuPreinit(
+    void
+    )
+{
+    static PCPU* __dummySelfCpu = NULL;
+
+    memzero(&m_cpuMuData, sizeof(CPUMU_DATA));
+
+    // Basic information
+    _CpuMuCollectBasicInformation();
+
+    // Extended information
+    _CpuMuCollectExtendedInformation();
+
+    // We cannot have the current CPU NULL because we always dereference the first field
+    //  => use static dummy PCPU which has the first field NULL
+    SetCurrentPcpu(&__dummySelfCpu);
+
+    // we're not using the SetCurrentThread macro because it will
+    // try to dereference the PCPU pointer
+    __writemsr(IA32_FS_BASE_MSR, &__dummySelfThread);
+}
+
+void
+CpuMuValidateConfiguration(
+    void
+    )
+{
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.APIC, "We cannot wake up APs without APIC!");
+
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.MSR, "We cannot do anything without MSRs!");
+
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.TSC, "We need a way to measure time!");
+
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.PAT, "We need PAT!");
+
+    ASSERT( IA32_EXPECTED_PAT_VALUES == __readmsr(IA32_PAT) );
+
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.SSE, "We need SFENCE support!");
+
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.edx.SSE2, "We need LFENCE/MFENCE support");
+
+#if INCLUDE_FP_SUPPORT
+    ASSERT_INFO( m_cpuMuData.FeatureInformation.ecx.XSAVE, "We need XSAVE/XRSTOR support");
+
+    ASSERT_INFO(IsBooleanFlagOn(
+        DWORDS_TO_QWORD(m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportHigh, m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportLow),
+        HAL9000_USED_XCR0_FEATURES),
+        "We need to support 0x%X, however we only have support for 0x%X\n",
+        HAL9000_USED_XCR0_FEATURES,
+        DWORDS_TO_QWORD(m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportHigh, m_cpuMuData.ExtendedStateMainLeaf.Xcr0FeatureSupportLow));
+#endif
+
+    ASSERT_INFO( m_cpuMuData.ExtendedFeatureInformation.edx.Syscall, "We need SYSCALL/SYSRET support");
+}
+
+STATUS
+CpuMuSetMonitorFilterSize(
+    IN          WORD        FilterSize
+    )
+{
+    if (!m_cpuMuData.FeatureInformation.ecx.MONITOR)
+    {
+        // no monitor available
+        return STATUS_CPU_MONITOR_NOT_SUPPORTED;
+    }
+
+    if (FilterSize < m_cpuMuData.MonitorLeaf.eax.SmallestMonitorLineSize)
+    {
+        return STATUS_CPU_MONITOR_FILTER_SIZE_TOO_SMALL;
+    }
+
+    if (FilterSize > m_cpuMuData.MonitorLeaf.ebx.LargestMonitorLineSize)
+    {
+        return STATUS_CPU_MONITOR_FILTER_SIZE_TOO_LARGE;
+    }
+
+    __writemsr( IA32_MONITOR_FILTER_SIZE_MSR, FilterSize);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+CpuMuAllocAndInitCpu(
+    OUT_PTR     PPCPU*      PhysicalCpu,
+    IN _Strict_type_match_
+                APIC_ID     ApicId,
+    IN          DWORD       StackSize,
+    IN          BYTE        NoOfTssStacks
+    )
+{
+    STATUS status;
+    PPCPU pPcpu;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pPcpu = NULL;
+
+    status = CpuMuAllocCpu(&pPcpu, ApicId, StackSize, NoOfTssStacks);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("CpuMuAllocCpu", status);
+        return status;
+    }
+
+    status = CpuMuInitCpu(pPcpu, TRUE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("CpuMuInitCpu", status );
+        return status;
+    }
+
+    *PhysicalCpu = pPcpu;
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+CpuMuAllocCpu(
+    OUT_PTR     PPCPU*      PhysicalCpu,
+    IN _Strict_type_match_
+                APIC_ID     ApicId,
+    IN          DWORD       StackSize,
+    IN          BYTE        NumberOfTssStacks
+    )
+{
+    STATUS status;
+    PCPU* pPcpu;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != PhysicalCpu);
+    ASSERT(0 != StackSize);
+    ASSERT( NumberOfTssStacks <= NO_OF_IST );
+
+    status = STATUS_SUCCESS;
+    pPcpu = NULL;
+
+    pPcpu = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PCPU), HEAP_CPU_TAG, 0);
+    if (NULL == pPcpu)
+    {
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(PCPU));
+        return STATUS_MEMORY_CANNOT_BE_MAPPED;
+    }
+
+    pPcpu->Self = pPcpu;
+    pPcpu->ApicId = ApicId;
+    pPcpu->LogicalApicId = ( 1U << ApicId );
+
+    LOG("APIC ID: 0x%02x, logical ID: 0x%02x\n", pPcpu->ApicId, pPcpu->LogicalApicId );
+
+    pPcpu->StackTop = MmuAllocStack(StackSize, TRUE, FALSE, NULL);
+    if (NULL == pPcpu->StackTop)
+    {
+        LOG_FUNC_ERROR_ALLOC("MmuAllocStack", StackSize);
+        return STATUS_MEMORY_CANNOT_BE_COMMITED;
+    }
+    pPcpu->StackSize = StackSize;
+
+    for (DWORD i = 0; i < NumberOfTssStacks; ++i)
+    {
+        pPcpu->TssStacks[i] = MmuAllocStack(TSS_STACK_DEFAULT_SIZE, TRUE, FALSE, NULL);
+        if (NULL == pPcpu->TssStacks[i])
+        {
+            LOG_FUNC_ERROR_ALLOC("MmuAllocStack", TSS_STACK_DEFAULT_SIZE);
+            return STATUS_MEMORY_CANNOT_BE_COMMITED;
+        }
+    }
+    pPcpu->NumberOfTssStacks = NumberOfTssStacks;
+
+    status = GdtMuInstallTssDescriptor(&pPcpu->Tss, NumberOfTssStacks, pPcpu->TssStacks, &pPcpu->TrSelector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("GdtMuInstallTssDescriptor", status);
+        return status;
+    }
+
+    InitializeListHead(&pPcpu->EventList);
+    LockInit(&pPcpu->EventListLock);
+    pPcpu->NoOfEventsInList = 0;
+
+    *PhysicalCpu = pPcpu;
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+CpuMuInitCpu(
+    IN          PPCPU       PhysicalCpu,
+    IN          BOOLEAN     ChangeStack
+    )
+{
+    STATUS status;
+
+    ASSERT( NULL != PhysicalCpu );
+    _CpuValidateCurrentCpu();
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    // load task register
+    __ltr(PhysicalCpu->TrSelector);
+
+    // write CPU structure to GS
+    SetCurrentPcpu(PhysicalCpu);
+    SetCurrentThread((PTHREAD)&__dummySelfThread);
+
+    // we assume we haven't used more than 1 PAGE of our stack
+    if (ChangeStack)
+    {
+        LOGPL("Will change to stack: 0x%X\n", PhysicalCpu->StackTop );
+        CpuMuChangeStack(PhysicalCpu->StackTop);
+    }
+
+    _CpuActivateAvailableFeatures();
+
+    status = SmpCpuInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SmpCpuInit", status);
+        return status;
+    }
+
+    SyscallCpuInit();
+
+    // create thread
+    status = ThreadSystemInitMainForCurrentCPU();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ThreadSystemInitForCurrentCPU", status);
+        return status;
+    }
+
+    // notify SMP module that the CPU has woken up
+    SmpNotifyCpuWakeup();
+
+    LOG_FUNC_END;
+
+    return status;
+
+}
+
+void
+CpuMuChangeStack(
+    IN          PVOID       NewStack
+    )
+{
+    PVOID oldStackBase = (PVOID)AlignAddressUpper(_AddressOfReturnAddress(), PAGE_SIZE);
+
+    ASSERT( NULL != NewStack );
+
+    // function needs to be written in assembly, else we cannot know how much
+    // we need to copy for the local variables
+    __changeStack(oldStackBase, NewStack);
+
+    // if GS is enabled we need to update the cookies on the stack because the value placed
+    // on the stack is the result __security_cookie ^ RSP at the moment the cookie is placed
+    // because we changed our RSP when we will check the value on the stack
+    // __security_cookie ^ OldRSP ^ NewRSP != __security_cookie => we will have a spurious
+    // cookie corruption
+    GSNotifyStackChange(oldStackBase, NewStack, PAGE_SIZE);
+}
+
+BOOLEAN
+CpuMuIsPcidFeaturePresent(
+    void
+    )
+{
+    return (m_cpuMuData.FeatureInformation.ecx.PCID == 1);
+}
+
+STATUS
+CpuMuActivateFpuFeatures(
+    void
+    )
+{
+    return HalSetActiveFpuFeatures(HAL9000_USED_XCR0_FEATURES);
+}
+
+static
+void
+_CpuValidateCurrentCpu(
+    void
+    )
+{
+    QWORD cr0;
+    QWORD cr4;
+    QWORD cr8;
+    QWORD eferMsr;
+    QWORD ia32PatValues;
+
+    // read CRs
+    cr0 = __readcr0();
+    cr4 = __readcr4();
+    cr8 = __readcr8();
+
+    // read MSRs
+    eferMsr = __readmsr(IA32_EFER);
+    ia32PatValues = __readmsr(IA32_PAT);
+
+    // Step 1. check control registers
+
+    // check for protection and paging
+    ASSERT(IsBooleanFlagOn(cr0, CR0_PG | CR0_PE));
+
+    // check for write protect
+    ASSERT(IsBooleanFlagOn(cr0, CR0_WP));
+
+    // make sure caching is enabled
+    ASSERT(!IsFlagOn(cr0, CR0_CD | CR0_NW));
+
+    // how did we get into IA32-e without enabling PAE?
+    ASSERT(IsBooleanFlagOn(cr4, CR4_PAE));
+
+    // we are not using hardware priorities
+    ASSERT(0 == cr8);
+
+    // Step 2. check MSRs
+
+    // make sure we're in 64 bit
+    ASSERT(IsBooleanFlagOn(eferMsr, IA32_EFER_LME | IA32_EFER_LMA));
+
+    // make sure we're using the NX feature
+    ASSERT(IsBooleanFlagOn(eferMsr, IA32_EFER_NXE));
+
+    ASSERT(IA32_EXPECTED_PAT_VALUES == ia32PatValues);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/defines.yasm b/src_proiect/HAL9000/src/defines.yasm
new file mode 100644
index 0000000..73e4bdb
--- /dev/null
+++ b/src_proiect/HAL9000/src/defines.yasm
@@ -0,0 +1,180 @@
+%ifndef _DEFINES_ASM_
+%define _DEFINES_ASM_
+
+;-----------------------------------------------------------------------;
+; DEFINES
+;-----------------------------------------------------------------------;
+
+; 1 MULTIBOOT DEFINES
+;-----------------------------------------------------------------------;
+
+;
+; we use hardcoded address space / map for our data structures, the multiboot header and the entry point
+; the plain binary image is loaded to 0x00200000 (2MB), the entry point is fixed to 0x00209000
+;
+%define     MULTIBOOT_HEADER_SIZE       48                                      ; check out '3.1.1 The layout of Multiboot header'
+%define     MULTIBOOT_HEADER_MAGIC      0x1BADB002
+%define     MULTIBOOT_HEADER_FLAGS      0x00010001                              ; flags[16] | flags[0]
+%define     MULTIBOOT_LOADER_MAGIC      0x2BADB002
+
+%define     MULTIBOOT_ENTRY_POINT       KERNEL_CODE_START_ADDRESS               ; at EIP = 0x20C000 we start the execution (32 bit, non-paged)
+
+%define     MULTIBOOT_INFO_STRUCT_SIZE  90
+
+%define     MULTIBOOT_INFO_ADDRESS      MULTIBOOT_BASE + MULTIBOOT_HEADER_SIZE
+
+; 2 MINIHV DEFINES
+;-----------------------------------------------------------------------;
+%define     PA_2_VA_DIFFERENCE          0xFFFF800000000000
+%define     KERNEL_BASE_VIRTUAL         (PA_2_VA_DIFFERENCE + KERNEL_BASE)      ; magic 1T
+%define     KERNEL_BASE                 0x01000000                              ; 16 MB
+%define     KERNEL_LENGTH               0x00200000                              ; 2 MB
+%define     KERNEL_XE_NO_OF_PAGES       ((KERNEL_LENGTH+PAGE_SIZE-1)/PAGE_SIZE)
+%define     KERNEL_XD_NO_OF_PAGES       (PTE_PER_TABLE-KERNEL_XE_NO_OF_PAGES)
+
+%define     CANONICAL_MASK              0x0000FFFFFFFFFFFF
+%define     KERNEL_PML4_INDEX           ((KERNEL_BASE_VIRTUAL & CANONICAL_MASK)/PML4_PAGE_SIZE)
+
+; Number of pages which will not be mapped between (0,KernelBase)
+; The reason for the -1 is that we subtract the memory mapped by the first PD(2MB)
+%define     KERNEL_NO_OF_PAGES_BEFORE   ((KERNEL_BASE/PD_ENTRY_LENGTH)-1)
+
+; Number of pages which will not be mapped between (KernelBase,1Gb)
+; The reason for the -2 is the PD for the first 2MB and the PD for the kernel
+%define     KERNEL_NO_OF_PAGES_AFTER    (PTE_PER_TABLE-KERNEL_NO_OF_PAGES_BEFORE-1)
+
+%define     INITIAL_TOP_OF_STACK        TOP_OF_STACK 
+%define     INITIAL_TOP_OF_STACK_1T     (PA_2_VA_DIFFERENCE + TOP_OF_STACK)
+
+; 3 GDT DEFINES
+;-----------------------------------------------------------------------;
+%define     GDT_DESC(g,x)               (g %+ . %+ x - g)
+
+%define     GDT_DESC_DATA64             0x00CF93000000FFFF
+%define     GDT_DESC_CODE64             0x00AF9B000000FFFF
+%define     GDT_DESC_DATA32             0x00CF93000000FFFF
+%define     GDT_DESC_CODE32             0x00CF9B000000FFFF
+%define     GDT_DESC_DATA16             0x000093000000FFFF
+%define     GDT_DESC_CODE16             0x00009B000000FFFF
+
+; 4 Upper MEMORY LAYOUT DEFINES
+;-----------------------------------------------------------------------;
+%define     MULTIBOOT_SECTION_SIZE              0x100
+%define     GDT_SECTION_SIZE                    0x200
+%define     DATA_SECTION_SIZE                   0x1900
+
+%define     MULTIBOOT_BASE                      (KERNEL_BASE + 0x400)           ; take into account the MZ/PE header + 0x400 allignment
+                                                                                ; the multiboot header begins in the _text section
+%define     GDT_BASE_ADDRESS                    (MULTIBOOT_BASE+MULTIBOOT_SECTION_SIZE)  
+%define     GDT_DESCRIPTOR_ADDRESS              (GDT_BASE_ADDRESS + __gdt_base.end - __gdt_base )
+%define     DATA_BASE_ADDRESS                   (GDT_BASE_ADDRESS+GDT_SECTION_SIZE)
+%define     PML4_TABLE_BASE                     (DATA_BASE_ADDRESS + DATA_SECTION_SIZE)
+%define     PDP_TABLE_BASE                      (PML4_TABLE_BASE + 0x1000)
+%define     PD_TABLE_LOW_1GB_BASE               (PDP_TABLE_BASE + 0x1000)
+%define     PT_TABLE_LOW_2MB_BASE               (PD_TABLE_LOW_1GB_BASE + 0x1000)
+%define     KERNEL_CODE_START_ADDRESS           (PT_TABLE_LOW_2MB_BASE + 0x1000)
+
+%define     TOP_OF_STACK                        (KERNEL_BASE + KERNEL_LENGTH)
+
+%define     ASM_PARAMETERS_DATA_OFFSET          0x0
+
+; 5 LOWER MEMORY LAYOUT DEFINES
+;-----------------------------------------------------------------------;
+%define     LOW_MEMORY_ADDRESS                  0x00003000
+%define     LOW_GDT_BASE_ADDRESS                LOW_MEMORY_ADDRESS
+%define     LOW_PM32_RM16_ADDRESS               LOW_GDT_BASE_ADDRESS + 0x100
+%define     LOW_RM16_PM32_ADDRESS               LOW_PM32_RM16_ADDRESS + 0x100
+%define     LOW_RETRIEVE_INT15_MAP_ADDRESS      LOW_RM16_PM32_ADDRESS + 0x100
+%define     LOW_CALL_TO_RM_ADDRESS              LOW_RETRIEVE_INT15_MAP_ADDRESS + 0x100
+%define     LOW_MEMORY_MAP_NUMBER_ADDRESS       LOW_CALL_TO_RM_ADDRESS + 0x100
+%define     LOW_MEMORY_MAP_ENTRIES_ADDRESS      LOW_MEMORY_MAP_NUMBER_ADDRESS + 0x10
+
+%define     LOW_MEMORY_STACK_TOP                LOW_MEMORY_ADDRESS
+
+%define     LOW_MEMORY_LENGTH                   0x2000
+
+%define     REAL_MODE_IVT_LIMIT                 0x3FF
+%define     REAL_MODE_IVT_BASE                  0x0
+
+%define     INT15_MEMORY_MAP_ENTRY_MIN_SIZE     0x14
+
+%define     p16(n)                              bp + 4 + 2*(n)
+%define     p32(n)                              ebp + 8 + 4*(n)
+%define     p64(n)                              rbp + 0x10 + 8*(n)
+
+%define     INT15_E820_CODE                     0xE820
+%define     INT15_E820_SIGNATURE                'PAMS'
+
+; 6 TRAMPOLINE DEFINES
+;-----------------------------------------------------------------------;
+%define     TRAMPOLINE_LOW_MEMORY_ADDRESS       0x00001000
+%define     TRAMPOLINE_AP_DESCRIPTOR_ADDRESS    TRAMPOLINE_LOW_MEMORY_ADDRESS
+%define     TRAMPOLINE_MEMORY_TRAMP_START       TRAMPOLINE_LOW_MEMORY_ADDRESS + PAGE_SIZE
+
+; 7 PAGING STRUCTURES DEFINES
+;-----------------------------------------------------------------------;
+%define     P_BIT                       (1<<0)
+%define     RW_BIT                      (1<<1)
+%define     US_BIT                      (1<<2)
+%define     PWT_BIT                     (1<<3)
+%define     PCD_BIT                     (1<<4)
+%define     A_BIT                       (1<<5)
+%define     PS_BIT                      (1<<7)
+%define     XD_BIT                      (1<<63)
+
+%define     PML4_PAGE_SIZE              0x8000000000             ; 512 TB
+%define     PD_ENTRY_LENGTH             0x00200000               ; 2 MB
+%define     PAGE_SIZE                   0x1000                   ; 4KB
+
+%define     PTE_PER_TABLE               0x200
+
+; 8 CONTROL & STATUS REGISTER DEFINES
+;-----------------------------------------------------------------------;
+
+; CR0
+%define     CR0_PE                      (1<<0)
+%define     CR0_NE                      (1<<5)
+%define     CR0_WP                      (1<<16)
+%define     CR0_NW                      (1<<29)
+%define     CR0_CD                      (1<<30)
+%define     CR0_PG                      (1<<31)
+
+; CR4
+%define     CR4_PAE                     (1<<5)
+
+; EFLAGS masks
+%define     ID_FLAG                     (1<<21)
+
+; EFER
+%define     IA32_EFER                   0xC0000080
+%define     IA32_EFER_LME               (1<<8)
+%define     IA32_EFER_NXE               (1<<11)
+
+; 9 CPUID DEFINES
+;-----------------------------------------------------------------------;
+
+%define     CPUID_FEATURE_INFORMATION   1
+
+; 10 MSR DEFINES
+;-----------------------------------------------------------------------;
+
+%define     IA32_FS_BASE_MSR                    0xC0000100
+%define     IA32_GS_BASE_MSR                    0xC0000101
+%define     IA32_KERNEL_GS_BASE                 0xC0000102
+
+; 11 MBR DEFINES
+;-----------------------------------------------------------------------;
+
+%define     MBR_MAGIC_SIGNATURE         'ALEX'
+%define     MBR_PARTITION_ENTRY_SIZE    0x10
+%define     MBR_SIGNATURE_SIZE          2
+%define     MBR_SIZE                    0x200
+
+; 12 BIOS DEFINES
+;-----------------------------------------------------------------------;
+%define     BIOS_SERIAL_PORT_ADDRESS    0x400
+%define     BIOS_NO_OF_SERIAL_PORTS     4
+
+%define     INCLUDE_FP_SUPPORT          0
+
+%endif ; _DEFINES_ASM_
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/display.c b/src_proiect/HAL9000/src/display.c
new file mode 100644
index 0000000..4bb2e88
--- /dev/null
+++ b/src_proiect/HAL9000/src/display.c
@@ -0,0 +1,293 @@
+#include "HAL9000.h"
+#include "display.h"
+
+#pragma pack(push,1)
+typedef struct _SCREEN_CHARACTER
+{
+    BYTE        Character;
+    BYTE        Color;
+} SCREEN_CHARACTER,*PSCREEN_CHARACTER;
+static_assert(sizeof(SCREEN_CHARACTER) == 2 * sizeof(BYTE), "This structure needs to be 2 bytes");
+#pragma pack(pop)
+
+typedef SCREEN_CHARACTER    SCREEN_MEMORY[LINES_PER_SCREEN][CHARS_PER_LINE];
+typedef SCREEN_MEMORY*      PSCREEN_MEMORY;
+
+typedef struct _DISPLAY_DATA
+{
+    PSCREEN_MEMORY      MappedScreenAddress;
+    PSCREEN_MEMORY      StartOfUsableScreen;
+    DWORD               TotalUsableCharacters;
+    DWORD               TotalUsableBytes;
+    BYTE                CurrentColumn;
+    BYTE                CurrentLine;
+    COLOR               CurrentColor;
+    BYTE                IndexOfFirstValidLine;
+    BYTE                IndexOfFirstInvalidLine;
+} DISPLAY_DATA, *PDISPLAY_DATA;
+
+static DISPLAY_DATA m_displayData;
+
+static
+void
+_DispScrollScreen(
+    void
+    );
+
+
+static
+void
+_DispPutChar(
+    IN      char    Character,
+    IN      BYTE    Line,
+    IN      BYTE    Column
+    );
+
+void
+DispPreinitScreen(
+    IN      PVOID   VideoAddress,
+    IN      BYTE    IndexOfFirstUsableRow,
+    IN      BYTE    IndexOfFirstUnusableRow
+    )
+{
+    memzero(&m_displayData, sizeof(DISPLAY_DATA));
+
+    m_displayData.MappedScreenAddress = (PSCREEN_MEMORY)VideoAddress;
+    m_displayData.StartOfUsableScreen = (PSCREEN_MEMORY) &((*m_displayData.MappedScreenAddress)[IndexOfFirstUsableRow]);
+    m_displayData.IndexOfFirstValidLine = IndexOfFirstUsableRow;
+    m_displayData.IndexOfFirstInvalidLine = IndexOfFirstUnusableRow;
+    m_displayData.TotalUsableCharacters = (IndexOfFirstUnusableRow - IndexOfFirstUsableRow) * CHARS_PER_LINE;
+    m_displayData.TotalUsableBytes = BYTES_PER_CHAR * m_displayData.TotalUsableCharacters;
+    m_displayData.CurrentLine = m_displayData.IndexOfFirstValidLine;
+    DispSetColor(WHITE_COLOR);
+
+    DispClearScreen();
+}
+
+void
+DispSetColor(
+    IN      COLOR           Color
+    )
+{
+    m_displayData.CurrentColor = Color;
+}
+
+COLOR
+DispGetColor(
+    void
+    )
+{
+    return m_displayData.CurrentColor;
+}
+
+void
+DispPrintString
+(
+    IN_Z    char*    Buffer
+    )
+{
+    DWORD index;
+    BOOLEAN newline;
+
+    // check parameters
+    if (NULL == Buffer)
+    {
+        return;
+    }
+
+    // preinit variables
+    index = 0;
+
+    while ('\0' != Buffer[index])
+    {
+        newline = FALSE;
+
+        // check if we need to scroll the screen before writing
+        if (m_displayData.IndexOfFirstInvalidLine == m_displayData.CurrentLine)
+        {
+            _DispScrollScreen();
+        }
+
+        if ('\n' == Buffer[index])
+        {
+            // newline
+            newline = TRUE;
+            goto end_it;
+        }
+
+        if ('\t' == Buffer[index])
+        {
+            // lets place a tab
+            DispPrintString("    ");
+
+            // go to next character
+            ++index;
+            continue;
+        }
+
+        _DispPutChar(Buffer[index], m_displayData.CurrentLine, m_displayData.CurrentColumn);
+
+        ++m_displayData.CurrentColumn;
+
+        if (CHARS_PER_LINE == m_displayData.CurrentColumn)
+        {
+            // newline
+            newline = TRUE;
+            goto end_it;
+        }
+
+    end_it:
+        if (newline)
+        {
+            m_displayData.CurrentLine++;
+            m_displayData.CurrentColumn = 0;
+        }
+
+        ++index;
+    }
+
+}
+
+void
+DispPutBuffer(
+    IN_Z    char*       Buffer,
+    IN      BYTE        Line,
+    IN      BYTE        Column
+    )
+{
+    DispPutBufferColor(Buffer, Line, Column, DispGetColor());
+}
+
+void
+DispPutBufferColor(
+    IN_Z    char*       Buffer,
+    IN      BYTE        Line,
+    IN      BYTE        Column,
+    IN      COLOR       Color
+    )
+{
+    BYTE i;
+    COLOR prevColor;
+
+    prevColor = DispGetColor();
+
+    DispSetColor(Color);
+    for (i = 0;
+    (i < CHARS_PER_LINE - Column) && (Buffer[i] != '\0');
+        ++i)
+    {
+        _DispPutChar(Buffer[i], Line, Column + i);
+    }
+
+    DispSetColor(prevColor);
+}
+
+static
+void
+_DispScrollScreen(
+    void
+    )
+{
+    // we scroll the screen
+
+    // warning C4312: 'type cast': conversion from 'DWORD' to 'PVOID' of greater size
+#pragma warning(suppress:4312)
+    memmove(m_displayData.StartOfUsableScreen, 
+           (*m_displayData.StartOfUsableScreen)[1], 
+           m_displayData.TotalUsableBytes - BYTES_PER_LINE );
+
+    // clear last line
+    m_displayData.CurrentLine--;
+    DispClearLine(m_displayData.CurrentLine);
+}
+
+void
+DispClearScreen(
+    void
+    )
+{
+    // clear the screen
+    memzero(m_displayData.StartOfUsableScreen, m_displayData.TotalUsableBytes);
+
+    // update current line to start toping at top of the usable screen
+    m_displayData.CurrentLine = m_displayData.IndexOfFirstValidLine;
+}
+
+static
+void
+_DispPutChar(
+    IN      char    Character,
+    IN      BYTE    Line,
+    IN      BYTE    Column
+    )
+{
+    PSCREEN_CHARACTER pScreenAddress;
+
+// warning C4312: 'type cast': conversion from 'unsigned long' to 'WORD *' of greater size
+#pragma warning(suppress:4312)
+    pScreenAddress = (PSCREEN_CHARACTER) &((*m_displayData.MappedScreenAddress)[Line][Column]);
+
+    pScreenAddress->Color = m_displayData.CurrentColor;
+    pScreenAddress->Character = Character;
+}
+
+void
+DispClearLine(
+    IN      BYTE        Line
+    )
+{
+    memzero( (*m_displayData.MappedScreenAddress)[Line], BYTES_PER_LINE);
+}
+
+void
+DispSetCursor(
+    IN      SCREEN_POSITION     CursorPosition,
+    IN      COLOR               Color
+    )
+{
+    WORD position = CursorPosition.Line * CHARS_PER_LINE + CursorPosition.Column;
+
+    __outbyte(0x3D4, 14);                    // write to register 14 first
+    __outbyte(0x3D5, (position >> 8) & 0xFF); // output high byte
+    __outbyte(0x3D4, 15);                    // again to register 15
+    __outbyte(0x3D5, position & 0xFF);      // low byte in this register
+
+    DispPutBufferColor(" ",
+                       CursorPosition.Line,
+                       CursorPosition.Column,
+                       Color);
+}
+
+STATUS
+DispStoreBuffer(
+    OUT_WRITES_BYTES(Size)  PVOID               Buffer,
+    IN                      DWORD               Size
+    )
+{
+    if (Size < m_displayData.TotalUsableBytes)
+    {
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+
+    memcpy(Buffer, m_displayData.StartOfUsableScreen, m_displayData.TotalUsableBytes );
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+DispRestoreBuffer(
+    IN_READS_BYTES(Size)    PVOID               Buffer,
+    IN                      DWORD               Size
+    )
+{
+    if (Size < m_displayData.TotalUsableBytes)
+    {
+        return STATUS_BUFFER_TOO_SMALL;
+    }
+
+    memcpy(m_displayData.StartOfUsableScreen, Buffer, m_displayData.TotalUsableBytes);
+
+    m_displayData.CurrentLine = m_displayData.IndexOfFirstInvalidLine;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_ata.c b/src_proiect/HAL9000/src/dmp_ata.c
new file mode 100644
index 0000000..fc4a795
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_ata.c
@@ -0,0 +1,86 @@
+#include "HAL9000.h"
+#include "dmp_ata.h"
+#include "dmp_common.h"
+
+void
+DumpAtaIdentifyCommand(
+    IN      PATA_IDENTIFY_RESPONSE          Identify
+    )
+{
+    QWORD totalSectors;
+    WORD* wordArray;
+    char serialNumber[ATA_SERIAL_NO_CHARS + 1];
+    char modelNumber[ATA_MODEL_NO_CHARS + 1];
+    DWORD i;
+    INTR_STATE intrState;
+
+    if (NULL == Identify)
+    {
+        return;
+    }
+
+    memzero(serialNumber, ATA_SERIAL_NO_CHARS + 1);
+    memzero(modelNumber, ATA_MODEL_NO_CHARS + 1);
+
+    totalSectors = Identify->Address48Bit;
+
+    for (i = 0; i < ATA_SERIAL_NO_CHARS / 2; ++i)
+    {
+        serialNumber[2 * i] = Identify->SerialNumbers[2 * i + 1];
+        serialNumber[2 * i + 1] = Identify->SerialNumbers[2 * i];
+    }
+
+    for (i = 0; i < ATA_MODEL_NO_CHARS / 2; ++i)
+    {
+        modelNumber[2 * i] = Identify->ModelNumber[2 * i + 1];
+        modelNumber[2 * i + 1] = Identify->ModelNumber[2 * i];
+    }
+
+    intrState = DumpTakeLock();
+    LOG("Serial number: %s\n", serialNumber);
+    LOG("Model number: %s\n", modelNumber);
+    LOG("totalSectors: %U\n", totalSectors);
+    LOG("Current C/H/S: %u/%u/%u\n", Identify->LogicalCylindersCurrent, Identify->LogicalHeadsCurrent, Identify->LogicalSectorsCurrent);
+    LOG("Default C/H/S: %u/%u/%u\n", Identify->LogicalCylinders, Identify->LogicalHeads, Identify->LogicalSectors);
+    LOG("Total capacity: %U MB\n", (totalSectors * SECTOR_SIZE) >> 20);
+    LOG("28 addressable: %U GB\n", ((QWORD)Identify->Address28Bit * SECTOR_SIZE) >> 30);
+    LOG("48 addressable: %U GB\n", ((QWORD)Identify->Address48Bit * SECTOR_SIZE) >> 30);
+
+    wordArray = (WORD*)Identify;
+    LOG("Maximum sectors per interrupt: %d\n", wordArray[47] & MAX_BYTE);
+    LOG("Current setting for sectors per interrupt: %d\n", wordArray[59] & MAX_BYTE);
+
+    LOG("Support for DMA mode 2: %d\n", IsBooleanFlagOn(wordArray[63], (1 << 2)));
+    LOG("Selected DMA mode: 2: %d\n", IsBooleanFlagOn(wordArray[64], (1<<10)));
+
+    LOG("PIO mode support: 0b%b\n", WORD_LOW(wordArray[64]));
+
+    LOG("Minimum cycle time PIO transfer: %d ns\n", wordArray[68]);
+
+    LOG("ATA-8 compliant: %d\n", IsBooleanFlagOn(wordArray[80], (1 << 8)));
+    LOG("ATA-7 compliant: %d\n", IsBooleanFlagOn(wordArray[80], (1 << 7)));
+    LOG("ATA-6 compliant: %d\n", IsBooleanFlagOn(wordArray[80], (1 << 6)));
+    LOG("ATA-5 compliant: %d\n", IsBooleanFlagOn(wordArray[80], (1 << 5)));
+    LOG("ATA-4 compliant: %d\n", IsBooleanFlagOn(wordArray[80], (1 << 4)));
+
+    LOG("48-bit LBA support: %d\n", Identify->Features.SupportLba48);
+
+    LOG("Ultra-DMA 6 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 6)));
+    LOG("Ultra-DMA 5 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 5)));
+    LOG("Ultra-DMA 4 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 4)));
+    LOG("Ultra-DMA 3 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 3)));
+    LOG("Ultra-DMA 2 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 2)));
+    LOG("Ultra-DMA 1 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 1)));
+    LOG("Ultra-DMA 0 support: %d\n", IsBooleanFlagOn(wordArray[88], (1 << 0)));
+
+    LOG("Ultra-DMA 6 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (6 + 8))));
+    LOG("Ultra-DMA 5 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (5 + 8))));
+    LOG("Ultra-DMA 4 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (4 + 8))));
+    LOG("Ultra-DMA 3 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (3 + 8))));
+    LOG("Ultra-DMA 2 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (2 + 8))));
+    LOG("Ultra-DMA 1 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (1 + 8))));
+    LOG("Ultra-DMA 0 selected: %d\n", IsBooleanFlagOn(wordArray[88], (1 << (0 + 8))));
+
+    LOG("Packet support: %d\n", Identify->Features.PacketFeature);
+    DumpReleaseLock(intrState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_cmos.c b/src_proiect/HAL9000/src/dmp_cmos.c
new file mode 100644
index 0000000..22d26d5
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_cmos.c
@@ -0,0 +1,27 @@
+#include "HAL9000.h"
+#include "dmp_cmos.h"
+#include "dmp_common.h"
+
+void
+DumpCmos(
+    IN      PCMOS_DATA      CmosData
+    )
+{
+    INTR_STATE intrState;
+
+    if (NULL == CmosData)
+    {
+        return;
+    }
+
+    intrState = DumpTakeLock();
+
+    LOG("Second: %d\n", CmosData->Second);
+    LOG("Minute: %d\n", CmosData->Minute);
+    LOG("Hour: %d\n", CmosData->Hour);
+    LOG("Day: %d\n", CmosData->Day);
+    LOG("Month: %d\n", CmosData->Month);
+    LOG("Year: %d\n", CmosData->Year);
+
+    DumpReleaseLock(intrState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_common.c b/src_proiect/HAL9000/src/dmp_common.c
new file mode 100644
index 0000000..b4bb0fb
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_common.c
@@ -0,0 +1,40 @@
+#include "HAL9000.h"
+#include "dmp_common.h"
+#include "synch.h"
+
+static REC_RW_SPINLOCK m_dumpLock;
+
+void
+DumpPreinit(
+    void
+    )
+{
+    RecRwSpinlockInit(2, &m_dumpLock);
+}
+
+REQUIRES_NOT_HELD_LOCK(m_dumpLock)
+RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
+INTR_STATE
+// Warning C26165 Possibly failing to release lock 'm_dumpLock' in function 'DumpTakeLock'
+// This is because SAL does not understand who m_dumpLock is
+#pragma warning(suppress: 26165)
+DumpTakeLock(
+    void
+    )
+{
+    INTR_STATE oldState;
+
+    RecRwSpinlockAcquireExclusive(&m_dumpLock, &oldState);
+
+    return oldState;
+}
+
+REQUIRES_EXCL_LOCK(m_dumpLock) 
+RELEASES_EXCL_AND_REENTRANT_LOCK(m_dumpLock)
+void
+DumpReleaseLock(
+    IN INTR_STATE   OldIntrState
+    )
+{
+    RecRwSpinlockReleaseExclusive(&m_dumpLock, OldIntrState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_cpu.c b/src_proiect/HAL9000/src/dmp_cpu.c
new file mode 100644
index 0000000..2aefa12
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_cpu.c
@@ -0,0 +1,144 @@
+#include "HAL9000.h"
+#include "dmp_cpu.h"
+#include "dmp_common.h"
+
+#define MAX_REGISTER_NAME_LENGTH        3
+#define MAX_LEAF_NAME_LENGTH            50
+
+// +1 because of NULL terminator
+static const char REGISTER_NAMES[RegisterR15 + 1][MAX_REGISTER_NAME_LENGTH + 1] = { "RAX", "RCX", "RDX", "RBX", "RSP", "RBP", "RSI", "RDI",
+                                                                                    "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"
+                                                                                    };
+
+static const char CPUID_LEAF_NAMES[][MAX_LEAF_NAME_LENGTH] = { "Basic Information", "Feature Information", "Cache Information", "Reserved", "Deterministic Cache",
+                                                               "Monitor Leaf", "Power Management Leaf", "Extended Feature Flags Leaf", "Reserved", "Direct Cache Access Leaf",
+                                                                "Architectural Performance Monitoring Leaf",  "Extended Topology Enumeration Leaf", "Reserved", "Processor Extended State Leaf",
+                                                                };
+
+const
+char*
+RetrieveCpuIdLeafName(
+    IN      DWORD                             Index
+    )
+{
+    if (Index >= ARRAYSIZE(CPUID_LEAF_NAMES))
+    {
+        return "Unknown";
+    }
+
+    return CPUID_LEAF_NAMES[Index];
+}
+
+const
+char*
+RetrieveRegisterName(
+    IN      GeneralPurposeRegisterIndexes     Index
+    )
+{
+    if (Index > RegisterR15)
+    {
+        return NULL;
+    }
+
+    return REGISTER_NAMES[Index];
+}
+
+void
+DumpRegisterArea(
+    IN  REGISTER_AREA*                  RegisterArea
+    )
+{
+    ASSERT(RegisterArea != NULL);
+
+    for (DWORD i = 0; i <= RegisterR15; ++i)
+    {
+        QWORD regValue = RegisterArea->RegisterValues[i];
+
+        LOG("%s: 0x%X\n", RetrieveRegisterName(i), regValue);
+    }
+
+    LOG("RIP: 0x%X\n", RegisterArea->Rip);
+    LOG("Rflags: 0x%X\n", RegisterArea->Rflags);
+}
+
+void
+DumpProcessorState(
+    IN  COMPLETE_PROCESSOR_STATE*    ProcessorState
+    )
+{
+    INTR_STATE intrState;
+
+    ASSERT( NULL != ProcessorState);
+
+    intrState = DumpTakeLock();
+    LOG("\nProcessor State:\n");
+
+    DumpRegisterArea(&ProcessorState->RegisterArea);
+
+    DumpReleaseLock(intrState);
+}
+
+void
+DumpControlRegisters(
+    void
+    )
+{
+    INTR_STATE intrState;
+
+    intrState = DumpTakeLock();
+    LOG("\nControl registers:\n");
+    LOG("CR0: 0x%X\n", __readcr0());
+    LOG("CR2: 0x%X\n", __readcr2());
+    LOG("CR3: 0x%X\n", __readcr3());
+    LOG("CR4: 0x%X\n", __readcr4());
+    LOG("CR8: 0x%X\n", __readcr8());
+    DumpReleaseLock(intrState);
+}
+
+void
+DumpInterruptStack(
+    IN  PINTERRUPT_STACK_COMPLETE       InterruptStack,
+    IN  BOOLEAN                         ErrorCodeValid
+    )
+{
+    INTR_STATE intrState;
+
+    intrState = DumpTakeLock();
+    LOG("\nInterrupt stack:\n");
+    if (ErrorCodeValid)
+    {
+        LOG("Error code: 0x%x\n", InterruptStack->ErrorCode);
+    }
+
+    LOG("RIP: 0x%X\n",      InterruptStack->Registers.Rip);
+    LOG("CS: 0x%X\n",       InterruptStack->Registers.CS);
+    LOG("RFLAGS: 0x%X\n",   InterruptStack->Registers.RFLAGS);
+    LOG("RSP: 0x%X\n",      InterruptStack->Registers.Rsp);
+    LOG("SS: 0x%X\n",       InterruptStack->Registers.SS);
+
+    DumpReleaseLock(intrState);
+}
+
+void
+DumpFeatureInformation(
+    IN  PCPUID_FEATURE_INFORMATION       FeatureInformation
+    )
+{
+    ASSERT( NULL != FeatureInformation);
+}
+
+void
+DumpCpuidValues(
+    IN  DWORD               Index,
+    IN  DWORD               SubIndex,
+    IN  CPUID_INFO          Cpuid
+    )
+{
+    LOG("Cpuid[0x%x]: [%s]\n", Index, RetrieveCpuIdLeafName(Index));
+    LOG("Subindex: 0x%x\n", SubIndex);
+
+    LOG("\t0x%08x EAX\n", Cpuid.eax);
+    LOG("\t0x%08x EBX\n", Cpuid.ebx);
+    LOG("\t0x%08x ECX\n", Cpuid.ecx);
+    LOG("\t0x%08x EDX\n", Cpuid.edx);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_disk.c b/src_proiect/HAL9000/src/dmp_disk.c
new file mode 100644
index 0000000..31385b1
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_disk.c
@@ -0,0 +1,60 @@
+#include "HAL9000.h"
+#include "pci.h"
+#include "list.h"
+#include "dmp_disk.h"
+#include "dmp_volume.h"
+#include "dmp_common.h"
+
+static FUNC_ListFunction        _DumpDiskVolume;
+
+void
+DumpDisk(
+    IN      PDISK_OBJECT        Disk
+    )
+{
+    DWORD i;
+    INTR_STATE intrState;
+
+    ASSERT( NULL != Disk );
+
+    intrState = DumpTakeLock();
+    LOG("Number of sectors: 0x%X\n", Disk->NumberOfSectors);
+    LOG("Number of partitions: %d\n", Disk->DiskLayout->NumberOfPartitions);
+
+    for (i = 0; i < Disk->DiskLayout->NumberOfPartitions; ++i)
+    {
+        DumpPartition(&Disk->DiskLayout->Partitions[i]);
+    }
+    DumpReleaseLock(intrState);
+}
+
+void
+DumpPartition(
+    IN      PPARTITION_INFORMATION  Partition
+    )
+{
+    ASSERT( NULL != Partition );
+
+    LOG("Partition offset: 0x%X\n", Partition->OffsetInDisk);
+    LOG("Partition size: 0x%X\n", Partition->PartitionSize);
+    LOG("Partition type: 0x%x\n", Partition->PartitionType);
+    LOG("Partition bootable: 0x%x\n", Partition->Bootable);
+}
+
+STATUS
+(__cdecl _DumpDiskVolume) (
+    IN      PLIST_ENTRY ListEntry,
+    IN_OPT  PVOID       FunctionContext
+    )
+{
+    PVOLUME_LIST_ENTRY pVolumeEntry;
+
+    ASSERT(NULL != ListEntry);
+    ASSERT(NULL == FunctionContext);
+
+    pVolumeEntry = CONTAINING_RECORD(ListEntry, VOLUME_LIST_ENTRY, ListEntry);
+    DumpVolume(IoGetDeviceExtension(pVolumeEntry->Volume));
+
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_int15.c b/src_proiect/HAL9000/src/dmp_int15.c
new file mode 100644
index 0000000..6a2b1de
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_int15.c
@@ -0,0 +1,18 @@
+#include "HAL9000.h"
+#include "dmp_int15.h"
+
+void
+DumpInt15Entry(
+    IN  PINT15_MEMORY_MAP_ENTRY     MemoryMapEntry
+    )
+{
+    if (NULL == MemoryMapEntry)
+    {
+        return;
+    }
+
+    LOG("BaseAddress: 0x%X\n", MemoryMapEntry->BaseAddress);
+    LOG("Size: 0x%X\n", MemoryMapEntry->Length);
+    LOG("Type: %d\n", MemoryMapEntry->Type);
+    LOG("Extended attributed: 0x%x\n", MemoryMapEntry->ExtendedAttributes);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_io.c b/src_proiect/HAL9000/src/dmp_io.c
new file mode 100644
index 0000000..01efe04
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_io.c
@@ -0,0 +1,181 @@
+#include "HAL9000.h"
+#include "dmp_io.h"
+
+#include "../../Volume/headers/volume_structures.h"
+#include "filesystem.h"
+
+#define DEVICE_TYPE_MAX_NAME_LEN            25
+
+static const char DEVICE_TYPE_NAMES[][DEVICE_TYPE_MAX_NAME_LEN] = {
+    "System",
+    "Harddisk Controller",
+    "Disk",
+    "Volume",
+    "File System",
+    "Physical Netcard",
+};
+
+__forceinline
+static
+const
+char*
+_PartitionTypeToString(
+    IN      BYTE            PartitionType
+    )
+{
+    switch (PartitionType)
+    {
+    case PARTITION_TYPE_NTFS:
+        return "NTFS";
+    case PARTITION_TYPE_FAT_CHS:
+        return "FAT-CHS";
+    case PARTITION_TYPE_FAT_LBA:
+        return "FAT-LBA";
+    case PARTITION_TYPE_FAT16_LBA:
+        return "FAT16-LBA";
+    case PARTITION_TYPE_LINUX_SWAP:
+        return "LINUX-SWP";
+    case PARTITION_TYPE_LINUX_NATIVE:
+        return "LINUX-NAT";
+    case PARTITION_TYPE_MICROSOFT_PROTECTIVE_MBR:
+        return "MS PRT MBR";
+    case PARTITION_TYPE_INTEL_PROTECTIVE_MBR:
+        return "IT PRT MBR";
+    default:
+        return "UNKNOWN";
+    }
+}
+
+__forceinline
+static
+const
+char*
+_DeviceTypeToString(
+    IN      DEVICE_TYPE     DeviceType
+    )
+{
+    return DEVICE_TYPE_NAMES[DeviceType];
+}
+
+STATUS
+(__cdecl DumpVpb) (
+    IN      PLIST_ENTRY ListEntry,
+    IN_OPT  PVOID       FunctionContext
+    )
+{
+    PVPB pVpb;
+    PVOLUME pVolume;
+
+    ASSERT(NULL != ListEntry);
+    ASSERT(NULL == FunctionContext);
+
+    pVpb = CONTAINING_RECORD(ListEntry, VPB, NextVpb);
+
+    pVolume = IoGetDeviceExtension(pVpb->VolumeDevice);
+    ASSERT(NULL != pVolume);
+
+    LOG("%c:\\%4c", pVpb->VolumeLetter, '|');
+    LOG("%10s(0x%02x)%c", _PartitionTypeToString(pVolume->PartitionInformation.PartitionType), pVolume->PartitionInformation.PartitionType, '|');
+    LOG("%9s%c", pVpb->Flags.Mounted ? "YES" : "NO", '|');
+    LOG("%9s%c", pVolume->PartitionInformation.Bootable ? "YES" : "NO", '|');
+    LOG("%16X%c", pVolume->PartitionInformation.OffsetInDisk * SECTOR_SIZE, '|');
+    LOG("%16X%c", pVolume->PartitionInformation.PartitionSize * SECTOR_SIZE, '|');
+
+    LOG("\n");
+
+    return STATUS_SUCCESS;
+}
+
+void
+DumpDriverList(
+    IN      PLIST_ENTRY     DriverList
+    )
+{
+    PDRIVER_OBJECT pDriverObject;
+    PLIST_ENTRY pCurEntry;
+
+    if (NULL == DriverList)
+    {
+        return;
+    }
+
+
+    for(pCurEntry = DriverList->Flink;
+        pCurEntry != DriverList;
+        pCurEntry = pCurEntry->Flink)
+    {
+        pDriverObject = CONTAINING_RECORD(pCurEntry, DRIVER_OBJECT, NextDriver);
+
+        LOG("\n");
+        DumpDriver(pDriverObject);
+    }
+}
+
+void
+DumpDriver(
+    IN      PDRIVER_OBJECT  Driver
+    )
+{
+    DWORD i;
+
+    if (NULL == Driver)
+    {
+        return;
+    }
+    
+    LOG("Driver at 0x%X\n", Driver);
+    LOG("Name: %s\n", Driver->DriverName);
+    LOG("Dispatch functions:\n");
+    for (i = 0; i < IRP_MJ_MAX; ++i)
+    {
+        LOG("DispatchFunction[%u] = 0x%X\n", i, Driver->DispatchFunctions[i]);
+    }
+
+    LOG("Device number: %d\n", Driver->NoOfDevices);
+    if (0 != Driver->NoOfDevices)
+    {
+        LOG("Device list:\n");
+        DumpDeviceList(&Driver->DeviceList);
+    }
+}
+
+void
+DumpDeviceList(
+    IN      PLIST_ENTRY     DeviceList
+    )
+{
+    PDEVICE_OBJECT pDeviceObject;
+    PLIST_ENTRY pCurEntry;
+
+    if (NULL == DeviceList)
+    {
+        return;
+    }
+
+    for(pCurEntry = DeviceList->Flink;
+        pCurEntry != DeviceList;
+        pCurEntry = pCurEntry->Flink)
+    {
+        pDeviceObject = CONTAINING_RECORD(pCurEntry, DEVICE_OBJECT, NextDevice);
+
+        DumpDevice(pDeviceObject);
+        LOG("\n");
+    }
+}
+
+void
+DumpDevice(
+    IN      PDEVICE_OBJECT  Device
+    )
+{
+    if (NULL == Device)
+    {
+        return;
+    }
+
+    LOG("Device at 0x%X\n", Device);
+    LOG("Device type: %s\n", _DeviceTypeToString(Device->DeviceType));
+    LOG("Stack size: %d\n", Device->StackSize);
+    LOG("Device extension size: 0x%x\n", Device->DeviceExtensionSize);
+    LOG("Attached to device: 0x%X\n", Device->AttachedDevice);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_ioapic.c b/src_proiect/HAL9000/src/dmp_ioapic.c
new file mode 100644
index 0000000..e4090b3
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_ioapic.c
@@ -0,0 +1,84 @@
+#include "HAL9000.h"
+#include "ioapic.h"
+#include "dmp_common.h"
+#include "../../HAL/headers/ioapic_registers.h"
+
+__forceinline
+static
+const
+char*
+_DeliveryModeToString(
+    IN      APIC_DELIVERY_MODE      DeliveryMode
+    )
+{
+    switch (DeliveryMode)
+    {
+    case ApicDeliveryModeFixed:
+        return "FIXED";
+    case ApicDeliveryModeLowest:
+        return "LOWEST";
+    case ApicDeliveryModeSMI:
+        return "SMI";
+    case ApicDeliveryModeNMI:
+        return "NMI";
+    case ApicDeliveryModeINIT:
+        return "INIT";
+    case ApicDeliveryModeSIPI:
+        return "SIPI";
+    case ApicDeliveryModeExtINT:
+        return "EXTINT";
+    default:
+        return "UNKNOWN";
+    }
+}
+
+extern IO_APIC_REDIR_TABLE_ENTRY
+_IoApicReadRedirectionEntry(
+    IN      PIO_APIC        IoApic,
+    IN      BYTE            Index
+    );
+
+void
+DumpIoApic(
+    IN      PVOID       IoApicBaseAddress
+    )
+{
+    INTR_STATE oldState;
+
+    ASSERT( NULL != IoApicBaseAddress );
+
+    oldState = DumpTakeLock();
+
+    LOG("ELCR 1: 0b%08b\n", __inbyte(0x4d0));
+    LOG("ELCR 2: 0b%08b\n", __inbyte(0x4d1));
+
+    LOG("IO Apic ID: 0x%x\n", IoApicGetId(IoApicBaseAddress));
+    LOG("Apic version: 0x%x\n", IoApicGetVersion(IoApicBaseAddress));
+    LOG("Max redirection entry: 0x%x\n", IoApicGetMaximumRedirectionEntry(IoApicBaseAddress));
+    LOG("%6s", "Index|");
+    LOG("%7s", "Vector|");
+    LOG("%7s", "Masked|");
+    LOG("%14s", "Delivery Mode|");
+    LOG("%17s", "Destination Mode|");
+    LOG("%8s", "Trigger|");
+    LOG("%9s", "Polarity|");
+    LOG("%8s", "APIC ID|");
+    LOG("\n");
+    for (BYTE i = 0; i <= IoApicGetMaximumRedirectionEntry(IoApicBaseAddress); ++i)
+    {
+        IO_APIC_REDIR_TABLE_ENTRY entry = _IoApicReadRedirectionEntry(IoApicBaseAddress,i);
+
+        LOG("%3c%02x|", ' ', i );
+        LOG("%4c%02x|", ' ', entry.Vector);
+        LOG("%6s|", entry.Masked ? "YES" : "NO");
+        LOG("%13s|", _DeliveryModeToString(entry.DeliveryMode));
+        LOG("%16s|", entry.DestinationMode == ApicDestinationModePhysical ? "PHYSICAL" : "LOGICAL" );
+        LOG("%7s|", entry.TriggerMode == ApicTriggerModeEdge ? "EDGE" : "LEVEL" );
+        LOG("%8s|", entry.PinPolarity == ApicPinPolarityActiveHigh ? "HIGH" : "LOW" );
+        LOG("%5c%02x|", ' ', entry.Destination );
+
+        LOG("\n");
+    }
+
+    DumpReleaseLock(oldState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_lapic.c b/src_proiect/HAL9000/src/dmp_lapic.c
new file mode 100644
index 0000000..7010e7a
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_lapic.c
@@ -0,0 +1,168 @@
+#include "HAL9000.h"
+#include "dmp_common.h"
+#include "cpu.h"
+#include "../../HAL/headers/lapic_registers.h"
+
+static
+void
+_DumpLapicLogicalDestination(
+    IN      PLAPIC          Apic
+    );
+
+static
+void
+_DumpLapicLvt(
+    IN      LVT_REGISTER    LvtEntry,
+    IN      BOOLEAN         ErrorRegister
+    );
+
+static
+void
+_DumpLapicLint(
+    IN      LVT_REGISTER    Lint
+    );
+
+static
+void
+_DumpLapicTimer(
+    IN      PLAPIC          Apic
+    );
+
+void
+DumpLapic(
+    IN      PVOID           LapicBaseAddress
+    )
+{
+    PLAPIC pLapic;
+    DWORD i;
+    LAPIC_VERSION_REGISTER lapicVersion;
+    LVT_REGISTER lvtReg;
+    SVR_REGISTER svrReg;
+    INTR_STATE oldState;
+
+    ASSERT(NULL != LapicBaseAddress);
+
+    pLapic = (PLAPIC) LapicBaseAddress;
+    
+    lapicVersion.Raw = pLapic->ApicVersion.Value;
+    svrReg.Raw = pLapic->SpuriousInterruptVector.Value;
+
+    oldState = DumpTakeLock();
+
+    LOG("\nLAPIC on CPU %02x\n", CpuGetApicId() );
+    _DumpLapicLogicalDestination(pLapic);
+    LOG("Apic is SW %s\n", svrReg.ApicEnable ? "ENABLED" : "DISABLED");
+    LOG("Spurious vector: 0x%x\n", svrReg.Vector );
+    LOG("EOI broadcast suppression: 0x%x\n", svrReg.EOIBroadcastSuppresion );
+    LOG("Focus processor checking: 0x%x\n", svrReg.FocusProcessorChecking );
+    LOG("Lapic version: 0x%x\n", lapicVersion.Version );
+    LOG("Max LVT entry: 0x%x\n", lapicVersion.MaxLvtEntry );
+    LOG("Error status: 0x%x\n", pLapic->ErrorStatus.Value );
+    LOG("Task priority: 0x%x\n", pLapic->TPR.Value );
+    LOG("Processor priority: 0x%x\n", pLapic->PPR.Value );
+    LOG("Arbitration priority: 0x%x\n", pLapic->APR.Value );
+
+    for (i = 0; i < 8; ++i)
+    {
+        DWORD startIndex = i * BITS_FOR_STRUCTURE(DWORD);
+        DWORD endIndex = ( i + 1 ) * BITS_FOR_STRUCTURE(DWORD) - 1;
+
+        LOG("IRR [0x%02x - 0x%02x]: 0b%032b\n", 
+            endIndex, startIndex, pLapic->IRR[i].Value);
+        LOG("ISR [0x%02x - 0x%02x]: 0b%032b\n", 
+            endIndex, startIndex, pLapic->ISR[i].Value);
+        LOG("TMR [0x%02x - 0x%02x]: 0b%032b\n", 
+            endIndex, startIndex, pLapic->TMR[i].Value);
+    }
+
+    LOG("LINT0:\n");
+    lvtReg.Raw = pLapic->LvtLINT0.Value;
+    _DumpLapicLint(lvtReg);
+
+    LOG("LINT1:\n");
+    lvtReg.Raw = pLapic->LvtLINT1.Value;
+    _DumpLapicLint(lvtReg);
+
+    LOG("CMCI:\n");
+    lvtReg.Raw = pLapic->LvtCMCI.Value;
+    _DumpLapicLvt(lvtReg, FALSE);
+
+    LOG("Error:\n");
+    lvtReg.Raw = pLapic->LvtError.Value;
+    _DumpLapicLvt(lvtReg, TRUE);
+
+    LOG("Performance counter:\n");
+    lvtReg.Raw = pLapic->LvtPerformanceMonitoringCounters.Value;
+    _DumpLapicLvt(lvtReg, FALSE);
+
+    LOG("Thermal sensor:\n");
+    lvtReg.Raw = pLapic->LvtThermalSensor.Value;
+    _DumpLapicLvt(lvtReg, FALSE);
+
+    _DumpLapicTimer(pLapic);
+
+    DumpReleaseLock(oldState);
+}
+
+static
+void
+_DumpLapicLogicalDestination(
+    IN      PLAPIC          Apic
+    )
+{
+    LDR_REGISTER ldrRegister;
+
+    ldrRegister.Raw = Apic->LogicalDestination.Value;
+
+    LOG("Logical destination: 0x%02x\n", ldrRegister.LogicalApicId );
+    LOG("Destination format: 0x%08x\n", Apic->DestinationFormat.Value );
+}
+
+static
+void
+_DumpLapicLvt(
+    IN      LVT_REGISTER    LvtEntry,
+    IN      BOOLEAN         ErrorOrTimerRegister
+    )
+{
+    LOG("Vector: 0x%x\n", LvtEntry.Vector );
+    if (!ErrorOrTimerRegister)
+    {
+        LOG("Delivery mode: 0b%b\n", LvtEntry.DeliveryMode );
+    }
+    LOG("Delivery status: [%s]\n", ( 0 == LvtEntry.DeliveryStatus ) ? "Idle" : "Send Pending" );
+    LOG("Masked: [%s]\n", ( 0 == LvtEntry.Masked ) ? "FALSE" : "TRUE" );
+}
+
+static
+void
+_DumpLapicLint(
+    IN      LVT_REGISTER    Lint
+    )
+{
+    _DumpLapicLvt(Lint, FALSE);
+    LOG("Pin polarity: 0x%x\n", Lint.PinPolarity );
+    LOG("Remote IRR: 0x%x\n", Lint.RemoteIRR);
+    LOG("Trigger mode: [%s]\n", ( 0 == Lint.TriggerMode ) ? "Edge" : "Level" );
+}
+
+static
+void
+_DumpLapicTimer(
+    IN      PLAPIC          Apic
+    )
+{
+    LVT_REGISTER lvtReg;
+
+    ASSERT( NULL != Apic );
+
+    LOG("Timer:\n");
+
+    lvtReg.Raw = Apic->LvtTimer.Value;
+    LOG("Timer mode: 0x%x\n", lvtReg.TimerMode);
+    _DumpLapicLvt(lvtReg, TRUE);
+
+    LOG("Divide configuration: 0x%x\n", Apic->TimerDivideConfiguration.Value );
+    LOG("Initial count: 0x%x\n", Apic->TimerInitialCount.Value );
+    LOG("Current count: 0x%x\n", Apic->TimerCurrentCount.Value );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_mbr.c b/src_proiect/HAL9000/src/dmp_mbr.c
new file mode 100644
index 0000000..abffbdc
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_mbr.c
@@ -0,0 +1,43 @@
+#include "HAL9000.h"
+#include "dmp_mbr.h"
+#include "dmp_memory.h"
+
+static
+void
+_DumpMbrPartitionEntry(
+    IN      PMBR_PARTITION_ENTRY        PartitionEntry
+    )
+{
+    if (NULL == PartitionEntry)
+    {
+        return;
+    }
+
+    LOG("Status: 0x%x\n", PartitionEntry->Status);
+    LOG("Partition type: 0x%x\n", PartitionEntry->PartitionType);
+    LOG("First sector (LBA): 0x%x\n", PartitionEntry->FirstSectorLBA);
+    LOG("Number of sectors: 0x%x\n", PartitionEntry->NumberOfSectors);
+}
+
+void
+DumpMbr(
+    IN      PMBR                        Mbr
+    )
+{
+    DWORD i;
+
+    if (NULL == Mbr)
+    {
+        return;
+    }
+
+    for (i = 0; i < MBR_NO_OF_PARTITIONS; ++i)
+    {
+        LOG("Partition %d\n", i);
+        _DumpMbrPartitionEntry(&Mbr->Partitions[i]);
+    }
+
+    LOG("MBR signature: 0x%x\n", Mbr->BootSignature);
+
+    DumpMemory(Mbr, 0, sizeof(MBR), TRUE, TRUE );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_mdl.c b/src_proiect/HAL9000/src/dmp_mdl.c
new file mode 100644
index 0000000..1de66f6
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_mdl.c
@@ -0,0 +1,29 @@
+#include "HAL9000.h"
+#include "io.h"
+#include "dmp_mdl.h"
+
+void 
+DumpMdl(
+    IN PMDL Mdl
+    )
+{
+    DWORD i;
+
+    if (NULL == Mdl)
+    {
+        return;
+    }
+
+    LOG("Will dump MDL found at 0x%X\n", Mdl );
+    LOG("Start VA: 0x%X\n", Mdl->StartVa );
+    LOG("Byte offset: 0x%x\n", Mdl->ByteOffset );
+    LOG("Byte count: 0x%x\n", Mdl->ByteCount );
+    LOG("Number of translation pairs: %u\n", Mdl->NumberOfTranslationPairs );
+
+    for (i = 0; i < Mdl->NumberOfTranslationPairs; ++i)
+    {
+        LOG("PA: 0x%X, #of bytes: %u\n", 
+            Mdl->Translations[i].Address, Mdl->Translations[i].NumberOfBytes
+            );
+    }
+}
diff --git a/src_proiect/HAL9000/src/dmp_memory.c b/src_proiect/HAL9000/src/dmp_memory.c
new file mode 100644
index 0000000..3116b91
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_memory.c
@@ -0,0 +1,86 @@
+#include "HAL9000.h"
+#include "dmp_memory.h"
+#include "dmp_common.h"
+#include "strutils.h"
+
+void
+DumpMemory(
+    IN      PVOID           LogicalAddress,
+    IN      QWORD           Offset,
+    IN      DWORD           Size,
+    IN      BOOLEAN         DisplayAddress,
+    IN      BOOLEAN         DisplayAscii
+    )
+{
+    DWORD index;
+    DWORD charPosition;
+    PBYTE pCurAddress;
+    char currentLine[3 * DUMP_LINE_WIDTH + 1];
+    char currentAddress[LONG_ADDRESS_DIGITS + 1];
+    char tempStr[3];
+    char asciiLine[DUMP_LINE_WIDTH + 1];
+    DWORD curValue;
+    PVOID pointerToCurAddress;
+    PBYTE pCurrentOffset;
+    BOOLEAN bLogState;
+    INTR_STATE oldState;
+
+    ASSERT(NULL != LogicalAddress);
+    ASSERT(0 != Size );
+
+    bLogState = LogSetState(TRUE);
+
+    pCurAddress = (PBYTE)LogicalAddress;
+    charPosition = 0;
+    pCurrentOffset = (PBYTE) Offset;
+
+    oldState = DumpTakeLock();
+
+    for (index = 0; index < Size; ++index)
+    {
+        curValue = pCurAddress[index];
+        snprintf(tempStr, 3, "%02x", curValue);
+
+        currentLine[3 * charPosition] = tempStr[0];
+        currentLine[3 * charPosition + 1] = tempStr[1];
+        currentLine[3 * charPosition + 2] = ' ';
+        
+        snprintf(tempStr, 3, "%c", curValue);
+        asciiLine[charPosition] = isascii(tempStr[0]) ? tempStr[0] : ' ';
+
+        charPosition++;
+
+        if (0 == ((index + 1) % DUMP_LINE_WIDTH))
+        {
+            currentLine[3 * charPosition] = '\0';
+            asciiLine[charPosition] = '\0';
+            charPosition = 0;
+
+            pointerToCurAddress = pCurrentOffset + (index / DUMP_LINE_WIDTH) * DUMP_LINE_WIDTH;
+            snprintf(currentAddress, 17, "%012X", pointerToCurAddress);
+
+            if (DisplayAddress)
+            {
+                LOG("%s| ", currentAddress);
+            }
+            LOG("%s", currentLine);
+            if (DisplayAscii)
+            {
+                LOG("|%s", asciiLine);
+            }
+            LOG("\n");
+        }
+    }
+
+    /// TODO: properly log last line (address + ascii representation)
+    // log the last line
+    if (0 != charPosition)
+    {
+        currentLine[3 * charPosition] = '\0';
+        LOG("%s\n", currentLine);
+    }
+
+     LogSetState(bLogState);
+
+     DumpReleaseLock(oldState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_multiboot.c b/src_proiect/HAL9000/src/dmp_multiboot.c
new file mode 100644
index 0000000..47c6f4c
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_multiboot.c
@@ -0,0 +1,72 @@
+#include "HAL9000.h"
+#include "dmp_multiboot.h"
+
+void
+DumpMultiBootInformation(
+    IN MULTIBOOT_INFORMATION* MultibootInformation
+    )
+{
+
+    if (NULL == MultibootInformation)
+    {
+        return;
+    }
+
+    LOG("\n");
+    LOG("-----------------------------\n");
+    LOG("Multiboot structure at: 0x%X\n", MultibootInformation);
+    LOG("Flags: 0b%b\n", MultibootInformation->Flags);
+    LOG("Lower Memory Size: %D bytes\n", MultibootInformation->LowerMemorySize * KB_SIZE);
+    LOG("Higher Memory SIze: %D bytes\n", MultibootInformation->HigherMemorySize * KB_SIZE);
+    LOG("Boot device: 0x%x\n", MultibootInformation->BootDevice);
+    // command line
+    // module information
+    LOG("Memory map address: 0x%X\n", MultibootInformation->MemoryMapAddress);
+    LOG("Size of memory map: %d bytes\n", MultibootInformation->MemoryMapSize);
+
+    if (IsBooleanFlagOn(MultibootInformation->Flags, MULTIBOOT_FLAG_LOADER_NAME_PRESENT))
+    {
+        // warning C4312: 'type cast': conversion from 'const DWORD' to 'char *' of greater size
+#pragma warning(suppress:4312)
+        LOG("Loader name: %s\n", (char*)MultibootInformation->BootLoaderName);
+    }
+    LOG("-----------------------------");
+    LOG("\n");
+
+    if (IsBooleanFlagOn(MultibootInformation->Flags, MULTIBOOT_FLAG_BOOT_MODULES_PRESENT))
+    {
+        LOG("%u boot modules are present!\n", MultibootInformation->ModuleCount);
+        LOG("Boot modules are at 0x%X\n", MultibootInformation->ModuleAddress);
+
+        for (DWORD i = 0; i < MultibootInformation->ModuleCount; ++i)
+        {
+            PMULTIBOOT_MODULE_INFORMATION pModuleInformation = &((PMULTIBOOT_MODULE_INFORMATION)(QWORD)MultibootInformation->ModuleAddress)[i];
+
+            LOG("Module between 0x%X -> 0x%X\n",
+                pModuleInformation->ModuleStartPhysAddr, pModuleInformation->ModuleEndPhysAddr);
+
+            LOG("Module name is [%s]\n",
+                (char*)(QWORD)pModuleInformation->StringPhysAddr);
+        }
+    }
+}
+
+void
+DumpParameters(
+    IN ASM_PARAMETERS* Parameters
+    )
+{
+    if (NULL == Parameters)
+    {
+        return;
+    }
+
+    LOG("Kernel base address: 0x%X\n", Parameters->KernelBaseAddress);
+    LOG("Kernel code size: 0x%X\n", Parameters->KernelSize);
+    LOG("VA2PA offset: 0x%X\n", Parameters->VirtualToPhysicalOffset);
+
+    LOG("Number of entries: %d\n", Parameters->MemoryMapEntries );
+    LOG("PA of memory map: 0x%X\n", Parameters->MemoryMapAddress );
+
+    DumpMultiBootInformation(Parameters->MultibootInformation);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_net_device.c b/src_proiect/HAL9000/src/dmp_net_device.c
new file mode 100644
index 0000000..1bf7cfb
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_net_device.c
@@ -0,0 +1,30 @@
+#include "HAL9000.h"
+#include "dmp_net_device.h"
+#include "network_utils.h"
+#include "dmp_common.h"
+
+void
+DumpNetworkDevice(
+    IN      PNETWORK_DEVICE_INFO        NetworkDevice
+    )
+{
+    char macAddress[TEXT_MAC_ADDRESS_CHARS_REQUIRED];
+    INTR_STATE intrState;
+
+    ASSERT( NULL != NetworkDevice );
+
+    intrState = DumpTakeLock();
+    LOG("Device ID: 0x%x\n", NetworkDevice->DeviceId );
+
+    NetUtilMacAddressToText(NetworkDevice->PhysicalAddress, macAddress);
+
+    LOG("Mac address [%s]\n", macAddress );
+    LOG("Link status is [%s]\n", NetworkDevice->LinkStatus ? "UP" : "DOWN" );
+    LOG("Device RX is [%s]\n", 
+        NetworkDevice->DeviceStatus.RxEnabled ? "ENABLED" : "DISABLED"
+        );
+    LOG("Device TX is [%s]\n",
+        NetworkDevice->DeviceStatus.TxEnabled ? "ENABLED" : "DISABLED"
+        );
+    DumpReleaseLock(intrState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_network.c b/src_proiect/HAL9000/src/dmp_network.c
new file mode 100644
index 0000000..7fae211
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_network.c
@@ -0,0 +1,214 @@
+#include "HAL9000.h"
+#include "dmp_network.h"
+#include "network_utils.h"
+#include "dmp_memory.h"
+#include "dmp_common.h"
+
+static
+const
+char*
+_DumpEthTypeToString(
+    IN      ETHERNET_FRAME_TYPE FrameType
+    )
+{
+    switch (FrameType)
+    {
+    case ETHERNET_FRAME_TYPE_IP4:
+        return "IP4";
+    case ETHERNET_FRAME_TYPE_ARP:
+        return "ARP";
+    case ETHERNET_FRAME_TYPE_RARP:
+        return "RARP";
+    case ETHERNET_FRAME_TYPE_VLAN:
+        return "VLAN";
+    case ETHERNET_FRAME_TYPE_IP6:
+        return "IP6";
+    case ETHERNET_FRAME_TYPE_LLDP:
+        return "LLDP";
+    default:
+        LOGL("Frame type: [0x%x]\n", FrameType);
+        NOT_REACHED;
+        return "UNKNOWN";
+    }
+}
+
+static
+const
+char*
+_DumpProtocolTypeToString(
+    IN      IP_PROTOCOL     Protocol
+    )
+{
+    switch (Protocol)
+    {
+    case IP_PROTOCOL_ICMP:
+        return "ICMP";
+    case IP_PROTOCOL_IGMP:
+        return "IGMP";
+    case IP_PROTOCOL_TCP:
+        return "TCP";
+    case IP_PROTOCOL_UDP:
+        return "UDP";
+    default:
+        LOGL("Protocol: [0x%x]\n", Protocol);
+        NOT_REACHED;
+        return "UNKNOWN";
+    }
+}
+
+void
+DumpEthernetFrame(
+    IN      PETHERNET_FRAME     Frame,
+    IN      DWORD               BufferSize
+    )
+{
+    ETHERNET_FRAME_TYPE frameType;
+    char srcAddress[TEXT_MAC_ADDRESS_CHARS_REQUIRED];
+    char dstAddress[TEXT_MAC_ADDRESS_CHARS_REQUIRED];
+    DWORD remainingSize;
+    INTR_STATE oldState;
+
+    ASSERT( NULL != Frame );
+    ASSERT( BufferSize >= sizeof(ETHERNET_FRAME) );
+
+    NetUtilMacAddressToText(Frame->Source, srcAddress);
+    NetUtilMacAddressToText(Frame->Destination, dstAddress);
+    frameType = ntohw(Frame->Type);
+
+    oldState = DumpTakeLock();
+    LOG("Ethernet frame of type: 0x%x [%s]\nSource: [%s]\nDestination: [%s]\n\n", 
+        frameType,
+        _DumpEthTypeToString(frameType),
+        srcAddress,
+        dstAddress
+        );
+
+    remainingSize = BufferSize - sizeof(ETHERNET_FRAME);
+
+    switch (frameType)
+    {
+    case ETHERNET_FRAME_TYPE_ARP:
+        DumpArpPacket((PARP_PACKET)Frame->Data,
+                      remainingSize
+                      );
+        break;
+    case ETHERNET_FRAME_TYPE_IP4:
+        DumpIp4Packet((PIP4_PACKET)Frame->Data,
+                      remainingSize
+                      );
+        break;
+    default:
+        DumpMemory(Frame->Data,
+                   0,
+                   remainingSize,
+                   FALSE,
+                   TRUE
+                   );
+        break;
+    }
+    DumpReleaseLock(oldState);
+}
+
+void
+DumpArpPacket(
+    IN      PARP_PACKET         ArpPacket,
+    IN      DWORD               BufferSize
+    )
+{
+    char senderHwAddress[TEXT_MAC_ADDRESS_CHARS_REQUIRED];
+    char senderPrtAddress[TEXT_IP4_ADDRESS_CHARS_REQUIRED];
+    char targetHwAddress[TEXT_MAC_ADDRESS_CHARS_REQUIRED];
+    char targetPrtAddress[TEXT_IP4_ADDRESS_CHARS_REQUIRED];
+    ETHERNET_FRAME_TYPE protocolType;
+    ARP_OPERATION arpOperation;
+    HARDWARE_TYPE hwType;
+
+    ASSERT( NULL != ArpPacket );
+    ASSERT( BufferSize >= sizeof(ARP_PACKET) );
+
+    hwType = ntohw(ArpPacket->HardwareType);
+    protocolType = ntohw(ArpPacket->ProtocolType);
+    arpOperation = ntohw(ArpPacket->Operation);
+
+    if (HARDWARE_TYPE_ETHERNET != hwType)
+    {
+        LOG_WARNING("Unknown hardware type: 0x%x\n", ArpPacket->HardwareType );
+        return;
+    }
+
+    if (MAC_ADDRESS_SIZE != ArpPacket->HardwareAddressLength)
+    {
+        LOG_WARNING("Unknown hardware address length: %u\n", ArpPacket->HardwareAddressLength );
+        return;
+    }
+
+    if (ETHERNET_FRAME_TYPE_IP4 != protocolType)
+    {
+        LOG_WARNING("Unknown protocol type: 0x%x\n", protocolType );
+        return;
+    }
+
+    if (IP4_ADDRESS_SIZE != ArpPacket->ProtocolAddressLength)
+    {
+        LOG_WARNING("Unknown protocol address length: %u\n", ArpPacket->ProtocolAddressLength);
+        return;
+    }
+
+    LOG("ARP packet of type [%s]\n"
+        "Sender HW address: [%s]\n"
+        "Sender protocol address: [%s]\n"
+        "Target HW address: [%s]\n"
+        "Target protocol address: [%s]\n\n",
+        ( ARP_OPERATION_REQUEST == arpOperation ) ? "Request" : "Reply",
+        NetUtilMacAddressToText(ArpPacket->SenderHardwareAddress, senderHwAddress),
+        NetUtilIp4AddressToText(ArpPacket->SenderProtocolAddress, senderPrtAddress),
+        NetUtilMacAddressToText(ArpPacket->TargetHardwareAddress, targetHwAddress),
+        NetUtilIp4AddressToText(ArpPacket->TargetProtocolAddress, targetPrtAddress)
+        )
+        ;
+}
+
+void
+DumpIp4Packet(
+    IN      PIP4_PACKET         Ip4Packet,
+    IN      DWORD               BufferSize
+    )
+{
+    char sourceAddress[TEXT_IP4_ADDRESS_CHARS_REQUIRED];
+    char destinationAddress[TEXT_IP4_ADDRESS_CHARS_REQUIRED];
+    DWORD dataLength;
+    DWORD remainingBufferLength;
+
+    ASSERT( NULL != Ip4Packet );
+    ASSERT( BufferSize >= sizeof(IP4_PACKET) );
+
+    dataLength = ntohw(Ip4Packet->Length) - (Ip4Packet->InternetHeaderLength * sizeof(DWORD));
+    remainingBufferLength = BufferSize - sizeof(IP4_PACKET);
+
+    ASSERT(4 == Ip4Packet->Version);
+
+    if (5 != Ip4Packet->InternetHeaderLength)
+    {
+        LOG_WARNING("Unhandled IHL: %u\n", Ip4Packet->InternetHeaderLength);
+        return;
+    }
+    ASSERT_INFO(dataLength <= remainingBufferLength,
+                "Calculated remaining size: %u\nActual size from header: %u\n", 
+                remainingBufferLength,
+                dataLength
+                );
+
+    LOG("IP Packet\n"
+        "Source: [%s]\n"
+        "Destination: [%s]\n"
+        "Length: %u bytes\n"
+        "TTL: %u\n"
+        "Protocol: 0x%x [%s]\n\n",
+        NetUtilIp4AddressToText(Ip4Packet->Source, sourceAddress),
+        NetUtilIp4AddressToText(Ip4Packet->Destination, destinationAddress),
+        dataLength,
+        Ip4Packet->TimeToLive,
+        Ip4Packet->Protocol, _DumpProtocolTypeToString(Ip4Packet->Protocol)
+        )
+        ;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_nt.c b/src_proiect/HAL9000/src/dmp_nt.c
new file mode 100644
index 0000000..9b83e7e
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_nt.c
@@ -0,0 +1,29 @@
+#include "HAL9000.h"
+#include "dmp_nt.h"
+
+void
+DumpNtHeader(
+    IN      PPE_NT_HEADER_INFO      NtHeader
+    )
+{
+    ASSERT( NULL != NtHeader );
+
+    LOG("Image Base: 0x%X\n", NtHeader->ImageBase);
+    LOG("NT base: 0x%X\n", NtHeader->NtBase );
+    LOG("Image Size: 0x%X\n", NtHeader->Size);
+    LOG("Image machine: 0x%x\n", NtHeader->Machine);
+    LOG("Image subsystem: 0x%x\n", NtHeader->Subsystem );
+    LOG("Number of sections: %u\n", NtHeader->NumberOfSections );
+}
+
+void
+DumpNtSection(
+    IN      PPE_SECTION_INFO        SectionInfo
+    )
+{
+    ASSERT( NULL != SectionInfo );
+    
+    LOG("Base address: 0x%X\n", SectionInfo->BaseAddress );
+    LOG("Size: 0x%x\n", SectionInfo->Size );
+    LOG("Characteristics: 0x%x\n", SectionInfo->Characteristics );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_pci.c b/src_proiect/HAL9000/src/dmp_pci.c
new file mode 100644
index 0000000..30cee3e
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_pci.c
@@ -0,0 +1,188 @@
+#include "HAL9000.h"
+#include "dmp_pci.h"
+
+static
+__forceinline
+char*
+_PciCapabilityIdToString(
+    IN PCI_CAPABILITY_ID    Id
+    )
+{
+    switch (Id)
+    {
+    case PCI_CAPABILITY_ID_RESERVED:
+        return "RESERVED";
+    case PCI_CAPABILITY_ID_POWER_MGMT:
+        return "Power Management";
+    case PCI_CAPABILITY_ID_MSI:
+        return "MSI";
+    case PCI_CAPABILITY_ID_VENDOR:
+        return "Vendor specific";
+    case PCI_CAPABILITY_ID_HOT_PLUG:
+        return "PCI Hot Plug";
+    case PCI_CAPABILITY_ID_BRIDGE_SUB_VENDOR:
+        return "PCI Bridge Subsystem Vendor";
+    case PCI_CAPABILITY_ID_SECURE_DEVICE:
+        return "PCI Secure Device";
+    case PCI_CAPABILITY_ID_PCI_EXPRESS:
+        return "PCI Express";
+    case PCI_CAPABILITY_ID_MSIX:
+        return "MSI-X";
+    default:
+        return "UNKNOWN";
+    }
+}
+
+static
+void
+_DumpPciHeader(
+    IN PPCI_COMMON_HEADER Header
+    );
+
+static
+void
+_DumpPciCapabilities(
+    IN PPCI_DEVICE          Device
+    );
+
+static
+void
+_DumpPciCapability(
+    IN PPCI_CAPABILITY_HEADER   Capability
+    );
+
+void
+DumpPciDevice(
+    IN  PPCI_DEVICE_DESCRIPTION     Device
+    )
+{
+    if (NULL == Device)
+    {
+        return;
+    }
+
+    LOG("PCI device at (%d.%d.%d)\n",
+        Device->DeviceLocation.Bus,
+        Device->DeviceLocation.Device,
+        Device->DeviceLocation.Function
+        );
+
+    _DumpPciHeader(&Device->DeviceData->Header);
+    _DumpPciCapabilities(Device->DeviceData);
+
+    LOG("\n");
+}
+
+static
+void
+_DumpPciHeader(
+    IN PPCI_COMMON_HEADER Header
+    )
+{
+    BOOLEAN bBridge;
+
+    ASSERT( NULL != Header );
+
+    LOG("Vendor ID: 0x%04x\n", Header->VendorID);
+    LOG("Device ID: 0x%04x\n", Header->DeviceID);
+    LOG("Class Code: 0x%x\n", Header->ClassCode);
+    LOG("Subclass: 0x%x\n", Header->Subclass);
+    LOG("Header type: 0x%x\n", Header->HeaderType );
+    LOG("Is multifunction: 0x%x\n", Header->HeaderType.Multifunction );
+
+    bBridge = Header->HeaderType.Layout == PCI_HEADER_LAYOUT_PCI_TO_PCI;
+
+    for (DWORD i = 0;
+         i < (bBridge ? PCI_BRIDGE_NO_OF_BARS : PCI_DEVICE_NO_OF_BARS);
+         ++i)
+    {
+        LOG("Bar[%d] = 0x%x\n", i, Header->Device.Bar[i]);
+    }
+
+    if(bBridge)
+    {
+        LOG("Primary bus number: 0x%x\n", Header->Bridge.PrimaryBusNumber );
+        LOG("Secondary bus number: 0x%x\n", Header->Bridge.SecondaryBusNumber );
+        LOG("Subordinate bus number: 0x%x\n", Header->Bridge.SubordinateBusNumber );
+    }
+
+    LOG("Interrupt PIN: %d\n", Header->Device.InterruptPin );
+    LOG("Interrupt line: %d\n", Header->Device.InterruptLine );
+
+    LOG("Status: 0x%x\n", Header->Status.Value );
+    LOG("Device control: 0x%x\n", Header->Command );
+    LOG("Program IF: 0x%x\n", Header->ProgIF );
+}
+
+static
+void
+_DumpPciCapabilities(
+    IN PPCI_DEVICE          Device
+    )
+{
+    STATUS status;
+    PPCI_CAPABILITY_HEADER pciCap;
+
+    ASSERT( NULL != Device );
+
+    status = STATUS_SUCCESS;
+    pciCap = NULL;
+
+    LOG("Device capabilities list:\n");
+
+    // warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+    while(TRUE)
+    {
+        status = PciDevRetrieveNextCapability(Device, pciCap, &pciCap );
+        if (!SUCCEEDED(status))
+        {
+            if (STATUS_DEVICE_CAPABILITIES_NOT_SUPPORTED == status)
+            {
+                LOG("Device does not have capabilities\n");
+            }
+            break;
+        }
+
+        _DumpPciCapability(pciCap);
+
+
+    }
+
+}
+
+static
+void
+_DumpPciCapability(
+    IN PPCI_CAPABILITY_HEADER   Capability
+    )
+{
+    ASSERT( NULL != Capability );
+
+    LOG("Next capability pointer: 0x%x\n", Capability->NextPointer);
+    LOG("Capability ID: 0x%x [%s]\n", Capability->CapabilityId, _PciCapabilityIdToString(Capability->CapabilityId));
+
+    switch (Capability->CapabilityId)
+    {
+    case PCI_CAPABILITY_ID_MSI:
+        {
+            PPCI_CAPABILITY_MSI capMsi = (PPCI_CAPABILITY_MSI) Capability;
+
+            LOG("Per-vector masking capable: [%s]\n", capMsi->MessageControl.PerVectorMasking ? "YES" : "NO" );
+            LOG("64 bit capable: [%s]\n", capMsi->MessageControl.Is64BitCapable ? "YES" : "NO" );
+            LOG("Multiple message capable: 0x%x\n", 1UL << capMsi->MessageControl.MultipleMessageCapable );
+            LOG("MSI enabled: [%s]\n", capMsi->MessageControl.MsiEnable ? "YES" : "NO" );
+
+            if (capMsi->MessageControl.Is64BitCapable)
+            {
+                LOG("Message address: 0x%X\n", DWORDS_TO_QWORD(capMsi->Capability64Bit.MessageAddressHigher, capMsi->MessageAddressLower.Raw));
+                LOG("Message data: 0x%x\n", capMsi->Capability64Bit.MessageData);
+            }
+            else
+            {
+                LOG("Message address: 0x%x\n", capMsi->MessageAddressLower.Raw);
+                LOG("Message data: 0x%x\n", capMsi->Capability32Bit.MessageData);
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_process.c b/src_proiect/HAL9000/src/dmp_process.c
new file mode 100644
index 0000000..16073a6
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_process.c
@@ -0,0 +1,32 @@
+#include "HAL9000.h"
+#include "dmp_common.h"
+#include "dmp_process.h"
+#include "thread_internal.h"
+#include "process_internal.h"
+
+void
+DumpProcess(
+    IN  PPROCESS    Process
+    )
+{
+    INTR_STATE oldState;
+
+    ASSERT(Process != NULL);
+
+    oldState = DumpTakeLock();
+
+    _Benign_race_begin_
+
+    LOG("Process %U - 0x%X\n", Process->Id, Process->Id);
+    LOG("----------------------\n");
+    LOG("Name is [%s]\n", Process->ProcessName);
+    LOG("Command line is [%s]\n", Process->FullCommandLine);
+    LOG("Number of arguments %u\n", Process->NumberOfArguments);
+    LOG("Process VA space at 0x%X\n", Process->VaSpace);
+    LOG("Number of threads: %u\n", Process->NumberOfThreads);
+    LOG("Reference count is: %u\n", Process->RefCnt.ReferenceCount);
+
+    _Benign_race_end_
+
+    DumpReleaseLock(oldState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/dmp_volume.c b/src_proiect/HAL9000/src/dmp_volume.c
new file mode 100644
index 0000000..c425ea3
--- /dev/null
+++ b/src_proiect/HAL9000/src/dmp_volume.c
@@ -0,0 +1,19 @@
+#include "HAL9000.h"
+#include "dmp_volume.h"
+
+void
+DumpVolume(
+    IN      PVOLUME     Volume
+    )
+{
+    if (NULL == Volume)
+    {
+        return;
+    }
+
+
+    LOG("Disk device: 0x%X\n", Volume->DiskDevice);
+    LOG("Partition type: 0x%x\n", Volume->PartitionInformation.PartitionType);
+    LOG("Offset in disk: 0x%x\n", Volume->PartitionInformation.OffsetInDisk);
+    LOG("Size in sectors: 0x%x\n", Volume->PartitionInformation.PartitionSize);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/ex.c b/src_proiect/HAL9000/src/ex.c
new file mode 100644
index 0000000..97a8ea7
--- /dev/null
+++ b/src_proiect/HAL9000/src/ex.c
@@ -0,0 +1,47 @@
+#include "HAL9000.h"
+#include "ex.h"
+#include "mmu.h"
+#include "iomu.h"
+
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+ExAllocatePoolWithTag(
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    )
+{
+    return MmuAllocatePoolWithTag(Flags,AllocationSize,Tag,AllocationAlignment);
+}
+
+void
+ExFreePoolWithTag(
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    )
+{
+    MmuFreePoolWithTag(MemoryAddress, Tag);
+}
+
+void
+ExGetSystemInformation(
+    OUT     PSYSTEM_INFORMATION     SystemInformation
+    )
+{
+    QWORD tickFreq;
+
+    ASSERT( NULL != SystemInformation );
+
+    tickFreq = 0;
+
+    IomuGetSystemTicks(&tickFreq);
+
+    SystemInformation->CpuFrequency = tickFreq;
+    SystemInformation->SystemUptimeUs = IomuGetSystemTimeUs();
+
+    SystemInformation->TotalPhysicalMemory = MmuGetTotalSystemMemory();
+    SystemInformation->HighestPhysicalAddress = MmuGetHighestPhysicalMemoryAddressPresent();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/ex_event.c b/src_proiect/HAL9000/src/ex_event.c
new file mode 100644
index 0000000..8c58e20
--- /dev/null
+++ b/src_proiect/HAL9000/src/ex_event.c
@@ -0,0 +1,115 @@
+#include "HAL9000.h"
+#include "ex_event.h"
+#include "thread_internal.h"
+
+#include "cpumu.h"
+
+STATUS
+ExEventInit(
+    OUT     EX_EVENT*     Event,
+    IN      EX_EVT_TYPE   EventType,
+    IN      BOOLEAN       Signaled
+    )
+{
+    if (NULL == Event)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (EventType >= ExEventTypeReserved)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    LockInit(&Event->EventLock);
+    InitializeListHead(&Event->WaitingList);
+
+    Event->EventType = EventType;
+    _InterlockedExchange8(&Event->Signaled, Signaled );
+
+    return STATUS_SUCCESS;
+}
+
+void
+ExEventSignal(
+    INOUT   EX_EVENT*      Event
+    )
+{
+    INTR_STATE oldState;
+    PLIST_ENTRY pEntry;
+
+    ASSERT(NULL != Event);
+
+    pEntry = NULL;
+
+    LockAcquire(&Event->EventLock, &oldState);
+    _InterlockedExchange8(&Event->Signaled, TRUE);
+    
+    for(pEntry = RemoveHeadList(&Event->WaitingList);
+        pEntry != &Event->WaitingList;
+        pEntry = RemoveHeadList(&Event->WaitingList)
+            )
+    {
+        PTHREAD pThreadToSignal = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
+        ThreadUnblock(pThreadToSignal);
+
+        if (ExEventTypeSynchronization == Event->EventType)
+        {
+            // sorry, we only wake one thread
+            // we must not clear the signal here, because the first thread which will
+            // wake up will claar it :)
+            break;
+        }
+    }
+
+    LockRelease(&Event->EventLock, oldState);
+}
+
+void
+ExEventClearSignal(
+    INOUT   EX_EVENT*      Event
+    )
+{
+    ASSERT( NULL != Event );
+
+    _InterlockedExchange8(&Event->Signaled, FALSE);
+}
+
+void
+ExEventWaitForSignal(
+    INOUT   EX_EVENT*      Event
+    )
+{
+    PTHREAD pCurrentThread;
+    INTR_STATE dummyState;
+    INTR_STATE oldState;
+    BYTE newState;
+
+    ASSERT(NULL != Event);
+
+    pCurrentThread = GetCurrentThread();
+
+    ASSERT( NULL != pCurrentThread);
+
+    newState = ExEventTypeNotification == Event->EventType;
+
+    oldState = CpuIntrDisable();
+    while (TRUE != _InterlockedCompareExchange8(&Event->Signaled, newState, TRUE))
+    {
+        LockAcquire(&Event->EventLock, &dummyState);
+        InsertTailList(&Event->WaitingList, &pCurrentThread->ReadyList);
+        ThreadTakeBlockLock();
+        LockRelease(&Event->EventLock, dummyState);
+        ThreadBlock();
+
+        // if we are waiting for a notification type event => all threads
+        // must be woken up => we have no reason to check the state of the
+        // event again
+        if (ExEventTypeNotification == Event->EventType)
+        {
+            break;
+        }
+    }
+
+    CpuIntrSetState(oldState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/ex_system.c b/src_proiect/HAL9000/src/ex_system.c
new file mode 100644
index 0000000..bd7deb4
--- /dev/null
+++ b/src_proiect/HAL9000/src/ex_system.c
@@ -0,0 +1,11 @@
+#include "HAL9000.h"
+#include "ex_system.h"
+#include "thread_internal.h"
+
+void
+ExSystemTimerTick(
+    void
+    )
+{
+    ThreadTick();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/ex_timer.c b/src_proiect/HAL9000/src/ex_timer.c
new file mode 100644
index 0000000..8a1bd61
--- /dev/null
+++ b/src_proiect/HAL9000/src/ex_timer.c
@@ -0,0 +1,115 @@
+#include "HAL9000.h"
+#include "ex_timer.h"
+#include "iomu.h"
+#include "thread_internal.h"
+
+STATUS
+ExTimerInit(
+    OUT     PEX_TIMER       Timer,
+    IN      EX_TIMER_TYPE   Type,
+    IN      QWORD           Time
+    )
+{
+    STATUS status;
+
+    if (NULL == Timer)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (Type > ExTimerTypeMax)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    status = STATUS_SUCCESS;
+
+    memzero(Timer, sizeof(EX_TIMER));
+
+    Timer->Type = Type;
+    if (Timer->Type != ExTimerTypeAbsolute)
+    {
+        // relative time
+
+        // if the time trigger time has already passed the timer will
+        // be signaled after the first scheduler tick
+        Timer->TriggerTimeUs = IomuGetSystemTimeUs() + Time;
+        Timer->ReloadTimeUs = Time;
+    }
+    else
+    {
+        // absolute
+        Timer->TriggerTimeUs = Time;
+    }
+
+    return status;
+}
+
+void
+ExTimerStart(
+    IN      PEX_TIMER       Timer
+    )
+{
+    ASSERT(Timer != NULL);
+
+    if (Timer->TimerUninited)
+    {
+        return;
+    }
+
+    Timer->TimerStarted = TRUE;
+}
+
+void
+ExTimerStop(
+    IN      PEX_TIMER       Timer
+    )
+{
+    ASSERT(Timer != NULL);
+
+    if (Timer->TimerUninited)
+    {
+        return;
+    }
+
+    Timer->TimerStarted = FALSE;
+}
+
+void
+ExTimerWait(
+    INOUT   PEX_TIMER       Timer
+    )
+{
+    ASSERT(Timer != NULL);
+
+    if (Timer->TimerUninited)
+    {
+        return;
+    }
+
+    while (IomuGetSystemTimeUs() < Timer->TriggerTimeUs && Timer->TimerStarted)
+    {
+        ThreadYield();
+    }
+}
+
+void
+ExTimerUninit(
+    INOUT   PEX_TIMER       Timer
+    )
+{
+    ASSERT(Timer != NULL);
+
+    ExTimerStop(Timer);
+
+    Timer->TimerUninited = TRUE;
+}
+
+INT64
+ExTimerCompareTimers(
+    IN      PEX_TIMER     FirstElem,
+    IN      PEX_TIMER     SecondElem
+)
+{
+    return FirstElem->TriggerTimeUs - SecondElem->TriggerTimeUs;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/gdtmu.c b/src_proiect/HAL9000/src/gdtmu.c
new file mode 100644
index 0000000..a46d5ba
--- /dev/null
+++ b/src_proiect/HAL9000/src/gdtmu.c
@@ -0,0 +1,136 @@
+#include "HAL9000.h"
+#include "tss.h"
+#include "gdtmu.h"
+#include "gdt.h"
+
+static volatile WORD m_selectorIndex = 0;
+
+#define FIRST_SELECTOR_INDEX                    0x8
+
+static
+__forceinline
+WORD
+_GdtMuRetrieveNextSelectorIndex(
+    IN      BOOLEAN         SystemDescriptor
+    )
+{
+    return _InterlockedExchangeAdd16(&m_selectorIndex,
+                                     SystemDescriptor ? sizeof(TSS_DESCRIPTOR) : sizeof(SEGMENT_DESCRIPTOR));
+}
+
+STATUS
+GdtMuInit(
+    void
+)
+{
+    STATUS status;
+    SEGMENT_DESCRIPTOR_FLAGS flags;
+    WORD selIdx;
+
+    status = STATUS_SUCCESS;
+
+    // NULL descriptor is guaranteed by HAL no need to place it
+
+    for (SEL_PRIV selPriv = SelPrivillegeSupervisor; selPriv < SelPrivillegeReserved; ++selPriv)
+    {
+        for (SEL_OP_MODE opMode = SelOpMode32; opMode < SelOpModeReserved; ++opMode)
+        {
+            for (SEL_TYPE selType = SelTypeCode; selType < SelTypeReserved; ++selType)
+            {
+                flags = ((selPriv == SelPrivillegeSupervisor) ? (1 << SegmentDescriptorFlagRing0) : 0) |
+                    ((opMode == SelOpMode64 && selType == SelTypeCode) ? (1 << SegmentDescriptorLongMode) :
+                    ((opMode == SelOpMode16) ? 0 : (1 << SegmentDescriptor32bitOperation)));
+
+                selIdx = GdtMuRetrieveSelectorIndex(selPriv, opMode, selType);
+                status = GdtInstallDescriptor(selIdx,
+                                              0,
+                                              (selType == SelTypeData) ? NonSystemSegmentDataReadWriteAccessed : NonSystemSegmentCodeExecuteOnlyAccessed,
+                                              flags);
+            }
+        }
+    }
+
+    GdtMuReload(
+        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeCode),
+        GdtMuRetrieveSelectorIndex(SelPrivillegeSupervisor, SelOpMode64, SelTypeData),
+        TRUE,
+        TRUE);
+
+    m_selectorIndex = selIdx + sizeof(SEGMENT_DESCRIPTOR);
+
+    return status;
+}
+
+STATUS
+GdtMuInstallTssDescriptor(
+    OUT     PTSS            Tss,
+    IN_RANGE(1,NO_OF_IST)
+            BYTE            NumberOfStacks,
+    IN_READS(NumberOfStacks)
+            PVOID*          Stacks,
+    OUT_OPT WORD*           Selector
+    )
+{
+    STATUS status;
+    WORD selector;
+    
+    selector = _GdtMuRetrieveNextSelectorIndex(TRUE);
+
+    status = TssInstall(Tss,
+                        selector,
+                        NumberOfStacks,
+                        Stacks);
+    if(!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("TssInstall", status );
+        return status;
+    }
+
+    if (NULL != Selector)
+    {
+        *Selector = selector;
+    }
+
+    return status;
+}
+
+WORD
+GdtMuRetrieveSelectorIndex(
+    IN      SEL_PRIV        Privillege,
+    IN      SEL_OP_MODE     Mode,
+    IN      SEL_TYPE        Type
+    )
+{
+    ASSERT(Privillege < SelPrivillegeReserved);
+    ASSERT(Mode < SelOpModeReserved);
+    ASSERT(Type < SelTypeReserved);
+
+    return (WORD) (
+            FIRST_SELECTOR_INDEX +
+                (Privillege * SelOpModeReserved * SelTypeReserved + 
+                Mode * SelTypeReserved +
+                Type
+                ) * sizeof(SEGMENT_DESCRIPTOR));
+}
+
+void
+GdtMuReload(
+    IN          WORD            CodeSelector,
+    IN          WORD            DataSelector,
+    IN          BOOLEAN         PreserveGsBase,
+    IN          BOOLEAN         PreserveFsBase
+    )
+{
+    // The initialization is done just because the compiler is retarded :)
+    // It thinks we might write the oldGs/FsBase values without reading them
+    QWORD oldGsBase = 0;
+    QWORD oldFsBase = 0;
+
+    if (PreserveGsBase) oldGsBase = __readmsr(IA32_GS_BASE_MSR);
+    if (PreserveFsBase) oldFsBase = __readmsr(IA32_FS_BASE_MSR);
+
+    GdtReload(CodeSelector, DataSelector);
+
+    if (PreserveGsBase) __writemsr(IA32_GS_BASE_MSR, oldGsBase);
+    if (PreserveFsBase) __writemsr(IA32_FS_BASE_MSR, oldFsBase);
+}
diff --git a/src_proiect/HAL9000/src/hal_assert.c b/src_proiect/HAL9000/src/hal_assert.c
new file mode 100644
index 0000000..41171ca
--- /dev/null
+++ b/src_proiect/HAL9000/src/hal_assert.c
@@ -0,0 +1,39 @@
+#include "HAL9000.h"
+#include "hal_assert.h"
+#include "cpumu.h"
+#include "smp.h"
+#include "thread.h"
+
+static volatile DWORD m_osAsserted = 0;
+
+void
+(__cdecl Hal9000Assert)(
+    IN_Z            char*       Message
+    )
+{
+    DWORD assertValue;
+
+    LogSetState(TRUE);
+
+    if (SmpGetNumberOfActiveCpus() > 1)
+    {
+        assertValue = _InterlockedExchange(&m_osAsserted, 1);
+        if (0 == assertValue)
+        {
+            // we are the first to assert
+            LOGP_ERROR("Sending IPI to other processors\n");
+            SmpSendPanic();
+        }
+    }
+
+    LOGP_ERROR( "Kernel panic!\n");
+
+    LOGP_ERROR("Thread: [%s]\n", ThreadGetName(NULL));
+
+    LOGP_ERROR( "%s\n", Message);
+
+    AssertFreeLock();
+
+    CpuIntrDisable();
+    __halt();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/idt_handlers.c b/src_proiect/HAL9000/src/idt_handlers.c
new file mode 100644
index 0000000..20d1c6c
--- /dev/null
+++ b/src_proiect/HAL9000/src/idt_handlers.c
@@ -0,0 +1,362 @@
+#include "HAL9000.h"
+#include "idt.h"
+#include "idt_handlers.h"
+#include "gdt.h"
+#include "cpu.h"
+
+// exceptions
+extern void DivideError();
+extern void DebugException();
+extern void NMIInterrupt();
+extern void BreakpointException();
+extern void OverflowException();
+extern void BoundRangeExceededException();
+extern void InvalidOpcode();
+extern void DeviceNotAvailable();
+extern void DoubleFault();
+extern void CoprocessorSegmentOverrun();
+extern void InvalidTSS();
+extern void SegmentNotPresent();
+extern void StackFault();
+extern void GeneralProtection();
+extern void PageFault();
+extern void FloatingPointX87Error();
+extern void AlignmentCheck();
+extern void MachineCheck();
+extern void FloatingPointSIMD();
+extern void VirtualizationException();
+
+#define GENERATE_GENERIC_NAME(x)    GenericIsr##x
+#define IMPORT_GENERIC_ISR(x)       extern void GENERATE_GENERIC_NAME(x)();
+
+IMPORT_GENERIC_ISR(32); IMPORT_GENERIC_ISR(33); IMPORT_GENERIC_ISR(34); IMPORT_GENERIC_ISR(35);
+IMPORT_GENERIC_ISR(36); IMPORT_GENERIC_ISR(37); IMPORT_GENERIC_ISR(38); IMPORT_GENERIC_ISR(39);
+IMPORT_GENERIC_ISR(40); IMPORT_GENERIC_ISR(41); IMPORT_GENERIC_ISR(42); IMPORT_GENERIC_ISR(43);
+IMPORT_GENERIC_ISR(44); IMPORT_GENERIC_ISR(45); IMPORT_GENERIC_ISR(46); IMPORT_GENERIC_ISR(47);
+
+IMPORT_GENERIC_ISR(48); IMPORT_GENERIC_ISR(49); IMPORT_GENERIC_ISR(50); IMPORT_GENERIC_ISR(51);
+IMPORT_GENERIC_ISR(52); IMPORT_GENERIC_ISR(53); IMPORT_GENERIC_ISR(54); IMPORT_GENERIC_ISR(55);
+IMPORT_GENERIC_ISR(56); IMPORT_GENERIC_ISR(57); IMPORT_GENERIC_ISR(58); IMPORT_GENERIC_ISR(59);
+IMPORT_GENERIC_ISR(60); IMPORT_GENERIC_ISR(61); IMPORT_GENERIC_ISR(62); IMPORT_GENERIC_ISR(63);
+
+IMPORT_GENERIC_ISR(64); IMPORT_GENERIC_ISR(65); IMPORT_GENERIC_ISR(66); IMPORT_GENERIC_ISR(67);
+IMPORT_GENERIC_ISR(68); IMPORT_GENERIC_ISR(69); IMPORT_GENERIC_ISR(70); IMPORT_GENERIC_ISR(71);
+IMPORT_GENERIC_ISR(72); IMPORT_GENERIC_ISR(73); IMPORT_GENERIC_ISR(74); IMPORT_GENERIC_ISR(75);
+IMPORT_GENERIC_ISR(76); IMPORT_GENERIC_ISR(77); IMPORT_GENERIC_ISR(78); IMPORT_GENERIC_ISR(79);
+
+IMPORT_GENERIC_ISR(80); IMPORT_GENERIC_ISR(81); IMPORT_GENERIC_ISR(82); IMPORT_GENERIC_ISR(83);
+IMPORT_GENERIC_ISR(84); IMPORT_GENERIC_ISR(85); IMPORT_GENERIC_ISR(86); IMPORT_GENERIC_ISR(87);
+IMPORT_GENERIC_ISR(88); IMPORT_GENERIC_ISR(89); IMPORT_GENERIC_ISR(90); IMPORT_GENERIC_ISR(91);
+IMPORT_GENERIC_ISR(92); IMPORT_GENERIC_ISR(93); IMPORT_GENERIC_ISR(94); IMPORT_GENERIC_ISR(95);
+
+IMPORT_GENERIC_ISR(96); IMPORT_GENERIC_ISR(97); IMPORT_GENERIC_ISR(98); IMPORT_GENERIC_ISR(99);
+IMPORT_GENERIC_ISR(100); IMPORT_GENERIC_ISR(101); IMPORT_GENERIC_ISR(102); IMPORT_GENERIC_ISR(103);
+IMPORT_GENERIC_ISR(104); IMPORT_GENERIC_ISR(105); IMPORT_GENERIC_ISR(106); IMPORT_GENERIC_ISR(107);
+IMPORT_GENERIC_ISR(108); IMPORT_GENERIC_ISR(109); IMPORT_GENERIC_ISR(110); IMPORT_GENERIC_ISR(111);
+
+IMPORT_GENERIC_ISR(112); IMPORT_GENERIC_ISR(113); IMPORT_GENERIC_ISR(114); IMPORT_GENERIC_ISR(115);
+IMPORT_GENERIC_ISR(116); IMPORT_GENERIC_ISR(117); IMPORT_GENERIC_ISR(118); IMPORT_GENERIC_ISR(119);
+IMPORT_GENERIC_ISR(120); IMPORT_GENERIC_ISR(121); IMPORT_GENERIC_ISR(122); IMPORT_GENERIC_ISR(123);
+IMPORT_GENERIC_ISR(124); IMPORT_GENERIC_ISR(125); IMPORT_GENERIC_ISR(126); IMPORT_GENERIC_ISR(127);
+
+IMPORT_GENERIC_ISR(128); IMPORT_GENERIC_ISR(129); IMPORT_GENERIC_ISR(130); IMPORT_GENERIC_ISR(131);
+IMPORT_GENERIC_ISR(132); IMPORT_GENERIC_ISR(133); IMPORT_GENERIC_ISR(134); IMPORT_GENERIC_ISR(135);
+IMPORT_GENERIC_ISR(136); IMPORT_GENERIC_ISR(137); IMPORT_GENERIC_ISR(138); IMPORT_GENERIC_ISR(139);
+IMPORT_GENERIC_ISR(140); IMPORT_GENERIC_ISR(141); IMPORT_GENERIC_ISR(142); IMPORT_GENERIC_ISR(143);
+
+IMPORT_GENERIC_ISR(144); IMPORT_GENERIC_ISR(145); IMPORT_GENERIC_ISR(146); IMPORT_GENERIC_ISR(147);
+IMPORT_GENERIC_ISR(148); IMPORT_GENERIC_ISR(149); IMPORT_GENERIC_ISR(150); IMPORT_GENERIC_ISR(151);
+IMPORT_GENERIC_ISR(152); IMPORT_GENERIC_ISR(153); IMPORT_GENERIC_ISR(154); IMPORT_GENERIC_ISR(155);
+IMPORT_GENERIC_ISR(156); IMPORT_GENERIC_ISR(157); IMPORT_GENERIC_ISR(158); IMPORT_GENERIC_ISR(159);
+
+IMPORT_GENERIC_ISR(160); IMPORT_GENERIC_ISR(161); IMPORT_GENERIC_ISR(162); IMPORT_GENERIC_ISR(163);
+IMPORT_GENERIC_ISR(164); IMPORT_GENERIC_ISR(165); IMPORT_GENERIC_ISR(166); IMPORT_GENERIC_ISR(167);
+IMPORT_GENERIC_ISR(168); IMPORT_GENERIC_ISR(169); IMPORT_GENERIC_ISR(170); IMPORT_GENERIC_ISR(171);
+IMPORT_GENERIC_ISR(172); IMPORT_GENERIC_ISR(173); IMPORT_GENERIC_ISR(174); IMPORT_GENERIC_ISR(175);
+
+IMPORT_GENERIC_ISR(176); IMPORT_GENERIC_ISR(177); IMPORT_GENERIC_ISR(178); IMPORT_GENERIC_ISR(179);
+IMPORT_GENERIC_ISR(180); IMPORT_GENERIC_ISR(181); IMPORT_GENERIC_ISR(182); IMPORT_GENERIC_ISR(183);
+IMPORT_GENERIC_ISR(184); IMPORT_GENERIC_ISR(185); IMPORT_GENERIC_ISR(186); IMPORT_GENERIC_ISR(187);
+IMPORT_GENERIC_ISR(188); IMPORT_GENERIC_ISR(189); IMPORT_GENERIC_ISR(190); IMPORT_GENERIC_ISR(191);
+
+IMPORT_GENERIC_ISR(192); IMPORT_GENERIC_ISR(193); IMPORT_GENERIC_ISR(194); IMPORT_GENERIC_ISR(195);
+IMPORT_GENERIC_ISR(196); IMPORT_GENERIC_ISR(197); IMPORT_GENERIC_ISR(198); IMPORT_GENERIC_ISR(199);
+IMPORT_GENERIC_ISR(200); IMPORT_GENERIC_ISR(201); IMPORT_GENERIC_ISR(202); IMPORT_GENERIC_ISR(203);
+IMPORT_GENERIC_ISR(204); IMPORT_GENERIC_ISR(205); IMPORT_GENERIC_ISR(206); IMPORT_GENERIC_ISR(207);
+
+IMPORT_GENERIC_ISR(208); IMPORT_GENERIC_ISR(209); IMPORT_GENERIC_ISR(210); IMPORT_GENERIC_ISR(211);
+IMPORT_GENERIC_ISR(212); IMPORT_GENERIC_ISR(213); IMPORT_GENERIC_ISR(214); IMPORT_GENERIC_ISR(215);
+IMPORT_GENERIC_ISR(216); IMPORT_GENERIC_ISR(217); IMPORT_GENERIC_ISR(218); IMPORT_GENERIC_ISR(219);
+IMPORT_GENERIC_ISR(220); IMPORT_GENERIC_ISR(221); IMPORT_GENERIC_ISR(222); IMPORT_GENERIC_ISR(223);
+
+IMPORT_GENERIC_ISR(224); IMPORT_GENERIC_ISR(225); IMPORT_GENERIC_ISR(226); IMPORT_GENERIC_ISR(227);
+IMPORT_GENERIC_ISR(228); IMPORT_GENERIC_ISR(229); IMPORT_GENERIC_ISR(230); IMPORT_GENERIC_ISR(231);
+IMPORT_GENERIC_ISR(232); IMPORT_GENERIC_ISR(233); IMPORT_GENERIC_ISR(234); IMPORT_GENERIC_ISR(235);
+IMPORT_GENERIC_ISR(236); IMPORT_GENERIC_ISR(237); IMPORT_GENERIC_ISR(238); IMPORT_GENERIC_ISR(239);
+
+IMPORT_GENERIC_ISR(240); IMPORT_GENERIC_ISR(241); IMPORT_GENERIC_ISR(242); IMPORT_GENERIC_ISR(243);
+IMPORT_GENERIC_ISR(244); IMPORT_GENERIC_ISR(245); IMPORT_GENERIC_ISR(246); IMPORT_GENERIC_ISR(247);
+IMPORT_GENERIC_ISR(248); IMPORT_GENERIC_ISR(249); IMPORT_GENERIC_ISR(250); IMPORT_GENERIC_ISR(251);
+IMPORT_GENERIC_ISR(252); IMPORT_GENERIC_ISR(253); IMPORT_GENERIC_ISR(254); IMPORT_GENERIC_ISR(255);
+
+
+#define CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(x)     \
+        status = CREATE_INTERRUPT_GATE_DESC(GENERATE_GENERIC_NAME(x), (x), CodeSelector, 0); \
+        ASSERT(SUCCEEDED(status));
+
+#define CREATE_DUMMY_DESC(idx,cs,ist)                      IdtInstallDescriptor((idx),(cs),SystemSegment64BitInterruptGate,(ist),FALSE,NULL)
+
+#define CREATE_TASK_GATE_DESC(addr,idx,cs,ist)             IdtInstallDescriptor((idx),(cs),SystemSegment64BitTaskGate,(ist),TRUE,(addr))
+
+// The ONLY difference between an interrupt and a trap gate is that the
+// INTERRUPT gate clears the IF flag => no more interrupts in the current handler
+#define CREATE_INTERRUPT_GATE_DESC(addr,idx,cs,ist)        IdtInstallDescriptor((idx),(cs),SystemSegment64BitInterruptGate,(ist),TRUE,(addr))
+#define CREATE_TRAP_GATE_DESC(addr,idx,cs,ist)             IdtInstallDescriptor((idx),(cs),SystemSegment64BitTrapGate,(ist),TRUE,(addr))
+
+// The lower the value of the IST index the likelier it is for the exception to use the IST
+// i.e. we may have a limited number of ISTs (define by the TSS to only 7)
+// As a result we'll have some handlers using the same IST
+#define IST_DB          5
+#define IST_BP          6
+#define IST_NMI         7
+#define IST_DF          1
+#define IST_NP          3
+#define IST_SS          4
+#define IST_GP          2
+#define IST_MC          1
+
+#define IST_CHOOSE(Cur,Max)     ((Cur)<=(Max) ? (Cur) : 0)
+
+static
+STATUS
+_InitInternalHandlers(
+    IN      WORD                CodeSelector,
+    IN      BYTE                NumberOfTssStacks
+    );
+
+static
+STATUS
+_InitExternalInterruptHandlers(
+    IN      WORD                CodeSelector
+    );
+
+STATUS
+InitIdtHandlers(
+    IN      WORD                CodeSelector,
+    IN      BYTE                NumberOfTssStacks
+    )
+{
+    STATUS status;
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_INTERRUPT("Will Initialize handlers for CS 0x%x and %u TSS stacks\n",
+                        CodeSelector, NumberOfTssStacks );
+
+    status = _InitInternalHandlers(CodeSelector, NumberOfTssStacks);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_InitExceptionHandlers", status);
+        return status;
+    }
+
+    status = _InitExternalInterruptHandlers(CodeSelector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_InitInterruptHandlers", status);
+        return status;
+    }
+
+    // lidt Idt
+    IdtReload();
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_InitInternalHandlers(
+    IN      WORD                CodeSelector,
+    IN      BYTE                NumberOfTssStacks
+    )
+{
+    STATUS status;
+
+    status = STATUS_SUCCESS;
+
+#pragma warning(push)
+    // warning C4152: nonstandard extension, function/data pointer conversion in expression
+#pragma warning(disable:4152)
+    // 00 - #DE - Divide Error
+    status = CREATE_INTERRUPT_GATE_DESC(DivideError, ExceptionDivideError, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 01 - #DB - Debug Exception
+    status = CREATE_INTERRUPT_GATE_DESC(DebugException, ExceptionDebugException, CodeSelector, IST_CHOOSE(IST_DB, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 02 - NMI - NMI Interrupt
+    status = CREATE_INTERRUPT_GATE_DESC(NMIInterrupt, ExceptionNMI, CodeSelector, IST_CHOOSE(IST_NMI, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 03 - #BP - Breakpoint Exception
+    status = CREATE_INTERRUPT_GATE_DESC(BreakpointException, ExceptionBreakpoint, CodeSelector, IST_CHOOSE(IST_BP, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 04 - #OF - Overflow Exception
+    status = CREATE_INTERRUPT_GATE_DESC(OverflowException, ExceptionOverflow, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 05 - #BR - BOUND Range Exceeded Exception
+    status = CREATE_INTERRUPT_GATE_DESC(BoundRangeExceededException, ExceptionBoundRange, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 06 - #UD - Invalid Opcode
+    status = CREATE_INTERRUPT_GATE_DESC(InvalidOpcode, ExceptionInvalidOpcode, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 07 - #NM - Device Not Available Exception
+    status = CREATE_INTERRUPT_GATE_DESC(DeviceNotAvailable, ExceptionDeviceNotAvailable, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 08 - #DF - Double Fault
+    status = CREATE_INTERRUPT_GATE_DESC(DoubleFault, ExceptionDoubleFault, CodeSelector, IST_CHOOSE(IST_DF, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 09 - COS - Coprocessor Segment Overrrun
+    status = CREATE_INTERRUPT_GATE_DESC(CoprocessorSegmentOverrun, ExceptionCoprocOverrun, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 10 - #TS - Invalid TSS Exception
+    status = CREATE_INTERRUPT_GATE_DESC(InvalidTSS, ExceptionInvalidTSS, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 11 - #NP - Segment Not Present
+    status = CREATE_INTERRUPT_GATE_DESC(SegmentNotPresent, ExceptionSegmentNotPresent, CodeSelector, IST_CHOOSE(IST_NP, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 12 - #SS - Stack Fault Exception
+    status = CREATE_INTERRUPT_GATE_DESC(StackFault, ExceptionStackFault, CodeSelector, IST_CHOOSE(IST_SS, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 13 - #GP - General Protection
+    status = CREATE_INTERRUPT_GATE_DESC(GeneralProtection, ExceptionGeneralProtection, CodeSelector, IST_CHOOSE(IST_GP, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 14 - #PF - Page Fault
+    status = CREATE_INTERRUPT_GATE_DESC(PageFault, ExceptionPageFault, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 16 - #MF - x87 FPU Floating-Point Error
+    status = CREATE_INTERRUPT_GATE_DESC(FloatingPointX87Error, ExceptionX87FpuException, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 17 - #AC - Alignment Check Exception
+    status = CREATE_INTERRUPT_GATE_DESC(AlignmentCheck, ExceptionAlignmentCheck, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 18 - #MC - Machine Check Exception
+    status = CREATE_INTERRUPT_GATE_DESC(MachineCheck, ExceptionMachineCheck, CodeSelector, IST_CHOOSE(IST_MC, NumberOfTssStacks));
+    ASSERT(SUCCEEDED(status));
+
+    // 19 - #XM - SIMD Floating-Point Exception
+    status = CREATE_INTERRUPT_GATE_DESC(FloatingPointSIMD, ExceptionSIMDFpuException, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+    // 20 - #VE - Virtualization Exception
+    status = CREATE_INTERRUPT_GATE_DESC(VirtualizationException, ExceptionVirtualizationException, CodeSelector, 0);
+    ASSERT(SUCCEEDED(status));
+
+#pragma warning(pop)
+
+    return status;
+}
+
+static
+STATUS
+_InitExternalInterruptHandlers(
+    IN      WORD                CodeSelector
+    )
+{
+    STATUS status;
+
+    status = STATUS_SUCCESS;
+
+#pragma warning(push)
+    // warning C4152: nonstandard extension, function/data pointer conversion in expression
+#pragma warning(disable:4152)
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(32); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(33); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(34); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(35);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(36); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(37); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(38); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(39);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(40); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(41); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(42); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(43);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(44); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(45); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(46); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(47);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(48); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(49); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(50); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(51);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(52); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(53); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(54); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(55);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(56); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(57); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(58); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(59);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(60); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(61); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(62); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(63);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(64); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(65); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(66); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(67);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(68); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(69); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(70); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(71);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(72); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(73); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(74); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(75);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(76); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(77); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(78); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(79);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(80); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(81); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(82); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(83);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(84); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(85); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(86); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(87);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(88); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(89); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(90); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(91);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(92); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(93); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(94); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(95);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(96); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(97); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(98); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(99);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(100); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(101); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(102); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(103);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(104); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(105); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(106); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(107);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(108); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(109); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(110); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(111);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(112); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(113); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(114); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(115);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(116); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(117); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(118); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(119);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(120); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(121); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(122); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(123);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(124); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(125); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(126); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(127);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(128); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(129); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(130); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(131);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(132); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(133); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(134); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(135);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(136); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(137); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(138); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(139);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(140); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(141); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(142); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(143);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(144); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(145); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(146); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(147);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(148); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(149); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(150); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(151);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(152); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(153); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(154); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(155);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(156); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(157); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(158); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(159);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(160); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(161); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(162); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(163);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(164); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(165); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(166); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(167);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(168); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(169); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(170); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(171);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(172); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(173); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(174); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(175);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(176); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(177); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(178); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(179);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(180); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(181); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(182); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(183);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(184); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(185); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(186); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(187);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(188); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(189); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(190); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(191);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(192); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(193); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(194); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(195);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(196); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(197); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(198); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(199);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(200); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(201); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(202); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(203);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(204); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(205); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(206); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(207);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(208); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(209); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(210); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(211);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(212); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(213); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(214); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(215);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(216); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(217); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(218); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(219);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(220); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(221); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(222); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(223);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(224); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(225); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(226); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(227);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(228); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(229); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(230); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(231);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(232); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(233); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(234); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(235);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(236); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(237); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(238); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(239);
+
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(240); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(241); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(242); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(243);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(244); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(245); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(246); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(247);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(248); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(249); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(250); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(251);
+    CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(252); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(253); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(254); CREATE_EXT_INTERRUPT_GATE_AND_CHECK_FAILURE(255);
+#pragma warning(pop)
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/io_devices.c b/src_proiect/HAL9000/src/io_devices.c
new file mode 100644
index 0000000..7275b36
--- /dev/null
+++ b/src_proiect/HAL9000/src/io_devices.c
@@ -0,0 +1,1017 @@
+#include "HAL9000.h"
+#include "io.h"
+
+#include "volume.h"
+#include "iomu.h"
+#include "filesystem.h"
+#include "mdl.h"
+#include "isr.h"
+#include "mmu.h"
+#include "vmm.h"
+#include "os_time.h"
+
+/// TODO: These function calls cross trust boundaries, validate parameters
+/// and do not ASSERT
+__forceinline
+static
+BOOLEAN
+_IoIsValidDeviceType(
+    IN      DEVICE_TYPE     DeviceType
+    )
+{
+    return ((DeviceTypeMin <= DeviceType) && (DeviceType <= DeviceTypeMax));
+}
+
+static
+STATUS
+_IoReadWriteDevice(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    _When_(Write,OUT_WRITES_BYTES(*Length))
+    _When_(!Write,IN_READS_BYTES(*Length))
+                PVOID                   Buffer,
+    INOUT       QWORD*                  Length,
+    IN          QWORD                   Offset,
+    IN          BOOLEAN                 Write,
+    IN          BOOLEAN                 Asynchronous
+    );
+
+static
+void
+_IoAllocateVpb(
+    INOUT   PDEVICE_OBJECT  VolumeDevice
+    );
+
+PTR_SUCCESS
+PDEVICE_OBJECT
+IoCreateDevice(
+    INOUT   PDRIVER_OBJECT  DriverObject,
+    IN      DWORD           DeviceExtensionSize,
+    IN      DEVICE_TYPE     DeviceType
+    )
+{
+    PDEVICE_OBJECT pDevice;
+    STATUS status;
+
+    ASSERT(NULL != DriverObject);
+
+    ASSERT(_IoIsValidDeviceType(DeviceType));
+
+    pDevice = NULL;
+    status = STATUS_SUCCESS;
+
+    __try
+    {
+        pDevice = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(DEVICE_OBJECT), HEAP_DEVICE_TAG, 0);
+        if (NULL == pDevice)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            __leave;
+        }
+
+        pDevice->DeviceExtensionSize = DeviceExtensionSize;
+        if (0 != DeviceExtensionSize)
+        {
+            pDevice->DeviceExtension = ExAllocatePoolWithTag(PoolAllocateZeroMemory, DeviceExtensionSize, HEAP_DEVICE_EXT_TAG, 0);
+            if (NULL == pDevice->DeviceExtension)
+            {
+                status = STATUS_HEAP_NO_MORE_MEMORY;
+                __leave;
+            }
+        }
+        pDevice->DeviceType = DeviceType;
+
+        if (DeviceTypeVolume == pDevice->DeviceType)
+        {
+            // we need to allocate a volume parameter block
+            _IoAllocateVpb(pDevice);
+        }
+
+        pDevice->StackSize = 1;
+
+        MutexInit(&pDevice->DeviceLock, FALSE);
+
+        // insert device into list
+        /// TODO: need to lock
+        /// Actually this is debatable: the IoCreateDevice should normally be called only in the DriverEntry portion
+        /// of the driver which is single-threaded. Because we have no PNP support (ATM) I see no way in which we could
+        /// have a problem by not synchronizing access to this list.
+
+        InsertTailList(&DriverObject->DeviceList, &pDevice->NextDevice);
+        DriverObject->NoOfDevices = DriverObject->NoOfDevices + 1;
+
+        // set driver object
+        pDevice->DriverObject = DriverObject;
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pDevice)
+            {
+                if (0 != pDevice->DeviceExtension)
+                {
+                    ExFreePoolWithTag(pDevice->DeviceExtension, HEAP_DEVICE_EXT_TAG);
+                    pDevice->DeviceExtension = NULL;
+                }
+
+                ExFreePoolWithTag(pDevice, HEAP_DEVICE_TAG);
+                pDevice = NULL;
+            }
+        }
+    }
+
+    // if we failed => pDevice will be NULL,
+    // else it will point to the new device object
+    return pDevice;
+}
+
+PVOID
+IoGetDeviceExtension(
+    IN      PDEVICE_OBJECT      Device
+    )
+{
+    ASSERT(NULL != Device);
+
+    return Device->DeviceExtension;
+}
+
+void
+IoDeleteDevice(
+    INOUT   PDEVICE_OBJECT      Device
+    )
+{
+    PDRIVER_OBJECT pDriver;
+
+    ASSERT(NULL != Device);
+
+    pDriver = Device->DriverObject;
+
+    ASSERT(NULL != pDriver);
+
+    RemoveEntryList(&Device->NextDevice);
+    pDriver->NoOfDevices = pDriver->NoOfDevices - 1;
+
+    if (0 != Device->DeviceExtensionSize)
+    {
+        ASSERT(NULL != Device->DeviceExtension);
+
+        ExFreePoolWithTag(Device->DeviceExtension, HEAP_DEVICE_EXT_TAG);
+        Device->DeviceExtension = NULL;
+    }
+
+    ExFreePoolWithTag(Device, HEAP_DEVICE_TAG);
+    Device = NULL;
+}
+
+PTR_SUCCESS
+PDRIVER_OBJECT
+IoCreateDriver(
+    IN_Z        char*                   DriverName,
+    IN          PFUNC_DriverEntry       DriverEntry
+    )
+{
+    STATUS status;
+    PDRIVER_OBJECT pDriver;
+    DWORD drvNameLength;
+
+    ASSERT(NULL != DriverName);
+    ASSERT(NULL != DriverEntry);
+
+    pDriver = NULL;
+    status = STATUS_SUCCESS;
+    drvNameLength = INVALID_STRING_SIZE;
+
+    __try
+    {
+        pDriver = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(DRIVER_OBJECT), HEAP_DRIVER_TAG, 0);
+        if (NULL == pDriver)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            __leave;
+        }
+
+        drvNameLength = strlen(DriverName);
+        ASSERT(INVALID_STRING_SIZE != drvNameLength);
+
+        pDriver->DriverName = ExAllocatePoolWithTag(PoolAllocateZeroMemory, drvNameLength + 1, HEAP_DRIVER_TAG, 0);
+        if (NULL == pDriver->DriverName)
+        {
+            status = STATUS_HEAP_NO_MORE_MEMORY;
+            __leave;
+        }
+        strcpy(pDriver->DriverName, DriverName);
+
+        InitializeListHead(&pDriver->DeviceList);
+
+        // call driver entry
+        status = DriverEntry(pDriver);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("DriverEntry", status);
+            __leave;
+        }
+
+        IomuDriverInstalled(pDriver);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pDriver)
+            {
+                if (NULL != pDriver->DriverName)
+                {
+                    ExFreePoolWithTag(pDriver->DriverName, HEAP_DRIVER_TAG);
+                    pDriver->DriverName = NULL;
+                }
+
+                ExFreePoolWithTag(pDriver, HEAP_DRIVER_TAG);
+                pDriver = NULL;
+            }
+        }
+    }
+
+    return pDriver;
+}
+
+PVOID
+IoGetDriverExtension(
+    IN          PDEVICE_OBJECT  Device
+    )
+{
+    ASSERT( NULL != Device );
+    ASSERT( NULL != Device->DriverObject );
+
+    return Device->DriverObject->DriverExtension;
+}
+
+void
+IoAttachDevice(
+    INOUT   PDEVICE_OBJECT  SourceDevice,
+    IN      PDEVICE_OBJECT  TargetDevice
+    )
+{
+    ASSERT(NULL != SourceDevice);
+    ASSERT(NULL != TargetDevice);
+
+    ASSERT(NULL == SourceDevice->AttachedDevice);
+    SourceDevice->AttachedDevice = TargetDevice;
+
+    SourceDevice->StackSize = TargetDevice->StackSize + 1;
+}
+
+PTR_SUCCESS
+PIRP
+IoAllocateIrp(
+    IN      BYTE            StackSize
+    )
+{
+    PIRP pIrp;
+    DWORD irpSize;
+
+    ASSERT(StackSize > 0);
+
+    pIrp = NULL;
+    irpSize = sizeof(IRP) + StackSize * sizeof(IO_STACK_LOCATION);
+
+    LOG_TRACE_IO("Irp has %d stack locations\n", StackSize);
+
+    pIrp = ExAllocatePoolWithTag(PoolAllocateZeroMemory, irpSize, HEAP_IRP_TAG, 0);
+    if (NULL == pIrp)
+    {
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", irpSize );
+        return NULL;
+    }
+
+    // set current stack location
+    // this is intentionally not set to StackSize - 1 because
+    // at each call to IoCallDriver it is decremented => the
+    // current stack location will properly point to StackSize - 1
+    pIrp->CurrentStackLocation = StackSize;
+
+    LOG_FUNC_END;
+
+    return pIrp;
+}
+
+void
+IoFreeIrp(
+    IN      PIRP            Irp
+    )
+{
+    ASSERT(NULL != Irp);
+
+    if (NULL != Irp->Mdl)
+    {
+        IoFreeMdl(Irp->Mdl);
+        Irp->Mdl = NULL;
+    }
+
+    ExFreePoolWithTag(Irp, HEAP_IRP_TAG);
+}
+
+PTR_SUCCESS
+PIO_STACK_LOCATION
+IoGetCurrentIrpStackLocation(
+    IN      PIRP            Irp
+    )
+{
+    ASSERT(NULL != Irp);
+
+    ASSERT(MAX_BYTE != Irp->CurrentStackLocation);
+
+    return &Irp->StackLocations[Irp->CurrentStackLocation];
+}
+
+PTR_SUCCESS
+PIO_STACK_LOCATION
+IoGetNextIrpStackLocation(
+    IN      PIRP            Irp
+    )
+{
+    ASSERT(NULL != Irp);
+
+    ASSERT(0 != Irp->CurrentStackLocation);
+
+    return &Irp->StackLocations[Irp->CurrentStackLocation - 1];
+}
+
+
+void
+IoCopyCurrentStackLocationToNext(
+    INOUT   PIRP            Irp
+    )
+{
+    BYTE currentStackLocation;
+
+    ASSERT(NULL != Irp);
+
+    currentStackLocation = Irp->CurrentStackLocation;
+    ASSERT(0 != currentStackLocation);
+
+    LOG_TRACE_IO("Current stack location: %d\n", currentStackLocation);
+
+    memcpy(&Irp->StackLocations[currentStackLocation - 1], &Irp->StackLocations[currentStackLocation], sizeof(IO_STACK_LOCATION));
+}
+
+STATUS
+IoCallDriver(
+    IN      PDEVICE_OBJECT  Device,
+    INOUT   PIRP            Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PDRIVER_OBJECT pDriver;
+    PFUNC_DriverDispatch pDispatchFunction;
+
+    ASSERT(NULL != Device);
+    ASSERT(NULL != Irp);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+
+    ASSERT(0 != Irp->CurrentStackLocation);
+    Irp->CurrentStackLocation = Irp->CurrentStackLocation - 1;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+
+    if ((IRP_MJ_READ == pStackLocation->MajorFunction) || (IRP_MJ_WRITE == pStackLocation->MajorFunction))
+    {
+        if (!IsAddressAligned(pStackLocation->Parameters.ReadWrite.Length, Device->DeviceAlignment))
+        {
+            // read/write length not aligned to device requirement
+            LOG_ERROR("ReadWrite length does not satisfy alignment requirement\nRequested: 0x%X, Required: 0x%x\n", pStackLocation->Parameters.ReadWrite.Length, Device->DeviceAlignment);
+            return STATUS_DEVICE_ALIGNMENT_NO_SATISFIED;
+        }
+
+        if (!IsAddressAligned(pStackLocation->Parameters.ReadWrite.Offset, Device->DeviceAlignment))
+        {
+            // read/write offset not aligned to device requirement
+            LOG_ERROR("ReadWrite offset does not satisfy alignment requirement\nRequested: 0x%X, Required: 0x%x\n", pStackLocation->Parameters.ReadWrite.Offset, Device->DeviceAlignment);
+            return STATUS_DEVICE_ALIGNMENT_NO_SATISFIED;
+        }
+    }
+
+    pDriver = Device->DriverObject;
+    ASSERT(NULL != pDriver);
+
+    pDispatchFunction = pDriver->DispatchFunctions[pStackLocation->MajorFunction];
+    if (NULL == pDispatchFunction)
+    {
+        status = STATUS_DEVICE_INVALID_OPERATION;
+    }
+    else
+    {
+        MutexAcquire(&Device->DeviceLock);
+        status = pDispatchFunction(Device, Irp);
+        MutexRelease(&Device->DeviceLock);
+    }
+    if (!SUCCEEDED(status))
+    {
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+void
+IoCompleteIrp(
+    INOUT   PIRP            Irp
+    )
+{
+    ASSERT(NULL != Irp);
+    ASSERT(FALSE == Irp->Flags.Completed);
+
+    Irp->Flags.Completed = TRUE;
+}
+
+static
+STATUS
+_IoReadWriteDevice(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    _When_(!Write,OUT_WRITES_BYTES(*Length))
+    _When_(Write,IN_READS_BYTES(*Length))
+                PVOID                   Buffer,
+    INOUT       QWORD*                  Length,
+    IN          QWORD                   Offset,
+    IN          BOOLEAN                 Write,
+    IN          BOOLEAN                 Asynchronous
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PIO_STACK_LOCATION pStackLocation;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Buffer);
+    ASSERT(NULL != Length);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pStackLocation = NULL;
+
+    pIrp = IoAllocateIrp(DeviceObject->StackSize);
+    ASSERT(NULL != pIrp);
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+    pStackLocation->MajorFunction = Write ? IRP_MJ_WRITE : IRP_MJ_READ;
+
+    pIrp->Buffer = Buffer;
+    pIrp->Flags.Asynchronous = Asynchronous;
+
+    pStackLocation->Parameters.ReadWrite.Length = *Length;
+    pStackLocation->Parameters.ReadWrite.Offset = Offset;
+
+    __try
+    {
+        status = IoCallDriver(DeviceObject, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        *Length = pIrp->IoStatus.Information;
+        status = pIrp->IoStatus.Status;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+static
+void
+_IoAllocateVpb(
+    INOUT   PDEVICE_OBJECT  VolumeDevice
+    )
+{
+    PVPB pVpb;
+
+    ASSERT(NULL != VolumeDevice);
+
+    ASSERT(DeviceTypeVolume == VolumeDevice->DeviceType);
+
+    pVpb = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(VPB), HEAP_VPB_TAG, 0);
+    ASSERT(NULL != pVpb);
+
+    pVpb->VolumeDevice = VolumeDevice;
+    VolumeDevice->Vpb = pVpb;
+
+    IomuNewVpbCreated(pVpb);
+}
+
+STATUS
+IoGetPciDevicesMatchingSpecification(
+    IN          PCI_SPEC        Specification,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+                PPCI_DEVICE_DESCRIPTION**    PciDevices,
+    OUT         DWORD*           NumberOfDevices
+    )
+{
+    STATUS status;
+    PLIST_ENTRY pDeviceList;
+    DWORD noOfDevices;
+    DWORD temp;
+    PPCI_DEVICE_DESCRIPTION* pDevices;
+
+    ASSERT(NULL != PciDevices);
+    ASSERT(NULL != NumberOfDevices);
+
+    status = STATUS_SUCCESS;
+    pDeviceList = IomuGetPciDeviceList();
+    noOfDevices = 0;
+    pDevices = NULL;
+
+    status = PciSystemFindDevicesMatchingSpecification(pDeviceList, Specification, NULL, &noOfDevices );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciDevFindDevicesByClassAndSubclass", status);
+        return status;
+    }
+
+    __try
+    {
+        if (0 == noOfDevices)
+        {
+            status = STATUS_SUCCESS;
+            __leave;
+        }
+
+        pDevices = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PPCI_DEVICE_DESCRIPTION) * noOfDevices, HEAP_TEMP_TAG, 0);
+        if (NULL == pDevices)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PPCI_DEVICE_DESCRIPTION) * noOfDevices);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        temp = noOfDevices;
+        status = PciSystemFindDevicesMatchingSpecification(pDeviceList, Specification, pDevices, &temp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("PciDevFindDevicesByClassAndSubclass", status);
+            __leave;
+        }
+        ASSERT(temp == noOfDevices);
+    }
+    __finally
+    {
+        if (SUCCEEDED(status))
+        {
+            *NumberOfDevices = noOfDevices;
+            *PciDevices = pDevices;
+        }
+        else
+        {
+            if( NULL != pDevices )
+            {
+                ExFreePoolWithTag(pDevices, HEAP_TEMP_TAG );
+                pDevices = NULL;
+            }
+        }
+    }
+
+    return status;
+}
+
+STATUS
+IoGetPciDevicesMatchingLocation(
+    IN          PCI_SPEC_LOCATION           Specification,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+                PPCI_DEVICE_DESCRIPTION**   PciDevices,
+    OUT         DWORD*                      NumberOfDevices
+    )
+{
+    STATUS status;
+    PLIST_ENTRY pDeviceList;
+    DWORD noOfDevices;
+    DWORD temp;
+    PPCI_DEVICE_DESCRIPTION* pDevices;
+
+    ASSERT(NULL != PciDevices);
+    ASSERT(NULL != NumberOfDevices);
+
+    status = STATUS_SUCCESS;
+    pDeviceList = IomuGetPciDeviceList();
+    noOfDevices = 0;
+    pDevices = NULL;
+
+    status = PciSystemFindDevicesMatchingLocation(pDeviceList, Specification, NULL, &noOfDevices );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciDevFindDevicesByClassAndSubclass", status);
+        return status;
+    }
+
+    __try
+    {
+        if (0 == noOfDevices)
+        {
+            status = STATUS_SUCCESS;
+            __leave;
+        }
+
+        pDevices = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PPCI_DEVICE_DESCRIPTION) * noOfDevices, HEAP_TEMP_TAG, 0);
+        if (NULL == pDevices)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PPCI_DEVICE_DESCRIPTION) * noOfDevices);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        temp = noOfDevices;
+        status = PciSystemFindDevicesMatchingLocation(pDeviceList, Specification, pDevices, &temp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("PciDevFindDevicesByClassAndSubclass", status);
+            __leave;
+        }
+        ASSERT(temp == noOfDevices);
+    }
+    __finally
+    {
+        if (SUCCEEDED(status))
+        {
+            *NumberOfDevices = noOfDevices;
+            *PciDevices = pDevices;
+        }
+        else
+        {
+            if( NULL != pDevices )
+            {
+                ExFreePoolWithTag(pDevices, HEAP_TEMP_TAG );
+                pDevices = NULL;
+            }
+        }
+    }
+
+    return status;
+}
+
+STATUS
+IoGetPciSecondaryBusForBridge(
+    IN          PCI_DEVICE_LOCATION         DeviceLocation,
+    OUT         BYTE*                       Bus
+    )
+{
+    STATUS status;
+    PLIST_ENTRY pDeviceList;
+    DWORD noOfDevices;
+    PPCI_DEVICE_DESCRIPTION device;
+    PCI_SPEC_LOCATION pciLocation;
+
+    ASSERT(NULL != Bus);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pDeviceList = IomuGetPciDeviceList();
+    noOfDevices = 0;
+    memzero(&pciLocation, sizeof(PCI_SPEC_LOCATION));
+
+    LOG_TRACE_IO("Will search for device at (%u.%u.%u)\n",
+        DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function);
+
+    memcpy(&pciLocation.Location, (const PVOID) &DeviceLocation, sizeof(PCI_DEVICE_LOCATION));
+    pciLocation.MatchBus = pciLocation.MatchDevice = pciLocation.MatchFunction = TRUE;
+
+    status = PciSystemFindDevicesMatchingLocation(pDeviceList, pciLocation, &device, &noOfDevices);
+    if(!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemFindDevicesMatchingLocation", status);
+        return status;
+    }
+    ASSERT(noOfDevices == 1);
+
+    if(device->DeviceData->Header.HeaderType.Layout != PCI_HEADER_LAYOUT_PCI_TO_PCI)
+    {
+        LOG_ERROR("Only bridges have devices attached to their secondary bus!\n");
+        return STATUS_DEVICE_TYPE_INVALID;
+    }
+
+    *Bus = device->DeviceData->Header.Bridge.SecondaryBusNumber;
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+IoGetDevicesByType(
+    IN                      DEVICE_TYPE         DeviceType,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+    PDEVICE_OBJECT**    DeviceObjects,
+    OUT                     DWORD*              NumberOfDevices
+    )
+{
+    ASSERT(_IoIsValidDeviceType(DeviceType));
+
+    // warning C6001: Using uninitialized memory (this warning is a caused by a SAL bug)
+    // NumberOfDevices is an OUT parameter to IomuGetDevicesByType as well
+#pragma warning(suppress: 6001)
+    return IomuGetDevicesByType(DeviceType, DeviceObjects, NumberOfDevices);
+}
+
+void
+IoFreeTemporaryData(
+    IN          PVOID               Data
+    )
+{
+    ASSERT(NULL != Data);
+
+    LOG_FUNC_START;
+
+    ExFreePoolWithTag(Data, HEAP_TEMP_TAG);
+
+    LOG_FUNC_END;
+}
+
+PTR_SUCCESS
+PIRP
+// Warning C6101 Returning uninitialized memory '*OutputBuffer'. A successful path through
+// the function does not set the named _Out_ parameter.
+// I'm really not proud of this, but there is no other way to tell SAL what's going on
+// and Microsoft does the exact same hack... You learn from the best!
+#pragma warning(suppress: 6101)
+IoBuildDeviceIoControlRequest(
+    IN          DWORD            IoControlCode,
+    IN          PDEVICE_OBJECT   DeviceObject,
+    IN_OPT      PVOID            InputBuffer,
+    IN          DWORD            InputBufferLength,
+    OUT_OPT     PVOID            OutputBuffer,
+    IN          DWORD            OutputBufferLength
+    )
+{
+    PIRP pIrp;
+    PIO_STACK_LOCATION pStackLocation;
+
+    ASSERT(NULL != DeviceObject);
+
+    pIrp = IoAllocateIrp(DeviceObject->StackSize);
+    if (NULL == pIrp)
+    {
+        LOG_ERROR("IoAllocateIrp failed!\n");
+        return NULL;
+    }
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+
+    pStackLocation->MajorFunction = IRP_MJ_DEVICE_CONTROL;
+    pStackLocation->Parameters.DeviceControl.IoControlCode = IoControlCode;
+    pStackLocation->Parameters.DeviceControl.InputBufferLength = InputBufferLength;
+    pStackLocation->Parameters.DeviceControl.OutputBufferLength = OutputBufferLength;
+    pStackLocation->Parameters.DeviceControl.OutputBuffer = OutputBuffer;
+
+    pIrp->Buffer = InputBuffer;
+
+    return pIrp;
+}
+
+STATUS
+IoReadDeviceEx(
+    IN                          PDEVICE_OBJECT          DeviceObject,
+    OUT_WRITES_BYTES(*Length)   PVOID                   Buffer,
+    INOUT                       QWORD*                  Length,
+    IN                          QWORD                   Offset,
+    IN                          BOOLEAN                 Asynchronous
+    )
+{
+    LOG_FUNC_START;
+
+    return _IoReadWriteDevice(DeviceObject, Buffer, Length, Offset, FALSE, Asynchronous);
+}
+
+STATUS
+IoWriteDeviceEx(
+    IN                          PDEVICE_OBJECT          DeviceObject,
+    IN_READS_BYTES(*Length)     PVOID                   Buffer,
+    INOUT                       QWORD*                  Length,
+    IN                          QWORD                   Offset,
+    IN                          BOOLEAN                 Asynchronous
+    )
+{
+    LOG_FUNC_START;
+
+    return _IoReadWriteDevice(DeviceObject, Buffer, Length, Offset, TRUE, Asynchronous);
+}
+
+STATUS
+IoAllocateMdl(
+    IN          PVOID           VirtualAddress,
+    IN          DWORD           Length,
+    IN_OPT      PIRP            Irp,
+    OUT_PTR     PMDL*           Mdl
+    )
+{
+    PMDL pMdl;
+
+    LOG_FUNC_START;
+
+    if (NULL == VirtualAddress)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (0 == Length)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == Mdl)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    pMdl = MdlAllocate(VirtualAddress, Length );
+    if (NULL == pMdl)
+    {
+        LOG_ERROR("MdlAllocate failed!\n");
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    if (NULL != Irp)
+    {
+        // set MDL
+        Irp->Mdl = pMdl;
+    }
+
+    *Mdl = pMdl;
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+void
+IoFreeMdl(
+    INOUT       PMDL            Mdl
+    )
+{
+    LOG_FUNC_START;
+
+    ASSERT( NULL != Mdl );
+
+    MdlFree(Mdl);
+
+    LOG_FUNC_END;
+}
+
+SIZE_SUCCESS
+DWORD
+IoMdlGetNumberOfPairs(
+    IN          PMDL            Mdl
+    )
+{
+    if (NULL == Mdl)
+    {
+        return INVALID_STRING_SIZE;
+    }
+
+    return MdlGetNumberOfPairs(Mdl);
+}
+
+PTR_SUCCESS
+PMDL_TRANSLATION_PAIR
+IoMdlGetTranslationPair(
+    IN          PMDL            Mdl,
+    IN          DWORD           Index
+    )
+{
+    if (NULL == Mdl)
+    {
+        return NULL;
+    }
+
+    return MdlGetTranslationPair(Mdl, Index);
+}
+
+STATUS
+IoRegisterInterruptEx(
+    IN          PIO_INTERRUPT           Interrupt,
+    IN_OPT      PDEVICE_OBJECT          DeviceObject,
+    OUT_OPT     PBYTE                   Vector
+    )
+{
+    STATUS status;
+
+    if (NULL == Interrupt)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = IomuRegisterInterrupt(Interrupt,DeviceObject, Vector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IomuRegisterInterrupt", status );
+        return status;
+    }
+
+    return status;
+}
+
+PTR_SUCCESS
+PVOID
+IoMapMemory(
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      DWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights
+    )
+{
+    if ( (NULL == PhysicalAddress) || ( 0 == Size ) )
+    {
+        return NULL;
+    }
+
+    return MmuMapMemoryEx(PhysicalAddress, Size, PageRights, TRUE, TRUE, NULL );
+}
+
+void
+IoUnmapMemory(
+    IN      PVOID                   VirtualAddress,
+    IN      DWORD                   Size
+    )
+{
+    ASSERT( NULL != VirtualAddress );
+    ASSERT( 0 != Size );
+
+    MmuUnmapSystemMemory(VirtualAddress, Size );
+}
+
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+IoGetPhysicalAddress(
+    IN      PVOID                   VirtualAddress
+    )
+{
+    if (NULL == VirtualAddress)
+    {
+        return NULL;
+    }
+
+    return MmuGetPhysicalAddress(VirtualAddress);
+}
+
+PTR_SUCCESS
+PVOID
+IoAllocateContinuousMemoryEx(
+    IN      DWORD                   AllocationSize,
+    IN      BOOLEAN                 Uncacheable
+    )
+{
+    if (0 == AllocationSize)
+    {
+        return NULL;
+    }
+
+    return VmmAllocRegionEx(NULL,
+                            AllocationSize,
+                            VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_NOT_LAZY,
+                            PAGE_RIGHTS_READWRITE,
+                            Uncacheable,
+                            NULL,
+                            NULL,
+                            NULL,
+                            NULL
+                            );
+}
+
+void
+IoFreeContinuousMemory(
+    IN      PVOID                   VirtualAddress
+    )
+{
+    ASSERT( NULL != VirtualAddress );
+
+    VmmFreeRegion(VirtualAddress, 0, VMM_FREE_TYPE_RELEASE );
+}
+
+
+DATETIME
+IoGetCurrentDateTime(
+    void
+    )
+{
+    return OsTimeGetCurrentDateTime();
+}
diff --git a/src_proiect/HAL9000/src/io_files.c b/src_proiect/HAL9000/src/io_files.c
new file mode 100644
index 0000000..a6a2093
--- /dev/null
+++ b/src_proiect/HAL9000/src/io_files.c
@@ -0,0 +1,549 @@
+#include "HAL9000.h"
+#include "io.h"
+#include "filesystem.h"
+#include "iomu.h"
+
+#include "strutils.h"
+
+// X:\\ => minimum 3 letters to open root
+#define FILE_NAME_MIN_LEN               3
+
+__forceinline
+static
+void
+_IoFreeFileObject(
+    IN          PFILE_OBJECT            FileObject
+    )
+{
+    ASSERT(NULL != FileObject);
+
+    ExFreePoolWithTag(FileObject, HEAP_FILE_OBJECT_TAG);
+}
+
+__forceinline
+static
+void
+_IoAllocateFileObject(
+    INOUT       PIO_STACK_LOCATION      StackLocation,
+    IN_Z        char*                   FileName,
+    IN          BOOLEAN                 Asynchronous,
+    IN          BOOLEAN                 Create,
+    IN          BOOLEAN                 Directory
+    )
+{
+    PFILE_OBJECT pFileObject;
+
+    ASSERT(NULL != StackLocation);
+    ASSERT(NULL != FileName);
+
+    pFileObject = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(FILE_OBJECT), HEAP_FILE_OBJECT_TAG, 0);
+    ASSERT(NULL != pFileObject);
+
+    pFileObject->FileName = (char*) FileName;
+
+    pFileObject->Flags.Asynchronous = Asynchronous;
+    pFileObject->Flags.Create = Create;
+    pFileObject->Flags.DirectoryFile = Directory;
+
+    pFileObject->FileSystemDevice = StackLocation->DeviceObject;
+
+    StackLocation->FileObject = pFileObject;
+}
+
+__forceinline
+static
+BOOLEAN
+_IoIsFilePathValid(
+    IN_Z        char*                   FileName
+    )
+{
+    DWORD strLength;
+
+    ASSERT(NULL != FileName);
+
+    strLength = strlen(FileName);
+    if (strLength < FILE_NAME_MIN_LEN)
+    {
+        return FALSE;
+    }
+
+    // there must be at least a backslash
+    if (FileName == strrchr(FileName, '\\'))
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static
+STATUS
+_IoReadWriteFile(
+    IN          PFILE_OBJECT            FileHandle,
+    _When_(!Write,OUT_WRITES_BYTES(Length))
+    _When_(Write,IN_READS_BYTES(Length))
+                PVOID                   Buffer,
+    IN          QWORD                   Length,
+    IN_OPT      QWORD*                  FileOffset,
+    OUT         QWORD*                  BytesTransferred,
+    IN          BOOLEAN                 Write
+    );
+
+STATUS
+IoCreateFile(
+    OUT_PTR     PFILE_OBJECT*           Handle,
+    IN_Z        char*                   FileName,
+    IN          BOOLEAN                 Directory,
+    IN          BOOLEAN                 Create,
+    IN          BOOLEAN                 Asynchronous
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PVPB pVpb;
+    char driveLetter;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PIO_STACK_LOCATION pStackLocation;
+
+    ASSERT(NULL != Handle);
+    ASSERT(NULL != FileName);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pVpb = NULL;
+    pFileSystemDevice = NULL;
+    pStackLocation = NULL;
+
+    // the search is case insensitive, but its nicer to print
+    // driver letters in uppercase :)
+    driveLetter = toupper(FileName[0]);
+
+    if (!_IoIsFilePathValid(FileName))
+    {
+        LOG_ERROR("_IoIsFilePathValid failed\n");
+        return STATUS_INVALID_FILE_NAME;
+    }
+
+    pVpb = IomuSearchForVpb(driveLetter);
+    if (NULL == pVpb)
+    {
+        LOG_ERROR("There is no corresponding VPB for drive letter: %c\n", driveLetter);
+        return STATUS_DEVICE_DOES_NOT_EXIST;
+    }
+
+    LOG_TRACE_IO("Found VPB for file %s\n", FileName);
+
+    if (!pVpb->Flags.Mounted)
+    {
+        LOG_ERROR("There is no file system mounted on drive %c\n", driveLetter);
+        return STATUS_DEVICE_NO_FILESYSTEM_MOUNTED;
+    }
+
+    pFileSystemDevice = pVpb->FilesystemDevice;
+    ASSERT(NULL != pFileSystemDevice);
+
+    pIrp = IoAllocateIrp(pFileSystemDevice->StackSize);
+    if (NULL == pIrp)
+    {
+        LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
+        return STATUS_HEAP_NO_MORE_MEMORY;
+    }
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+    pStackLocation->MajorFunction = IRP_MJ_CREATE;
+    pStackLocation->DeviceObject = pFileSystemDevice;
+
+    // currently there are no parameters for the create operation
+
+    // create the FILE_OBJECT for the stack location
+    _IoAllocateFileObject(pStackLocation, &FileName[FILE_NAME_MIN_LEN - 1], Asynchronous, Create, Directory);
+
+    __try
+    {
+
+        // call file system
+        status = IoCallDriver(pFileSystemDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            LOG_TRACE_IO("[ERROR]IoCallDriver failed with status 0x%x\n", status);
+
+            ASSERT(NULL != pStackLocation);
+            ASSERT(NULL != pStackLocation->FileObject);
+            _IoFreeFileObject(pStackLocation->FileObject);
+        }
+        else
+        {
+            LOG_TRACE_IO("File size: 0x%X\n", pStackLocation->FileObject->FileSize);
+
+            // complete file handle
+            *Handle = pStackLocation->FileObject;
+        }
+
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+IoCloseFile(
+    IN          PFILE_OBJECT            FileHandle
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PIO_STACK_LOCATION pStackLocation;
+
+    ASSERT(NULL != FileHandle);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pFileSystemDevice = FileHandle->FileSystemDevice;
+    pStackLocation = NULL;
+
+    ASSERT(NULL != pFileSystemDevice);
+
+    pIrp = IoAllocateIrp(pFileSystemDevice->StackSize);
+    if (NULL == pIrp)
+    {
+        LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
+        return STATUS_HEAP_NO_MORE_MEMORY;
+    }
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+
+    pStackLocation->MajorFunction = IRP_MJ_CLOSE;
+    pStackLocation->FileObject = FileHandle;
+
+    __try
+    {
+        status = IoCallDriver(pFileSystemDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+        status = pIrp->IoStatus.Status;
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+IoReadFile(
+    IN          PFILE_OBJECT            FileHandle,
+    IN          QWORD                   BytesToRead,
+    IN_OPT      QWORD*                  FileOffset,
+    OUT_WRITES_BYTES(BytesToRead)
+                PVOID                   Buffer,
+    OUT         QWORD*                  BytesRead
+    )
+{
+    return _IoReadWriteFile(FileHandle,
+                            Buffer,
+                            BytesToRead,
+                            FileOffset,
+                            BytesRead,
+                            FALSE);
+}
+
+STATUS
+IoWriteFile(
+    IN          PFILE_OBJECT            FileHandle,
+    IN          QWORD                   BytesToWrite,
+    IN_OPT      QWORD*                  FileOffset,
+    IN_READS_BYTES(BytesToWrite)
+                PVOID                   Buffer,
+    OUT         QWORD*                  BytesWritten
+    )
+{
+    return _IoReadWriteFile(FileHandle,
+                            Buffer,
+                            BytesToWrite,
+                            FileOffset,
+                            BytesWritten,
+                            TRUE);
+}
+
+STATUS
+IoGetFileSize(
+    IN          PFILE_OBJECT            FileHandle,
+    OUT         QWORD*                  FileSize
+    )
+{
+    if (FileHandle == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (FileSize == NULL)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    *FileSize = FileHandle->FileSize;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+IoQueryInformationFile(
+    IN          PFILE_OBJECT            FileHandle,
+    OUT         PFILE_INFORMATION       FileInformation
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PIO_STACK_LOCATION pStackLocation;
+
+    ASSERT(NULL != FileHandle);
+    ASSERT(NULL != FileInformation);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pFileSystemDevice = NULL;
+    pStackLocation = NULL;
+
+    pFileSystemDevice = FileHandle->FileSystemDevice;
+    ASSERT(NULL != pFileSystemDevice);
+
+    pIrp = IoAllocateIrp(pFileSystemDevice->StackSize);
+    if (NULL == pIrp)
+    {
+        LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
+        return STATUS_HEAP_NO_MORE_MEMORY;
+    }
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+    pStackLocation->MajorFunction = IRP_MJ_QUERY_INFORMATION;
+    pStackLocation->MinorFunction = IRP_MN_INFORMATION_FILE_INFORMATION;
+    pStackLocation->DeviceObject = pFileSystemDevice;
+    pStackLocation->FileObject = FileHandle;
+
+    // setup parameters
+    pStackLocation->Parameters.QueryFile.Length = sizeof(FILE_INFORMATION);
+    pIrp->Buffer = FileInformation;
+
+    __try
+    {
+        // call file system
+        status = IoCallDriver(pFileSystemDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+IoQueryDirectoryFile(
+    IN          PFILE_OBJECT                    FileHandle,
+    IN          DWORD                           BufferSize,
+    _When_(0==BufferSize,OUT_OPT)
+    _When_(0!=BufferSize,OUT)
+                PFILE_DIRECTORY_INFORMATION     DirectoryInformation,
+    OUT         DWORD*                          SizeRequired
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PIO_STACK_LOCATION pStackLocation;
+
+    ASSERT(NULL != FileHandle);
+    ASSERT(NULL != DirectoryInformation || 0 == BufferSize);
+    ASSERT(NULL != SizeRequired);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pFileSystemDevice = NULL;
+    pStackLocation = NULL;
+
+    pFileSystemDevice = FileHandle->FileSystemDevice;
+    ASSERT(NULL != pFileSystemDevice);
+
+    pIrp = IoAllocateIrp(pFileSystemDevice->StackSize);
+    if (NULL == pIrp)
+    {
+        LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
+        return STATUS_HEAP_NO_MORE_MEMORY;
+    }
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+    pStackLocation->MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
+    pStackLocation->MinorFunction = IRP_MN_QUERY_DIRECTORY;
+    pStackLocation->DeviceObject = pFileSystemDevice;
+
+    pStackLocation->FileObject = FileHandle;
+    pStackLocation->Parameters.QueryDirectory.Length = BufferSize;
+
+    pIrp->Buffer = DirectoryInformation;
+
+    __try
+    {
+        status = IoCallDriver(pFileSystemDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+
+        ASSERT(pIrp->IoStatus.Information <= MAX_DWORD);
+        *SizeRequired = (DWORD)pIrp->IoStatus.Information;
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+static
+STATUS
+_IoReadWriteFile(
+    IN          PFILE_OBJECT            FileHandle,
+    _When_(!Write,OUT_WRITES_BYTES(Length))
+    _When_(Write,IN_READS_BYTES(Length))
+                PVOID                   Buffer,
+    IN          QWORD                   Length,
+    IN_OPT      QWORD*                  FileOffset,
+    OUT         QWORD*                  BytesTransferred,
+    IN          BOOLEAN                 Write
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PIO_STACK_LOCATION pStackLocation;
+    QWORD fileOffset;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != FileHandle);
+    ASSERT(NULL != Buffer);
+    ASSERT(NULL != BytesTransferred);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    pFileSystemDevice = NULL;
+    pStackLocation = NULL;
+
+    if (FileHandle->Flags.Asynchronous)
+    {
+        ASSERT(NULL != FileOffset);
+
+        fileOffset = *FileOffset;
+    }
+    else
+    {
+        if (NULL == FileOffset)
+        {
+            fileOffset = FileHandle->CurrentByteOffset;
+        }
+        else
+        {
+            fileOffset = *FileOffset;
+        }
+    }
+
+    pFileSystemDevice = FileHandle->FileSystemDevice;
+    ASSERT(NULL != pFileSystemDevice);
+
+    pIrp = IoAllocateIrp(pFileSystemDevice->StackSize);
+    if (NULL == pIrp)
+    {
+        LOG_FUNC_ERROR_ALLOC("IoAllocateIrp", sizeof(IRP));
+        return STATUS_HEAP_NO_MORE_MEMORY;
+    }
+    pIrp->Buffer = Buffer;
+
+    // pass async parameter
+    pIrp->Flags.Asynchronous = FileHandle->Flags.Asynchronous;
+
+    pStackLocation = IoGetNextIrpStackLocation(pIrp);
+    pStackLocation->MajorFunction = Write ? IRP_MJ_WRITE : IRP_MJ_READ;
+    pStackLocation->DeviceObject = pFileSystemDevice;
+
+    // setup parameters
+    pStackLocation->Parameters.ReadWrite.Length = Length;
+    pStackLocation->Parameters.ReadWrite.Offset = fileOffset;
+    pStackLocation->FileObject = FileHandle;
+
+    __try
+    {
+        // call file system
+        status = IoCallDriver(pFileSystemDevice, pIrp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        *BytesTransferred = pIrp->IoStatus.Information;
+
+        if (SUCCEEDED(status))
+        {
+            // if synchronous operation => update file offset
+            if (!FileHandle->Flags.Asynchronous)
+            {
+                FileHandle->CurrentByteOffset = FileHandle->CurrentByteOffset + *BytesTransferred;
+            }
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/ioapic_system.c b/src_proiect/HAL9000/src/ioapic_system.c
new file mode 100644
index 0000000..749b28b
--- /dev/null
+++ b/src_proiect/HAL9000/src/ioapic_system.c
@@ -0,0 +1,841 @@
+#include "HAL9000.h"
+#include "pci_system.h"
+#include "ioapic_system.h"
+#include "acpi_interface.h"
+#include "io.h"
+#include "ioapic.h"
+#include "bitmap.h"
+#include "lapic_system.h"
+#include "synch.h"
+
+typedef struct _IO_APIC_INTERRUPT_OVERRIDE
+{
+    BYTE                SourceIrq;
+    BYTE                DestinationIrq;
+
+    APIC_TRIGGER_MODE   TriggerMode;
+    APIC_PIN_POLARITY   PinPolarity;
+} IO_APIC_INTERRUPT_OVERRIDE, *PIO_APIC_INTERRUPT_OVERRIDE;
+
+typedef struct _IO_APIC_PRT_ENTRY
+{
+    PCI_DEVICE_LOCATION DeviceLocation;
+
+    DWORD               IoApicLine;
+    BYTE                InterruptPin;
+} IO_APIC_PRT_ENTRY, *PIO_APIC_PRT_ENTRY;
+
+typedef struct _IO_APIC_ENTRY
+{
+    // Pseudo RO - initialized once, should never be modified again
+    APIC_ID             ApicId;
+    BYTE                Version;
+    BYTE                IrqBase;
+    BYTE                MaximumRedirectionEntry;
+
+    LOCK                IoApicLock;
+
+    // Access to the IOAPIC memory and to the software managed interrupts written bitmap
+    // must be protected by a lock, we can't use a shared one because even reads from the
+    // IOAPIC imply writes to some mapped registers
+
+    _Guarded_by_(IoApicLock)
+    PVOID               MappedAddress;
+
+    _Guarded_by_(IoApicLock)
+    BITMAP              InterruptsWritten;
+    DWORD               BitmapBuffer;
+
+    LIST_ENTRY          ListEntry;
+} IO_APIC_ENTRY, *PIO_APIC_ENTRY;
+
+typedef struct _IO_APIC_SYSTEM_DATA
+{
+    LIST_ENTRY                      ApicList;
+
+    BOOLEAN                         MaskInterrupts;
+
+    BYTE                            Version;
+
+    DWORD                           NoOfInterruptOverrides;
+    PIO_APIC_INTERRUPT_OVERRIDE     InterruptOverrides;
+
+    DWORD                           NoOfPrtEntries;
+    PIO_APIC_PRT_ENTRY              PrtEntries;
+} IO_APIC_SYSTEM_DATA, *PIO_APIC_SYSTEM_DATA;
+
+static IO_APIC_SYSTEM_DATA m_ioApicData;
+
+__forceinline
+static
+_Ret_maybenull_
+PIO_APIC_INTERRUPT_OVERRIDE
+_IoApicReturnInterruptOverrideForIrq(
+    IN      BYTE        Irq
+    )
+{
+    PIO_APIC_INTERRUPT_OVERRIDE pResult = NULL;
+    DWORD i;
+
+    for( i = 0; i < m_ioApicData.NoOfInterruptOverrides; ++i )
+    {
+        ASSERT( NULL != m_ioApicData.InterruptOverrides );
+
+        if( m_ioApicData.InterruptOverrides[i].SourceIrq == Irq )
+        {
+            pResult = &m_ioApicData.InterruptOverrides[i];
+        }
+    }
+
+    if( NULL != pResult )
+    {
+        LOG_TRACE_INTERRUPT("Found interrupt override IRQ 0x%x -> 0x%x, Trigger mode: [%s], Pin Polarity: [%s]\n",
+                            Irq, pResult->DestinationIrq,
+                            pResult->TriggerMode == ApicTriggerModeEdge ? "Edge" : "Level",
+                            pResult->PinPolarity == ApicPinPolarityActiveHigh ? "High" : "Low"
+                            );
+    }
+    else
+    {
+        LOG_TRACE_INTERRUPT("No interrupt override for IRQ 0x%x\n", Irq );
+    }
+
+    return pResult;
+}
+
+static
+STATUS
+_IoApicSystemRetrieveIoApics(
+    void
+    );
+
+static
+STATUS
+_IoApicSystemRetrieveInterruptOverrides(
+    void
+    );
+
+static
+STATUS
+_IoApicSystemRetrievePrtEntries(
+    void
+    );
+
+static
+STATUS
+_IoApicSystemInitEntry(
+    IN          ACPI_MADT_IO_APIC*     AcpiEntry,
+    OUT_PTR     PIO_APIC_ENTRY*        IoApicEntry
+    );
+
+static
+PTR_SUCCESS
+PIO_APIC_ENTRY
+_IoApicSystemGetIoApicForIrq(
+    IN          BYTE                            Irq,
+    OUT         PBYTE                           RelativeIrq,
+    OUT_OPT_PTR_MAYBE_NULL
+                PIO_APIC_INTERRUPT_OVERRIDE*    InterruptOverride
+    );
+
+_No_competing_thread_
+void
+IoApicSystemPreinit(
+    void
+    )
+{
+    memzero(&m_ioApicData, sizeof(IO_APIC_SYSTEM_DATA));
+
+    InitializeListHead(&m_ioApicData.ApicList);
+    m_ioApicData.MaskInterrupts = TRUE;
+}
+
+_No_competing_thread_
+STATUS
+IoApicSystemInit(
+    void
+    )
+{
+    STATUS status;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    status = _IoApicSystemRetrieveIoApics();
+    if(!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IoApicSystemRetrieveIoApics", status);
+        return status;
+    }
+    LOGL("IO APICs retrieved successfully\n");
+
+    status = _IoApicSystemRetrieveInterruptOverrides();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IoApicSystemRetrieveInterruptOverrides", status);
+        return status;
+    }
+    LOGL("IO APIC interrupt overrides retrieved successfully\n");
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+_No_competing_thread_
+STATUS
+IoApicLateSystemInit(
+    void
+    )
+{
+    STATUS status;
+
+    LOG_FUNC_START;
+
+    status = _IoApicSystemRetrievePrtEntries();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IoApicSystemRetrievePrtEntries", status);
+        return status;
+    }
+    LOGL("PRT entries retrieved successfully\n");
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+_No_competing_thread_
+void
+IoApicSystemEnableRegisteredInterrupts(
+    void
+    )
+{
+    PLIST_ENTRY pEntry;
+    PIO_APIC_ENTRY pIoApic;
+
+    m_ioApicData.MaskInterrupts = FALSE;
+
+
+    for (pEntry = m_ioApicData.ApicList.Flink;
+        pEntry != &m_ioApicData.ApicList;
+        pEntry = pEntry->Flink
+        )
+    {
+        pIoApic = CONTAINING_RECORD(pEntry, IO_APIC_ENTRY, ListEntry);
+
+        for (BYTE i = 0; i <= pIoApic->MaximumRedirectionEntry; ++i)
+        {
+            // if there is an interrupt registered => unmask it
+            if (BitmapGetBitValue(&pIoApic->InterruptsWritten, i))
+            {
+                LOG_TRACE_INTERRUPT("Will unmask entry %u on IO APIC 0x%02x\n", i, pIoApic->ApicId );
+                IoApicSetRedirectionTableEntryMask(pIoApic->MappedAddress, i, FALSE);
+            }
+        }
+    }
+}
+
+STATUS
+IoApicSystemSetInterrupt(
+    IN      BYTE                    Irq,
+    IN      BYTE                    Vector,
+    IN _Strict_type_match_
+            APIC_DESTINATION_MODE   DestinationMode,
+    IN _Strict_type_match_
+            APIC_DELIVERY_MODE      DeliveryMode,
+    IN _Strict_type_match_
+            APIC_PIN_POLARITY       PinPolarity,
+    IN  _Strict_type_match_
+            APIC_TRIGGER_MODE       TriggerMode,
+    IN      APIC_ID                 Destination,
+    IN      BOOLEAN                 Overwrite
+    )
+{
+    PIO_APIC_ENTRY pIoApic;
+    BYTE offsetInIoApic;
+    PIO_APIC_INTERRUPT_OVERRIDE pInterruptOverride;
+    APIC_PIN_POLARITY pinPolarity;
+    APIC_TRIGGER_MODE triggerMode;
+    STATUS status;
+    INTR_STATE oldState;
+
+    LOG_FUNC_START;
+
+    pIoApic = NULL;
+    offsetInIoApic = 0;
+    pInterruptOverride = NULL;
+    status = STATUS_SUCCESS;
+
+    pIoApic = _IoApicSystemGetIoApicForIrq(Irq, &offsetInIoApic, &pInterruptOverride);
+    if (NULL == pIoApic)
+    {
+        LOG_ERROR("Couldn't find IO Apic for IRQ 0x%x\n", Irq);
+        return STATUS_DEVICE_DOES_NOT_EXIST;
+    }
+    ASSERT(NULL != pIoApic);
+
+    LockAcquire(&pIoApic->IoApicLock, &oldState);
+
+    __try
+    {
+        pinPolarity = pInterruptOverride != NULL ? pInterruptOverride->PinPolarity : PinPolarity;
+        triggerMode = pInterruptOverride != NULL ? pInterruptOverride->TriggerMode : TriggerMode;
+
+        LOG_TRACE_INTERRUPT("Irq 0x%x belongs to IO APIC 0x%02x\n", Irq, pIoApic->ApicId);
+
+        if (BitmapGetBitValue(&pIoApic->InterruptsWritten, offsetInIoApic) && !Overwrite)
+        {
+            LOG_ERROR("Interrupt 0x%x is already taken in IO Apic 0x%x\n", offsetInIoApic, pIoApic->ApicId);
+            status = STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE;
+            __leave;
+        }
+
+        ASSERT(TRUE == LapicSystemGetState());
+        IoApicSetRedirectionTableEntry(pIoApic->MappedAddress,
+                                       offsetInIoApic,
+                                       Vector,
+                                       DestinationMode,
+                                       Destination,
+                                       DeliveryMode,
+                                       pinPolarity,
+                                       8 != Irq ? triggerMode : ApicTriggerModeLevel
+        );
+        BitmapSetBit(&pIoApic->InterruptsWritten, offsetInIoApic);
+
+        if (!m_ioApicData.MaskInterrupts)
+        {
+            IoApicSetRedirectionTableEntryMask(pIoApic->MappedAddress, offsetInIoApic, FALSE);
+        }
+    }
+    __finally
+    {
+        LockRelease(&pIoApic->IoApicLock, oldState);
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+void
+IoApicSystemMaskInterrupt(
+    IN      BYTE                    Irq,
+    IN      BOOLEAN                 Mask
+    )
+{
+    PIO_APIC_ENTRY pIoApic;
+    BYTE offsetInIoApic;
+    INTR_STATE oldState;
+
+    LOG_FUNC_START;
+
+    pIoApic = NULL;
+    offsetInIoApic = 0;
+
+    pIoApic = _IoApicSystemGetIoApicForIrq(Irq, &offsetInIoApic, NULL);
+    ASSERT(NULL != pIoApic);
+
+    LockAcquire(&pIoApic->IoApicLock, &oldState);
+    IoApicSetRedirectionTableEntryMask(pIoApic->MappedAddress, offsetInIoApic, Mask);
+    LockRelease(&pIoApic->IoApicLock, oldState);
+
+    LOG_FUNC_END;
+}
+
+STATUS
+IoApicSystemGetVectorForIrq(
+    IN      BYTE                    Irq,
+    OUT     PBYTE                   Vector
+    )
+{
+    PIO_APIC_ENTRY pIoApic;
+    BYTE offsetInIoApic;
+    INTR_STATE oldState;
+    STATUS status;
+
+    ASSERT(Vector != NULL);
+
+    status = STATUS_SUCCESS;
+
+    pIoApic = _IoApicSystemGetIoApicForIrq(Irq, &offsetInIoApic, NULL);
+    if (NULL == pIoApic)
+    {
+        LOG_ERROR("Couldn't find IO Apic for IRQ 0x%x\n", Irq);
+        return STATUS_DEVICE_DOES_NOT_EXIST;
+    }
+    ASSERT(NULL != pIoApic);
+
+    LockAcquire(&pIoApic->IoApicLock, &oldState);
+
+    __try
+    {
+        if (0 == BitmapGetBitValue(&pIoApic->InterruptsWritten, offsetInIoApic))
+        {
+            LOG_WARNING("Interrupt 0x%x is not registered in IO Apic 0x%x\n", offsetInIoApic, pIoApic->ApicId);
+            status = STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED;
+            __leave;
+        }
+
+        *Vector = IoApicGetRedirectionTableEntryVector(pIoApic->MappedAddress, offsetInIoApic);
+    }
+    __finally
+    {
+        LockRelease(&pIoApic->IoApicLock, oldState);
+    }
+
+    return status;
+}
+
+DWORD
+IoApicGetInterruptLineForPciDevice(
+    IN      struct _PCI_DEVICE_DESCRIPTION* PciDevice
+    )
+{
+    BOOLEAN bFound;
+    DWORD irqLine;
+
+    ASSERT( NULL != PciDevice );
+
+    LOG_FUNC_START;
+
+    bFound = FALSE;
+    irqLine = MAX_DWORD;
+
+    for( DWORD i = 0; i < m_ioApicData.NoOfPrtEntries; ++i )
+    {
+        PIO_APIC_PRT_ENTRY pEntry = &m_ioApicData.PrtEntries[i];
+
+        if( pEntry->DeviceLocation.Bus != PciDevice->DeviceLocation.Bus )
+        {
+            continue;
+        }
+
+        if( pEntry->DeviceLocation.Device != PciDevice->DeviceLocation.Device )
+        {
+            continue;
+        }
+
+        if( pEntry->DeviceLocation.Function != MAX_BYTE && pEntry->DeviceLocation.Function != PciDevice->DeviceLocation.Function )
+        {
+            continue;
+        }
+
+        if( pEntry->InterruptPin != PciDevice->DeviceData->Header.Device.InterruptPin )
+        {
+            continue;
+        }
+
+        bFound = TRUE;
+        irqLine = pEntry->IoApicLine;
+        break;
+    }
+
+    if(!bFound)
+    {
+        // If we didn't find an entry for the device we need to see if it is behind a secondary bridge
+        // If it is => we need to translate the PIN index of the device connected to the bridge, i.e
+        // on the secondary bus to the pin index of the bridge on the primary bus
+        // See PCI Bridge Specification V 1.1 Section 9.1 Interrupt Routing
+        BYTE accumulatedOffset = PciDevice->DeviceData->Header.Device.InterruptPin;
+
+        for( PPCI_DEVICE_DESCRIPTION pParentDescription = PciDevice->Parent;
+             pParentDescription != NULL;
+             pParentDescription = pParentDescription->Parent )
+        {
+            if(pParentDescription->Parent != NULL)
+            {
+                /// TODO: Make sure translation for secondary bus to primary bus is actually correct
+                accumulatedOffset = ( accumulatedOffset + pParentDescription->DeviceLocation.Function ) % 4;
+            }
+        }
+
+        irqLine = 0x10 + accumulatedOffset;
+
+        LOGL("Accumulated offset 0x%x, child line 0x%02x\n",
+             accumulatedOffset, irqLine );
+    }
+
+    LOGL("PCI device at (%u.%u.%u) will use IO APIC line 0x%02x for PIN %c, %s entry in PRT\n",
+         PciDevice->DeviceLocation.Bus, PciDevice->DeviceLocation.Device, PciDevice->DeviceLocation.Function,
+         irqLine, 'A' + PciDevice->DeviceData->Header.Device.InterruptPin - 1,
+         bFound ? "use" : "no");
+
+    LOG_FUNC_END;
+
+    return irqLine;
+}
+
+void
+IoApicSystemSendEOI(
+    IN      BYTE                Vector
+    )
+{
+    UNREFERENCED_PARAMETER(Vector);
+
+    if (m_ioApicData.Version >= IO_APIC_VERSION_PCI_22_COMPLIANT)
+    {
+        LOG_WARNING("This functionality is not implemented\n");
+    }
+}
+
+static
+STATUS
+_IoApicSystemRetrieveIoApics(
+    void
+    )
+{
+    STATUS status;
+    ACPI_MADT_IO_APIC* pEntry;
+    BOOLEAN bRestartSearch;
+    PIO_APIC_ENTRY pIoApic;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pEntry = NULL;
+    bRestartSearch = TRUE;
+    pIoApic = NULL;
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        ASSERT(NULL == pIoApic);
+
+        status = AcpiRetrieveNextIoApic(bRestartSearch, &pEntry);
+        if (STATUS_NO_MORE_OBJECTS == status)
+        {
+            LOGL("Reached end of IO Apic list\n");
+            status = STATUS_SUCCESS;
+            break;
+        }
+
+        status = _IoApicSystemInitEntry(pEntry, &pIoApic);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_IoApicInitEntry", status );
+            return status;
+        }
+
+        InsertTailList(&m_ioApicData.ApicList, &pIoApic->ListEntry);
+
+        if (bRestartSearch)
+        {
+            // first iteration
+            m_ioApicData.Version = pIoApic->Version;
+        }
+
+        // make sure we don't have 2+ IO Apics with different versions
+        ASSERT(pIoApic->Version == m_ioApicData.Version);
+
+        bRestartSearch = FALSE;
+        pIoApic = NULL;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_IoApicSystemRetrieveInterruptOverrides(
+    void
+    )
+{
+    STATUS status;
+    ACPI_MADT_INTERRUPT_OVERRIDE* pEntry;
+    BOOLEAN bRestartSearch;
+    PIO_APIC_INTERRUPT_OVERRIDE pInterruptOverride;
+    DWORD noOfInterruptOverrides;
+    DWORD i;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pInterruptOverride = NULL;
+    noOfInterruptOverrides = 0;
+    pEntry = NULL;
+
+    for (i = 0; i < 2; ++i)
+    {
+        bRestartSearch = TRUE;
+        m_ioApicData.NoOfInterruptOverrides = noOfInterruptOverrides;
+
+        if( noOfInterruptOverrides == 0 )
+        {
+            if (i == 1)
+            {
+                // there are no interrupt overrides
+                break;
+            }
+        }
+
+        if( noOfInterruptOverrides != 0 )
+        {
+            pInterruptOverride = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(IO_APIC_INTERRUPT_OVERRIDE) * noOfInterruptOverrides, HEAP_APIC_TAG, 0 );
+            if( NULL == pInterruptOverride )
+            {
+                LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(IO_APIC_INTERRUPT_OVERRIDE) * noOfInterruptOverrides);
+                return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            }
+        }
+
+        noOfInterruptOverrides = 0;
+
+#pragma warning(suppress:4127)
+        while (TRUE)
+        {
+            status = AcpiRetrieveNextInterruptOverride(bRestartSearch, &pEntry);
+            if (STATUS_NO_MORE_OBJECTS == status)
+            {
+                LOGL("Reached end of Interrupt override list\n");
+                status = STATUS_SUCCESS;
+                break;
+            }
+
+            if( NULL != pInterruptOverride )
+            {
+                // init structure
+                pInterruptOverride[noOfInterruptOverrides].SourceIrq = pEntry->SourceIrq;
+
+                ASSERT( pEntry->GlobalIrq <= MAX_BYTE );
+                pInterruptOverride[noOfInterruptOverrides].DestinationIrq = (BYTE) pEntry->GlobalIrq;
+                pInterruptOverride[noOfInterruptOverrides].PinPolarity = IsBooleanFlagOn(pEntry->IntiFlags, 0b10);
+                pInterruptOverride[noOfInterruptOverrides].TriggerMode = IsBooleanFlagOn(pEntry->IntiFlags, 0b1000 );
+
+                ASSERT_INFO( 0 == pEntry->Bus, "Only 0 (ISA Bus) is documented in the ACPI specfication\n" );
+            }
+
+            noOfInterruptOverrides++;
+
+            bRestartSearch = FALSE;
+        }
+
+        if( i == 1 )
+        {
+            ASSERT( noOfInterruptOverrides == m_ioApicData.NoOfInterruptOverrides );
+        }
+    }
+
+    m_ioApicData.NoOfInterruptOverrides = noOfInterruptOverrides;
+    m_ioApicData.InterruptOverrides = pInterruptOverride;
+
+    return status;
+}
+
+
+static
+STATUS
+_IoApicSystemRetrievePrtEntries(
+    void
+    )
+{
+    STATUS status;
+    ACPI_PCI_ROUTING_TABLE* pEntry;
+    BOOLEAN bRestartSearch;
+    PIO_APIC_PRT_ENTRY pPrtEntires;
+    DWORD noOfPrtEntries;
+    DWORD i;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pPrtEntires = NULL;
+    noOfPrtEntries = 0;
+    pEntry = NULL;
+
+    for (i = 0; i < 2; ++i)
+    {
+        bRestartSearch = TRUE;
+        m_ioApicData.NoOfInterruptOverrides = noOfPrtEntries;
+
+        if (noOfPrtEntries == 0)
+        {
+            if (i == 1)
+            {
+                // there are no PRT entries
+                break;
+            }
+        }
+
+        if (noOfPrtEntries != 0)
+        {
+            pPrtEntires = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(IO_APIC_PRT_ENTRY) * noOfPrtEntries, HEAP_APIC_TAG, 0);
+            if (NULL == pPrtEntires)
+            {
+                LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(IO_APIC_PRT_ENTRY) * noOfPrtEntries);
+                return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            }
+        }
+
+        noOfPrtEntries = 0;
+
+#pragma warning(suppress:4127)
+        while (TRUE)
+        {
+            BYTE busNumber;
+            WORD segmentNumber;
+
+            status = AcpiRetrieveNextPrtEntry(bRestartSearch, &pEntry, &busNumber, &segmentNumber);
+            if (STATUS_NO_MORE_OBJECTS == status)
+            {
+                LOGL("Reached end of PRT list\n");
+                status = STATUS_SUCCESS;
+                break;
+            }
+
+            ASSERT( 0 == segmentNumber );
+
+            if (NULL != pPrtEntires)
+            {
+                // init structure
+                pPrtEntires[noOfPrtEntries].DeviceLocation.Bus = busNumber;
+                pPrtEntires[noOfPrtEntries].DeviceLocation.Device = (BYTE) (WORD_LOW(DWORD_HIGH(QWORD_LOW(pEntry->Address))));
+                pPrtEntires[noOfPrtEntries].DeviceLocation.Function = (BYTE) (pEntry->Address & MAX_BYTE);
+
+                // PCI specification 3.0 Section 6.2.4
+                // A value of 1 corresponds to INTA#.A value of 2 corresponds to INTB#.A value of 3
+                // corresponds to INTC#.A value of 4 corresponds to INTD#. Devices (or device functions)
+                // that do not use an interrupt pin must put a 0 in this register.
+
+                // ACPI specification 6.0 Section 6.2.13
+                // The PCI pin number of the device (0INTA, 1INTB, 2INTC, 3INTD).
+
+                // => we need to add 1 to the PIN number
+                pPrtEntires[noOfPrtEntries].InterruptPin = (BYTE) pEntry->Pin + 1;
+                pPrtEntires[noOfPrtEntries].IoApicLine = pEntry->SourceIndex;
+
+                ASSERT( 0 == *((DWORD*)pEntry->Source));
+
+                LOG_TRACE_PCI("[%u] PRT entry for device (%u.%u.%u) with interrupt pin %c at IO APIC line 0x%02x\n",
+                    noOfPrtEntries,
+                    pPrtEntires[noOfPrtEntries].DeviceLocation.Bus,
+                    pPrtEntires[noOfPrtEntries].DeviceLocation.Device,
+                    pPrtEntires[noOfPrtEntries].DeviceLocation.Function,
+                    'A' + pPrtEntires[noOfPrtEntries].InterruptPin - 1,
+                    pPrtEntires[noOfPrtEntries].IoApicLine);
+            }
+
+            noOfPrtEntries++;
+
+            bRestartSearch = FALSE;
+        }
+
+        if (i == 1)
+        {
+            ASSERT(noOfPrtEntries == m_ioApicData.NoOfInterruptOverrides);
+        }
+    }
+
+    m_ioApicData.NoOfPrtEntries = noOfPrtEntries;
+    m_ioApicData.PrtEntries = pPrtEntires;
+
+    return status;
+}
+
+static
+STATUS
+_IoApicSystemInitEntry(
+    IN          ACPI_MADT_IO_APIC*     AcpiEntry,
+    OUT_PTR     PIO_APIC_ENTRY*        IoApicEntry
+    )
+{
+    PIO_APIC_ENTRY pIoApic;
+    DWORD bitmapSize;
+    BYTE i;
+
+    ASSERT( NULL != AcpiEntry );
+    ASSERT( NULL != IoApicEntry );
+
+    pIoApic = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(IO_APIC_ENTRY), HEAP_APIC_TAG, 0);
+    if (NULL == pIoApic)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(IO_APIC_ENTRY));
+        return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+    }
+
+    pIoApic->ApicId = AcpiEntry->Id;
+
+
+    ASSERT(AcpiEntry->GlobalIrqBase <= MAX_BYTE);
+    pIoApic->IrqBase = (BYTE) AcpiEntry->GlobalIrqBase;
+
+    // warning C4312: 'type cast': conversion from 'const UINT32' to 'PHYSICAL_ADDRESS' of greater size
+#pragma warning(suppress:4312)
+    pIoApic->MappedAddress = IoMapMemory((PHYSICAL_ADDRESS)AcpiEntry->Address,
+                                         PAGE_SIZE,
+                                         PAGE_RIGHTS_READWRITE
+                                         );
+    if (NULL == pIoApic->MappedAddress)
+    {
+        LOG_FUNC_ERROR("IoMapMemory failed to map PA 0x%x\n", AcpiEntry->Address);
+        return STATUS_MEMORY_CANNOT_BE_MAPPED;
+    }
+    ASSERT(IoApicGetId( pIoApic->MappedAddress) == pIoApic->ApicId);
+    pIoApic->Version = IoApicGetVersion(pIoApic->MappedAddress);
+
+    pIoApic->MaximumRedirectionEntry = IoApicGetMaximumRedirectionEntry(pIoApic->MappedAddress);
+
+    bitmapSize = BitmapPreinit(&pIoApic->InterruptsWritten, pIoApic->MaximumRedirectionEntry + 1 );
+    ASSERT( bitmapSize <= sizeof(DWORD));
+
+    BitmapInit(&pIoApic->InterruptsWritten, (PBYTE) &pIoApic->BitmapBuffer );
+
+    for (i = 0; i <= pIoApic->MaximumRedirectionEntry; ++i)
+    {
+        // mask all IO apic interrupts
+        IoApicSetRedirectionTableEntryMask(pIoApic->MappedAddress, i, TRUE );
+    }
+
+    LockInit(&pIoApic->IoApicLock);
+
+    *IoApicEntry = pIoApic;
+
+    return STATUS_SUCCESS;
+}
+
+static
+PTR_SUCCESS
+PIO_APIC_ENTRY
+_IoApicSystemGetIoApicForIrq(
+    IN          BYTE                            Irq,
+    OUT         PBYTE                           RelativeIrq,
+    OUT_OPT_PTR_MAYBE_NULL
+                PIO_APIC_INTERRUPT_OVERRIDE*    InterruptOverride
+    )
+{
+    PLIST_ENTRY pEntry;
+    PIO_APIC_ENTRY pIoApic;
+    PIO_APIC_INTERRUPT_OVERRIDE pInterruptOverride;
+    BYTE finalIrq;
+
+    ASSERT( NULL != RelativeIrq );
+
+    // before searching for the Irq we have to see if we don't have any interrupt
+    // overrides for it
+    pInterruptOverride = _IoApicReturnInterruptOverrideForIrq(Irq);
+    finalIrq = pInterruptOverride != NULL ? pInterruptOverride->DestinationIrq : Irq;
+    if( NULL != InterruptOverride )
+    {
+        *InterruptOverride = pInterruptOverride;
+    }
+
+    for (pEntry = m_ioApicData.ApicList.Flink;
+    pEntry != &m_ioApicData.ApicList;
+        pEntry = pEntry->Flink
+        )
+    {
+        pIoApic = CONTAINING_RECORD(pEntry, IO_APIC_ENTRY, ListEntry);
+
+        if (CHECK_BOUNDS(finalIrq, 1, pIoApic->IrqBase, pIoApic->MaximumRedirectionEntry + 1))
+        {
+            LOG("Irq 0x%x is handled by IO APIC 0x%x which handles [0x%x, 0x%x]\n",
+                finalIrq, pIoApic->ApicId, pIoApic->IrqBase, pIoApic->MaximumRedirectionEntry);
+
+            *RelativeIrq = finalIrq - pIoApic->IrqBase;
+            return pIoApic;
+        }
+    }
+
+    return NULL;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/iomu.c b/src_proiect/HAL9000/src/iomu.c
new file mode 100644
index 0000000..cf49feb
--- /dev/null
+++ b/src_proiect/HAL9000/src/iomu.c
@@ -0,0 +1,1370 @@
+#include "HAL9000.h"
+#include "idt_handlers.h"
+#include "iomu.h"
+#include "pic.h"
+#include "rtc.h"
+#include "keyboard.h"
+#include "pci_system.h"
+#include "strutils.h"
+#include "disk.h"
+#include "volume.h"
+#include "ata.h"
+#include "filesystem.h"
+#include "fat32.h"
+#include "swapfs.h"
+#include "lapic_system.h"
+#include "dmp_io.h"
+#include "isr.h"
+#include "os_info.h"
+#include "eth_82574L.h"
+#include "system_driver.h"
+#include "ioapic_system.h"
+#include "bitmap.h"
+#include "pit.h"
+#include "smp.h"
+#include "ex_system.h"
+#include "lock_common.h"
+
+#define PIC_MASTER_OFFSET                   0x20
+#define PIC_SLAVE_OFFSET                    0x28
+
+#define SCHEDULER_TIMER_INTERRUPT_TIME_US   (40*MS_IN_US)
+
+#define HAL9000_SYSTEM_FILE_NAME            "HAL9000.ini"
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+typedef union __declspec(align(8)) _UPTIME
+{
+    struct
+    {
+        volatile    DWORD   UptimeSeconds;
+        volatile    DWORD   UptimeMicroseconds;
+    };
+    volatile        QWORD   Raw;
+} UPTIME, *PUPTIME;
+#pragma warning(pop)
+
+typedef struct _REGISTERED_INTERRUPT_ENTRY
+{
+    LIST_ENTRY                  ListEntry;
+
+    PFUNC_InterruptFunction     Function;
+    PDEVICE_OBJECT              Device;
+} REGISTERED_INTERRUPT_ENTRY, *PREGISTERED_INTERRUPT_ENTRY;
+
+typedef struct _REGISTERED_INTERRUPT_LIST
+{
+    RW_SPINLOCK                 Lock;
+
+    _Guarded_by_(Lock)
+    LIST_ENTRY                  List;
+} REGISTERED_INTERRUPT_LIST, *PREGISTERED_INTERRUPT_LIST;
+
+typedef struct _IOMU_DATA
+{
+    QWORD                       TscFrequency;
+
+    LIST_ENTRY                  PciDeviceList;
+
+    LIST_ENTRY                  PciBridgeList;
+
+    LIST_ENTRY                  DriverList;
+
+    LIST_ENTRY                  VpbList;
+
+    UPTIME                      SystemUptime;
+
+    PDEVICE_OBJECT              SystemDevice;
+
+    PFILE_OBJECT                SwapFile;
+
+    DWORD                       TimerInterruptTimeUs;
+    DWORD                       TimeUpdatePerCpuUs;
+    WORD                        PitInitialTickCount;
+
+    char                        SystemDrive[4];
+
+    LOCK                        GlobalInterruptLock;
+
+    REGISTERED_INTERRUPT_LIST   RegisteredInterrupts[NO_OF_USABLE_INTERRUPTS];
+
+    _Guarded_by_(GlobalInterruptLock)
+    BITMAP                      InterruptBitmap;
+    BYTE                        BitmapBuffer[NO_OF_TOTAL_INTERRUPTS / BITS_FOR_STRUCTURE(BYTE)];
+} IOMU_DATA, *PIOMU_DATA;
+STATIC_ASSERT(FIELD_OFFSET(IOMU_DATA, SystemUptime) % sizeof(QWORD) == 0 );
+
+static IOMU_DATA m_iomuData;
+
+#define DRIVER_MAX_NAME         16
+
+typedef struct _DRIVER_DECLARATION
+{
+    char*                   DriverName;
+    PFUNC_DriverEntry       DriverEntry;
+    BOOLEAN                 Mandatory;
+} DRIVER_DECLARATION, *PDRIVER_DECLARATION;
+
+#define DECLARE_DRIVER(name,entry,mand)    { name ## ".sys" , (entry), (mand) }
+
+static const DRIVER_DECLARATION SYSTEM_DRIVER = DECLARE_DRIVER( "system", SystemDriverEntry, TRUE );
+
+static const DRIVER_DECLARATION DRIVER_NAMES[] = {
+    DECLARE_DRIVER("ata", AtaDriverEntry, FALSE),
+    DECLARE_DRIVER("disk", DiskDriverEntry, FALSE),
+    DECLARE_DRIVER("vol", VolDriverEntry, FALSE),
+    DECLARE_DRIVER("fat", FatDriverEntry, FALSE),
+    DECLARE_DRIVER("swapfs", SwapFsDriverEntry, FALSE),
+    DECLARE_DRIVER("eth82574L", Eth82574LDriverEntry, FALSE)
+};
+
+static FUNC_CompareFunction     _VpbCompareFunction;
+
+static FUNC_IsrRoutine          _IomuGenericInterrupt;
+static FUNC_InterruptFunction   _IomuSystemTickInterrupt;
+
+__forceinline
+char
+static
+_IomuGetNextVolumeLetter(
+    void
+    )
+{
+    static char m_currentVolumeLetter = 'B';
+
+    m_currentVolumeLetter = m_currentVolumeLetter + 1;
+    ASSERT(m_currentVolumeLetter <= 'Z');
+
+
+    return m_currentVolumeLetter;
+}
+
+static
+__forceinline
+void
+_IomuUpdateSystemTime(
+    void
+    )
+{
+    _InterlockedExchangeAdd( &m_iomuData.SystemUptime.UptimeMicroseconds, m_iomuData.TimeUpdatePerCpuUs );
+}
+
+static
+STATUS
+_IomuSetupRtc(
+    OUT_OPT     QWORD*          TscFrequency
+    );
+
+static
+STATUS
+_IomuSetupPit(
+    IN          DWORD           TimerPeriodUs,
+    OUT         WORD*           InitialPitCount
+    );
+
+STATUS
+_IomuRetrievePciDevicesAndEstablishHierarchy(
+    void
+    );
+
+static
+STATUS
+_IomuInitDrivers(
+    void
+    );
+
+static
+STATUS
+_IomuDetermineSystemPartition(
+    void
+    );
+
+static
+STATUS
+_IomuInitializeSwapFile(
+    void
+    );
+
+static
+BOOLEAN
+_IomuIsSystemPartitionOnDrive(
+    IN      char        DriveLetter
+    );
+
+static
+BOOLEAN
+_IomuIsDeviceMsiCapable(
+    IN          PPCI_DEVICE_DESCRIPTION     PciDevice
+    );
+
+static
+STATUS
+_IomuProgramPciInterrupt(
+    IN          PPCI_DEVICE_DESCRIPTION     PciDevice,
+    IN          BYTE                        Vector,
+    IN _Strict_type_match_
+                APIC_DELIVERY_MODE          DeliveryMode
+    );
+
+void
+_No_competing_thread_
+IomuPreinitSystem(
+    void
+    )
+{
+    DWORD i;
+    DWORD bitmapSize;
+
+    memzero(&m_iomuData, sizeof(IOMU_DATA));
+
+    m_iomuData.TimerInterruptTimeUs = SCHEDULER_TIMER_INTERRUPT_TIME_US;
+    m_iomuData.TimeUpdatePerCpuUs = SCHEDULER_TIMER_INTERRUPT_TIME_US;
+
+    InitializeListHead(&m_iomuData.PciDeviceList);
+    InitializeListHead(&m_iomuData.PciBridgeList);
+    InitializeListHead(&m_iomuData.DriverList);
+    InitializeListHead(&m_iomuData.VpbList);
+
+    for (i = 0; i < NO_OF_USABLE_INTERRUPTS; ++i)
+    {
+        InitializeListHead(&m_iomuData.RegisteredInterrupts[i].List);
+        RwSpinlockInit(&m_iomuData.RegisteredInterrupts[i].Lock);
+    }
+
+    bitmapSize = BitmapPreinit(&m_iomuData.InterruptBitmap, NO_OF_TOTAL_INTERRUPTS);
+    ASSERT( bitmapSize == sizeof(m_iomuData.BitmapBuffer));
+
+    BitmapInit(&m_iomuData.InterruptBitmap, m_iomuData.BitmapBuffer);
+
+    // reserve bits for exceptions
+    BitmapSetBits(&m_iomuData.InterruptBitmap, 0, NO_OF_RESERVED_EXCEPTIONS );
+
+    LockInit(&m_iomuData.GlobalInterruptLock);
+
+    IoApicSystemPreinit();
+}
+
+_No_competing_thread_
+STATUS
+IomuInitSystem(
+    IN      WORD        CodeSelector,
+    IN      BYTE        NumberOfTssStacks
+    )
+{
+    STATUS status;
+
+    status = STATUS_SUCCESS;
+
+    status = PciSystemInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemInit", status);
+        return status;
+    }
+    LOGL("PciSystemInit suceeded\n");
+
+    // we must initialize the PIC before we enable the IO APIC
+    PicInitialize(PIC_MASTER_OFFSET, PIC_SLAVE_OFFSET);
+    LOGL("Legacy PIC inititialized\n");
+
+    status = IoApicSystemInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoApicSystemInit", status);
+        return status;
+    }
+    LOGL("IoApicSystemInit suceeded\n");
+
+    // We re-initialize the IDT handlers after we created the TSS stacks for the
+    // current CPU. We first initialized them with 0 TSS stacks to be able to
+    // satisfy page faults and to be able to detect an early exception when we
+    // modify early boot code.
+    status = InitIdtHandlers(CodeSelector, NumberOfTssStacks);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("InitIdtHandlers", status);
+        return status;
+    }
+
+    LOGL("InitIdtHandlers succeeded\n");
+
+    // retrieve PCI devices and hierarchy
+    status = _IomuRetrievePciDevicesAndEstablishHierarchy();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IomuRetrievePciDevicesAndEstablishHierarchy", status);
+        return status;
+    }
+
+    LOGL("_IomuRetrievePciDevicesAndEstablishHierarchy succeeded\n");
+
+    // setup RTC
+    status = _IomuSetupRtc(&m_iomuData.TscFrequency);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IomuSetupRtc", status);
+        return status;
+    }
+    LOGL("_IomuSetupRtc succeeded\n");
+
+    LOGL("TSC frequency: 0x%X\n", m_iomuData.TscFrequency );
+
+    status = _IomuSetupPit(m_iomuData.TimerInterruptTimeUs,
+                           &m_iomuData.PitInitialTickCount);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IomuSetupPit", status);
+        return status;
+    }
+    LOGL("_IomuSetupPit succeeded\n");
+
+    // setup KBD
+    status = KeyboardInitialize(IrqKeyboard);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("KeyboardInitialize", status);
+        return status;
+    }
+
+    LOGL("KeyboardInitialize succeeded\n");
+
+    return status;
+}
+
+STATUS
+IomuInitSystemAfterApWakeup(
+    void
+    )
+{
+    DWORD noOfActiveCpus;
+    STATUS status;
+
+    noOfActiveCpus = SmpGetNumberOfActiveCpus();
+    status = STATUS_SUCCESS;
+
+    m_iomuData.TimeUpdatePerCpuUs = m_iomuData.TimerInterruptTimeUs / noOfActiveCpus;
+    LOGL("CPU interrupt time %u/%u us\n", m_iomuData.TimeUpdatePerCpuUs, m_iomuData.TimerInterruptTimeUs);
+
+    status = IoApicLateSystemInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoApicLateSystemInit", status);
+        return status;
+    }
+    LOGL("IoApicLateSystemInit succeeded\n");
+
+    // unmask IO Apic interrupts
+    IoApicSystemEnableRegisteredInterrupts();
+
+    return status;
+}
+
+void
+IomuAckInterrupt(
+    IN      BYTE        InterruptIndex
+    )
+{
+    LapicSystemSendEOI(InterruptIndex);
+
+    // 10.8.5 - Vol 3 US 057
+    // System software desiring to perform directed EOIs for level - triggered interrupts should set bit 12 of the Spurious
+    // Interrupt Vector Register and follow each the EOI to the local xAPIC for a level triggered interrupt with a directed
+    // EOI to the I / O APIC generating the interrupt(this is done by writing to the I / O APICs EOI register).
+}
+
+static
+STATUS
+_IomuSetupRtc(
+    OUT_OPT     QWORD*          TscFrequency
+    )
+{
+    STATUS status;
+    IO_INTERRUPT ioInterrupt;
+
+    status = STATUS_SUCCESS;
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    RtcInit(TscFrequency);
+    LOGL("RtcInit finished\n");
+
+    // install ISR
+    ioInterrupt.Type = IoInterruptTypeLegacy;
+    ioInterrupt.Irql = IrqlClockLevel;
+    ioInterrupt.ServiceRoutine = OsInfoTimeUpdateIsr;
+    ioInterrupt.Exclusive = TRUE;
+    ioInterrupt.Legacy.Irq = IrqRtc;
+
+    status = IoRegisterInterrupt( &ioInterrupt, NULL);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoRegisterInterrupt", status);
+        return status;
+    }
+    LOGL("RTC Isr successfully installed!\n");
+
+    return status;
+}
+
+static
+STATUS
+_IomuSetupPit(
+    IN          DWORD           TimerPeriodUs,
+    OUT         WORD*           InitialPitCount
+    )
+{
+    STATUS status;
+    IO_INTERRUPT ioInterrupt;
+    WORD initialPitCount;
+
+    ASSERT(NULL != InitialPitCount);
+
+    status = STATUS_SUCCESS;
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    // setup PIT timer
+    initialPitCount = PitSetTimer(TimerPeriodUs, TRUE);
+    LOGL("Initial PIT timer count is 0x%x\n", initialPitCount );
+
+    // install ISR
+    ioInterrupt.Type = IoInterruptTypeLegacy;
+    ioInterrupt.Irql = IrqlClockLevel;
+    ioInterrupt.ServiceRoutine = _IomuSystemTickInterrupt;
+    ioInterrupt.Exclusive = TRUE;
+    ioInterrupt.BroadcastInterrupt = TRUE;
+    ioInterrupt.Legacy.Irq = IrqPitTimer;
+
+    status = IoRegisterInterrupt(&ioInterrupt, NULL);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoRegisterInterrupt", status);
+        return status;
+    }
+    LOGL("PIT Isr successfully installed!\n");
+
+    *InitialPitCount = initialPitCount;
+
+    return status;
+}
+
+STATUS
+_IomuRetrievePciDevicesAndEstablishHierarchy(
+    void
+    )
+{
+    STATUS status;
+
+    status = STATUS_SUCCESS;
+
+    status = PciSystemRetrieveDevices(&m_iomuData.PciDeviceList);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemRetrieveDevices", status);
+        return status;
+    }
+
+    LOGL("PciDevRetrieveDevices succeeded\n");
+
+    PciSystemEstablishHierarchy(&m_iomuData.PciDeviceList, &m_iomuData.PciBridgeList);
+    LOGL("PciSystemEstablishHierarchy finished\n");
+
+    return status;
+}
+
+STATUS
+IomuInitSystemDriver(
+    void
+    )
+{
+    PDRIVER_OBJECT pDriver;
+    PLIST_ENTRY pNextDevice;
+
+    LOG_FUNC_START;
+
+    pDriver = IoCreateDriver( SYSTEM_DRIVER.DriverName, SYSTEM_DRIVER.DriverEntry );
+    if (NULL == pDriver)
+    {
+        LOG_ERROR("IoCreateDriver failed for system driver!\n");
+        return STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED;
+    }
+
+    ASSERT(1 == pDriver->NoOfDevices);
+
+    pNextDevice = pDriver->DeviceList.Flink;
+    ASSERT(pNextDevice != &pDriver->DeviceList);
+
+    m_iomuData.SystemDevice = CONTAINING_RECORD(pNextDevice, DEVICE_OBJECT, NextDevice);
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+IomuLateInit(
+    void
+    )
+{
+    STATUS status;
+
+    status = _IomuInitDrivers();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IomuInitDrivers", status);
+        return status;
+    }
+
+    LOGL("Drivers successfully initialized!\n");
+
+    status = _IomuDetermineSystemPartition();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IomuDetermineSystemPartition", status);
+    }
+    else
+    {
+        LOGL("Successfully determined system partition!\n");
+    }
+
+    status = _IomuInitializeSwapFile();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_IomuInitializeSwapFile", status);
+    }
+    else
+    {
+        LOGL("Successfully determined swap partition!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
+
+const char*
+IomuGetSystemPartitionPath(
+    void
+    )
+{
+    return m_iomuData.SystemDrive;
+}
+
+PFILE_OBJECT
+IomuGetSwapFile(
+    void
+    )
+{
+    return m_iomuData.SwapFile;
+}
+
+PDRIVER_OBJECT
+IomuGetDriverByName(
+    IN_Z    char*           DriverName
+    )
+{
+    PDRIVER_OBJECT pDriver;
+    PLIST_ENTRY pCurEntry;
+
+    ASSERT(NULL != DriverName);
+
+    pDriver = NULL;
+    for(pCurEntry = m_iomuData.DriverList.Flink;
+        pCurEntry != &m_iomuData.DriverList;
+        pCurEntry = pCurEntry->Flink)
+    {
+        pDriver = CONTAINING_RECORD(pCurEntry, DRIVER_OBJECT, NextDriver);
+
+        if (0 == strcmp(pDriver->DriverName, DriverName))
+        {
+            // found driver
+            return pDriver;
+        }
+    }
+
+    return NULL;
+}
+
+void
+IomuDriverInstalled(
+    IN      PDRIVER_OBJECT  Driver
+    )
+{
+    ASSERT(NULL != Driver);
+
+    InsertTailList(&m_iomuData.DriverList, &Driver->NextDriver);
+}
+
+PLIST_ENTRY
+IomuGetPciDeviceList(
+    void
+    )
+{
+    return &m_iomuData.PciDeviceList;
+}
+
+STATUS
+IomuGetDevicesByType(
+    IN_RANGE_UPPER(DeviceTypeMax)
+                                    DEVICE_TYPE         DeviceType,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+                                    PDEVICE_OBJECT**    DeviceObjects,
+    OUT                             DWORD*              NumberOfDevices
+    )
+{
+    STATUS status;
+    PLIST_ENTRY pCurDriverEntry;
+    PLIST_ENTRY pCurDeviceEntry;
+    DWORD count;
+    DWORD i;
+    PDEVICE_OBJECT* pFoundDevices;
+    DWORD indexInArray;
+
+    ASSERT(NULL != DeviceObjects);
+    ASSERT(NULL != NumberOfDevices);
+
+    status = STATUS_SUCCESS;
+    count = 0;
+    pFoundDevices = NULL;
+    indexInArray = 0;
+
+    for (i = 0; i < 2; ++i)
+    {
+        if (1 == i)
+        {
+            // second iteration
+            if (0 == count)
+            {
+                // nothing to do, no devices by type found
+                break;
+            }
+
+            pFoundDevices = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PDEVICE_OBJECT) * count, HEAP_TEMP_TAG, 0);
+            if (NULL == pFoundDevices)
+            {
+                status = STATUS_HEAP_NO_MORE_MEMORY;
+                break;
+            }
+        }
+
+        for(pCurDriverEntry = m_iomuData.DriverList.Flink;
+            pCurDriverEntry != &m_iomuData.DriverList;
+            pCurDriverEntry = pCurDriverEntry->Flink)
+        {
+            PDRIVER_OBJECT pDriver = CONTAINING_RECORD(pCurDriverEntry, DRIVER_OBJECT, NextDriver);
+
+            for (pCurDeviceEntry = pDriver->DeviceList.Flink;
+            pCurDeviceEntry != &pDriver->DeviceList;
+                pCurDeviceEntry = pCurDeviceEntry->Flink)
+            {
+                PDEVICE_OBJECT pDeviceObject = CONTAINING_RECORD(pCurDeviceEntry, DEVICE_OBJECT, NextDevice);
+
+                if (DeviceType == pDeviceObject->DeviceType)
+                {
+                    // found device type we're looking for
+                    if (0 == i)
+                    {
+                        // on the first iteration we count
+                        count = count + 1;
+                    }
+                    else
+                    {
+                        // on the second iteration we add to our allocated array
+                        pFoundDevices[indexInArray] = pDeviceObject;
+                        indexInArray = indexInArray + 1;
+                    }
+                }
+            }
+        }
+    }
+
+    if (SUCCEEDED(status))
+    {
+        ASSERT(indexInArray == count);
+
+        *DeviceObjects = pFoundDevices;
+        *NumberOfDevices = count;
+    }
+
+    return status;
+}
+
+void
+IomuNewVpbCreated(
+    INOUT       struct _VPB*        Vpb
+    )
+{
+    ASSERT(NULL != Vpb);
+
+    Vpb->VolumeLetter = _IomuGetNextVolumeLetter();
+
+    InsertOrderedList(&m_iomuData.VpbList, &Vpb->NextVpb, _VpbCompareFunction, NULL);
+}
+
+void
+IomuExecuteForEachVpb(
+    IN          PFUNC_ListFunction  Function,
+    IN_OPT      PVOID               Context,
+    IN          BOOLEAN             Exclusive
+    )
+{
+    ASSERT(NULL != Function);
+
+    UNREFERENCED_PARAMETER(Exclusive);
+
+    // take lock
+    ForEachElementExecute(&m_iomuData.VpbList, Function, Context, FALSE);
+    // release lock
+}
+
+PTR_SUCCESS
+PVPB
+IomuSearchForVpb(
+    IN          char                DriveLetter
+    )
+{
+    VPB vpbToSearchFor;
+    PLIST_ENTRY pCorrespondingVpb;
+
+    memzero(&vpbToSearchFor, sizeof(VPB));
+
+    // take volume letter
+    vpbToSearchFor.VolumeLetter = DriveLetter;
+
+    pCorrespondingVpb = ListSearchForElement(&m_iomuData.VpbList, &vpbToSearchFor.NextVpb, TRUE, _VpbCompareFunction, NULL);
+    if (NULL == pCorrespondingVpb)
+    {
+        return NULL;
+    }
+
+    return CONTAINING_RECORD(pCorrespondingVpb, VPB, NextVpb);
+}
+
+STATUS
+IomuRegisterInterrupt(
+    IN          PIO_INTERRUPT           Interrupt,
+    IN_OPT      PDEVICE_OBJECT          DeviceObject,
+    OUT_OPT     PBYTE                   Vector
+    )
+{
+    STATUS status;
+    BOOLEAN bListEmpty;
+    PREGISTERED_INTERRUPT_ENTRY pNewEntry;
+    BOOLEAN bSetupIoApicRedirEntry;
+    PDEVICE_OBJECT pDevObj;
+    BYTE interruptIndex;
+    BYTE interruptVector;
+    DWORD bitmapResult;
+    BOOLEAN bIoApicEntryRegistered;
+    APIC_DELIVERY_MODE apicDeliveryMode;
+    BOOLEAN bMsiCapable;
+    BOOLEAN bIoApicInterrupt;
+    BYTE interruptLine;
+    INTR_STATE intrState;
+    BOOLEAN bAcquiredListLock;
+    INTR_STATE dummyState;
+
+    ASSERT( NULL != Interrupt );
+    ASSERT( NULL != Interrupt->ServiceRoutine );
+
+
+    status = STATUS_SUCCESS;
+    bSetupIoApicRedirEntry = FALSE;
+    pNewEntry = NULL;
+    pDevObj = ( NULL != DeviceObject ) ? DeviceObject : m_iomuData.SystemDevice;
+    ASSERT( NULL != pDevObj );
+    bIoApicEntryRegistered = FALSE;
+    interruptVector = 0;
+    apicDeliveryMode = Interrupt->BroadcastInterrupt ? ApicDeliveryModeFixed : ApicDeliveryModeLowest;
+    bMsiCapable = FALSE;
+    bAcquiredListLock = FALSE;
+    interruptIndex = MAX_BYTE;
+
+    LOG_TRACE_INTERRUPT("Searching for free vector for IRQL 0x%x\n", Interrupt->Irql );
+
+    // Need to take lock here because we must protect the whole flow of configuring an interrupt
+    // IoApicSystemGetVectorForIrq and BitmapScanFromToAndFlip will cause problems if they are called concurrently
+    LockAcquire(&m_iomuData.GlobalInterruptLock, &intrState);
+
+    __try
+    {
+
+        interruptLine = MAX_BYTE;
+        if (Interrupt->Type == IoInterruptTypePci)
+        {
+            bMsiCapable = _IomuIsDeviceMsiCapable(Interrupt->Pci.PciDevice);
+            if (!bMsiCapable)
+            {
+                DWORD temp = IoApicGetInterruptLineForPciDevice(Interrupt->Pci.PciDevice);
+
+                ASSERT(temp <= MAX_BYTE);
+                interruptLine = (BYTE)temp;
+                LOGL("IRQ line is 0x%x\n", interruptLine);
+            }
+        }
+        else if (Interrupt->Type == IoInterruptTypeLegacy)
+        {
+            interruptLine = Interrupt->Legacy.Irq;
+        }
+
+        bIoApicInterrupt = (Interrupt->Type == IoInterruptTypeLegacy) || (Interrupt->Type == IoInterruptTypePci && !bMsiCapable);
+
+        if (bIoApicInterrupt)
+        {
+            ASSERT((Interrupt->Type == IoInterruptTypeLegacy) || (Interrupt->Type == IoInterruptTypePci && !bMsiCapable));
+
+            // check to see if we already have an IO APIC entry for this IRQ
+            status = IoApicSystemGetVectorForIrq(interruptLine,
+                                                 &interruptVector);
+            if (STATUS_SUCCESS == status)
+            {
+                // it means we already have a vector mapped for the IRQ
+                if (VECTOR_TO_IRQL(interruptVector) != Interrupt->Irql)
+                {
+                    LOG_ERROR("Cannot register legacy interrupt for IRQL 0x%x because there is already a registered vector 0x%02x for IRQ 0x%x which differs in priority\n",
+                              Interrupt->Irql, interruptVector, interruptLine);
+                    status = STATUS_DEVICE_INTERRUPT_PRIORITY_NOT_AVAILABLE;
+                    __leave;
+                }
+
+                // we can share the vector from the IRQL point of view
+                bIoApicEntryRegistered = TRUE;
+            }
+            if (!SUCCEEDED(status) && status != STATUS_DEVICE_INTERRUPT_NOT_CONFIGURED)
+            {
+                LOG_FUNC_ERROR("IoApicSystemGetVectorForIrq", status);
+                __leave;
+            }
+
+            // if the IoApicSystemGetVectorForIrq failed because these is no vector registered for the
+            // specified IRQ => it is all ok
+            status = STATUS_SUCCESS;
+        }
+
+        if (!bIoApicEntryRegistered)
+        {
+            bitmapResult = BitmapScanFromToAndFlip(&m_iomuData.InterruptBitmap,
+                                                   IRQL_TO_VECTOR(Interrupt->Irql),
+                                                   IRQL_TO_VECTOR(Interrupt->Irql) + VECTORS_PER_IRQL,
+                                                   1,
+                                                   FALSE);
+        }
+        else
+        {
+            ASSERT((Interrupt->Type == IoInterruptTypeLegacy) || (Interrupt->Type == IoInterruptTypePci && !bMsiCapable));
+
+            // simulate the fact that the interrupt needs to be shared
+            bitmapResult = MAX_DWORD;
+        }
+
+        if (MAX_DWORD == bitmapResult)
+        {
+            // we don't have any vectors left for the required IRQL
+            if (Interrupt->Exclusive)
+            {
+                LOG_ERROR("All the vectors left for the required IRQL 0x%x are already registered and exclusive rights were requested!\n", Interrupt->Irql);
+                status = STATUS_DEVICE_INTERRUPT_NOT_AVAILABLE;
+                __leave;
+            }
+            else
+            {
+                // can share interrupts
+                // if bIoApicEntryRegistered is set => the interrupt vector is already set
+                if (!bIoApicEntryRegistered)
+                {
+                    interruptVector = IRQL_TO_VECTOR(Interrupt->Irql);
+                }
+            }
+        }
+        else
+        {
+            interruptVector = (BYTE)bitmapResult;
+        }
+
+        LOG_TRACE_INTERRUPT("Will register vector 0x%02x for IRQL 0x%x\n", interruptVector, Interrupt->Irql);
+
+        ASSERT(interruptVector >= NO_OF_RESERVED_EXCEPTIONS && interruptVector < NO_OF_TOTAL_INTERRUPTS);
+        interruptIndex = interruptVector - NO_OF_RESERVED_EXCEPTIONS;
+
+        RwSpinlockAcquireExclusive(&m_iomuData.RegisteredInterrupts[interruptIndex].Lock, &dummyState);
+        bAcquiredListLock = TRUE;
+
+        bListEmpty = IsListEmpty(&m_iomuData.RegisteredInterrupts[interruptIndex].List);
+        ASSERT_INFO(bListEmpty || !Interrupt->Exclusive, "We shouldn't get here because the check is already done and the function should have returned\n");
+
+        if (bListEmpty)
+        {
+            // try to install handler
+
+            // warning C4306: 'type cast': conversion from 'const BYTE' to 'PVOID' of greater size
+#pragma warning(suppress:4306)
+            status = IsrInstallEx(interruptVector, _IomuGenericInterrupt, (PVOID)interruptIndex);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IsrInstallEx", status);
+                __leave;
+            }
+
+            bSetupIoApicRedirEntry = ((IoInterruptTypeLegacy == Interrupt->Type) || (Interrupt->Type == IoInterruptTypePci && !bMsiCapable)) && !bIoApicEntryRegistered;
+        }
+
+        pNewEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(REGISTERED_INTERRUPT_ENTRY), HEAP_IOMU_TAG, 0);
+        if (NULL == pNewEntry)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(REGISTERED_INTERRUPT_ENTRY));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        pNewEntry->Function = Interrupt->ServiceRoutine;
+        pNewEntry->Device = pDevObj;
+
+        // there is no reason to maintain information about device exclusivity
+        // because new interrupts are added to the tail of the list =>
+        // if we have an exclusive ISR at the beginning it thinks it is the
+        // only one being executed
+        InsertTailList(&m_iomuData.RegisteredInterrupts[interruptIndex].List, &pNewEntry->ListEntry);
+
+        RwSpinlockReleaseExclusive(&m_iomuData.RegisteredInterrupts[interruptIndex].Lock, INTR_OFF);
+        bAcquiredListLock = FALSE;
+
+        if (Interrupt->Type == IoInterruptTypePci && bMsiCapable)
+        {
+            LOG_TRACE_INTERRUPT("Will setup PCI interrupt for device at (%u.%u.%u)\n",
+                                Interrupt->Pci.PciDevice->DeviceLocation.Bus,
+                                Interrupt->Pci.PciDevice->DeviceLocation.Device,
+                                Interrupt->Pci.PciDevice->DeviceLocation.Function);
+
+            status = _IomuProgramPciInterrupt(Interrupt->Pci.PciDevice,
+                                              interruptVector,
+                                              apicDeliveryMode);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_IomuRegisterPciInterrupt", status);
+                __leave;
+            }
+        }
+
+        if (bSetupIoApicRedirEntry)
+        {
+            ASSERT((Interrupt->Type == IoInterruptTypeLegacy) || (Interrupt->Type == IoInterruptTypePci && !bMsiCapable));
+
+
+            // PCI specification 3.0 Section 2.2.6 Interrupt Pins
+            // Interrupts on PCI are optional and defined as "level sensitive," asserted low (negative true)
+            LOG_TRACE_INTERRUPT("Will setup IOAPIC redirection entry for IRQ 0x%x\n", interruptLine);
+            status = IoApicSystemSetInterrupt(interruptLine,
+                                              interruptVector,
+                                              ApicDestinationModeLogical,
+                                              apicDeliveryMode,
+                                              (Interrupt->Type == IoInterruptTypePci) ? ApicPinPolarityActiveLow : ApicPinPolarityActiveHigh,
+                                              (Interrupt->Type == IoInterruptTypePci) ? ApicTriggerModeLevel : ApicTriggerModeEdge,
+                                              MAX_BYTE,
+                                              FALSE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoApicSystemSetInterrupt", status);
+                __leave;
+            }
+        }
+    }
+    __finally
+    {
+        if (bAcquiredListLock)
+        {
+            ASSERT(interruptIndex != MAX_BYTE);
+
+            RwSpinlockReleaseExclusive(&m_iomuData.RegisteredInterrupts[interruptIndex].Lock, INTR_OFF);
+        }
+
+        LockRelease(&m_iomuData.GlobalInterruptLock, intrState);
+
+        if (SUCCEEDED(status))
+        {
+            if (NULL != Vector)
+            {
+                *Vector = interruptVector;
+            }
+
+            LOG_TRACE_INTERRUPT("Succesfully registered interrupt [0x%02x] for device 0x%X\n", interruptVector, pDevObj);
+        }
+    }
+
+    return status;
+}
+
+QWORD
+IomuGetSystemTicks(
+    OUT_OPT     QWORD*                  TickFrequency
+    )
+{
+    if (NULL != TickFrequency)
+    {
+        *TickFrequency = m_iomuData.TscFrequency;
+    }
+
+    return RtcGetTickCount();
+}
+
+QWORD
+IomuGetSystemTimeUs(
+    void
+    )
+{
+    UPTIME uptime;
+    QWORD systemTime;
+
+    uptime.Raw = m_iomuData.SystemUptime.Raw;
+
+    systemTime = (QWORD) uptime.UptimeSeconds * SEC_IN_US +
+                 ( uptime.UptimeMicroseconds >= SEC_IN_US ? SEC_IN_US : uptime.UptimeMicroseconds );
+
+    return systemTime;
+}
+
+QWORD
+IomuTickCountToUs(
+    IN          QWORD                   TickCount
+    )
+{
+    return ( TickCount * 1000 ) / ( m_iomuData.TscFrequency / 1000 );
+}
+
+void
+IomuCmosUpdateOccurred(
+    void
+    )
+{
+    QWORD newSecCount;
+
+    newSecCount = (QWORD) m_iomuData.SystemUptime.UptimeSeconds + 1;
+    ASSERT( newSecCount <= MAX_DWORD );
+
+    // this will also set UptimeMicroseconds to zero
+    _InterlockedExchange64(&m_iomuData.SystemUptime.Raw, newSecCount );
+}
+
+DWORD
+IomuGetTimerInterrupTimeUs(
+    void
+    )
+{
+    return m_iomuData.TimerInterruptTimeUs;
+}
+
+BOOLEAN
+IomuIsInterruptSpurious(
+    IN          BYTE                    Vector
+    )
+{
+    return ((Vector == PIC_MASTER_OFFSET + IrqSpurious) || (Vector == PIC_SLAVE_OFFSET + IrqSpurious))
+        && !LapicSystemIsInterruptServiced(Vector);
+}
+
+static
+INT64
+(__cdecl _VpbCompareFunction) (
+    IN      PLIST_ENTRY     FirstElem,
+    IN      PLIST_ENTRY     SecondElem,
+    IN_OPT  PVOID           Context
+    )
+{
+    PVPB pFirstVpb;
+    PVPB pSecondVpb;
+
+    ASSERT(NULL != FirstElem);
+    ASSERT(NULL != SecondElem);
+    ASSERT(Context == NULL);
+
+    pFirstVpb = CONTAINING_RECORD(FirstElem, VPB, NextVpb);
+    pSecondVpb = CONTAINING_RECORD(SecondElem, VPB, NextVpb);
+
+    return ( tolower(pFirstVpb->VolumeLetter) - tolower(pSecondVpb->VolumeLetter));
+}
+
+static
+BOOLEAN
+(__cdecl _IomuGenericInterrupt)(
+    IN_OPT      PVOID           Context
+    )
+{
+    BYTE interrupt;
+    BOOLEAN bHandledInterrupt;
+    INTR_STATE dummyState;
+    BOOLEAN bFoundEntry;
+
+    ASSERT( NULL != Context );
+    ASSERT(CpuIntrGetState() == INTR_OFF);
+
+    // warning C4305: 'type cast': truncation from 'const PVOID' to 'BYTE'
+#pragma warning(suppress:4305)
+    interrupt = (BYTE) Context;
+
+    bFoundEntry = FALSE;
+    bHandledInterrupt = FALSE;
+
+    ASSERT( interrupt < NO_OF_USABLE_INTERRUPTS );
+
+    RwSpinlockAcquireShared(&m_iomuData.RegisteredInterrupts[interrupt].Lock, &dummyState);
+    for (PLIST_ENTRY pListEntry = m_iomuData.RegisteredInterrupts[interrupt].List.Flink;
+         pListEntry != &m_iomuData.RegisteredInterrupts[interrupt].List;
+         pListEntry = pListEntry->Flink
+        )
+    {
+        PREGISTERED_INTERRUPT_ENTRY pEntry = CONTAINING_RECORD(pListEntry, REGISTERED_INTERRUPT_ENTRY, ListEntry);
+
+        bHandledInterrupt = pEntry->Function( pEntry->Device );
+        if (bHandledInterrupt)
+        {
+            break;
+        }
+    }
+    RwSpinlockReleaseShared(&m_iomuData.RegisteredInterrupts[interrupt].Lock, dummyState);
+
+    return bHandledInterrupt;
+}
+
+static
+BOOLEAN
+(__cdecl _IomuSystemTickInterrupt)(
+    IN        PDEVICE_OBJECT           Device
+    )
+{
+    ASSERT( NULL != Device );
+
+    _IomuUpdateSystemTime();
+    //LOGP("%U us\n", IomuGetSystemTimeUs());
+
+    ExSystemTimerTick();
+
+    return TRUE;
+}
+
+static
+STATUS
+_IomuInitDrivers(
+    void
+    )
+{
+    STATUS status;
+    PDRIVER_OBJECT pDriver;
+    DWORD i;
+
+    status = STATUS_SUCCESS;
+    pDriver = NULL;
+
+    __try
+    {
+        for (i = 0; i < ARRAYSIZE(DRIVER_NAMES); ++i)
+        {
+            pDriver = IoCreateDriver(DRIVER_NAMES[i].DriverName, DRIVER_NAMES[i].DriverEntry);
+            if (NULL == pDriver)
+            {
+                if (DRIVER_NAMES[i].Mandatory)
+                {
+                    LOG_ERROR("Mandatory driver %s could not be loaded\n", DRIVER_NAMES[i].DriverName);
+                    status = STATUS_DEVICE_DRIVER_COULD_NOT_BE_CREATED;
+                    __leave;
+                }
+                else
+                {
+                    LOG_WARNING("Secondary driver %s could not be loaded\n", DRIVER_NAMES[i].DriverName);
+                }
+            }
+        }
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            // call IomuUnitDrivers
+        }
+    }
+
+    // dump driver list
+    DumpDriverList(&m_iomuData.DriverList);
+
+    return status;
+}
+
+static
+STATUS
+_IomuDetermineSystemPartition(
+    void
+    )
+{
+    STATUS status;
+    BOOLEAN bFoundSystemPartition;
+
+    status = STATUS_SUCCESS;
+    bFoundSystemPartition = FALSE;
+
+    for (PLIST_ENTRY pListEntry = m_iomuData.VpbList.Flink;
+         pListEntry != &m_iomuData.VpbList;
+         pListEntry = pListEntry->Flink)
+    {
+        PVPB pVpb = CONTAINING_RECORD(pListEntry, VPB, NextVpb);
+
+        if (!pVpb->Flags.Mounted)
+        {
+            continue;
+        }
+
+        bFoundSystemPartition = _IomuIsSystemPartitionOnDrive(pVpb->VolumeLetter);
+        if (bFoundSystemPartition)
+        {
+            snprintf(m_iomuData.SystemDrive, sizeof(m_iomuData.SystemDrive),
+                     "%c:\\", pVpb->VolumeLetter);
+
+            LOG("Found system partition at [%s]\n", m_iomuData.SystemDrive);
+
+            break;
+        }
+    }
+
+    return bFoundSystemPartition ? STATUS_SUCCESS : STATUS_FILE_NOT_FOUND;
+}
+
+static
+STATUS
+_IomuInitializeSwapFile(
+    void
+    )
+{
+    STATUS status;
+    BOOLEAN bOpenedSwapFile;
+
+    status = STATUS_SUCCESS;
+    bOpenedSwapFile = FALSE;
+
+    for (PLIST_ENTRY pListEntry = m_iomuData.VpbList.Flink;
+         pListEntry != &m_iomuData.VpbList;
+         pListEntry = pListEntry->Flink)
+    {
+        PVPB pVpb = CONTAINING_RECORD(pListEntry, VPB, NextVpb);
+        char swapFilePath[4];
+
+        // if the FS is not mounted => we do not recognize it
+        if (!pVpb->Flags.Mounted)
+        {
+            continue;
+        }
+
+        // we only care about swap partitions
+        if (!pVpb->Flags.SwapSpace)
+        {
+            continue;
+        }
+
+        status = snprintf(swapFilePath, sizeof(swapFilePath), "%c:\\", pVpb->VolumeLetter);
+        ASSERT(SUCCEEDED(status));
+
+        status = IoCreateFile(&m_iomuData.SwapFile,
+                              swapFilePath,
+                              FALSE,
+                              FALSE,
+                              FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCreateFile", status);
+            continue;
+        }
+        bOpenedSwapFile = TRUE;
+    }
+
+    return bOpenedSwapFile ? STATUS_SUCCESS : STATUS_FILE_NOT_FOUND;
+}
+
+static
+BOOLEAN
+_IomuIsSystemPartitionOnDrive(
+    IN      char        DriveLetter
+    )
+{
+    PFILE_OBJECT pFileObject;
+    STATUS status;
+    char iniFilePath[MAX_PATH];
+
+    snprintf(iniFilePath, MAX_PATH, "%c:\\%s",
+             DriveLetter, HAL9000_SYSTEM_FILE_NAME);
+
+    status = IoCreateFile(&pFileObject,
+                          iniFilePath,
+                          FALSE,
+                          FALSE,
+                          FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_TRACE_IO("Cannot find [%s] ini file on %c\n",
+                     iniFilePath, DriveLetter);
+        return FALSE;
+    }
+
+    IoCloseFile(pFileObject);
+    pFileObject = NULL;
+
+    return TRUE;
+}
+
+static
+BOOLEAN
+_IomuIsDeviceMsiCapable(
+    IN          PPCI_DEVICE_DESCRIPTION     PciDevice
+    )
+{
+    STATUS status;
+    PPCI_CAPABILITY_HEADER pciCap;
+
+    ASSERT( NULL != PciDevice );
+
+    status = PciDevRetrieveCapabilityById(PciDevice->DeviceData,
+                                          PCI_CAPABILITY_ID_MSI,
+                                          &pciCap
+                                          );
+
+    return SUCCEEDED(status);
+}
+
+static
+STATUS
+_IomuProgramPciInterrupt(
+    IN          PPCI_DEVICE_DESCRIPTION     PciDevice,
+    IN          BYTE                        Vector,
+    IN _Strict_type_match_
+                APIC_DELIVERY_MODE          DeliveryMode
+    )
+{
+    STATUS status;
+
+    ASSERT( NULL != PciDevice );
+    ASSERT(_IomuIsDeviceMsiCapable(PciDevice));
+
+    LOG_FUNC_START;
+
+    status = PciDevDisableLegacyInterrupts(PciDevice);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciDevDisableLegacyInterrupts", status);
+        return status;
+    }
+    LOG_TRACE_INTERRUPT("Successfully disabled legacy interrupts for PCI device at (%u.%u.%u)\n",
+                        PciDevice->DeviceLocation.Bus, PciDevice->DeviceLocation.Device, PciDevice->DeviceLocation.Function );
+
+    status = PciDevProgramMsiInterrupt(PciDevice,
+                                       Vector,
+                                       ApicDestinationModeLogical,
+                                       MAX_BYTE,
+                                       DeliveryMode,
+                                       ApicPinPolarityActiveHigh,
+                                       ApicTriggerModeLevel
+                                       );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciDevProgramMsiInterrupt", status );
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/ipc.c b/src_proiect/HAL9000/src/ipc.c
new file mode 100644
index 0000000..3399933
--- /dev/null
+++ b/src_proiect/HAL9000/src/ipc.c
@@ -0,0 +1,228 @@
+#include "HAL9000.h"
+#include "ipc.h"
+#include "synch.h"
+#include "smp.h"
+
+#pragma warning(push)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+
+typedef struct _IPC_EVENT
+{
+    REF_COUNT               RefCnt;
+    PFUNC_IpcProcessEvent   Function;
+    PVOID                   Context;
+
+    BOOLEAN                 SignalTermination;
+
+    // valid only if SignalTermination is TRUE
+    EVENT                   TerminationEvent;
+
+    PFUNC_FreeFunction      FreeFunction;
+    PVOID                   FreeFunctionContext;
+
+    IPC_EVENT_CPU           CpuEvents[0];
+} IPC_EVENT, *PIPC_EVENT;
+
+#pragma warning(pop)
+
+static FUNC_FreeFunction _IpcFreeEvent;
+
+_Ret_writes_maybenull_(NumberOfCpus)
+PTR_SUCCESS
+PIPC_EVENT_CPU
+IpcGenerateEvent(
+    IN      PFUNC_IpcProcessEvent   BroadcastFunction,
+    IN_OPT  PVOID                   Context,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   FreeContext,
+    IN      BOOLEAN                 WaitForHandling,
+    IN_RANGE_LOWER(1)
+            DWORD                   NumberOfCpus
+    )
+{
+    STATUS status;
+    PIPC_EVENT pEvent;
+    DWORD noOfAdditionalReferences;
+    DWORD i;
+    DWORD totalAllocationSize;
+
+    if (NULL == BroadcastFunction)
+    {
+        return NULL;
+    }
+
+    if (0 == NumberOfCpus)
+    {
+        LOG_ERROR("We can't send an IPI to 0 processors! :(\n");
+        return NULL;
+    }
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pEvent = NULL;
+    noOfAdditionalReferences = WaitForHandling ? NumberOfCpus : NumberOfCpus - 1;
+    totalAllocationSize = sizeof(IPC_EVENT) + NumberOfCpus * sizeof(IPC_EVENT_CPU);
+
+    __try
+    {
+        pEvent = ExAllocatePoolWithTag(PoolAllocateZeroMemory, totalAllocationSize, HEAP_IPC_TAG, 0);
+        if (NULL == pEvent)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag\n", totalAllocationSize);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+        LOG_TRACE_CPU("Allocated event at: 0x%X\n", pEvent);
+
+        pEvent->SignalTermination = WaitForHandling;
+        if (pEvent->SignalTermination)
+        {
+            status = EvtInitialize(&pEvent->TerminationEvent, EventTypeSynchronization, FALSE);
+            if (!SUCCEEDED(status))
+            {
+                LOGL("EvtInitialize failed with status: 0x%x\n", status);
+                __leave;
+            }
+        }
+        pEvent->Function = BroadcastFunction;
+        pEvent->Context = Context;
+        pEvent->FreeFunction = FreeFunction;
+        pEvent->FreeFunctionContext = FreeContext;
+
+        for (i = 0; i < NumberOfCpus; ++i)
+        {
+            pEvent->CpuEvents[i].Event = pEvent;
+        }
+
+        RfcPreInit(&pEvent->RefCnt);
+
+        status = RfcInit(&pEvent->RefCnt, _IpcFreeEvent, NULL);
+        if (!SUCCEEDED(status))
+        {
+            LOGL("RfcInit failed with status: 0x%x\n", status);
+            __leave;
+        }
+
+        for (i = 0; i < noOfAdditionalReferences; ++i)
+        {
+            RfcReference(&pEvent->RefCnt);
+        }
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pEvent)
+            {
+                ExFreePoolWithTag(pEvent, HEAP_IPC_TAG);
+                pEvent = NULL;
+            }
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return NULL != pEvent ? pEvent->CpuEvents : NULL;
+}
+
+void
+IpcWaitForEventHandling(
+    _Pre_valid_ _Post_ptr_invalid_
+            PIPC_EVENT_CPU          CpuEvent
+    )
+{
+    ASSERT(NULL != CpuEvent);
+
+    LOG_FUNC_START;
+
+    ASSERT( NULL != CpuEvent->Event );
+
+    ASSERT(CpuEvent->Event->SignalTermination);
+    EvtWaitForSignal(&CpuEvent->Event->TerminationEvent);
+
+    LOG_TRACE_CPU("Event was processed\n");
+
+    RfcDereference(&CpuEvent->Event->RefCnt);
+
+    LOG_FUNC_END;
+}
+
+STATUS
+IpcProcessEvent(
+    _Pre_valid_ _Post_ptr_invalid_
+            PIPC_EVENT_CPU      CpuEvent,
+    OUT     STATUS*             FunctionStatus
+    )
+{
+    PIPC_EVENT pEvent;
+    STATUS funcStatus;
+    DWORD newRefCount;
+    BOOLEAN signalTermination;
+
+    if (NULL == CpuEvent)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == FunctionStatus)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    LOG_FUNC_START;
+
+    pEvent = CpuEvent->Event;
+    ASSERT( NULL != pEvent );
+
+    LOG_TRACE_CPU("Will process event at 0x%X\n", pEvent );
+
+    ASSERT( NULL != pEvent->Function );
+
+    funcStatus = pEvent->Function(pEvent->Context);
+
+    // must be used before RfcDereference because the event
+    // could become invalid if the ref count gets to 0
+    signalTermination = pEvent->SignalTermination;
+
+    newRefCount = RfcDereference(&pEvent->RefCnt);
+    if (signalTermination && (1 == newRefCount))
+    {
+        EvtSignal(&pEvent->TerminationEvent);
+    }
+    *FunctionStatus = funcStatus;
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+_IpcFreeEvent(
+    IN      PVOID       Object,
+    IN_OPT  PVOID       Context
+    )
+{
+    PIPC_EVENT pEvent;
+
+    ASSERT(NULL != Object);
+    ASSERT(NULL == Context);
+
+    LOG_FUNC_START;
+
+    pEvent = (PIPC_EVENT)Object;
+
+    if (NULL != pEvent->FreeFunction)
+    {
+        pEvent->FreeFunction(pEvent->Context, pEvent->FreeFunctionContext);
+    }
+
+    LOG_TRACE_CPU("Will deallocate event object at 0x%X\n", pEvent);
+    ExFreePoolWithTag(pEvent, HEAP_IPC_TAG);
+    pEvent = NULL;
+
+    LOG_FUNC_END;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/isr.c b/src_proiect/HAL9000/src/isr.c
new file mode 100644
index 0000000..fdbb407
--- /dev/null
+++ b/src_proiect/HAL9000/src/isr.c
@@ -0,0 +1,260 @@
+#include "HAL9000.h"
+#include "isr.h"
+#include "idt_handlers.h"
+#include "iomu.h"
+#include "pic.h"
+#include "thread_internal.h"
+#include "mmu.h"
+#include "cpumu.h"
+#include "dmp_cpu.h"
+#include "process.h"
+
+#define UNDEFINED_INTERRUPT_TEXT                "UNKNOWN INTERRUPT"
+#define STACK_BYTES_TO_DUMP_ON_EXCEPTION        0x100
+
+const char EXCEPTION_NAME[ExceptionVirtualizationException+1][MAX_PATH] = { "#DE - Divide Error", "#DB - Debug Exception", "NMI Interrupt",
+                                                                            "#BP - Breakpoint Exception", "#OF - Overflow Exception", "#BR - BOUND Range Exceeded Exception",
+                                                                            "#UD - Invalid Opcode Exception", "#NM - Device Not Available Exception", "#DF - Double Fault Exception",
+                                                                            "Coprocessor Segment Overrun", "#TS - Invalid TSS Exception", "#NP - Segment Not Present",
+                                                                            "#SS - Stack Fault Exception", "#GP - General Protection Exception", "#PF - Page-Fault Exception",
+                                                                            UNDEFINED_INTERRUPT_TEXT, "#MF - x87 FPU Floating-Point Error", "#AC - Alignment Check",
+                                                                            "#MC - Machine-Check Exception", "#XM - SIMD Floating-Point Exception", "#VE - Virtualization Exception"
+                                                                        };
+
+const char INTERRUPT_NAME[NO_OF_IRQS][MAX_PATH] = {     "Timer", "Keyboard", "Cascade",
+                                                        "COM2", "COM1", UNDEFINED_INTERRUPT_TEXT,
+                                                        "Diskette", "LPT1", "CMOS RTC",
+                                                        "CGA", UNDEFINED_INTERRUPT_TEXT,UNDEFINED_INTERRUPT_TEXT
+                                                        UNDEFINED_INTERRUPT_TEXT, "FPU","Hard Disk",UNDEFINED_INTERRUPT_TEXT,
+                                                        UNDEFINED_INTERRUPT_TEXT
+                                                        };
+
+static PFUNC_IsrRoutine m_isrRoutines[NO_OF_USABLE_INTERRUPTS] = { NULL };
+static PVOID m_isrContexts[NO_OF_USABLE_INTERRUPTS] = { NULL };
+
+static
+void
+_IsrExceptionHandler(
+    IN BYTE                         InterruptIndex,
+    IN PINTERRUPT_STACK_COMPLETE    StackPointer,
+    IN BOOLEAN                      ErrorCodeAvailable,
+    IN COMPLETE_PROCESSOR_STATE*    ProcessorState
+    );
+
+static
+void
+_IsrInterruptHandler(
+    IN BYTE             InterruptIndex
+    );
+
+
+void
+IsrCommonHandler(
+    IN BYTE                                 InterruptIndex,
+    IN PINTERRUPT_STACK_COMPLETE            StackPointer,
+    IN BOOLEAN                              ErrorCodeAvailable,
+    IN COMPLETE_PROCESSOR_STATE*            ProcessorState
+    )
+{
+    PPCPU pPcpu;
+
+    CHECK_STACK_ALIGNMENT;
+
+    ASSERT(CpuIntrGetState() == INTR_OFF);
+
+    pPcpu = GetCurrentPcpu();
+    if (NULL != pPcpu)
+    {
+        // in the early stages the PCPU may have not been yet set
+        pPcpu->InterruptsTriggered[InterruptIndex] += 1;
+    }
+
+    if (InterruptIndex < NO_OF_RESERVED_EXCEPTIONS)
+    {
+        _IsrExceptionHandler(InterruptIndex, StackPointer, ErrorCodeAvailable, ProcessorState);
+    }
+    else
+    {
+        _IsrInterruptHandler(InterruptIndex);
+    }
+}
+
+static
+void
+_IsrExceptionHandler(
+    IN BYTE                         InterruptIndex,
+    IN PINTERRUPT_STACK_COMPLETE    StackPointer,
+    IN BOOLEAN                      ErrorCodeAvailable,
+    IN COMPLETE_PROCESSOR_STATE*             ProcessorState
+    )
+{
+    DWORD errorCode;
+    BOOLEAN exceptionHandled;
+
+    errorCode = 0;
+    exceptionHandled = FALSE;
+
+    LOG_TRACE_EXCEPTION("Exception: 0x%x [%s]\n", InterruptIndex, EXCEPTION_NAME[InterruptIndex]);
+
+    // now even if we don't have an error code
+    // our ISRs push a zero on the stack
+    ASSERT(NULL != StackPointer);
+
+    if (ErrorCodeAvailable)
+    {
+        errorCode = (DWORD)StackPointer->ErrorCode;
+    }
+
+    if (ExceptionPageFault == InterruptIndex)
+    {
+        PVOID pfAddr;
+
+        ASSERT(ErrorCodeAvailable);
+
+        pfAddr = __readcr2();
+        LOG_TRACE_EXCEPTION("#PF address: 0x%X\n", pfAddr);
+        exceptionHandled = MmuSolvePageFault(pfAddr, errorCode );
+        if (!exceptionHandled)
+        {
+            PPCPU pCpu;
+
+            pCpu = GetCurrentPcpu();
+            if (NULL != pCpu)
+            {
+                BYTE* pStackBottom;
+
+                pStackBottom = (BYTE*)pCpu->StackTop - pCpu->StackSize;
+
+                if (CHECK_BOUNDS(pfAddr, 1, pStackBottom - STACK_GUARD_SIZE, STACK_GUARD_SIZE))
+                {
+                    // memory accessed is directly below the stack (in the unmapped stack guard area)
+                    LOG_ERROR("Stack overflow\n"
+                              "Stack in range [0x%X, 0x%X]\n"
+                              "#PF is at 0x%X\n",
+                              pStackBottom, pCpu->StackTop,
+                              pfAddr
+                              );
+                }
+            }
+        }
+    }
+    else if (ExceptionGeneralProtection == InterruptIndex)
+    {
+        LOG_TRACE_EXCEPTION("RSP[0]: 0x%X\n", *((QWORD*)StackPointer->Registers.Rsp));
+    }
+
+    // no use in logging if we solved the problem
+    if (!exceptionHandled)
+    {
+        PVOID* pCurrentStackItem;
+        DWORD noOfStackElementsToDump;
+        PPCPU pCpu;
+
+        LOG_ERROR("Could not handle exception 0x%x [%s]\n", InterruptIndex, EXCEPTION_NAME[InterruptIndex]);
+
+        DumpInterruptStack(StackPointer, ErrorCodeAvailable );
+        DumpControlRegisters();
+        DumpProcessorState(ProcessorState);
+
+        LOG("Faulting stack data:\n");
+
+        pCpu = GetCurrentPcpu();
+
+        pCurrentStackItem = (PVOID*) max(StackPointer->Registers.Rsp,
+                                         pCpu != NULL ? (QWORD) PtrDiff(pCpu->StackTop, (QWORD) pCpu->StackSize)
+                                                      : StackPointer->Registers.Rsp);
+        noOfStackElementsToDump = (DWORD) (min(STACK_BYTES_TO_DUMP_ON_EXCEPTION,
+                                               pCpu != NULL ? PtrDiff(pCpu->StackTop,pCurrentStackItem) : STACK_BYTES_TO_DUMP_ON_EXCEPTION)
+                                           / sizeof(PVOID));
+        for (DWORD i = 0; i < noOfStackElementsToDump; ++i)
+        {
+            LOG("[0x%X]: 0x%X\n", &pCurrentStackItem[i], pCurrentStackItem[i]);
+        }
+    }
+
+    ASSERT_INFO(exceptionHandled, "Exception 0x%x was not handled\n", InterruptIndex);
+}
+
+static
+void
+_IsrInterruptHandler(
+    IN BYTE             InterruptIndex
+    )
+{
+    BOOLEAN interruptHandled;
+    BOOLEAN bSpuriousInterrupt;
+    BYTE indexInHandlers;
+    IRQL prevIrql;
+
+    interruptHandled = FALSE;
+    indexInHandlers = InterruptIndex - NO_OF_RESERVED_EXCEPTIONS;
+    bSpuriousInterrupt = FALSE;
+
+    // In operating systems that use the lowest priority delivery mode but do not update the TPR, the TPR information
+    // saved in the chipset will potentially cause the interrupt to be always delivered to the same processor from the
+    // logical set. This behavior is functionally backward compatible with the P6 family processor but may result in
+    // unexpected performance implications.
+    prevIrql = CpuMuRaiseIrql(VECTOR_TO_IRQL(InterruptIndex));
+
+    // call registered interrupt
+    if (NULL != m_isrRoutines[indexInHandlers])
+    {
+        interruptHandled = m_isrRoutines[indexInHandlers](m_isrContexts[indexInHandlers]);
+    }
+    else
+    {
+        LOG_ERROR("No interrupt registered for interrupt 0x%x\n", InterruptIndex);
+    }
+
+    if (!interruptHandled)
+    {
+        bSpuriousInterrupt = IomuIsInterruptSpurious(InterruptIndex);
+        if (bSpuriousInterrupt)
+        {
+            LOGP_WARNING("Received spurious vector 0x%02x\n", InterruptIndex);
+        }
+    }
+
+    ASSERT_INFO(interruptHandled || bSpuriousInterrupt, "Interrupt 0x%x was not handled\n", InterruptIndex);
+
+    if (!bSpuriousInterrupt)
+    {
+        // send EOI
+        IomuAckInterrupt(InterruptIndex);
+    }
+
+    // must be called before ThreadYield, else we may lower the IRQL too late or never
+    // if the thread terminates
+    CpuMuLowerIrql(prevIrql);
+
+    if (ThreadYieldOnInterrupt())
+    {
+        ThreadYield();
+    }
+}
+
+STATUS
+IsrInstallEx(
+    IN      BYTE                Vector,
+    IN      PFUNC_IsrRoutine    IsrRoutine,
+    IN_OPT  PVOID               Context
+    )
+{
+    BYTE indexInRoutines;
+
+    ASSERT( Vector > NO_OF_RESERVED_EXCEPTIONS);
+
+    indexInRoutines = Vector - NO_OF_RESERVED_EXCEPTIONS;
+
+    if (NULL != m_isrRoutines[indexInRoutines])
+    {
+        LOG_WARNING("There is already a routine installed at vector 0x%x\n", indexInRoutines);
+        return STATUS_ALREADY_INITIALIZED;
+    }
+
+    LOG_TRACE_INTERRUPT("Registering ISR for vector: 0x%x\n", Vector);
+    m_isrRoutines[indexInRoutines] = IsrRoutine;
+    m_isrContexts[indexInRoutines] = Context;
+
+    return STATUS_SUCCESS;
+}
diff --git a/src_proiect/HAL9000/src/keyboard.c b/src_proiect/HAL9000/src/keyboard.c
new file mode 100644
index 0000000..f0ec5ed
--- /dev/null
+++ b/src_proiect/HAL9000/src/keyboard.c
@@ -0,0 +1,694 @@
+#include "HAL9000.h"
+#include "keyboard.h"
+#include "io.h"
+#include "strutils.h"
+#include "ex_event.h"
+
+#define KBD_ENCODER_INPUT_PORT         0x60
+#define KBD_ENCODER_COMMAND_PORT       0x60
+
+#define KBD_CONTROLLER_SREG_PORT       0x64
+#define KBD_CONTROLLER_COMMAND_PORT    0x64
+
+#define KBD_SREG_OUTPUT_BUFFER_FULL     (1<<0)
+#define KBD_SREG_INPUT_BUFFER_FULL      (1<<1)
+
+// keyboard controller commands
+typedef enum _KEYBOARD_CTRL_COMMAND
+{
+    KeyboardCtrlCommandReadCommand      = 0x20,
+    KeyboardCtrlCommandWriteCommand     = 0x60,
+    KeyboardCtrlCommandSelfTest         = 0xAA,
+    KeyboardCtrlCommandInterfaceTest    = 0xAB,
+    KeyboardCtrlCommandDisableKbd       = 0xAD,
+    KeyboardCtrlCommandEnableKbd        = 0xAE,
+    KeyboardCtrlCommandSystemReset      = 0xFE
+} KEYBOARD_CTRL_COMMAND;
+
+// keyboard encoder commands
+typedef enum _KEYBOARD_ENC_COMMAND
+{
+    KeyboardEncCommandSetLEDs           = 0xED
+} KEYBOARD_ENC_COMMAND;
+
+#define KBD_ENC_LED_SCROLL_LOCK_BIT     0
+#define KBD_ENC_LED_NUM_LOCK_BIT        1
+#define KBD_ENC_LED_CAPS_LOCK_BIT       2
+
+//! original xt scan code set. Array index==make code
+static WORD _kkybrd_scancode_std[] = {
+
+    //! key             scancode
+    KEY_UNKNOWN,        //0
+    KEY_ESCAPE,         //1
+    KEY_1,              //2
+    KEY_2,              //3
+    KEY_3,              //4
+    KEY_4,              //5
+    KEY_5,              //6
+    KEY_6,              //7
+    KEY_7,              //8
+    KEY_8,              //9
+    KEY_9,              //0xa
+    KEY_0,              //0xb
+    KEY_MINUS,          //0xc
+    KEY_EQUAL,          //0xd
+    KEY_BACKSPACE,      //0xe
+    KEY_TAB,            //0xf
+    KEY_Q,              //0x10
+    KEY_W,              //0x11
+    KEY_E,              //0x12
+    KEY_R,              //0x13
+    KEY_T,              //0x14
+    KEY_Y,              //0x15
+    KEY_U,              //0x16
+    KEY_I,              //0x17
+    KEY_O,              //0x18
+    KEY_P,              //0x19
+    KEY_LEFTBRACKET,    //0x1a
+    KEY_RIGHTBRACKET,   //0x1b
+    KEY_RETURN,         //0x1c
+    KEY_LCTRL,          //0x1d
+    KEY_A,              //0x1e
+    KEY_S,              //0x1f
+    KEY_D,              //0x20
+    KEY_F,              //0x21
+    KEY_G,              //0x22
+    KEY_H,              //0x23
+    KEY_J,              //0x24
+    KEY_K,              //0x25
+    KEY_L,              //0x26
+    KEY_SEMICOLON,      //0x27
+    KEY_QUOTE,          //0x28
+    KEY_GRAVE,          //0x29
+    KEY_LSHIFT,         //0x2a
+    KEY_BACKSLASH,      //0x2b
+    KEY_Z,              //0x2c
+    KEY_X,              //0x2d
+    KEY_C,              //0x2e
+    KEY_V,              //0x2f
+    KEY_B,              //0x30
+    KEY_N,              //0x31
+    KEY_M,              //0x32
+    KEY_COMMA,          //0x33
+    KEY_DOT,            //0x34
+    KEY_SLASH,          //0x35
+    KEY_RSHIFT,         //0x36
+    KEY_KP_ASTERISK,    //0x37
+    KEY_RALT,           //0x38
+    KEY_SPACE,          //0x39
+    KEY_CAPSLOCK,       //0x3a
+    KEY_F1,             //0x3b
+    KEY_F2,             //0x3c
+    KEY_F3,             //0x3d
+    KEY_F4,             //0x3e
+    KEY_F5,             //0x3f
+    KEY_F6,             //0x40
+    KEY_F7,             //0x41
+    KEY_F8,             //0x42
+    KEY_F9,             //0x43
+    KEY_F10,            //0x44
+    KEY_KP_NUMLOCK,     //0x45
+    KEY_SCROLLLOCK,     //0x46
+    KEY_KP_7,           //0x47
+    KEY_KP_8,           //0x48
+    KEY_KP_9,           //0x49
+    KEY_KP_MINUS,       //0x4a
+    KEY_KP_4,           //0x4b
+    KEY_KP_5,           //0x4c
+    KEY_KP_6,           //0x4d
+    KEY_KP_PLUS,        //0x4e
+    KEY_KP_1,           //0x4f
+    KEY_KP_2,           //0x50    //keypad down arrow
+    KEY_KP_3,           //0x51    //keypad page down
+    KEY_KP_0,           //0x52    //keypad insert key
+    KEY_KP_DECIMAL,     //0x53    //keypad delete key
+    KEY_UNKNOWN,        //0x54
+    KEY_UNKNOWN,        //0x55
+    KEY_UNKNOWN,        //0x56
+    KEY_F11,            //0x57
+    KEY_F12             //0x58
+};
+
+static WORD _kkybrd_scancode_ext[] = {
+
+    //! key            scancode
+    KEY_UNKNOWN,    //0
+    KEY_UNKNOWN,        //1
+    KEY_UNKNOWN,            //2
+    KEY_UNKNOWN,            //3
+    KEY_UNKNOWN,            //4
+    KEY_UNKNOWN,            //5
+    KEY_UNKNOWN,            //6
+    KEY_UNKNOWN,            //7
+    KEY_UNKNOWN,            //8
+    KEY_UNKNOWN,            //9
+    KEY_UNKNOWN,            //0xa
+    KEY_UNKNOWN,            //0xb
+    KEY_UNKNOWN,        //0xc
+    KEY_UNKNOWN,        //0xd
+    KEY_UNKNOWN,    //0xe
+    KEY_UNKNOWN,        //0xf
+    KEY_UNKNOWN,            //0x10
+    KEY_UNKNOWN,            //0x11
+    KEY_UNKNOWN,            //0x12
+    KEY_UNKNOWN,            //0x13
+    KEY_UNKNOWN,            //0x14
+    KEY_UNKNOWN,            //0x15
+    KEY_UNKNOWN,            //0x16
+    KEY_UNKNOWN,            //0x17
+    KEY_UNKNOWN,            //0x18
+    KEY_UNKNOWN,            //0x19
+    KEY_UNKNOWN,//0x1a
+    KEY_UNKNOWN,//0x1b
+    KEY_KP_ENTER,        //0x1c
+    KEY_UNKNOWN,        //0x1d
+    KEY_UNKNOWN,            //0x1e
+    KEY_UNKNOWN,            //0x1f
+    KEY_UNKNOWN,            //0x20
+    KEY_UNKNOWN,            //0x21
+    KEY_UNKNOWN,            //0x22
+    KEY_UNKNOWN,            //0x23
+    KEY_UNKNOWN,            //0x24
+    KEY_UNKNOWN,            //0x25
+    KEY_UNKNOWN,            //0x26
+    KEY_UNKNOWN,    //0x27
+    KEY_UNKNOWN,        //0x28
+    KEY_UNKNOWN,        //0x29
+    KEY_UNKNOWN,        //0x2a
+    KEY_UNKNOWN,    //0x2b
+    KEY_UNKNOWN,            //0x2c
+    KEY_UNKNOWN,            //0x2d
+    KEY_UNKNOWN,            //0x2e
+    KEY_UNKNOWN,            //0x2f
+    KEY_UNKNOWN,            //0x30
+    KEY_UNKNOWN,            //0x31
+    KEY_UNKNOWN,            //0x32
+    KEY_UNKNOWN,        //0x33
+    KEY_UNKNOWN,        //0x34
+    KEY_UNKNOWN,        //0x35
+    KEY_UNKNOWN,        //0x36
+    KEY_UNKNOWN,//0x37
+    KEY_UNKNOWN,        //0x38
+    KEY_UNKNOWN,        //0x39
+    KEY_UNKNOWN,    //0x3a
+    KEY_UNKNOWN,            //0x3b
+    KEY_UNKNOWN,            //0x3c
+    KEY_UNKNOWN,            //0x3d
+    KEY_UNKNOWN,            //0x3e
+    KEY_UNKNOWN,            //0x3f
+    KEY_UNKNOWN,            //0x40
+    KEY_UNKNOWN,            //0x41
+    KEY_UNKNOWN,            //0x42
+    KEY_UNKNOWN,            //0x43
+    KEY_UNKNOWN,        //0x44
+    KEY_UNKNOWN,    //0x45
+    KEY_UNKNOWN,    //0x46
+    KEY_HOME,       //0x47
+    KEY_UP,       //0x48
+    KEY_UNKNOWN,       //0x49
+    KEY_UNKNOWN,   //0x4a
+    KEY_LEFT,       //0x4b
+    KEY_UNKNOWN,       //0x4c
+    KEY_RIGHT,       //0x4d
+    KEY_UNKNOWN,    //0x4e
+    KEY_END,       //0x4f
+    KEY_DOWN,        //0x50    //keypad down arrow
+    KEY_UNKNOWN,        //0x51    //keypad page down
+    KEY_UNKNOWN,        //0x52    //keypad insert key
+    KEY_DELETE,    //0x53    //keypad delete key
+    KEY_UNKNOWN,    //0x54
+    KEY_UNKNOWN,    //0x55
+    KEY_UNKNOWN,    //0x56
+    KEY_UNKNOWN,        //0x57
+    KEY_UNKNOWN//0x58
+};
+
+#define KEY_BREAK               (1<<7)
+
+#define KEY_INVALID_SCANCODE    0x0
+
+typedef struct _KEYBOARD_DATA
+{
+    KEYCODE             Keycode;
+
+    // LEDs
+    BOOLEAN             NumLock;
+    BOOLEAN             ScrollLock;
+    BOOLEAN             CapsLock;
+
+    // Modifiers
+    BOOLEAN             Shift;
+    BOOLEAN             Alt;
+    BOOLEAN             Ctrl;
+
+    // Basic Assurance Test
+    BOOLEAN             BatSucceeded;
+    BOOLEAN             KeyboardInitialized;
+
+    // if signaled => key was pressed
+    // and it wasn't discarded yet
+    EX_EVENT            KeyPressedEvt;
+} KEYBOARD_DATA, *PKEYBOARD_DATA;
+
+static KEYBOARD_DATA m_keyboardData = { 0 };
+
+static FUNC_InterruptFunction  _KeyboardIsr;
+
+static
+void
+_KeyboardCtrlSendCommand(
+    IN      BYTE        Command
+);
+
+static
+void
+_KeyboardEncSendCommand(
+    IN      BYTE        Command
+);
+
+static
+void
+_KeyboardUpdateLEDs(
+    void
+);
+
+static
+__forceinline
+BYTE
+_KeyboardCtrlReadStatus(
+    void
+)
+{
+    return __inbyte(KBD_CONTROLLER_SREG_PORT);
+}
+
+static
+__forceinline
+BYTE
+_KeyboardEncReadBuffer(
+    void
+)
+{
+    return __inbyte(KBD_ENCODER_INPUT_PORT);
+}
+
+static
+__forceinline
+void
+_KeyboardEnableKbd(
+    void
+)
+{
+    _KeyboardCtrlSendCommand(KeyboardCtrlCommandEnableKbd);
+}
+
+STATUS
+KeyboardInitialize(
+    IN      BYTE        InterruptIrq
+)
+{
+    STATUS status;
+    IO_INTERRUPT ioInterrupt;
+
+    status = STATUS_SUCCESS;
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    // check to see if keyboard wasn't already initialized
+    if (m_keyboardData.KeyboardInitialized)
+    {
+        // return already a HINT, not an error
+        return STATUS_ALREADY_INITIALIZED_HINT;
+    }
+
+    m_keyboardData.Keycode = KEY_UNKNOWN;
+
+    // make sure keyboard is enabled
+    _KeyboardEnableKbd();
+
+    /// TODO: do a BAT test (basic assurance test)
+
+    // set LEDs status
+    m_keyboardData.CapsLock = m_keyboardData.ScrollLock = m_keyboardData.NumLock = FALSE;
+    _KeyboardUpdateLEDs();
+
+    // set shift, ctrl and alt keys status
+    m_keyboardData.Ctrl = m_keyboardData.Shift = m_keyboardData.Alt = FALSE;
+
+    // create event
+    status = ExEventInit(&m_keyboardData.KeyPressedEvt, ExEventTypeNotification, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ExEventInit", status);
+        return status;
+    }
+
+    // install ISR
+    ioInterrupt.Type = IoInterruptTypeLegacy;
+    ioInterrupt.Irql = IrqlUserInputLevel;
+    ioInterrupt.ServiceRoutine = _KeyboardIsr;
+    ioInterrupt.Exclusive = TRUE;
+    ioInterrupt.Legacy.Irq = InterruptIrq;
+
+    status = IoRegisterInterrupt(&ioInterrupt, NULL);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoRegisterInterrupt", status);
+        return status;
+    }
+
+    // keyboard initialized
+    m_keyboardData.KeyboardInitialized = TRUE;
+
+    return status;
+}
+
+_Success_(KEY_UNKNOWN != return)
+KEYCODE
+KeyboardGetLastKey(
+    void
+)
+{
+    return m_keyboardData.Keycode;
+}
+
+_Success_(KEY_UNKNOWN != return)
+KEYCODE
+KeyboardWaitForKey(
+    void
+)
+{
+    ExEventWaitForSignal(&m_keyboardData.KeyPressedEvt);
+    return m_keyboardData.Keycode;
+}
+
+void
+KeyboardDiscardLastKey(
+    void
+)
+{
+    ExEventClearSignal(&m_keyboardData.KeyPressedEvt);
+    m_keyboardData.Keycode = KEY_UNKNOWN;
+}
+
+char
+KeyboardKeyToAscii(
+    IN      KEYCODE     KeyCode
+)
+{
+    char result = KeyCode;
+
+    if (KEY_UNKNOWN == KeyCode || !isascii(KeyCode))
+    {
+        // we have nothing to return, this is not a valid ASCII
+        // character
+        return 0;
+    }
+
+    // if shift key is down xor caps lock is on, make the key uppercase
+    // we certainly have small letter
+    // if SHIFT on => uppercase
+    // if CAPS on => uppercase
+    // if BOTH shift and CAPS => it remains lowercase
+    if (m_keyboardData.Shift ^ m_keyboardData.CapsLock)
+    {
+        if (result >= 'a' && result <= 'z')
+        {
+            result = result - ('a' - 'A');
+        }
+    }
+
+    if (m_keyboardData.Shift)
+    {
+        if (result >= '0' && result <= '9')
+        {
+            switch (result)
+            {
+
+            case '0':
+                result = KEY_RIGHTPARENTHESIS;
+                break;
+            case '1':
+                result = KEY_EXCLAMATION;
+                break;
+            case '2':
+                result = KEY_AT;
+                break;
+            case '3':
+                result = KEY_EXCLAMATION;
+                break;
+            case '4':
+                result = KEY_HASH;
+                break;
+            case '5':
+                result = KEY_PERCENT;
+                break;
+            case '6':
+                result = KEY_CARRET;
+                break;
+            case '7':
+                result = KEY_AMPERSAND;
+                break;
+            case '8':
+                result = KEY_ASTERISK;
+                break;
+            case '9':
+                result = KEY_LEFTPARENTHESIS;
+                break;
+            }
+        }
+        else
+        {
+
+            switch (result)
+            {
+            case KEY_COMMA:
+                result = KEY_LESS;
+                break;
+
+            case KEY_DOT:
+                result = KEY_GREATER;
+                break;
+
+            case KEY_SLASH:
+                result = KEY_QUESTION;
+                break;
+
+            case KEY_SEMICOLON:
+                result = KEY_COLON;
+                break;
+
+            case KEY_QUOTE:
+                result = KEY_QUOTEDOUBLE;
+                break;
+
+            case KEY_LEFTBRACKET:
+                result = KEY_LEFTCURL;
+                break;
+
+            case KEY_RIGHTBRACKET:
+                result = KEY_RIGHTCURL;
+                break;
+
+            case KEY_GRAVE:
+                result = KEY_TILDE;
+                break;
+
+            case KEY_MINUS:
+                result = KEY_UNDERSCORE;
+                break;
+
+            case KEY_PLUS:
+                result = KEY_EQUAL;
+                break;
+
+            case KEY_BACKSLASH:
+                result = KEY_BAR;
+                break;
+            }
+        }
+    }
+
+    return result;
+}
+
+void
+KeyboardResetSystem(
+    void
+)
+{
+    _KeyboardCtrlSendCommand(KeyboardCtrlCommandSystemReset);
+}
+
+static
+void
+_KeyboardCtrlSendCommand(
+    IN      BYTE        Command
+)
+{
+    // we can't send any commands while the keyboard buffer is full
+    while (IsBooleanFlagOn(_KeyboardCtrlReadStatus(), KBD_SREG_INPUT_BUFFER_FULL));
+
+    __outbyte(KBD_CONTROLLER_COMMAND_PORT, Command);
+}
+
+static
+void
+_KeyboardEncSendCommand(
+    IN      BYTE        Command
+)
+{
+    // because the commands sent to the encoder go through the controller
+    // we can't send any commands while the keyboard buffer is full
+    while (IsBooleanFlagOn(_KeyboardCtrlReadStatus(), KBD_SREG_INPUT_BUFFER_FULL));
+
+    __outbyte(KBD_ENCODER_COMMAND_PORT, Command);
+}
+
+static
+void
+_KeyboardUpdateLEDs(
+    void
+)
+{
+    BYTE data = 0;
+
+    // set appriate bits
+    data = data | (m_keyboardData.ScrollLock << KBD_ENC_LED_SCROLL_LOCK_BIT);
+    data = data | (m_keyboardData.NumLock << KBD_ENC_LED_NUM_LOCK_BIT);
+    data = data | (m_keyboardData.CapsLock << KBD_ENC_LED_CAPS_LOCK_BIT);
+
+    LOG("Will update LEDs with data: 0x%x\n", data);
+
+    // send the command -- update (LEDs)
+    _KeyboardEncSendCommand(KeyboardEncCommandSetLEDs);
+    _KeyboardEncSendCommand(data);
+}
+
+static
+BOOLEAN
+(__cdecl _KeyboardIsr)(
+    IN      PDEVICE_OBJECT           Device
+    )
+{
+    BYTE code;
+    WORD key;
+    BOOLEAN updateLEDs;
+    BOOLEAN keyBreak;
+    BYTE kbdStatus;
+
+    static BOOLEAN _extendedCode = FALSE;
+
+    ASSERT(NULL != Device);
+
+    kbdStatus = _KeyboardCtrlReadStatus();
+
+    ASSERT_INFO(IsBooleanFlagOn(kbdStatus, KBD_SREG_OUTPUT_BUFFER_FULL),
+        "How did we get interrupt if there is nothing in the buffer??");
+
+    code = _KeyboardEncReadBuffer();
+    key = 0;
+    updateLEDs = FALSE;
+    keyBreak = IsBooleanFlagOn(code, KEY_BREAK);
+
+    __try
+    {
+        if (0xE0 == code || 0xE1 == code)
+        {
+            _extendedCode = TRUE;
+            __leave;
+        }
+
+        if (keyBreak)
+        {
+            // this is a key break
+            // covert the break code into its make code equivalent
+            code -= 0x80;
+        }
+
+        if (_extendedCode)
+        {
+            key = _kkybrd_scancode_ext[code];
+        }
+        else
+        {
+            // grab the key
+            key = _kkybrd_scancode_std[code];
+        }
+
+        if (keyBreak)
+        {
+            // test if a special key has been released & set it
+            switch (key)
+            {
+            case KEY_LCTRL:
+            case KEY_RCTRL:
+                m_keyboardData.Ctrl = FALSE;
+                break;
+
+            case KEY_LSHIFT:
+            case KEY_RSHIFT:
+                m_keyboardData.Shift = FALSE;
+                break;
+            case KEY_LALT:
+            case KEY_RALT:
+                m_keyboardData.Alt = FALSE;
+                break;
+            }
+        }
+        else
+        {
+            // this is a make - update current scan code
+            m_keyboardData.Keycode = key;
+
+            // test if user is holding down any special keys & set it
+            switch (key)
+            {
+
+            case KEY_LCTRL:
+            case KEY_RCTRL:
+                m_keyboardData.Ctrl = TRUE;
+                break;
+
+            case KEY_LSHIFT:
+            case KEY_RSHIFT:
+                m_keyboardData.Shift = TRUE;
+                break;
+
+            case KEY_LALT:
+            case KEY_RALT:
+                m_keyboardData.Alt = TRUE;
+                break;
+            case KEY_CAPSLOCK:
+                m_keyboardData.CapsLock = !m_keyboardData.CapsLock;
+                updateLEDs = TRUE;
+                break;
+            case KEY_KP_NUMLOCK:
+                m_keyboardData.NumLock = !m_keyboardData.NumLock;
+                updateLEDs = TRUE;
+                break;
+            case KEY_SCROLLLOCK:
+                m_keyboardData.ScrollLock = !m_keyboardData.ScrollLock;
+                updateLEDs = TRUE;
+                break;
+            }
+
+            if (updateLEDs)
+            {
+                _KeyboardUpdateLEDs();
+            }
+        }
+
+        // if we get here it's not an extended code
+        _extendedCode = FALSE;
+
+        // if we're here => we had a valid key press
+        ExEventSignal(&m_keyboardData.KeyPressedEvt);
+    }
+    __finally
+    {
+
+    }
+
+    return TRUE;
+}
diff --git a/src_proiect/HAL9000/src/keyboard_utils.c b/src_proiect/HAL9000/src/keyboard_utils.c
new file mode 100644
index 0000000..2e6b5d6
--- /dev/null
+++ b/src_proiect/HAL9000/src/keyboard_utils.c
@@ -0,0 +1,275 @@
+#include "HAL9000.h"
+#include "keyboard.h"
+#include "keyboard_utils.h"
+#include "display.h"
+
+#define CMD_SHELL       ">>"
+#define CMD_SHELL_SIZE  (sizeof(CMD_SHELL))
+
+#define CMD_HISTORY_MAX_SIZE    16
+
+static char m_CmdHistory[CMD_HISTORY_MAX_SIZE][CHARS_PER_LINE] = { 0 };
+
+static DWORD m_CmdHistoryFirstIndex = 0;
+static DWORD m_CmdHistorySize = 0;
+
+KEYCODE
+getch(
+    void
+)
+{
+    KEYCODE result = KEY_UNKNOWN;
+
+    do
+    {
+        result = KeyboardWaitForKey();
+        KeyboardDiscardLastKey();
+    } while (KEY_UNKNOWN == result);
+
+
+
+    return result;
+}
+
+void
+gets_s(
+    OUT_WRITES_Z(BufferSize)    char*       Buffer,
+    IN                          DWORD       BufferSize,
+    OUT                         DWORD*      UsedSize
+)
+{
+    DWORD i;
+    int j;
+    DWORD maxBufferSize;
+    KEYCODE key;
+    char c;
+    SCREEN_POSITION cursorPosition;
+    DWORD cmdHistoryIndex;
+
+    i = 0;
+    j = 0;
+    key = KEY_UNKNOWN;
+    c = 0;
+    cmdHistoryIndex = MAX_DWORD;
+
+    cursorPosition.Line = LINES_PER_SCREEN - 1;
+    cursorPosition.Column = CMD_SHELL_SIZE;
+
+    ASSERT(NULL != UsedSize);
+    ASSERT(NULL != Buffer);
+    ASSERT(BufferSize > 1);
+
+    // we cannot write more than a line or then the buffer we have
+    // we add sizeof('\0') because we do not need to print the NULL terminator :)
+    maxBufferSize = min(BufferSize, CHARS_PER_LINE - CMD_SHELL_SIZE + 1);
+
+    // zero the buffer
+    memzero(Buffer, BufferSize);
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        DispClearLine(LINES_PER_SCREEN - 1);
+        DispSetCursor(cursorPosition, CYAN_COLOR);
+
+        // display command shell
+        DispPutBufferColor(CMD_SHELL, LINES_PER_SCREEN - 1, 0, BLUE_COLOR);
+
+        // warning 6054: String 'Buffer' might not be zero-terminated
+        // the memzero call outside the while loop zero-terminates the string
+#pragma warning(suppress: 6054)
+        DispPutBufferColor(Buffer, LINES_PER_SCREEN - 1, CMD_SHELL_SIZE, BRIGHT_CYAN_COLOR);
+
+        key = getch();
+        ASSERT_INFO(KEY_UNKNOWN != key, "getch can't return when there is no valid key\n");
+
+        if (KEY_RETURN == key)
+        {
+            // enter was pressed
+
+            if (0 == strlen_s(Buffer, maxBufferSize))
+            {
+                break;
+            }
+
+            if (CMD_HISTORY_MAX_SIZE == m_CmdHistorySize)
+            {
+                m_CmdHistoryFirstIndex = (m_CmdHistoryFirstIndex + 1) % CMD_HISTORY_MAX_SIZE;
+            }
+            else
+            {
+                m_CmdHistorySize++;
+            }
+
+            strtrim(Buffer);
+
+            strncpy(m_CmdHistory[(m_CmdHistoryFirstIndex + m_CmdHistorySize - 1) % CMD_HISTORY_MAX_SIZE], Buffer, maxBufferSize - 1);
+
+            break;
+        }
+
+        if (KEY_BACKSPACE == key)
+        {
+            // delete a key
+            // if i is already 0 nothing to delete
+            if (0 != i)
+            {
+                // shift left all the characters in the Buffer after the current position
+                for (j = (int)i; j <= (int)strlen_s(Buffer, maxBufferSize - 1); j++)
+                {
+                    Buffer[j - 1] = Buffer[j];
+                }
+
+                cursorPosition.Column--;
+                --i;
+            }
+
+            // go to the next iteration
+            continue;
+        }
+
+        if (KEY_DELETE == key)
+        {
+            /// TODO: implement
+            continue;
+        }
+
+        if (KEY_UP == key)
+        {
+            if (0 == m_CmdHistorySize)  // nothing in history
+            {
+                continue;
+            }
+
+            if (MAX_DWORD == cmdHistoryIndex)
+            {
+                cmdHistoryIndex = (m_CmdHistoryFirstIndex + m_CmdHistorySize - 1) % CMD_HISTORY_MAX_SIZE;
+            }
+            else if (cmdHistoryIndex != m_CmdHistoryFirstIndex) // not yet at first command
+            {
+                cmdHistoryIndex = (cmdHistoryIndex - 1) % CMD_HISTORY_MAX_SIZE;
+            }
+
+            strncpy(Buffer, m_CmdHistory[cmdHistoryIndex], maxBufferSize - 1);
+
+            i = strlen_s(Buffer, maxBufferSize);
+            cursorPosition.Column = CMD_SHELL_SIZE + (BYTE)i;
+
+            // go to the next iteration
+            continue;
+        }
+
+        if (KEY_DOWN == key)
+        {
+            if (0 == m_CmdHistorySize)  // nothing in history
+            {
+                continue;
+            }
+
+            if (MAX_DWORD == cmdHistoryIndex)
+            {
+                continue;
+            }
+
+            if (cmdHistoryIndex != (m_CmdHistoryFirstIndex + m_CmdHistorySize - 1) % CMD_HISTORY_MAX_SIZE) // not yet at last command
+            {
+                cmdHistoryIndex = (cmdHistoryIndex + 1) % CMD_HISTORY_MAX_SIZE;
+            }
+
+            strncpy(Buffer, m_CmdHistory[cmdHistoryIndex], maxBufferSize - 1);
+
+            i = strlen_s(Buffer, maxBufferSize);
+            cursorPosition.Column = CMD_SHELL_SIZE + (BYTE)i;
+
+            // go to the next iteration
+            continue;
+        }
+
+        if (KEY_LEFT == key)
+        {
+            // move cursor to the left
+            if (0 != i)
+            {
+                // if i is already 0 we have nowhere to go
+                cursorPosition.Column--;
+                --i;
+            }
+
+            // go to the next iteration
+            continue;
+        }
+
+        if (KEY_RIGHT == key)
+        {
+            // move cursor to the right
+            if (i < maxBufferSize - 2)
+            {
+                // we use -2 because if we move the cursor we must
+                // be able to write a character afterward
+
+                // [BUFFER_SIZE - 2][CHAR AFTER CURSOR MOVEMENT][\0]
+
+                // move cursor only if there are characters to the right
+                if ('\0' != Buffer[i])
+                {
+                    cursorPosition.Column++;
+                    ++i;
+                }
+            }
+
+            // go to the next iteration
+            continue;
+        }
+
+        if (KEY_HOME == key)
+        {
+            if (0 != i)
+            {
+                cursorPosition.Column -= (BYTE)i;
+                i = 0;
+            }
+
+            continue;
+        }
+
+        if (KEY_END == key)
+        {
+            i = strlen_s(Buffer, maxBufferSize);
+            cursorPosition.Column = CMD_SHELL_SIZE + (BYTE)i;
+
+            continue;
+        }
+
+        if (KEY_TAB == key)
+        {
+            /// TODO: implement
+            continue;
+        }
+
+        // if we're here we might have an ASCII character
+        c = KeyboardKeyToAscii(key);
+        if (0 != c)
+        {
+            // we have an ASCII character
+
+            // shift right all the characters in the Buffer after the current position
+            for (j = strlen_s(Buffer, maxBufferSize - 1); j >= (int)i; j--)
+            {
+                Buffer[j + 1] = Buffer[j];
+            }
+
+            Buffer[i] = c;
+            ++i;
+            cursorPosition.Column++;
+        }
+
+        // we use BufferSize - 1 because we append a NULL terminator
+        if (i >= maxBufferSize - 1)
+        {
+            // we cannot write anymore in the buffer
+            break;
+        }
+    }
+
+    *UsedSize = i;
+}
diff --git a/src_proiect/HAL9000/src/lapic_system.c b/src_proiect/HAL9000/src/lapic_system.c
new file mode 100644
index 0000000..627e23b
--- /dev/null
+++ b/src_proiect/HAL9000/src/lapic_system.c
@@ -0,0 +1,361 @@
+#include "HAL9000.h"
+#include "lapic_system.h"
+#include "io.h"
+#include "cpumu.h"
+
+#define APIC_TIMER_DIVIDE_VALUE                 64
+
+typedef struct _APIC_DATA
+{
+    PVOID                   LocalApicAddress;
+    DWORD                   DividedBusFrequency;
+
+    DWORD                   InitialTimerCount;
+
+    BYTE                    ErrorVector;
+    BYTE                    SpuriousVector;
+} APIC_DATA, *PAPIC_DATA;
+
+static APIC_DATA            m_apicData;
+//******************************************************************************
+// Function:    ApicMapRegister
+// Description: This function MUST be called before any other APIC function.
+// Returns:       STATUS
+// Parameter:     void
+//******************************************************************************
+STATUS
+static
+_LapicSystemMapRegister(
+    IN      PHYSICAL_ADDRESS                ApicPhysicalAddress,
+    OUT_PTR PVOID*                          ApicVirtualAddress
+    );
+
+static
+STATUS
+_LapicInstallInterruptRoutines(
+    void
+    );
+
+static FUNC_InterruptFunction               _ApicSpuriousIsr;
+static FUNC_InterruptFunction               _ApicErrorIsr;
+
+__forceinline
+STATUS
+_LapicInstallInterruptRoutine(
+    IN      PFUNC_InterruptFunction     Function,
+    IN _Strict_type_match_
+            IRQL                        Irql,
+    OUT     PBYTE                       Vector
+)
+{
+    IO_INTERRUPT ioInterrupt;
+
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    ioInterrupt.Type = IoInterruptTypeLapic;
+    ioInterrupt.Exclusive = TRUE;
+    ioInterrupt.ServiceRoutine = Function;
+    ioInterrupt.Irql = Irql;
+
+    return IoRegisterInterruptEx(&ioInterrupt, NULL, Vector);
+}
+
+STATUS
+LapicSystemInit(
+    void
+    )
+{
+    STATUS status;
+    PHYSICAL_ADDRESS apicBaseAddress;
+    DWORD cpuFrequency;
+
+    status = _LapicInstallInterruptRoutines();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_LapicInstallInterruptRoutines", status );
+        return status;
+    }
+    LOGL("_LapicInstallInterruptRoutines succeeeded\n");
+
+    apicBaseAddress = LapicGetBasePhysicalAddress();
+
+    status = _LapicSystemMapRegister(apicBaseAddress, &m_apicData.LocalApicAddress);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_LapicSystemMapRegister", status);
+        return status;
+    }
+    LOGL("_LapicSystemMapRegister succeeded\n");
+
+    LapicDetermineDividedBusFrequency(m_apicData.LocalApicAddress, &cpuFrequency );
+    LOGL("CPU frequency: 0x%x\n", cpuFrequency );
+
+    m_apicData.DividedBusFrequency = cpuFrequency / APIC_TIMER_DIVIDE_VALUE;
+    LOGL("Divided bus frequency: 0x%x\n", m_apicData.DividedBusFrequency );
+
+    return status;
+}
+
+STATUS
+LapicSystemInitializeCpu(
+    IN      BYTE                            TimerInterruptVector
+    )
+{
+    STATUS status;
+    PPCPU pCpu;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pCpu = GetCurrentPcpu();
+
+    ASSERT(NULL != pCpu);
+    ASSERT(NULL != m_apicData.LocalApicAddress);
+
+    LapicInitialize(m_apicData.LocalApicAddress);
+
+    // before enabling LAPIC we should specify our logical destination
+    LapicSetLogicalApicId(m_apicData.LocalApicAddress,
+                          pCpu->LogicalApicId,
+                          APIC_DESTINATION_FORMAT_FLAT_MODEL
+                          );
+
+    // SW enable APIC
+    /// This must be done before any other settings are applied
+    // 10.4.7.2 Local APIC State After It Has Been Software Disabled
+    // The mask bits for all the LVT entries are set. Attempts to reset these bits will be ignored.
+    LapicSystemSetState(TRUE);
+    LOGL("Apic is SW enabled\n");
+
+    LapicConfigureLvtRegisters(m_apicData.LocalApicAddress, m_apicData.ErrorVector );
+    LOGPL("LAPIC registers configured\n");
+
+    LOGPL("Will configure timer using interrupt vector 0x%02x\n", TimerInterruptVector );
+    LapicConfigureTimer(m_apicData.LocalApicAddress,TimerInterruptVector,ApicDivideBy64);
+    LOGPL("LAPIC timer configured\n");
+
+    pCpu->ApicInitialized = TRUE;
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+void
+LapicSystemSetState(
+    IN      BOOLEAN                         Enable
+    )
+{
+    ASSERT( NULL != m_apicData.LocalApicAddress);
+
+    LapicSetState(m_apicData.LocalApicAddress, m_apicData.SpuriousVector, Enable);
+}
+
+BOOLEAN
+LapicSystemGetState(
+    void
+    )
+{
+    ASSERT(NULL != m_apicData.LocalApicAddress);
+
+    return LapicGetState(m_apicData.LocalApicAddress);
+}
+
+void
+LapicSystemSendEOI(
+    IN      BYTE                            Vector
+    )
+{
+    ASSERT(NULL != m_apicData.LocalApicAddress);
+
+    LapicSendEOI(m_apicData.LocalApicAddress,
+                 Vector
+                 );
+}
+
+void
+LapicSystemSetTimer(
+    IN      DWORD                           Microseconds
+    )
+{
+    DWORD timerCount;
+
+    ASSERT( NULL != m_apicData.LocalApicAddress );
+
+    timerCount = 0;
+
+    if (Microseconds != 0)
+    {
+        ASSERT(Microseconds < MAX_QWORD / m_apicData.DividedBusFrequency);
+        timerCount = ((QWORD)m_apicData.DividedBusFrequency * Microseconds) / SEC_IN_US;
+
+        m_apicData.InitialTimerCount = timerCount;
+
+        LOGL("DividedBusFrequency: 0x%x\n", m_apicData.DividedBusFrequency);
+        LOGL("timerCount: 0x%x\n", timerCount);
+    }
+
+    LapicSetTimerInterval(m_apicData.LocalApicAddress, timerCount);
+}
+
+void
+LapicSystemSendIpi(
+    _When_(ApicDestinationShorthandNone == DeliveryMode, IN)
+    _When_(ApicDestinationShorthandNone != DeliveryMode, _Reserved_)
+            APIC_ID                         ApicId,
+    IN      _Strict_type_match_
+            APIC_DELIVERY_MODE              DeliveryMode,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_SHORTHAND      DestinationShorthand,
+    IN      _Strict_type_match_
+            APIC_DESTINATION_MODE           DestinationMode,
+    IN_OPT  BYTE*                           Vector
+    )
+{
+    ASSERT(NULL != m_apicData.LocalApicAddress);
+
+    LapicSendIpi(m_apicData.LocalApicAddress,
+                 ApicId,
+                 DeliveryMode,
+                 DestinationShorthand,
+                 DestinationMode,
+                 Vector
+                 );
+}
+
+BYTE
+LapicSystemGetPpr(
+    void
+    )
+{
+    ASSERT( NULL != m_apicData.LocalApicAddress );
+
+    return LapicGetPpr(m_apicData.LocalApicAddress);
+}
+
+QWORD
+LapicSystemGetTimerElapsedUs(
+    void
+    )
+{
+    DWORD lapicTimerCount;
+    DWORD ticksCounted;
+    QWORD elapsedUs;
+
+    lapicTimerCount = 0;
+    ticksCounted = 0;
+    elapsedUs = 0;
+
+    ASSERT( NULL != m_apicData.LocalApicAddress );
+
+    lapicTimerCount = LapicGetTimerCount(m_apicData.LocalApicAddress);
+
+    ASSERT( m_apicData.InitialTimerCount >= lapicTimerCount );
+
+    ticksCounted = m_apicData.InitialTimerCount - lapicTimerCount;
+
+    elapsedUs = ( (QWORD) ticksCounted * SEC_IN_US ) /  m_apicData.DividedBusFrequency;
+
+    return elapsedUs;
+}
+
+BOOLEAN
+LapicSystemIsInterruptServiced(
+    IN      BYTE                            Vector
+    )
+{
+    return LapicIsInterruptServiced(m_apicData.LocalApicAddress, Vector);
+}
+
+STATUS
+static
+_LapicSystemMapRegister(
+    IN      PHYSICAL_ADDRESS                ApicPhysicalAddress,
+    OUT_PTR PVOID*                          ApicVirtualAddress
+    )
+{
+    PVOID apicVirtualAddress;
+
+    ASSERT( NULL != ApicPhysicalAddress );
+    ASSERT( NULL != ApicVirtualAddress );
+
+    apicVirtualAddress = IoMapMemory(ApicPhysicalAddress,
+                                     PAGE_SIZE,
+                                     PAGE_RIGHTS_READWRITE);
+    if (NULL == apicVirtualAddress)
+    {
+        return STATUS_MEMORY_CANNOT_BE_MAPPED;
+    }
+
+    // we return the apic base address
+    *ApicVirtualAddress = apicVirtualAddress;
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_LapicInstallInterruptRoutines(
+    void
+)
+{
+    STATUS status;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    // install APIC timer ISR
+    status = _LapicInstallInterruptRoutine(_ApicSpuriousIsr, IrqlErrorLevel, &m_apicData.SpuriousVector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_LapicInstallInterruptRoutine", status);
+        return status;
+    }
+
+    status = _LapicInstallInterruptRoutine(_ApicErrorIsr, IrqlErrorLevel, &m_apicData.ErrorVector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_LapicInstallInterruptRoutine", status);
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+BOOLEAN
+(__cdecl _ApicSpuriousIsr)(
+    IN      PDEVICE_OBJECT           Device
+    )
+{
+    ASSERT( NULL != Device );
+
+    LOG_FUNC_START;
+
+    LOG_FUNC_END;
+
+    return FALSE;
+}
+
+static
+BOOLEAN
+(__cdecl _ApicErrorIsr)(
+    IN      PDEVICE_OBJECT           Device
+    )
+{
+    DWORD error;
+
+    ASSERT( NULL != Device );
+
+    LOG_FUNC_START;
+
+    error = LapicGetErrorRegister(m_apicData.LocalApicAddress);
+    LOGL("Error: 0x%x\n", error );
+
+    LOG_FUNC_END;
+
+    return FALSE;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/lib.yasm b/src_proiect/HAL9000/src/lib.yasm
new file mode 100644
index 0000000..e77c802
--- /dev/null
+++ b/src_proiect/HAL9000/src/lib.yasm
@@ -0,0 +1,8 @@
+%ifndef _LIB_ASM_
+%define _LIB_ASM_
+
+%include "macros.yasm"
+%include "defines.yasm"
+%include "structs.yasm"
+
+%endif ; _LIB_ASM_
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/log.c b/src_proiect/HAL9000/src/log.c
new file mode 100644
index 0000000..ffcbe54
--- /dev/null
+++ b/src_proiect/HAL9000/src/log.c
@@ -0,0 +1,198 @@
+#include "HAL9000.h"
+#include "print.h"
+#include "log.h"
+#include "serial_comm.h"
+#include "synch.h"
+
+#define INFO_LEVEL_MODIFIER         ""
+#define WARNING_LEVEL_MODIFIER      "[WARNING]"
+#define ERROR_LEVEL_MODIFIER        "[ERROR]"
+
+#define LOG_BUF_MAX_SIZE            512
+
+typedef struct _LOG_DATA
+{
+    LOCK                        Lock;
+
+    _Interlocked_
+    volatile BOOLEAN            Enabled;
+
+    _Interlocked_
+    volatile LOG_LEVEL          LoggingLevel;
+
+    _Interlocked_
+    volatile LOG_COMPONENT      LoggingComponents;
+} LOG_DATA, *PLOG_DATA;
+
+static LOG_DATA m_logData;
+
+static
+void
+_LogBufferInternal(
+    IN_Z        char*                   Buffer,
+    IN          PFUNC_PrintFunction     PrintFunction
+    );
+
+_No_competing_thread_
+void
+LogSystemPreinit(
+    void
+    )
+{
+    memzero(&m_logData, sizeof(LOG_DATA));
+
+    LockInit(&m_logData.Lock);
+}
+
+_No_competing_thread_
+void
+LogSystemInit(
+    IN _Strict_type_match_
+                LOG_LEVEL       LogLevel,
+    IN
+                LOG_COMPONENT   LogComponenets,
+    IN          BOOLEAN         Enable
+    )
+{
+    m_logData.Enabled = Enable;
+    m_logData.LoggingComponents = LogComponenets;
+    m_logData.LoggingLevel = LogLevel;
+}
+
+void
+LogEx(
+    IN _Strict_type_match_
+                LOG_LEVEL       LogLevel,
+    IN
+                LOG_COMPONENT   LogComponent,
+    IN_Z        char*           FormatBuffer,
+    ...
+    )
+{
+    char logBuffer[LOG_BUF_MAX_SIZE];
+    char* pLevelModifier;
+    DWORD modifierLength;
+    PFUNC_PrintFunction printFunction;
+    va_list va;
+
+    if (!m_logData.Enabled)
+    {
+        return;
+    }
+
+    if (LogLevel < m_logData.LoggingLevel)
+    {
+        // logging is not activated for this level
+        return;
+    }
+
+
+    if (LogLevel == LogLevelTrace &&
+        !IsFlagOn(m_logData.LoggingComponents, LogComponent))
+    {
+        // logging is not activated for this component
+        return;
+    }
+
+    pLevelModifier = NULL;
+    printFunction = NULL;
+    modifierLength = MAX_DWORD;
+
+    switch (LogLevel)
+    {
+    case LogLevelTrace:
+    case LogLevelInfo:
+        pLevelModifier = INFO_LEVEL_MODIFIER;
+        printFunction = printf;
+        modifierLength = sizeof(INFO_LEVEL_MODIFIER);
+        break;
+    case LogLevelWarning:
+        pLevelModifier = WARNING_LEVEL_MODIFIER;
+        printFunction = pwarn;
+        modifierLength = sizeof(WARNING_LEVEL_MODIFIER);
+        break;
+    case LogLevelError:
+        pLevelModifier = ERROR_LEVEL_MODIFIER;
+        printFunction = perror;
+        modifierLength = sizeof(ERROR_LEVEL_MODIFIER);
+        break;
+    }
+    ASSERT(pLevelModifier != NULL);
+    ASSERT(printFunction != NULL);
+    ASSERT(modifierLength != MAX_DWORD);
+
+    // remove length of NULL terminator
+    modifierLength = modifierLength - 1;
+
+    // log buffer will start with level modifier
+    strcpy(logBuffer, pLevelModifier);
+
+    va_start(va, FormatBuffer);
+
+    // resolve formatted buffer
+    vsnprintf(logBuffer + modifierLength, 
+              LOG_BUF_MAX_SIZE - modifierLength, FormatBuffer, va);
+
+    _LogBufferInternal(logBuffer, printFunction);
+}
+
+BOOLEAN
+LogSetState(
+    IN          BOOLEAN         Enable
+    )
+{
+    return _InterlockedExchange8(&m_logData.Enabled, Enable );
+}
+
+LOG_LEVEL
+LogGetLevel(
+    void
+    )
+{
+    return m_logData.LoggingLevel;
+}
+
+LOG_LEVEL
+LogSetLevel(
+    IN          LOG_LEVEL   NewLogLevel
+    )
+{
+    return _InterlockedExchange(&m_logData.LoggingLevel, (DWORD) NewLogLevel);
+}
+
+LOG_COMPONENT
+LogGetTracedComponents(
+    void
+    )
+{
+    return m_logData.LoggingComponents;
+}
+
+LOG_COMPONENT
+LogSetTracedComponents(
+    IN          LOG_COMPONENT   Components
+    )
+{
+    return _InterlockedExchange(&m_logData.LoggingComponents, (DWORD) Components);
+}
+
+static
+void
+_LogBufferInternal(
+    IN_Z        char*                   Buffer,
+    IN          PFUNC_PrintFunction     PrintFunction
+    )
+{
+    INTR_STATE oldState;
+
+    ASSERT(NULL != Buffer);
+
+    LockAcquire(&m_logData.Lock, &oldState);
+
+    PrintFunction(Buffer);
+
+    // also write through the serial port
+    SerialCommWriteBuffer(Buffer);
+
+    LockRelease(&m_logData.Lock, oldState);
+}
diff --git a/src_proiect/HAL9000/src/macros.yasm b/src_proiect/HAL9000/src/macros.yasm
new file mode 100644
index 0000000..d99f5f1
--- /dev/null
+++ b/src_proiect/HAL9000/src/macros.yasm
@@ -0,0 +1,273 @@
+%ifndef _MACROS_ASM_
+%define _MACROS_ASM_
+
+;-----------------------------------------------------------------------;
+; MACRO DEFINITIONS
+;-----------------------------------------------------------------------;
+
+%macro debug_break 0
+    int 0x3
+%endmacro
+
+%macro bochs_break 0
+    xchg bx, bx
+%endmacro
+
+%macro AlignAddressLower    2
+    push    rax
+
+    mov     rax, QWORD ~(%2 - 1)
+    and     %1, rax
+
+    pop     rax
+%endmacro
+
+%macro AlignAddressUpper    2
+    add     %1, %2 - 1
+    AlignAddressLower       %1, %2
+%endmacro
+
+; This should be used only for x64 calls to C functions
+;
+%macro call_func_64    1-5
+; stack will be either aligned to 0x10 or to 0x8
+; bytes after the PUSH
+
+; NOTE: WE NEED THE PUSH BEFORE THE AND
+; TO BE SURE WE DON'T 'DEALLOCATE' ELEMENTS FROM THE
+; STACK
+
+; Example:
+; RSP <- aligned at 0x10
+; We to AND without sub => still aligned to 0x10
+; We then add 0x8 bytes to RSP (which we didn't allocate)
+; This means 8 bytes are lost from the stack
+    push    rbx
+
+    mov     rbx, 0xF
+    and     rbx, rsp
+
+; align stack to 0x10
+    sub     rsp, rbx
+
+%if %0 > 1
+    mov     rcx, %2
+%endif
+
+%if %0 > 2
+    mov     rdx, %3
+%endif
+
+%if %0 > 3
+    mov     r8, %4
+%endif
+
+%if %0 > 4
+    mov     r9, %5
+%endif
+
+    sub     rsp, 0x20
+; the stack must be aligned at 16 bytes here,
+; not after the call
+    call %1
+
+    add     rsp, 0x20
+
+    add     rsp, rbx
+    pop     rbx
+%endmacro
+
+; this should be used only for 32 bit _cdecl calls
+; Usage:
+; callproc $PROC_NAME $ARG0 ... $ARGN
+%macro callproc 1-*
+    %rep %0 - 1
+        %rotate -1
+        push %1
+    %endrep
+
+    %rotate -1
+    call %1
+
+    ; number of arguments - 1 because the first argument
+    ; is the function name
+    sub     esp, (%0 - 1 ) * 4
+%endmacro
+
+%macro check_vmoperation 0
+    jc          .failedNoError
+    jz          .failedError
+    xor         rax,    rax
+    ret
+.failedNoError:
+    mov         rax,    2
+    ret
+.failedError:
+    mov         rax,    1
+    ret
+%endmacro
+
+; according to MSDN x64 Register Usage
+%macro save_volatiles 0
+    push    r12
+    push    r13
+    push    r14
+    push    r15
+
+    push    rdi
+    push    rsi
+    push    rbx
+    push    rbp
+%endmacro
+
+%macro restore_volatiles 0
+    pop     rbp
+    pop     rbx
+    pop     rsi
+    pop     rdi
+
+    pop     r15
+    pop     r14
+    pop     r13
+    pop     r12
+%endmacro
+
+%macro save_proc_state 0
+    ; allocate local variable on stack
+    sub     rsp,                        COMPLETE_PROCESSOR_STATE_size
+
+    ; save guest GPR's
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rax],  Rax
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx],  Rcx
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx],  Rdx
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx],  Rbx
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbp],  Rbp
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rsi],  Rsi
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi],  Rdi
+
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R8],   R8
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R9],   R9
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R10],  R10
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R11],  R11
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R12],  R12
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R13],  R13
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R14],  R14
+    mov     [rsp+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R15],  R15
+
+    mov     rbx, rsp
+
+    AlignAddressUpper   rbx, XSAVE_AREA_REQUIRED_ALIGNMENT
+
+%if INCLUDE_FP_SUPPORT
+    cld
+    lea     rdi, [rbx + XSAVE_AREA.Header]
+    mov     rcx, XSAVE_AREA_HEADER_size / 8
+    xor     eax, eax
+    rep     stosq
+
+    mov     edx, 0xFFFFFFFF
+    mov     eax, edx
+
+    xsave   QWORD [rbx]
+%endif
+
+    ; restore RBX, RCX, RDX and RDI
+    mov     rbx, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx]
+    mov     rcx, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx]
+    mov     rdx, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx]
+    mov     rdi, [rsp + COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi]
+
+%endmacro
+
+;
+; setup_transition_config_16( TRANSITION_CONFIG*, DWORD Gdtr, DWORD StackPA, WORD CodeSelector, WORD DataSelector)
+%macro setup_transition_config_16 5
+    push    eax
+
+    mov     ecx,                                                %1
+
+    mov     eax,                                                %2
+    mov     [ecx + TRANSITION_CONFIG.GdtrPhysicalAddress],      eax
+
+    mov     eax,                                                DWORD %3
+    mov     [ecx + TRANSITION_CONFIG.StackPhysicalAddress],     eax
+
+    mov     ax,                                                 %4
+    mov     [ecx + TRANSITION_CONFIG.CodeSelector],             ax
+
+    mov     ax,                                                 %5
+    mov     [ecx + TRANSITION_CONFIG.DataSelector],             ax
+
+    pop     eax
+%endmacro
+
+;
+; setup_transition_config_32( TRANSITION_CONFIG*, DWORD Gdtr, DWORD StackPA, WORD CodeSelector, WORD DataSelector, DWORD StackVALow, DWORD StackVAHigh)
+%macro setup_transition_config_32 8
+    push    eax
+
+    mov     ecx,                                                %1
+
+    mov     eax,                                                DWORD %2
+    mov     [ecx + TRANSITION_CONFIG.GdtrPhysicalAddress],      eax
+
+    mov     eax,                                                DWORD %3
+    mov     [ecx + TRANSITION_CONFIG.StackPhysicalAddress],     eax
+
+    mov     ax,                                                 WORD %4
+    mov     [ecx + TRANSITION_CONFIG.CodeSelector],             ax
+
+    mov     ax,                                                 WORD %5
+    mov     [ecx + TRANSITION_CONFIG.DataSelector],             ax
+
+    mov     eax,                                                DWORD %6
+    mov     [ecx + TRANSITION_CONFIG.StackVirtualAddress],      eax
+
+    mov     eax,                                                DWORD %7
+    mov     [ecx + TRANSITION_CONFIG.StackVirtualAddress + 4],  eax
+
+    mov     eax,                                                DWORD %8
+    mov     [ecx + TRANSITION_CONFIG.Pml4PhysicalAddress],      eax
+
+    pop     eax
+%endmacro
+
+;
+; setup_transition_config_64( TRANSITION_CONFIG*, DWORD Gdtr, DWORD StackPA, WORD CodeSelector, WORD DataSelector, QWORD StackVA)
+%macro setup_transition_config_64 6
+    push    rax
+
+    mov     rcx,                                                        %1
+
+    mov     [rcx + TRANSITION_CONFIG.GdtrPhysicalAddress],      DWORD   %2
+    mov     [rcx + TRANSITION_CONFIG.StackPhysicalAddress],     DWORD   %3
+    mov     [rcx + TRANSITION_CONFIG.CodeSelector],             WORD    %4
+    mov     [rcx + TRANSITION_CONFIG.DataSelector],             WORD    %5
+
+    mov     rax,                                                        %6
+    mov     [rcx + TRANSITION_CONFIG.StackVirtualAddress],      rax
+
+    pop     rax
+%endmacro
+
+%macro retrieve_config_addresses 0
+    ; retrieve APIC ID
+    mov     eax, CPUID_FEATURE_INFORMATION
+    cpuid
+
+    shr     ebx, 24
+    ; we will now have in bx the CPU's APIC ID
+
+    and     ebx, 0xFF
+
+    ; we multiply ebx by 0x10
+    ; i.e the size of the AP_CONFIG_ENTRY structure size
+    shl     ebx, 4
+
+    mov     ecx, TRAMPOLINE_AP_DESCRIPTOR_ADDRESS               ; ecx <- PSYSTEM_CONFIG
+    lea     edx, [ecx + ebx + SYSTEM_CONFIG_size]               ; edx <- &PSYSTEM_CONFIG->ApEntries[ApicId]
+
+    mov     ebx, ecx
+%endmacro
+
+%endif ; _MACROS_ASM_
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/mdl.c b/src_proiect/HAL9000/src/mdl.c
new file mode 100644
index 0000000..1c8c542
--- /dev/null
+++ b/src_proiect/HAL9000/src/mdl.c
@@ -0,0 +1,195 @@
+#include "HAL9000.h"
+#include "io.h"
+#include "mdl.h"
+#include "mmu.h"
+
+PTR_SUCCESS
+PMDL
+MdlAllocateEx(
+    IN          PVOID               VirtualAddress,
+    IN          DWORD               Length,
+    IN_OPT      PHYSICAL_ADDRESS    Cr3,
+    IN_OPT      PPAGING_LOCK_DATA   PagingData
+    )
+{
+    STATUS status;
+    DWORD offset;
+    PBYTE pAlignedAddress;
+    PMDL pMdl;
+    PHYSICAL_ADDRESS pa;
+    MDL_TRANSLATION_PAIR mdlCurPair;
+    DWORD noOfPairs;
+    DWORD mdlSize;
+    DWORD indexInMdlArray;
+    DWORD alignedSize;
+    DWORD alignmentDifferences;
+    BOOLEAN bKernelMemory;
+
+    LOG_FUNC_START;
+
+    ASSERT( NULL != VirtualAddress);
+    ASSERT( 0 != Length );
+    ASSERT((Cr3 != NULL) ^ (PagingData != NULL));
+
+    LOG_TRACE_MMU("Will allocate MDL for VA: 0x%X of size %u\n", VirtualAddress, Length);
+
+    status = STATUS_SUCCESS;
+    pAlignedAddress = (PBYTE)AlignAddressLower(VirtualAddress, PAGE_SIZE);
+    offset = 0;
+    pMdl = NULL;
+    pa = NULL;
+    memzero(&mdlCurPair, sizeof(MDL_TRANSLATION_PAIR));
+    noOfPairs = 0;
+    mdlSize = 0;
+    alignmentDifferences = AddressOffset(VirtualAddress, PAGE_SIZE );
+    alignedSize = AlignAddressUpper(Length + alignmentDifferences, PAGE_SIZE);
+    bKernelMemory = (PagingData == NULL || PagingData->Data.KernelSpace);
+
+    LOG_TRACE_MMU("Aligned address: 0x%X\n", pAlignedAddress);
+    LOG_TRACE_MMU("Aligned size: %u\n", alignedSize);
+
+    if (bKernelMemory)
+    {
+        // We cannot probe memory user-mode memory (there is absolutely nothing we can do if it is not mapped)
+
+        // we first need to 'probe' the VAs
+        // before determining their physical address (they may not be mapped)
+        MmuProbeMemory(VirtualAddress, Length);
+    }
+
+    mdlCurPair.Address = MmuGetPhysicalAddressEx(VirtualAddress, PagingData, Cr3);
+    if (mdlCurPair.Address == NULL)
+    {
+        ASSERT_INFO(!bKernelMemory,
+                    "Accesses to kernel memory cause that region to be probed, if we probed it, it's certainly mapped!");
+
+        return NULL;
+    }
+
+    ASSERT(mdlCurPair.Address != NULL);
+
+    mdlCurPair.NumberOfBytes = PAGE_SIZE - alignmentDifferences;
+    noOfPairs = 1;
+
+    for(offset = PAGE_SIZE;
+        offset < alignedSize;
+        offset = offset + PAGE_SIZE
+        )
+    {
+        PBYTE pCurAddr = pAlignedAddress + offset;
+
+        // if we're here => VA was mapped to PA
+        pa = MmuGetPhysicalAddressEx(pCurAddr, PagingData, Cr3);
+        ASSERT(NULL != pa);
+
+        LOG_TRACE_MMU("VA 0x%X -> PA 0x%X\n", pCurAddr, pa);
+
+        if ((PBYTE)mdlCurPair.Address + mdlCurPair.NumberOfBytes == pa)
+        {
+            mdlCurPair.NumberOfBytes = mdlCurPair.NumberOfBytes + PAGE_SIZE;
+        }
+        else
+        {
+            noOfPairs = noOfPairs + 1;
+
+            mdlCurPair.Address = pa;
+            mdlCurPair.NumberOfBytes = PAGE_SIZE;
+        }
+    }
+
+    mdlSize = sizeof(MDL) + sizeof(MDL_TRANSLATION_PAIR) * noOfPairs;
+
+    pMdl = ExAllocatePoolWithTag(PoolAllocateZeroMemory, mdlSize, HEAP_MDL_TAG, 0);
+    if (NULL == pMdl)
+    {
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", mdlSize);
+        return NULL;
+    }
+
+    pMdl->ByteCount = Length;
+    pMdl->StartVa = pAlignedAddress;
+    pMdl->ByteOffset = alignmentDifferences;
+
+    indexInMdlArray = 0;
+    memzero(&mdlCurPair, sizeof(MDL_TRANSLATION_PAIR));
+
+    mdlCurPair.Address = MmuGetPhysicalAddressEx(VirtualAddress, PagingData, Cr3);
+    ASSERT(mdlCurPair.Address != NULL);
+    mdlCurPair.NumberOfBytes = PAGE_SIZE - pMdl->ByteOffset;
+
+    for(offset = PAGE_SIZE;
+        offset < alignedSize;
+        offset = offset + PAGE_SIZE
+        )
+    {
+        PBYTE pCurAddr = pAlignedAddress + offset;
+
+        // if we're here => VA was mapped to PA
+        pa = MmuGetPhysicalAddressEx(pCurAddr, PagingData, Cr3);
+        ASSERT(NULL != pa);
+
+        LOG_TRACE_MMU("VA 0x%X -> PA 0x%X\n", pCurAddr, pa);
+
+        if ((PBYTE)mdlCurPair.Address + mdlCurPair.NumberOfBytes == pa)
+        {
+            mdlCurPair.NumberOfBytes = mdlCurPair.NumberOfBytes + PAGE_SIZE;
+        }
+        else
+        {
+            pMdl->Translations[indexInMdlArray].Address = mdlCurPair.Address;
+            pMdl->Translations[indexInMdlArray].NumberOfBytes = mdlCurPair.NumberOfBytes;
+
+            mdlCurPair.Address = pa;
+            mdlCurPair.NumberOfBytes = PAGE_SIZE;
+
+            indexInMdlArray = indexInMdlArray + 1;
+        }
+    }
+
+    pMdl->Translations[indexInMdlArray].Address = mdlCurPair.Address;
+    pMdl->Translations[indexInMdlArray].NumberOfBytes = mdlCurPair.NumberOfBytes;
+    indexInMdlArray = indexInMdlArray + 1;
+    pMdl->NumberOfTranslationPairs = indexInMdlArray;
+
+    ASSERT(indexInMdlArray == noOfPairs);
+
+    LOG_FUNC_END;
+
+    return pMdl;
+}
+
+void
+MdlFree(
+    INOUT       PMDL            Mdl
+    )
+{
+    LOG_FUNC_START;
+
+    ASSERT( NULL != Mdl );
+
+    ExFreePoolWithTag(Mdl, HEAP_MDL_TAG );
+
+    LOG_FUNC_END;
+}
+
+DWORD
+MdlGetNumberOfPairs(
+    IN          PMDL            Mdl
+    )
+{
+    ASSERT( NULL != Mdl );
+
+    return Mdl->NumberOfTranslationPairs;
+}
+
+PTR_SUCCESS
+PMDL_TRANSLATION_PAIR
+MdlGetTranslationPair(
+    IN          PMDL            Mdl,
+    IN          DWORD           Index
+    )
+{
+    ASSERT( NULL != Mdl );
+
+    return ( Index < Mdl->NumberOfTranslationPairs ) ? &Mdl->Translations[Index] : NULL;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/mmu.c b/src_proiect/HAL9000/src/mmu.c
new file mode 100644
index 0000000..9e7938a
--- /dev/null
+++ b/src_proiect/HAL9000/src/mmu.c
@@ -0,0 +1,2082 @@
+#include "HAL9000.h"
+#include "mmu.h"
+#include "int15.h"
+#include "pmm.h"
+#include "vmm.h"
+#include "pte.h"
+#include "display.h"
+#include "synch.h"
+#include "cl_heap.h"
+#include "cpumu.h"
+#include "thread.h"
+#include "pe_parser.h"
+#include "ex_event.h"
+#include "process_internal.h"
+#include "thread_internal.h"
+#include "io.h"
+#include "mdl.h"
+
+#define PAGING_STRUCTURES_BASE_MEMORY                           (128*KB_SIZE)
+
+// this is in hundreds of percentage => 25 == 0.25%
+#define PAGING_STRUCTURES_PERCENTAGE                            25
+
+#define HEAP_NORMAL_BASE_MEMORY                                 (1 * MB_SIZE)
+
+// 100 == 1%
+#define HEAP_NORMAL_PERCENTAGE                                  100
+
+#define HEAP_SPECIAL_BASE_MEMORY                                (128 * KB_SIZE)
+#define HEAP_SPECIAL_PERCENTAGE                                 25
+
+#define TEMP_STACK_SIZE                                         (2*PAGE_SIZE)
+
+#define VA_METADATA_SIZE_FOR_UM_PROCESS                         (5*GB_SIZE)
+#define VA_ALLOCATIONS_START_OFFSET_FROM_IMAGE_BASE             (1*GB_SIZE)
+
+// [0x0000'0000'0000'1000 -> 0x0000'7FFF'FFFF'FFFF] belongs to UM
+// [0xFFFF'8000'0000'0000 -> 0xFFFF'FFFF'FFFF'FFFF] belongs to KM
+#define PML4_OFFSET_OF_KERNEL_STRUCTURES                        (PAGE_SIZE / 2)
+#define PML4_NO_OF_KERNEL_ENTRIES                               (PAGE_SIZE - PML4_OFFSET_OF_KERNEL_STRUCTURES)
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+typedef union _PAGE_FAULT_ERR_CODE
+{
+    struct
+    {
+        DWORD                       Present     :  1;
+        DWORD                       Write       :  1;
+        DWORD                       Usermode    :  1;
+        DWORD                       RsvdBit     :  1;
+        DWORD                       Execution   :  1;
+        DWORD                       Pk          :  1;
+        DWORD                       __Reserved0 : 10;
+        DWORD                       Sgx         :  1;
+        DWORD                       __Reserved1 : 15;
+    };
+    DWORD                           Raw;
+} PAGE_FAULT_ERR_CODE, *PPAGE_FAULT_ERR_CODE;
+STATIC_ASSERT( sizeof(PAGE_FAULT_ERR_CODE) == sizeof(DWORD));
+
+#pragma warning(pop)
+
+#pragma pack(pop)
+
+typedef struct _MMU_ZERO_WORKER_ITEM
+{
+    LIST_ENTRY                      ListEntry;
+
+    PHYSICAL_ADDRESS                PhysicalAddress;
+    DWORD                           NumberOfFrames;
+} MMU_ZERO_WORKER_ITEM, *PMMU_ZERO_WORKER_ITEM;
+
+typedef struct _MMU_ZERO_WORKER_THREAD_CTX
+{
+    PEX_EVENT                       NewPagesEvent;
+
+    PLOCK                           PagesLock;
+    PLIST_ENTRY                     PagesToZeroList;
+} MMU_ZERO_WORKER_THREAD_CTX, *PMMU_ZERO_WORKER_THREAD_CTX;
+
+typedef struct _MMU_ZERO_THREAD_DATA
+{
+    PTHREAD                         WorkerThread;
+
+    EX_EVENT                        NewPagesEvent;
+    LOCK                            PagesLock;
+    LIST_ENTRY                      PagesToZeroList;
+} MMU_ZERO_THREAD_DATA, *PMMU_ZERO_THREAD_DATA;
+
+typedef struct _MMU_HEAP_DATA
+{
+    _Guarded_by_(HeapLock)
+    PHEAP_HEADER                    Heap;
+    LOCK                            HeapLock;
+} MMU_HEAP_DATA, *PMMU_HEAP_DATA;
+
+typedef enum _MMU_HEAP_INDEX
+{
+    MmuHeapIndexNormal      = 0,
+    MmuHeapIndexSpecial     = 1,
+    MmuHeapIndexReserved    = MmuHeapIndexSpecial + 1
+} MMU_HEAP_INDEX;
+
+
+typedef struct _MMU_DATA
+{
+    PAGING_LOCK_DATA                PagingData;
+
+    PE_NT_HEADER_INFO               KernelInfo;
+    PVOID                           TemporaryStackBase;
+    BOOLEAN                         PcidSupportAvailable;
+
+    MMU_ZERO_THREAD_DATA            ZeroThreadData;
+
+    MMU_HEAP_DATA                   Heaps[MmuHeapIndexReserved];
+} MMU_DATA, *PMMU_DATA;
+
+static MMU_DATA m_mmuData;
+
+_No_competing_thread_
+static
+STATUS
+_MmuInitPagingSystem(
+    IN      PVOID                   BaseAddress
+    );
+
+static
+STATUS
+_MmuRetrieveKernelInfoAndValidate(
+    IN      PVOID                   KernelBase,
+    IN      DWORD                   ImageSize,
+    OUT     PPE_NT_HEADER_INFO      KernelInfo
+    );
+
+static
+STATUS
+_MmuRemapStack(
+    IN      PPAGING_DATA            PagingData,
+    IN      PVOID                   NewStackBase,
+    IN      DWORD                   StackSize
+    );
+
+static
+STATUS
+_MmuMapKernelMemory(
+    IN          PPAGING_DATA            PagingData,
+    IN          PHYSICAL_ADDRESS        PhysicalAddress,
+    IN          PPE_NT_HEADER_INFO      KernelInfo
+    );
+
+static
+STATUS
+_MmuMapPeInMemory(
+    IN          PPAGING_DATA            PagingData,
+    IN          PPE_NT_HEADER_INFO      HeaderInfo,
+    IN          PVOID                   AddressToMap
+    );
+
+static
+STATUS
+_MmuReserveAndMapMemory(
+    IN          PPAGING_DATA            PagingData,
+    IN          PVOID                   VirtualAddress,
+    IN          DWORD                   Size,
+    IN          PHYSICAL_ADDRESS        PhysicalAddress,
+    IN          PAGE_RIGHTS             AccessRights
+    );
+
+static
+STATUS
+_MmuInitializeHeap(
+    OUT         PMMU_HEAP_DATA          Heap,
+    IN          DWORD                   HeapBaseSize,
+    IN          WORD                    HeapPercentageSize
+    );
+
+static
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+_MmuAllocateFromPoolWithTag(
+    IN      MMU_HEAP_INDEX          Heap,
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    );
+
+static
+void
+_MmuFreeFromPoolWithTag(
+    IN      MMU_HEAP_INDEX          Heap,
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    );
+
+static
+void
+_MmuRemapDisplay(
+    IN          PPAGING_DATA            PagingData
+    );
+
+static
+STATUS
+_MmuCreatePagingTables(
+    OUT_PTR     PPAGING_LOCK_DATA*            PagingTables
+    );
+
+_No_competing_thread_
+static
+void
+_MmuDestroyPagingTables(
+    _Pre_valid_ _Post_ptr_invalid_
+        PPAGING_LOCK_DATA       PagingTables
+    );
+
+static FUNC_ThreadStart                 _MmuZeroWorkerThreadFunction;
+
+__forceinline
+static
+DWORD
+_MmuCalculateReservedFrames(
+    IN                              DWORD                       BaseSize,
+    IN                              WORD                        HundredsOfPercentage,
+    IN                              QWORD                       AvailableSystemMemory
+    )
+{
+    QWORD sizeInBytes = BaseSize + CalculatePercentage(AvailableSystemMemory, HundredsOfPercentage);
+    QWORD sizeInFrames = AlignAddressUpper(sizeInBytes, 2 * MB_SIZE) / PAGE_SIZE;
+
+    ASSERT(sizeInFrames < MAX_DWORD);
+
+    return (DWORD)sizeInFrames;
+}
+
+_No_competing_thread_
+void
+MmuPreinitSystem(
+    void
+    )
+{
+    memzero(&m_mmuData, sizeof(MMU_DATA));
+
+    RecRwSpinlockInit(0, &m_mmuData.PagingData.Lock);
+
+    InitializeListHead(&m_mmuData.ZeroThreadData.PagesToZeroList);
+    LockInit(&m_mmuData.ZeroThreadData.PagesLock);
+
+    m_mmuData.PcidSupportAvailable = CpuMuIsPcidFeaturePresent();
+
+    PmmPreinitSystem();
+    VmmPreinit();
+}
+
+// We have the following virtual memory layout
+// -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// | 0B        | 0xFFFF'8000'0000'0000 + KernelBase  | + NT.SizeOfImage      | + HighestPA / PAGE_SIZE   | + Highest PA                      | + 1 TB            |  + 4 TB                       |
+// -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// | UNMAPPED  | Kernel Code                         | PMM Allocation Bitmap | Paging structures         | VMM Reservation Area              | VMM Bitmap Area   | Future virtual reservations   |
+// -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+// |           |                    VA2PA works only for this VA region                                  |                                                                                       |
+// -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
+_No_competing_thread_
+STATUS
+MmuInitSystem(
+    IN          PVOID                   KernelBaseAddress,
+    IN          DWORD                   KernelSize,
+    IN          PHYSICAL_ADDRESS        MemoryEntries,
+    IN          DWORD                   NumberOfMemoryEntries
+    )
+{
+    STATUS status;
+    PINT15_MEMORY_MAP_ENTRY pMemoryMap;
+    PBYTE pPagingStructuresAddrBase;
+    PBYTE pmmBaseAddress;
+    PBYTE pVmmAddressBase;
+    DWORD pmmSizeRequired;
+    DWORD alignedKernelSize;
+    PBYTE pNewStackTop;
+
+    if (NULL == KernelBaseAddress)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (0 == KernelSize)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == NumberOfMemoryEntries)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    status = STATUS_SUCCESS;
+    pMemoryMap = (PINT15_MEMORY_MAP_ENTRY) PA2VA(MemoryEntries);
+    pPagingStructuresAddrBase = NULL;
+    pVmmAddressBase = NULL;
+    pmmBaseAddress = (PBYTE) KernelBaseAddress + KernelSize;
+    pmmSizeRequired = 0;
+    alignedKernelSize = 0;
+    pNewStackTop = NULL;
+
+    status = ExEventInit(&m_mmuData.ZeroThreadData.NewPagesEvent,
+                         ExEventTypeNotification,
+                         FALSE
+                         );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ExEventInit", status );
+        return status;
+    }
+    LOGL("ExEventInit succeeded\n");
+
+    status = _MmuRetrieveKernelInfoAndValidate(KernelBaseAddress,
+                                               KernelSize,
+                                               &m_mmuData.KernelInfo
+                                               );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuRetrieveKernelInfoAndValidate", status );
+        return status;
+    }
+    LOGL("_MmuRetrieveKernelInfoAndValidate succeeded\n");
+
+    alignedKernelSize = AlignAddressUpper(m_mmuData.KernelInfo.Size, PAGE_SIZE);
+    pNewStackTop = PtrOffset(m_mmuData.KernelInfo.ImageBase,
+                             alignedKernelSize + TEMP_STACK_SIZE + STACK_GUARD_SIZE);
+    pmmBaseAddress = pNewStackTop;
+    m_mmuData.TemporaryStackBase = pNewStackTop - TEMP_STACK_SIZE;
+
+    // change to new stack
+    LOGL("Will change to a temporary stack at 0x%X\n", pNewStackTop );
+    CpuMuChangeStack(pNewStackTop);
+
+    status = PmmInitSystem(pmmBaseAddress,
+                           pMemoryMap,
+                           NumberOfMemoryEntries,
+                           &pmmSizeRequired
+                           );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PmmInitSystem", status );
+        return status;
+    }
+
+    LOG("PmmInitSystem suceeded and needs %u bytes\n", pmmSizeRequired);
+    pPagingStructuresAddrBase = (PVOID) AlignAddressUpper( pmmBaseAddress + pmmSizeRequired, PAGE_SIZE );
+
+    status = _MmuInitPagingSystem(pPagingStructuresAddrBase);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuInitInternal", status);
+        return status;
+    }
+
+    LOG("_MmuInitPagingSystem succeeded\n");
+
+    // The start VA of the VMM structures will be placed after we reserved as many bytes for the paging structures
+    // as there is the highest physical address. This space will be shared by all the processes in the system and
+    // they'll ALL need to have virtual addresses on which the VA2PA and PA2VA macros work
+    pVmmAddressBase = (PVOID) PtrDiff(PA2VA(PmmGetHighestPhysicalMemoryAddressAvailable()), PAGE_SIZE);
+
+    status = VmmInit(pVmmAddressBase);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("VmmInit", status);
+        return status;
+    }
+
+    LOG("VmmInit suceeded\n");
+
+    // reserve and map the first page used by the
+    // virtual memory manager
+    status = _MmuReserveAndMapMemory(&m_mmuData.PagingData.Data,
+                                     pVmmAddressBase,
+                                     PAGE_SIZE,
+                                     VA2PA(pVmmAddressBase),
+                                     PAGE_RIGHTS_READWRITE
+                                     );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuReserveAndMapMemory", status);
+        return status;
+    }
+
+    // reserve and map the allocation bitmap used by the
+    // physical memory manager
+    status = _MmuReserveAndMapMemory(&m_mmuData.PagingData.Data,
+                                     pmmBaseAddress,
+                                     pmmSizeRequired,
+                                     VA2PA(pmmBaseAddress),
+                                     PAGE_RIGHTS_READWRITE
+                                     );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuReserveAndMapMemory", status);
+        return status;
+    }
+
+    // maps the kernel to memory
+    status = _MmuMapKernelMemory(&m_mmuData.PagingData.Data,
+                                 VA2PA(m_mmuData.KernelInfo.ImageBase),
+                                 &m_mmuData.KernelInfo);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuMapRequiredMemory", status);
+        return status;
+    }
+
+    LOG("_MmuMapKernelMemory suceeded\n");
+
+    // Switch to a temporary stack (which is mapped) until we can dynamically allocate
+    // memory from the heap
+    status = _MmuRemapStack(&m_mmuData.PagingData.Data,
+                            m_mmuData.TemporaryStackBase,
+                            TEMP_STACK_SIZE
+                            );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuRemapStack", status);
+        return status;
+    }
+    LOGL("_MmuRemapStack succeeded\n");
+
+    _MmuRemapDisplay(&m_mmuData.PagingData.Data);
+
+    LOG("Will change to new paging structures\n");
+    // #PF's are treatable only after we switch to the new CR3
+    // and we initialize the reservation system
+
+    // We can't use the VmmChangeCr3 function because that functions expects a PCID
+    // and an invalidate parameter which we currently don't until we spawn the system
+    // process
+    __writecr3(m_mmuData.PagingData.Data.BasePhysicalAddress);
+    LOG("Changed to new cr3\n");
+    VmmInitReservationSystem();
+
+    // The heap from which all the kernel allocations come from
+    status = _MmuInitializeHeap(&m_mmuData.Heaps[MmuHeapIndexNormal],
+                                HEAP_NORMAL_BASE_MEMORY,
+                                HEAP_NORMAL_PERCENTAGE
+                                );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuInitializeHeap", status );
+        return status;
+    }
+    LOG("_MmuInitializeHeap succeeded for normal heap\n");
+
+    // Currently the special heap is only used by the worker thread responsible
+    // for zeroing each physical frame of memory after it was released
+    /// TODO: investigate why we need this, as far as I can remember we had some sort of
+    /// deadlock if we tried to allocate heap memory in the function responsible for freeing
+    /// the physical frames of memory
+    status = _MmuInitializeHeap(&m_mmuData.Heaps[MmuHeapIndexSpecial],
+                                HEAP_SPECIAL_BASE_MEMORY,
+                                HEAP_SPECIAL_PERCENTAGE
+                                );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuInitializeHeap", status);
+        return status;
+    }
+    LOG("_MmuInitializeHeap succeeded for special heap\n");
+
+    return status;
+}
+
+_No_competing_thread_
+void
+MmuDiscardIdentityMappings(
+    void
+    )
+{
+    PVOID pIdentityMapped = VA2PA(m_mmuData.KernelInfo.ImageBase);
+    PVOID tempStack = m_mmuData.TemporaryStackBase;
+
+    ASSERT( NULL != tempStack );
+
+    // we must not release the physical pages
+    MmuUnmapSystemMemory(pIdentityMapped, m_mmuData.KernelInfo.Size);
+
+    m_mmuData.TemporaryStackBase = NULL;
+
+    MmuUnmapMemoryEx(tempStack, TEMP_STACK_SIZE, TRUE, NULL );
+}
+
+STATUS
+MmuInitThreadingSystem(
+    void
+    )
+{
+    STATUS status;
+    PTHREAD pThread;
+    PMMU_ZERO_WORKER_THREAD_CTX pCtx;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pThread = NULL;
+    pCtx = NULL;
+
+    pCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(MMU_ZERO_WORKER_THREAD_CTX), HEAP_MMU_TAG, 0 );
+    if (NULL == pCtx)
+    {
+        LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(MMU_ZERO_WORKER_THREAD_CTX));
+        return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+    }
+    pCtx->NewPagesEvent = &m_mmuData.ZeroThreadData.NewPagesEvent;
+    pCtx->PagesToZeroList = &m_mmuData.ZeroThreadData.PagesToZeroList;
+    pCtx->PagesLock = &m_mmuData.ZeroThreadData.PagesLock;
+
+    __try
+    {
+        status = ThreadCreate("Page Zeroer Thread",
+                              ThreadPriorityLowest,
+                              _MmuZeroWorkerThreadFunction,
+                              pCtx,
+                              &pThread
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("ThreadCreate", status);
+            __leave;
+        }
+
+        pCtx = NULL;
+        m_mmuData.ZeroThreadData.WorkerThread = pThread;
+    }
+    __finally
+    {
+        if (NULL != pCtx)
+        {
+            ExFreePoolWithTag(pCtx, HEAP_MMU_TAG);
+            pCtx = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+QWORD
+MmuGetTotalSystemMemory(
+    void
+    )
+{
+    return PmmGetTotalSystemMemory();
+}
+
+PHYSICAL_ADDRESS
+MmuGetHighestPhysicalMemoryAddressPresent(
+    void
+    )
+{
+    return PmmGetHighestPhysicalMemoryAddressPresent();
+}
+
+PTR_SUCCESS
+PVOID
+MmuMapMemoryEx(
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    )
+{
+    QWORD alignedSize;
+    PVOID pCurPointer;
+    PHYSICAL_ADDRESS alignedPhysicalAddress;
+    DWORD alignmentDifferences;
+    PPAGING_LOCK_DATA pPagingData;
+
+    INTR_STATE oldState;
+
+    ASSERT(Size != 0);
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_MMU("Physical address: 0x%X\n", PhysicalAddress);
+    LOG_TRACE_MMU("Size: 0x%x\n", Size);
+
+    // get page-aligned PA and size
+    // Unfortunately we cannot consider the PA 0 invalid because we may need to map it at some point (ACPI)
+    alignedPhysicalAddress = (PHYSICAL_ADDRESS) AlignAddressLower(PhysicalAddress, PAGE_SIZE);
+
+    alignmentDifferences = (DWORD) AddressOffset(PhysicalAddress, PAGE_SIZE);
+
+    alignedSize = AlignAddressUpper(Size + alignmentDifferences, PAGE_SIZE);
+    ASSERT(alignedPhysicalAddress < (PHYSICAL_ADDRESS) PtrDiff(MmuGetHighestPhysicalMemoryAddressPresent(),alignedSize));
+
+    pPagingData = (PagingData == NULL) ? &m_mmuData.PagingData : PagingData;
+
+    RecRwSpinlockAcquireExclusive(&pPagingData->Lock, &oldState);
+    pCurPointer = VmmMapMemoryEx(&pPagingData->Data,
+                                alignedPhysicalAddress,
+                                alignedSize,
+                                PageRights,
+                                Invalidate,
+                                Uncacheable
+                                );
+    RecRwSpinlockReleaseExclusive(&pPagingData->Lock, oldState);
+    if (NULL == pCurPointer)
+    {
+        LOG_ERROR("VmMapMemoryEx failed!\n");
+        return NULL;
+    }
+
+    LOG_FUNC_END;
+
+    return PtrOffset(pCurPointer,alignmentDifferences);
+}
+
+void
+MmuMapMemoryInternal(
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      PVOID                   VirtualAddress,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    )
+{
+    INTR_STATE oldState;
+    PPAGING_LOCK_DATA pPagingData;
+
+    ASSERT( 0 != Size );
+    ASSERT( IsAddressAligned(Size, PAGE_SIZE));
+
+    ASSERT( NULL != VirtualAddress );
+    ASSERT( IsAddressAligned(VirtualAddress, PAGE_SIZE));
+
+    pPagingData = (PagingData == NULL) ? &m_mmuData.PagingData : PagingData;
+
+    RecRwSpinlockAcquireExclusive(&pPagingData->Lock, &oldState );
+    VmmMapMemoryInternal(&pPagingData->Data,
+                         PhysicalAddress,
+                         Size,
+                         VirtualAddress,
+                         PageRights,
+                         Invalidate,
+                         Uncacheable
+                         );
+    RecRwSpinlockReleaseExclusive(&pPagingData->Lock, oldState);
+}
+
+void
+MmuUnmapMemoryEx(
+    IN      PVOID                   VirtualAddress,
+    IN      QWORD                   Size,
+    IN      BOOLEAN                 ReleaseMemory,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    )
+{
+    QWORD alignedVirtualAddress;
+    DWORD alignmentDifferences;
+    DWORD alignedSize;
+    PML4 cr3;
+    INTR_STATE oldState;
+    PPAGING_LOCK_DATA pPagingData;
+
+    ASSERT(VirtualAddress != NULL);
+    ASSERT(Size != 0);
+
+    pPagingData = (PagingData == NULL) ? &m_mmuData.PagingData : PagingData;
+
+    alignedVirtualAddress = AlignAddressLower(VirtualAddress, PAGE_SIZE);
+    alignmentDifferences = (DWORD)((QWORD)VirtualAddress - alignedVirtualAddress);
+    alignedSize = AlignAddressUpper(Size + alignmentDifferences, PAGE_SIZE);
+
+    RecRwSpinlockAcquireExclusive(&pPagingData->Lock, &oldState);
+    cr3.Raw = (QWORD) pPagingData->Data.BasePhysicalAddress;
+    VmmUnmapMemoryEx(cr3,
+                    (PVOID) alignedVirtualAddress,
+                     alignedSize,
+                     ReleaseMemory
+                    );
+    RecRwSpinlockReleaseExclusive(&pPagingData->Lock, oldState);
+}
+
+void
+MmuReleaseMemory(
+    IN          PHYSICAL_ADDRESS        PhysicalAddr,
+    IN          DWORD                   NoOfFrames
+    )
+{
+    BOOLEAN bListEmpty;
+    INTR_STATE oldState;
+    PMMU_ZERO_WORKER_ITEM pItem;
+
+    LOG_FUNC_START_CPU;
+
+    ASSERT( IsAddressAligned(PhysicalAddr, PAGE_SIZE ) );
+    ASSERT( 0 != NoOfFrames );
+
+    bListEmpty = FALSE;
+    pItem = NULL;
+
+    pItem = _MmuAllocateFromPoolWithTag(MmuHeapIndexSpecial,
+                                        PoolAllocateZeroMemory,
+                                        sizeof(MMU_ZERO_WORKER_ITEM),
+                                        HEAP_MMU_TAG,
+                                        0
+                                        );
+    ASSERT( NULL != pItem );
+
+    pItem->PhysicalAddress = PhysicalAddr;
+    pItem->NumberOfFrames = NoOfFrames;
+
+    LockAcquire(&m_mmuData.ZeroThreadData.PagesLock, &oldState );
+    InsertTailList(&m_mmuData.ZeroThreadData.PagesToZeroList, &pItem->ListEntry );
+    LockRelease(&m_mmuData.ZeroThreadData.PagesLock, oldState);
+    pItem = NULL;
+
+    LOG_TRACE_MMU("About to signal worker thread\n");
+    ExEventSignal(&m_mmuData.ZeroThreadData.NewPagesEvent);
+
+    LOG_FUNC_END_CPU;
+}
+
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+MmuGetPhysicalAddress(
+    IN      PVOID                   VirtualAddress
+    )
+{
+    return MmuGetPhysicalAddressEx(VirtualAddress,
+                                   NULL,
+                                   __readcr3());
+}
+
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+MmuGetPhysicalAddressEx(
+    IN      PVOID                   VirtualAddress,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData,
+    IN_OPT  PHYSICAL_ADDRESS        Cr3Base
+    )
+{
+    PML4 cr3;
+    INTR_STATE oldState;
+    PHYSICAL_ADDRESS pa;
+    PVOID alignedAddress;
+    DWORD alignmentDifference;
+
+    if (NULL == VirtualAddress)
+    {
+        return NULL;
+    }
+
+    ASSERT((PagingData != NULL) ^ (Cr3Base != NULL));
+
+    oldState = 0;
+    alignedAddress = (PVOID) AlignAddressLower(VirtualAddress,PAGE_SIZE);
+    alignmentDifference = AddressOffset(VirtualAddress, PAGE_SIZE );
+
+    if (PagingData != NULL)
+    {
+        RecRwSpinlockAcquireShared(&PagingData->Lock, &oldState);
+    }
+
+    cr3.Raw = (QWORD) ((PagingData != NULL ) ? PagingData->Data.BasePhysicalAddress : Cr3Base);
+    pa = VmmGetPhysicalAddress(cr3,
+                               alignedAddress
+                               );
+
+    if (PagingData != NULL)
+    {
+        RecRwSpinlockReleaseShared(&PagingData->Lock, oldState);
+    }
+
+    return (PBYTE) pa + alignmentDifference;
+}
+
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+MmuAllocatePoolWithTag(
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    )
+{
+    return _MmuAllocateFromPoolWithTag(MmuHeapIndexNormal,
+                                       Flags,
+                                       AllocationSize,
+                                       Tag,
+                                       AllocationAlignment
+                                       );
+}
+
+void
+MmuFreePoolWithTag(
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    )
+{
+    _MmuFreeFromPoolWithTag(MmuHeapIndexNormal,
+                            MemoryAddress,
+                            Tag
+                            );
+}
+
+void
+MmuProbeMemory(
+    IN      PVOID                   Buffer,
+    IN      DWORD                   NumberOfBytes
+    )
+{
+    PBYTE pBuffer;
+    DWORD offset;
+    DWORD alignedSize;
+    DWORD alignmentDifferences;
+
+    ASSERT( NULL != Buffer );
+    ASSERT( 0 != NumberOfBytes );
+
+    pBuffer = (PBYTE) AlignAddressLower(Buffer, PAGE_SIZE);
+    alignmentDifferences = AddressOffset(Buffer, PAGE_SIZE);
+    alignedSize = AlignAddressUpper(NumberOfBytes + alignmentDifferences, PAGE_SIZE);
+
+    for(offset = 0;
+        offset < alignedSize;
+        offset = offset + PAGE_SIZE
+        )
+    {
+        BYTE temp = *(pBuffer + offset);temp;
+    }
+}
+
+BOOLEAN
+MmuSolvePageFault(
+    IN      PVOID                   FaultingAddress,
+    IN      DWORD                   ErrorCode
+    )
+{
+    PAGE_RIGHTS rightsRequested;
+    PAGE_FAULT_ERR_CODE pfErrCode;
+
+    ASSERT( INTR_OFF == CpuIntrGetState() );
+
+    pfErrCode.Raw = ErrorCode;
+    rightsRequested = PAGE_RIGHTS_READ;
+
+    rightsRequested |= ( pfErrCode.Write ? PAGE_RIGHTS_WRITE : 0 );
+    rightsRequested |= ( pfErrCode.Execution ? PAGE_RIGHTS_EXECUTE : 0 );
+
+    return VmmSolvePageFault(FaultingAddress,
+                             rightsRequested,
+                             pfErrCode.Usermode ? GetCurrentThread()->Process->PagingData : &m_mmuData.PagingData
+                             );
+}
+
+STATUS
+MmuLoadPe(
+    IN      PPE_NT_HEADER_INFO      NtHeader,
+    IN      PPAGING_LOCK_DATA       PagingData
+    )
+{
+    STATUS status;
+    INTR_STATE oldState;
+
+    if (NtHeader == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (PagingData == NULL)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    status = STATUS_SUCCESS;
+
+    RecRwSpinlockAcquireExclusive(&PagingData->Lock, &oldState);
+    status = _MmuMapPeInMemory(&PagingData->Data,
+                               NtHeader,
+                               NtHeader->Preferred.ImageBase);
+    RecRwSpinlockReleaseExclusive(&PagingData->Lock, oldState);
+
+    return status;
+}
+
+STATUS
+MmuCreateAddressSpaceForProcess(
+    INOUT   PPROCESS                Process
+    )
+{
+    STATUS status;
+
+    ASSERT(Process != NULL);
+    ASSERT(!ProcessIsSystem(Process));
+
+    status = STATUS_SUCCESS;
+
+    // init will NULL so we can call the destroy function in case of failure
+    Process->PagingData = NULL;
+    Process->VaSpace = NULL;
+
+    __try
+    {
+        // Initialize the paging structures
+        // The kernel portion of the tables will be identical, only the UM part will differ
+        status = _MmuCreatePagingTables(&Process->PagingData);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_MmuCreatePagingTables", status);
+            __leave;
+        }
+
+        LOG_TRACE_MMU("Successfully created paging tables for process [%s]\n", ProcessGetName(Process));
+
+        // Create the VMM management structures (VMM_RESERVATION_SPACE) to describe the processes
+        // virtual memory allocations
+        status = VmmCreateVirtualAddressSpace(&Process->VaSpace,
+                                              VA_METADATA_SIZE_FOR_UM_PROCESS,
+                                              PtrOffset(Process->HeaderInfo->Preferred.ImageBase, VA_ALLOCATIONS_START_OFFSET_FROM_IMAGE_BASE));
+        if(!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("VmmCreateVirtualAddressSpace", status);
+            __leave;
+        }
+
+        LOG_TRACE_MMU("Successfully initialized VA space for process [%s]\n", ProcessGetName(Process));
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            MmuDestroyAddressSpaceForProcess(Process);
+        }
+    }
+
+    return status;
+}
+
+void
+MmuDestroyAddressSpaceForProcess(
+    INOUT   PPROCESS                Process
+    )
+{
+    ASSERT(Process != NULL);
+    ASSERT(!ProcessIsSystem(Process));
+
+    if (Process->VaSpace != NULL)
+    {
+        VmmDestroyVirtualAddressSpace(Process->VaSpace);
+        Process->VaSpace = NULL;
+    }
+
+    if (Process->PagingData != NULL)
+    {
+        // NOTE: from what I've realized nothing bad can happen if an interrupt
+        // occurs while we change our paging tables to those of another process
+        // this change does not modify the current's thread owner process or its
+        // paging structures so the original paging structures will be used in the
+        // interrupt handlers
+
+        // invalidate all PCID mappings => new processes can reuse
+        // PCID
+        ProcessActivatePagingTables(Process, TRUE);
+
+        // restore previous paging table
+        ProcessActivatePagingTables(GetCurrentThread()->Process, !m_mmuData.PcidSupportAvailable);
+
+        _MmuDestroyPagingTables(Process->PagingData);
+        Process->PagingData = NULL;
+    }
+}
+
+_No_competing_thread_
+void
+MmuInitAddressSpaceForSystemProcess(
+    void
+    )
+{
+    PPROCESS pProcess;
+
+    pProcess = ProcessRetrieveSystemProcess();
+
+    ASSERT(pProcess != NULL);
+    ASSERT(ProcessIsSystem(pProcess));
+
+    // The system process is special, we will not allocate paging data or a VA space
+    // because we already have one
+    pProcess->PagingData = &m_mmuData.PagingData;
+    pProcess->VaSpace = VmmRetrieveReservationSpaceForSystemProcess();
+
+    /// TODO: I have no idea why the PE_NT_HEADER_INFO is allocated dynamically
+    /// Nothing bad happens, I just don't know if we should keep this
+    memcpy(pProcess->HeaderInfo, &m_mmuData.KernelInfo, sizeof(PE_NT_HEADER_INFO));
+
+    MmuActivateProcessIds();
+}
+
+void
+MmuActivateProcessIds(
+    void
+    )
+{
+    if (m_mmuData.PcidSupportAvailable)
+    {
+        __writecr4(__readcr4() | CR4_PCIDE);
+    }
+
+    MmuChangeProcessSpace(ProcessRetrieveSystemProcess());
+
+    if (m_mmuData.PcidSupportAvailable)
+    {
+        LOGL("Successfully activated process identifiers!\n");
+    }
+    else
+    {
+        LOGL("This CPU doesn't have support for PCIDs, either an AMD or an old Intel!!!\n");
+    }
+}
+
+void
+MmuChangeProcessSpace(
+    IN          PPROCESS            Process
+    )
+{
+    ASSERT(Process != NULL);
+
+    ProcessActivatePagingTables(Process, !m_mmuData.PcidSupportAvailable);
+}
+
+PTR_SUCCESS
+PVOID
+MmuAllocStack(
+    IN          DWORD               StackSize,
+    IN          BOOLEAN             ProtectStack,
+    IN          BOOLEAN             LazyMap,
+    IN_OPT      PPROCESS            Process
+    )
+{
+    PBYTE pStackBase;
+    PBYTE pCommitedStackBase;
+    DWORD totalAllocationSize;
+    DWORD stackGuardSize;
+    VMM_ALLOC_TYPE allocTypeCommit;
+    PPAGING_LOCK_DATA pPagingData;
+    PVMM_RESERVATION_SPACE pVaSpace;
+
+    ASSERT( IsAddressAligned( StackSize, PAGE_SIZE ));
+
+    /// TODO: could also add upper protection for the stack (should not happen on normal execution because
+    /// the stack grows downwards, but it may happen when the stack contents are manipulated by our functions
+    /// such as GSConvertCookiesForNewStack, _ThreadSetupInitialState or _ThreadSetupMainThreadUserStack
+
+    // if we want to protect the stack we'll allocate an additional safeguard PAGE
+    stackGuardSize = ProtectStack ? STACK_GUARD_SIZE : 0;
+    totalAllocationSize = StackSize + stackGuardSize;
+    allocTypeCommit = VMM_ALLOC_TYPE_COMMIT;
+    allocTypeCommit |= (LazyMap ? 0 : VMM_ALLOC_TYPE_NOT_LAZY);
+    pPagingData = (Process == NULL) ? &m_mmuData.PagingData : Process->PagingData;
+    pVaSpace = (Process == NULL) ? NULL : Process->VaSpace;
+
+    // Reserve the StackSize requested + the size of the guard (if any)
+    pStackBase = VmmAllocRegionEx(NULL,
+                                  totalAllocationSize,
+                                  VMM_ALLOC_TYPE_RESERVE,
+                                  PAGE_RIGHTS_READWRITE,
+                                  FALSE,
+                                  NULL,
+                                  pVaSpace,
+                                  pPagingData,
+                                  NULL
+                                  );
+    if (NULL == pStackBase)
+    {
+        LOG_ERROR("VmmAllocRegion failed!\n");
+        return NULL;
+    }
+
+    LOG_TRACE_COMP(LogComponentGeneric | LogComponentThread,
+        "Stack Base: 0x%X\n", pStackBase );
+    LOG_TRACE_COMP(LogComponentGeneric | LogComponentThread,
+        "Total stack size (including guard region): 0x%x\n", totalAllocationSize );
+
+    // commit the memory only after the stack guard
+    // This way we'll have STACK_GUARD_SIZE bytes unmapped and uncommitted after the
+    // stack is depleted and we'll easily detect a stack overflow
+    pCommitedStackBase = VmmAllocRegionEx(pStackBase + stackGuardSize,
+                                          StackSize,
+                                          allocTypeCommit,
+                                          PAGE_RIGHTS_READWRITE,
+                                          FALSE,
+                                          NULL,
+                                          pVaSpace,
+                                          pPagingData,
+                                          NULL
+                                          );
+    if (NULL == pCommitedStackBase)
+    {
+        // this is weird
+        // and should never happen
+        LOG_ERROR("VmmAllocRegion didn't manage to commit previously reserved memory!\n");
+        return NULL;
+    }
+
+    return (PVOID) (pStackBase + totalAllocationSize);
+}
+
+void
+MmuFreeStack(
+    IN          PVOID       Stack,
+    IN_OPT      PPROCESS    Process
+    )
+{
+    PPAGING_LOCK_DATA pPagingData;
+    PVMM_RESERVATION_SPACE pVaSpace;
+
+    ASSERT(Stack != NULL);
+
+    pPagingData = (Process == NULL) ? &m_mmuData.PagingData : Process->PagingData;
+    pVaSpace = (Process == NULL) ? NULL : Process->VaSpace;
+
+    VmmFreeRegionEx(Stack,
+                    0,
+                    VMM_FREE_TYPE_RELEASE,
+                    TRUE,
+                    pVaSpace,
+                    pPagingData
+                    );
+}
+
+STATUS
+MmuIsBufferValid(
+    IN          PVOID               Buffer,
+    IN          QWORD               BufferSize,
+    IN          PAGE_RIGHTS         RightsRequested,
+    IN          PPROCESS            Process
+    )
+{
+    if (Buffer == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (BufferSize == 0)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (Process == NULL)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    // This is a temporary hack, we should also check the access rights, however HAL9000 currently does not support
+    // these checks in case the buffer is inside the binary
+    if (Process->HeaderInfo->Preferred.ImageBase <= Buffer
+        && Buffer < (PVOID)PtrOffset(Process->HeaderInfo->Preferred.ImageBase, Process->HeaderInfo->Size))
+    {
+        return STATUS_SUCCESS;
+    }
+
+    return VmmIsBufferValid(Buffer,
+                            BufferSize,
+                            RightsRequested,
+                            Process->VaSpace,
+                            Process->PagingData->Data.KernelSpace);
+}
+
+STATUS
+MmuGetSystemVirtualAddressForUserBuffer(
+    IN          PVOID               UserAddress,
+    IN          QWORD               Size,
+    IN          PAGE_RIGHTS         PageRights,
+    IN          PPROCESS            Process,
+    OUT         PVOID*              KernelAddress
+    )
+{
+    STATUS status;
+    PMDL pMdl;
+    PVOID pKernelAddress;
+
+    if (UserAddress == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (Size == 0)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (Process == NULL)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (KernelAddress == NULL)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    status = STATUS_SUCCESS;
+    pKernelAddress = NULL;
+    ASSERT(Size <= MAX_DWORD);
+
+    pMdl = NULL;
+
+    __try
+    {
+        pMdl = MdlAllocateEx(UserAddress,
+                             (DWORD)Size,
+                             NULL,
+                             Process->PagingData);
+        if (pMdl == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("MdlAllocateEx", Size);
+            status = STATUS_UNSUCCESSFUL;
+            __leave;
+        }
+
+        pKernelAddress = VmmAllocRegionEx(NULL,
+                                          Size,
+                                          VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_NOT_LAZY,
+                                          PageRights,
+                                          FALSE,
+                                          NULL,
+                                          NULL,
+                                          NULL,
+                                          pMdl);
+        if (pKernelAddress == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("VmmAllocRegionEx", Size);
+            status = STATUS_MEMORY_CANNOT_BE_COMMITED;
+            __leave;
+        }
+
+    }
+    __finally
+    {
+        // We need to free the MDL no matter what (success or failure)
+        if (pMdl != NULL)
+        {
+            MdlFree(pMdl);
+            pMdl = NULL;
+        }
+
+        if (SUCCEEDED(status))
+        {
+            // The UserAddress may not have been page aligned - re-offset it
+            *KernelAddress = PtrOffset(pKernelAddress, AddressOffset(UserAddress, PAGE_SIZE));
+        }
+    }
+
+    return status;
+}
+
+void
+MmuFreeSystemVirtualAddressForUserBuffer(
+    IN          PVOID               KernelAddress
+    )
+{
+    ASSERT(KernelAddress != NULL);
+
+    VmmFreeRegionEx(KernelAddress,
+                    0,
+                    VMM_FREE_TYPE_RELEASE,
+                    FALSE,
+                    NULL,
+                    NULL);
+}
+
+static
+STATUS
+_MmuCreatePagingTables(
+    OUT_PTR     PPAGING_LOCK_DATA*            PagingTables
+    )
+{
+    DWORD framesForPagingStructures;
+    STATUS status;
+    PHYSICAL_ADDRESS basePa;
+    INTR_STATE oldState;
+    PPAGING_LOCK_DATA pPagingData;
+
+    ASSERT(NULL != PagingTables);
+
+    status = STATUS_SUCCESS;
+    basePa = NULL;
+
+    pPagingData = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                        sizeof(PAGING_LOCK_DATA),
+                                        HEAP_PROCESS_TAG,
+                                        0);
+    if (pPagingData == NULL)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", status);
+        return STATUS_INSUFFICIENT_MEMORY;
+    }
+
+    RecRwSpinlockInit(0, &pPagingData->Lock);
+
+    // calculate size of paging structure
+    framesForPagingStructures = _MmuCalculateReservedFrames(PAGING_STRUCTURES_BASE_MEMORY,
+                                                            PAGING_STRUCTURES_PERCENTAGE,
+                                                            PmmGetTotalSystemMemory()
+                                                            );
+
+    LOG_TRACE_MMU("Frames reserved for paging structures 0x%x\n", framesForPagingStructures);
+
+    __try
+    {
+        basePa = PmmReserveMemory(framesForPagingStructures);
+        if (NULL == basePa)
+        {
+            status = STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE;
+            LOG_FUNC_ERROR("MmuRequestMemoryEx", status);
+            __leave;
+        }
+
+        RecRwSpinlockAcquireExclusive(&m_mmuData.PagingData.Lock, &oldState);
+        status = VmmSetupPageTables(&m_mmuData.PagingData.Data,
+                                    &pPagingData->Data,
+                                    basePa,
+                                    framesForPagingStructures,
+                                    FALSE
+        );
+        RecRwSpinlockReleaseExclusive(&m_mmuData.PagingData.Lock, oldState);
+
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("VmmSetupPageTables", status);
+            __leave;
+        }
+
+        LOG_TRACE_MMU("Will copy kernel PML4 table to new page tables!\n");
+
+        /// TODO: remove this hardcoded value and replace it with the virtual kernel base divided by 512GB (size of
+        /// a PML4 entry)
+        memcpy((PVOID)PA2VA(PtrOffset(pPagingData->Data.BasePhysicalAddress, PML4_OFFSET_OF_KERNEL_STRUCTURES)),
+               (PVOID)PA2VA(PtrOffset(m_mmuData.PagingData.Data.BasePhysicalAddress, PML4_OFFSET_OF_KERNEL_STRUCTURES)),
+               PML4_NO_OF_KERNEL_ENTRIES);
+
+        *PagingTables = pPagingData;
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (basePa != NULL)
+            {
+                PmmReleaseMemory(basePa, framesForPagingStructures);
+                basePa = NULL;
+            }
+
+            if (pPagingData != NULL)
+            {
+                ExFreePoolWithTag(pPagingData, HEAP_PROCESS_TAG);
+                pPagingData = NULL;
+            }
+        }
+    }
+
+    return status;
+}
+
+_No_competing_thread_
+static
+void
+_MmuDestroyPagingTables(
+    _Pre_valid_ _Post_ptr_invalid_
+        PPAGING_LOCK_DATA       PagingTables
+    )
+{
+    ASSERT(PagingTables != NULL);
+
+    // When we unmap the paging structures we also release the physical frames reserved
+    MmuUnmapMemoryEx((PVOID)PA2VA(PagingTables->Data.BasePhysicalAddress),
+                           PagingTables->Data.NumberOfFrames * PAGE_SIZE,
+                           TRUE,
+                           NULL
+                           );
+
+    ExFreePoolWithTag(PagingTables, HEAP_PROCESS_TAG);
+}
+
+_No_competing_thread_
+static
+STATUS
+_MmuInitPagingSystem(
+    IN      PVOID                   BaseAddress
+    )
+{
+    DWORD framesForPagingStructures;
+    STATUS status;
+    PHYSICAL_ADDRESS basePa;
+
+    ASSERT(BaseAddress != NULL);
+
+    status = STATUS_SUCCESS;
+    basePa = NULL;
+    framesForPagingStructures = 0;
+
+    status = VmmPreparePagingData();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("VmmSetupPagingStructures", status);
+        return status;
+    }
+
+    // calculate size of paging structure
+    framesForPagingStructures = _MmuCalculateReservedFrames(PAGING_STRUCTURES_BASE_MEMORY,
+                                                            PAGING_STRUCTURES_PERCENTAGE,
+                                                            PmmGetTotalSystemMemory()
+                                                            );
+
+    LOG("Frames reserved for paging structures 0x%x\n", framesForPagingStructures);
+
+    // Reserve the physical memory for the paging structures
+    basePa = PmmReserveMemoryEx(framesForPagingStructures,
+                                VA2PA(BaseAddress)
+                                );
+    if ((NULL == basePa) ||
+        (basePa != VA2PA(BaseAddress)))
+    {
+        status = STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE;
+        LOG_FUNC_ERROR("MmuRequestMemoryEx", status);
+        return status;
+    }
+
+    // Zero the PML4 - else we may have all sorts of junk there
+    memzero((PVOID)PA2VA(basePa), PAGE_SIZE);
+
+    status = VmmSetupPageTables(&m_mmuData.PagingData.Data,
+                                &m_mmuData.PagingData.Data,
+                                basePa,
+                                framesForPagingStructures,
+                                TRUE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuInitPagingSystem", status);
+        return status;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_MmuRetrieveKernelInfoAndValidate(
+    IN      PVOID                   KernelBase,
+    IN      DWORD                   ImageSize,
+    OUT     PPE_NT_HEADER_INFO      KernelInfo
+    )
+{
+    STATUS status;
+    PE_DATA_DIRECTORY dataDirectory;
+
+    ASSERT( NULL != KernelBase );
+    ASSERT( 0 != ImageSize );
+    ASSERT( NULL != KernelInfo );
+
+    status = STATUS_SUCCESS;
+    memzero(&dataDirectory, sizeof(PE_DATA_DIRECTORY));
+
+    status = PeRetrieveNtHeader(KernelBase,
+                                ImageSize,
+                                KernelInfo
+                                );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PeRetrieveNtHeader", status );
+        return status;
+    }
+    LOGL("PeRetrieveNtHeader succeeded\n");
+
+    if (ImageSize < KernelInfo->Size)
+    {
+        LOG_ERROR("We loaded only %u bytes and the image is %u bytes long\n", ImageSize, KernelInfo->Size );
+        return STATUS_IMAGE_NOT_FULLY_LOADED;
+    }
+
+    if (IMAGE_FILE_MACHINE_AMD64 != KernelInfo->Machine )
+    {
+        LOG_ERROR("Expecting a PE64 executable and received: 0x%x\n", KernelInfo->Machine );
+        return STATUS_IMAGE_NOT_64_BIT;
+    }
+
+    if (IMAGE_SUBSYSTEM_NATIVE != KernelInfo->Subsystem)
+    {
+        LOG_ERROR("Expecting a native sub-system executable and received: 0x%x\n", KernelInfo->Subsystem );
+        return STATUS_IMAGE_SUBSYSTEM_NOT_NATIVE;
+    }
+
+    status = PeRetrieveDataDirectory(KernelInfo,
+                                     IMAGE_DIRECTORY_ENTRY_BASERELOC,
+                                     &dataDirectory
+                                     );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PeRetrieveDataDirectory", status);
+        return status;
+    }
+
+    if (0 != dataDirectory.Size)
+    {
+        LOG_ERROR("Image has relocations, we don't support such executables!\n");
+        return STATUS_IMAGE_HAS_RELOCATIONS;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_MmuRemapStack(
+    IN      PPAGING_DATA            PagingData,
+    IN      PVOID                   NewStackBase,
+    IN      DWORD                   StackSize
+    )
+{
+    STATUS status;
+    PBYTE pNewStackTop;
+
+    ASSERT(NULL != PagingData);
+    ASSERT( NULL != NewStackBase );
+    ASSERT( 0 != StackSize );
+    ASSERT(IsAddressAligned(StackSize, PAGE_SIZE));
+
+    status = STATUS_SUCCESS;
+
+    // we will allocate the stack at the end of the kernel image + 2 * PAGE_SIZE
+    // this is so we'll have a free guard page in between
+    pNewStackTop = (PBYTE)NewStackBase + StackSize;
+
+    status = _MmuReserveAndMapMemory(PagingData,
+                                     (PBYTE)NewStackBase,
+                                     StackSize,
+                                     VA2PA(NewStackBase),
+                                     PAGE_RIGHTS_READWRITE
+                                     );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuReserveAndMapMemory", status);
+        return status;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_MmuMapPeInMemory(
+    IN          PPAGING_DATA            PagingData,
+    IN          PPE_NT_HEADER_INFO      HeaderInfo,
+    IN          PVOID                   AddressToMap
+    )
+{
+    STATUS status;
+    DWORD alignedKernelSize;
+    DWORD noOfFrames;
+    PAGE_RIGHTS prevSectionRequiredRights;
+    PAGE_RIGHTS curSectionRequiredRights;
+    DWORD remainingSizeUntilPageAlignFromPrevSections;
+    DWORD sectionSize;
+    PVOID pAlignedAddress;
+
+    ASSERT(NULL != PagingData );
+
+    ASSERT(NULL != HeaderInfo);
+    ASSERT(IsAddressAligned(HeaderInfo->ImageBase,PAGE_SIZE));
+
+    ASSERT(NULL != AddressToMap);
+    ASSERT(IsAddressAligned(AddressToMap,PAGE_SIZE));
+
+    if (HeaderInfo->FileAlignment != HeaderInfo->ImageAlignment)
+    {
+        LOG_ERROR("We do not support loading PEs which have a different file alignment 0x%x than section alignment 0x%x!\n",
+                  HeaderInfo->FileAlignment, HeaderInfo->ImageAlignment);
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    status = STATUS_SUCCESS;
+    alignedKernelSize = AlignAddressUpper(HeaderInfo->Size, PAGE_SIZE);
+    noOfFrames = alignedKernelSize / PAGE_SIZE;
+    prevSectionRequiredRights = PAGE_RIGHTS_READ;
+    curSectionRequiredRights = 0;
+    sectionSize = 0;
+    pAlignedAddress = NULL;
+
+    // the first section will start after the headers end
+    remainingSizeUntilPageAlignFromPrevSections = PAGE_SIZE - AddressOffset(HeaderInfo->SizeOfHeaders, PAGE_SIZE);
+
+    LOG_TRACE_MMU("PE image base is 0x%X\n", HeaderInfo->ImageBase);
+
+    // need to map headers if they occupy at least one page
+    for (PVOID pHeaderPage = AddressToMap;
+         pHeaderPage < (PVOID) PtrDiff(PtrOffset(AddressToMap, HeaderInfo->SizeOfHeaders), PAGE_SIZE);
+         pHeaderPage = PtrOffset(pHeaderPage, PAGE_SIZE))
+    {
+        VmmMapMemoryInternal(PagingData,
+                             MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pHeaderPage, AddressToMap))),
+                             PAGE_SIZE,
+                             pHeaderPage,
+                             PAGE_RIGHTS_READ,
+                             TRUE,
+                             FALSE
+                             );
+    }
+
+    // map each section
+    for (DWORD i = 0; i < HeaderInfo->NumberOfSections; ++i)
+    {
+        PE_SECTION_INFO section;
+
+        status = PeRetrieveSection(HeaderInfo,
+                                   i,
+                                   &section
+                                   );
+        if (!SUCCEEDED(status))
+        {
+            /// TODO: it's not ok to return here, we should actually unmap all the memory
+            /// we mapped in case of failure
+            LOG_FUNC_ERROR("PeRetrieveSection", status );
+            return status;
+        }
+
+        LOG_TRACE_MMU("Will map section at 0x%X of size 0x%x\n", section.BaseAddress, section.Size);
+
+        // The PE header tells us the section of the size without regard to the image's alignment
+        sectionSize = AlignAddressUpper(section.Size, HeaderInfo->ImageAlignment);
+
+        // determine section rights
+        curSectionRequiredRights  = IsBooleanFlagOn( section.Characteristics, IMAGE_SCN_MEM_READ ) ? PAGE_RIGHTS_READ : 0;
+        curSectionRequiredRights |= IsBooleanFlagOn( section.Characteristics, IMAGE_SCN_MEM_WRITE ) ? PAGE_RIGHTS_WRITE : 0;
+        curSectionRequiredRights |= IsBooleanFlagOn( section.Characteristics, IMAGE_SCN_MEM_EXECUTE ) ? PAGE_RIGHTS_EXECUTE : 0;
+
+        // we don't support sections which are write/execute, it's simply a bad practice and no compiler should
+        // generate this kind of code
+        ASSERT(!IsBooleanFlagOn(curSectionRequiredRights,PAGE_RIGHTS_WRITE | PAGE_RIGHTS_EXECUTE));
+
+        // We do not have enough memory in this section to map the whole page
+        if ( sectionSize < remainingSizeUntilPageAlignFromPrevSections )
+        {
+            LOG_TRACE_MMU("Remaining 0x%x, section size 0x%x\n",
+                 remainingSizeUntilPageAlignFromPrevSections,
+                 section.Size);
+
+            ASSERT(remainingSizeUntilPageAlignFromPrevSections > sectionSize);
+            remainingSizeUntilPageAlignFromPrevSections = remainingSizeUntilPageAlignFromPrevSections - sectionSize;
+
+            // there may be more than 2 sections in a single page of memory
+            prevSectionRequiredRights = prevSectionRequiredRights | curSectionRequiredRights;
+
+            // continue to next section
+            continue;
+        }
+
+        // Calculate the absolute VA where the section will be placed in the new mapping and page align it (it's ok to
+        // do this - we need to also map the leftovers from the previous section (if there are any)
+        // The reason why we don't first map the previous section is that the requested rights may differ between sections
+        // and there's no benefit in calling the function twice
+        pAlignedAddress = (PVOID) AlignAddressLower(
+                                    PtrOffset(AddressToMap,
+                                              PtrDiff(section.BaseAddress,
+                                                      HeaderInfo->ImageBase)),
+                                    PAGE_SIZE);
+
+        LOG_TRACE_MMU("Aligned address is 0x%X\n", pAlignedAddress);
+
+        if (0 != remainingSizeUntilPageAlignFromPrevSections)
+        {
+            // map first page of this section, this is shared with the last page
+            // of the previous section(s)
+            LOG_TRACE_MMU("Will map 0x%X -> 0x%X with rights 0x%x\n",
+                          MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pAlignedAddress,AddressToMap))),
+                          pAlignedAddress,
+                          prevSectionRequiredRights | curSectionRequiredRights);
+
+            // Because the alignment of the sections may be less than a PAGE_SIZE we may incur executables which
+            // have this undesirable property (of having a PAGE mapped with both execute and write rights)
+            if(IsBooleanFlagOn(prevSectionRequiredRights | curSectionRequiredRights, PAGE_RIGHTS_EXECUTE | PAGE_RIGHTS_WRITE))
+            {
+                LOG_WARNING("Section rights will be Write + Execute!!\n");
+            }
+
+            VmmMapMemoryInternal(PagingData,
+                                 MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pAlignedAddress,AddressToMap))),
+                                 PAGE_SIZE,
+                                 pAlignedAddress,
+                                 prevSectionRequiredRights | curSectionRequiredRights,
+                                 TRUE,
+                                 FALSE
+                                 );
+
+            // advance to next page
+            pAlignedAddress = PtrOffset(pAlignedAddress, PAGE_SIZE);
+            sectionSize = sectionSize - remainingSizeUntilPageAlignFromPrevSections;
+        }
+
+        // how much bytes are remaining until the page boundary is reached
+        remainingSizeUntilPageAlignFromPrevSections = PAGE_SIZE - AddressOffset(sectionSize, PAGE_SIZE);
+
+        // We can't map half a page (or anything less than it) that's why we do the comparison from
+        // the aligned address + PAGE_SIZE because we need to have the whole PAGE contained in the current
+        // section to be able to map it;
+        for (PVOID pPage = pAlignedAddress;
+             PtrOffset(pPage, PAGE_SIZE) <= PtrOffset(pAlignedAddress, sectionSize);
+             pPage = PtrOffset(pPage, PAGE_SIZE))
+        {
+            LOG_TRACE_MMU("Will map 0x%X -> 0x%X with rights 0x%x\n",
+                          MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pPage,AddressToMap))),
+                          pPage,
+                          curSectionRequiredRights);
+
+            VmmMapMemoryInternal(PagingData,
+                                 MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pPage,AddressToMap))),
+                                 PAGE_SIZE,
+                                 pPage,
+                                 curSectionRequiredRights,
+                                 TRUE,
+                                 FALSE
+                                 );
+        }
+
+        // we certainly mapped all the memory related to the previous sections
+        // => update previous section rights to reflect the rights of the current area
+        prevSectionRequiredRights = curSectionRequiredRights;
+    }
+
+    // The last section may have not ended nicely at the PAGE boundary => we may need to
+    // map it afterwards
+    if (sectionSize != 0)
+    {
+        LOG_TRACE_MMU("Will map 0x%X -> 0x%X with rights 0x%x\n",
+                      MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pAlignedAddress, AddressToMap))),
+                      pAlignedAddress,
+                      prevSectionRequiredRights);
+
+        // This can occur if there are multiple sections at the end of the PE which do not add up
+        // to a full page
+        if (IsBooleanFlagOn(prevSectionRequiredRights, PAGE_RIGHTS_EXECUTE | PAGE_RIGHTS_WRITE))
+        {
+            LOG_WARNING("Section rights will be Write + Execute!!\n");
+        }
+
+        VmmMapMemoryInternal(PagingData,
+                             MmuGetPhysicalAddress(PtrOffset(HeaderInfo->ImageBase, PtrDiff(pAlignedAddress, AddressToMap))),
+                             PAGE_SIZE,
+                             pAlignedAddress,
+                             prevSectionRequiredRights,
+                             TRUE,
+                             FALSE
+        );
+    }
+
+    LOG_TRACE_MMU("PE mapped succeesfully\n");
+
+    return status;
+
+}
+
+static
+STATUS
+_MmuMapKernelMemory(
+    IN          PPAGING_DATA            PagingData,
+    IN          PHYSICAL_ADDRESS        PhysicalAddress,
+    IN          PPE_NT_HEADER_INFO      KernelInfo
+    )
+{
+    STATUS status;
+    PHYSICAL_ADDRESS kernelPa;
+    DWORD noOfFrames;
+
+    ASSERT(NULL != PagingData);
+    ASSERT(NULL != KernelInfo);
+    ASSERT(IsAddressAligned(KernelInfo->ImageBase,PAGE_SIZE));
+
+    status = STATUS_SUCCESS;
+    noOfFrames = AlignAddressUpper(KernelInfo->Size, PAGE_SIZE) / PAGE_SIZE;
+
+    // Mark the kernel physical frames as reserved
+    kernelPa = PmmReserveMemoryEx(noOfFrames, PhysicalAddress);
+    if ((NULL == kernelPa) || (kernelPa != PhysicalAddress))
+    {
+        LOG_ERROR("PmmRequestMemoryEx failed!\n");
+        return STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE;
+    }
+
+    status = _MmuMapPeInMemory(PagingData, KernelInfo, KernelInfo->ImageBase);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuMapPeInMemory", status);
+        LOG_ERROR("Unable to perform high VA mapping for kernel!\n");
+        return status;
+    }
+
+    // Perform identity mapping - needed by APs
+    // Will be discarded after all the APs get in 64-bit mode
+    status = _MmuMapPeInMemory(PagingData, KernelInfo, VA2PA(KernelInfo->ImageBase));
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_MmuMapPeInMemory", status);
+        LOG_ERROR("Unable to perform identity mapping for kernel!\n");
+        return status;
+    }
+
+    LOG("Kernel mapped succeesfully\n");
+
+    return status;
+}
+
+static
+STATUS
+_MmuReserveAndMapMemory(
+    IN          PPAGING_DATA            PagingData,
+    IN          PVOID                   VirtualAddress,
+    IN          DWORD                   Size,
+    IN          PHYSICAL_ADDRESS        PhysicalAddress,
+    IN          PAGE_RIGHTS             AccessRights
+    )
+{
+    PHYSICAL_ADDRESS pa;
+    DWORD noOfFrames;
+
+    ASSERT( NULL != VirtualAddress );
+
+    ASSERT( 0 != Size );
+    ASSERT( IsAddressAligned( Size, PAGE_SIZE ));
+
+    noOfFrames = Size / PAGE_SIZE;
+
+    pa = PmmReserveMemoryEx( noOfFrames, PhysicalAddress);
+    if( ( NULL == pa ) || ( pa != PhysicalAddress) )
+    {
+        LOG_ERROR("PmmReserveMemoryEx failed for PA 0x%X!\n", PhysicalAddress);
+        return STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE;
+    }
+
+    ASSERT_INFO( pa == PhysicalAddress,
+                "Requested PA: 0x%X, Received: 0x%X\n",
+                PhysicalAddress, pa );
+
+    VmmMapMemoryInternal(PagingData,
+                         pa,
+                         (DWORD) Size,
+                         VirtualAddress,
+                         AccessRights,
+                         TRUE,
+                         FALSE
+                         );
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_MmuInitializeHeap(
+    OUT         PMMU_HEAP_DATA          Heap,
+    IN          DWORD                   HeapBaseSize,
+    IN          WORD                    HeapPercentageSize
+    )
+{
+    STATUS status;
+    DWORD framesForHeapStructures;
+    QWORD heapSize;
+    PVOID heapBaseAddress;
+
+    ASSERT( NULL != Heap );
+
+    status = STATUS_SUCCESS;
+
+    // calculate number of frames used by the heap
+    framesForHeapStructures = _MmuCalculateReservedFrames(HeapBaseSize,
+                                                          HeapPercentageSize,
+                                                          PmmGetTotalSystemMemory()
+                                                          );
+    LOG("Frames for heap structures: 0x%x\n", framesForHeapStructures);
+
+    heapSize = (QWORD)framesForHeapStructures * PAGE_SIZE;
+
+    LOG("Total size reserved for heap: %U bytes ( %U KB )\n", heapSize, heapSize / KB_SIZE);
+
+    heapBaseAddress = VmmAllocRegion(NULL,
+        heapSize,
+        VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+        PAGE_RIGHTS_READWRITE
+    );
+    if (heapBaseAddress == NULL)
+    {
+        LOG_ERROR("VmmAlloc failed to reserve & commit a heap of size %U!\n", heapSize);
+        return STATUS_MEMORY_CANNOT_BE_RESERVED;
+    }
+
+    status = ClHeapInit(heapBaseAddress, heapSize, &Heap->Heap);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ClHeapInit", status);
+        return status;
+    }
+
+    LOG("ClHeapInit suceeded\n");
+
+    LockInit(&Heap->HeapLock);
+
+    return status;
+}
+
+static
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+_MmuAllocateFromPoolWithTag(
+    IN      MMU_HEAP_INDEX          Heap,
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    )
+{
+    PVOID pResult;
+    INTR_STATE oldState;
+
+    ASSERT( Heap < MmuHeapIndexReserved );
+    ASSERT( NULL != m_mmuData.Heaps[Heap].Heap );
+
+    LockAcquire(&m_mmuData.Heaps[Heap].HeapLock, &oldState );
+    pResult = ClHeapAllocatePoolWithTag(m_mmuData.Heaps[Heap].Heap,
+                                      Flags,
+                                      AllocationSize,
+                                      Tag,
+                                      AllocationAlignment
+                                      );
+    LockRelease(&m_mmuData.Heaps[Heap].HeapLock, oldState );
+
+    return pResult;
+}
+
+static
+void
+_MmuFreeFromPoolWithTag(
+    IN      MMU_HEAP_INDEX          Heap,
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    )
+{
+    INTR_STATE oldState;
+
+    ASSERT(Heap < MmuHeapIndexReserved);
+    ASSERT( NULL != m_mmuData.Heaps[Heap].Heap );
+
+    LockAcquire(&m_mmuData.Heaps[Heap].HeapLock, &oldState);
+    ClHeapFreePoolWithTag(m_mmuData.Heaps[Heap].Heap,
+                        MemoryAddress,
+                        Tag
+                        );
+    LockRelease(&m_mmuData.Heaps[Heap].HeapLock, oldState);
+}
+
+static
+void
+_MmuRemapDisplay(
+    IN          PPAGING_DATA            PagingData
+    )
+{
+    // because of the way the PMM is implemented
+    // memory under 1MB is reserved and will never be allocated
+    // => we don't need to request the frames from the PMM
+
+    VmmMapMemoryInternal(PagingData,
+                         (PHYSICAL_ADDRESS) BASE_VIDEO_ADDRESS,
+                         AlignAddressUpper(SCREEN_SIZE, PAGE_SIZE),
+                         (PVOID) PA2VA(BASE_VIDEO_ADDRESS),
+                         PAGE_RIGHTS_READWRITE,
+                         TRUE,
+                         FALSE
+                         );
+}
+
+static
+STATUS
+_MmuZeroWorkerThreadFunction(
+    IN_OPT      PVOID           Context
+    )
+{
+    PLIST_ENTRY pListHead;
+    STATUS status;
+    PMMU_ZERO_WORKER_THREAD_CTX pCtx;
+    PEX_EVENT pEvent;
+    PLIST_ENTRY pCurrentEntry;
+    PLOCK pLock;
+
+    LOG_FUNC_START;
+
+    ASSERT( NULL != Context );
+
+    status = STATUS_SUCCESS;
+    pCtx = (PMMU_ZERO_WORKER_THREAD_CTX) Context;
+    pCurrentEntry = NULL;
+
+    pListHead = pCtx->PagesToZeroList;
+    ASSERT( NULL != pListHead );
+
+    pEvent = pCtx->NewPagesEvent;
+    ASSERT( NULL != pEvent );
+
+    pLock = pCtx->PagesLock;
+    ASSERT( NULL != pLock );
+
+    ExFreePoolWithTag(pCtx, HEAP_MMU_TAG);
+    pCtx = NULL;
+
+    // warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        PMMU_ZERO_WORKER_ITEM pItem;
+        INTR_STATE oldState;
+        DWORD noOfBytes;
+        PVOID pAddr;
+
+        pItem = NULL;
+        noOfBytes = 0;
+        pAddr = NULL;
+
+        // may use executive timer in the future
+        ExEventWaitForSignal(pEvent);
+
+        LockAcquire(pLock, &oldState);
+        pCurrentEntry = RemoveHeadList(pListHead);
+        LockRelease(pLock, oldState);
+
+        if (pCurrentEntry == pListHead)
+        {
+            // list is empty :(
+            ExEventClearSignal(pEvent);
+
+            // wait for another signal
+            continue;
+        }
+
+        pItem = CONTAINING_RECORD(pCurrentEntry, MMU_ZERO_WORKER_ITEM, ListEntry);
+
+        noOfBytes = pItem->NumberOfFrames * PAGE_SIZE;
+        pAddr = MmuMapMemoryEx(pItem->PhysicalAddress,
+                               noOfBytes,
+                               PAGE_RIGHTS_READWRITE,
+                               FALSE,
+                               FALSE,
+                               NULL
+                               );
+        ASSERT( NULL != pAddr );
+
+        // zero the memory, that's our job :)
+        memzero(pAddr, noOfBytes);
+
+        // truly release physical addresses
+        PmmReleaseMemory(pItem->PhysicalAddress, pItem->NumberOfFrames );
+
+        // it's ok, this does not release memory => no oo loop
+        MmuUnmapSystemMemory(pAddr, noOfBytes);
+
+        _MmuFreeFromPoolWithTag(MmuHeapIndexSpecial, pItem, HEAP_MMU_TAG );
+        pItem = NULL;
+    }
+
+    LOG_FUNC_END;
+
+    NOT_REACHED;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/mutex.c b/src_proiect/HAL9000/src/mutex.c
new file mode 100644
index 0000000..9c82227
--- /dev/null
+++ b/src_proiect/HAL9000/src/mutex.c
@@ -0,0 +1,113 @@
+#include "HAL9000.h"
+#include "thread_internal.h"
+#include "mutex.h"
+
+#define MUTEX_MAX_RECURSIVITY_DEPTH         MAX_BYTE
+
+_No_competing_thread_
+void
+MutexInit(
+    OUT         PMUTEX      Mutex,
+    IN          BOOLEAN     Recursive
+    )
+{
+    ASSERT( NULL != Mutex );
+
+    memzero(Mutex, sizeof(MUTEX));
+
+    LockInit(&Mutex->MutexLock);
+
+    InitializeListHead(&Mutex->WaitingList);
+
+    Mutex->MaxRecursivityDepth = Recursive ? MUTEX_MAX_RECURSIVITY_DEPTH : 1;
+}
+
+ACQUIRES_EXCL_AND_REENTRANT_LOCK(*Mutex)
+REQUIRES_NOT_HELD_LOCK(*Mutex)
+void
+MutexAcquire(
+    INOUT       PMUTEX      Mutex
+    )
+{
+    INTR_STATE dummyState;
+    INTR_STATE oldState;
+    PTHREAD pCurrentThread = GetCurrentThread();
+
+    ASSERT( NULL != Mutex);
+    ASSERT( NULL != pCurrentThread );
+
+    if (pCurrentThread == Mutex->Holder)
+    {
+        ASSERT( Mutex->CurrentRecursivityDepth < Mutex->MaxRecursivityDepth );
+
+        Mutex->CurrentRecursivityDepth++;
+        return;
+    }
+
+    oldState = CpuIntrDisable();
+
+    LockAcquire(&Mutex->MutexLock, &dummyState );
+    if (NULL == Mutex->Holder)
+    {
+        Mutex->Holder = pCurrentThread;
+        Mutex->CurrentRecursivityDepth = 1;
+    }
+
+    while (Mutex->Holder != pCurrentThread)
+    {
+        InsertTailList(&Mutex->WaitingList, &pCurrentThread->ReadyList);
+        ThreadTakeBlockLock();
+        LockRelease(&Mutex->MutexLock, dummyState);
+        ThreadBlock();
+        LockAcquire(&Mutex->MutexLock, &dummyState );
+    }
+
+    _Analysis_assume_lock_acquired_(*Mutex);
+
+    LockRelease(&Mutex->MutexLock, dummyState);
+
+    CpuIntrSetState(oldState);
+}
+
+RELEASES_EXCL_AND_REENTRANT_LOCK(*Mutex)
+REQUIRES_EXCL_LOCK(*Mutex)
+void
+MutexRelease(
+    INOUT       PMUTEX      Mutex
+    )
+{
+    INTR_STATE oldState;
+    PLIST_ENTRY pEntry;
+
+    ASSERT(NULL != Mutex);
+    ASSERT(GetCurrentThread() == Mutex->Holder);
+
+    if (Mutex->CurrentRecursivityDepth > 1)
+    {
+        Mutex->CurrentRecursivityDepth--;
+        return;
+    }
+
+    pEntry = NULL;
+
+    LockAcquire(&Mutex->MutexLock, &oldState);
+
+    pEntry = RemoveHeadList(&Mutex->WaitingList);
+    if (pEntry != &Mutex->WaitingList)
+    {
+        PTHREAD pThread = CONTAINING_RECORD(pEntry, THREAD, ReadyList);
+
+        // wakeup first thread
+        Mutex->Holder = pThread;
+        Mutex->CurrentRecursivityDepth = 1;
+        ThreadUnblock(pThread);
+    }
+    else
+    {
+        Mutex->Holder = NULL;
+    }
+
+    _Analysis_assume_lock_released_(*Mutex);
+
+    LockRelease(&Mutex->MutexLock, oldState);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/network_utils.c b/src_proiect/HAL9000/src/network_utils.c
new file mode 100644
index 0000000..86ba229
--- /dev/null
+++ b/src_proiect/HAL9000/src/network_utils.c
@@ -0,0 +1,43 @@
+#include "HAL9000.h"
+#include "network_utils.h"
+
+char*
+NetUtilMacAddressToText(
+    IN                                                          MAC_ADDRESS         Address,
+    OUT_WRITES_BYTES_ALL(TEXT_MAC_ADDRESS_CHARS_REQUIRED)       char*               Buffer
+    )
+{
+    ASSERT( NULL != Buffer );
+
+    snprintf(Buffer,
+             TEXT_MAC_ADDRESS_CHARS_REQUIRED,
+             "%02x:%02x:%02x:%02x:%02x:%02x",
+             Address.Value[0],
+             Address.Value[1],
+             Address.Value[2],
+             Address.Value[3],
+             Address.Value[4],
+             Address.Value[5]);
+
+    return Buffer;
+}
+
+char*
+NetUtilIp4AddressToText(
+    IN                                                          IP4_ADDRESS         Address,
+    OUT_WRITES_BYTES_ALL(TEXT_IP4_ADDRESS_CHARS_REQUIRED)       char*               Buffer
+    )
+{
+    ASSERT(NULL != Buffer);
+
+    snprintf(Buffer,
+             TEXT_IP4_ADDRESS_CHARS_REQUIRED,
+             "%u.%u.%u.%u",
+             Address.ByteAddress[0],
+             Address.ByteAddress[1],
+             Address.ByteAddress[2],
+             Address.ByteAddress[3]
+             );
+
+    return Buffer;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/os_info.c b/src_proiect/HAL9000/src/os_info.c
new file mode 100644
index 0000000..e35d0aa
--- /dev/null
+++ b/src_proiect/HAL9000/src/os_info.c
@@ -0,0 +1,127 @@
+#include "HAL9000.h"
+#include "os_info.h"
+#include "display.h"
+#include "os_time.h"
+#include "rtc.h"
+#include "iomu.h"
+
+#define TIME_BUFFER_SIZE                    100
+
+#define OS_NAME                             "HAL9000"
+#define OS_VERSION                          "1.8"
+
+#define OS_VERSION_COLUMN                   0
+
+static
+void
+_OsInfoUpdateTime(
+    void
+    );
+
+void
+OsInfoPreinit(
+    void
+    )
+{
+    DWORD osNameLength;
+    BYTE middlePosition;
+
+    osNameLength = 0;
+    middlePosition = 0;
+
+    // clear title line
+    DispClearLine(0);
+
+    osNameLength = strlen(OS_NAME);
+    ASSERT(osNameLength <= CHARS_PER_LINE);
+
+    // place OS version
+    DispPutBufferColor(OS_VERSION, 0, OS_VERSION_COLUMN, CYAN_COLOR);
+
+    // we want the OS name to be printed on the middle of the line
+    middlePosition = (CHARS_PER_LINE - (BYTE) osNameLength ) / 2;
+
+    DispPutBufferColor(OS_NAME, 0, middlePosition, BRIGHT_GREEN_COLOR);
+
+    // update time
+    _OsInfoUpdateTime();
+}
+
+STATUS
+OsInfoInit(
+    void
+    )
+{
+    return STATUS_SUCCESS;
+}
+
+const
+char*
+OsInfoGetName(
+    void
+    )
+{
+    return OS_NAME;
+}
+
+const
+char*
+OsGetBuildDate(
+    void
+    )
+{
+    return __TIMESTAMP__;
+}
+
+const
+char*
+OsGetBuildType(
+    void
+    )
+{
+#ifdef DEBUG
+    return "Debug";
+#else
+    return "Release";
+#endif
+}
+
+const
+char*
+OsGetVersion(
+    void
+    )
+{
+    return OS_VERSION;
+}
+
+
+static
+void
+_OsInfoUpdateTime(
+    void
+    )
+{
+    char timeBuffer[TIME_BUFFER_SIZE];
+
+    memzero(timeBuffer, TIME_BUFFER_SIZE);
+
+    OsTimeGetStringFormattedTime(NULL, timeBuffer, TIME_BUFFER_SIZE);
+
+    DispPutBufferColor(timeBuffer, 0, CHARS_PER_LINE - (BYTE)strlen(timeBuffer), CYAN_COLOR);
+}
+
+BOOLEAN
+(__cdecl OsInfoTimeUpdateIsr)(
+    IN      PDEVICE_OBJECT  Device
+    )
+{
+    ASSERT(NULL != Device);
+
+    RtcAcknowledgeTimerInterrupt();
+    IomuCmosUpdateOccurred();
+    _OsInfoUpdateTime();
+
+    // we handled the interrupt
+    return TRUE;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/os_time.c b/src_proiect/HAL9000/src/os_time.c
new file mode 100644
index 0000000..5d4eee7
--- /dev/null
+++ b/src_proiect/HAL9000/src/os_time.c
@@ -0,0 +1,55 @@
+#include "HAL9000.h"
+#include "os_time.h"
+#include "cmos.h"
+
+DATETIME
+OsTimeGetCurrentDateTime(
+    void
+    )
+{
+    DATETIME result;
+    CMOS_DATA cmosData;
+
+    memzero(&cmosData, sizeof(CMOS_DATA));
+
+    CmosReadData(&cmosData);
+
+    // set date
+    result.Date.Year = cmosData.Year;
+    result.Date.Month = cmosData.Month;
+    result.Date.Day = cmosData.Day;
+
+    // set time
+    result.Time.Hour = cmosData.Hour;
+    result.Time.Minute = cmosData.Minute;
+    result.Time.Second = cmosData.Second;
+
+    return result;
+}
+
+STATUS
+OsTimeGetStringFormattedTime(
+    IN_OPT                      PDATETIME       DateTime,
+    OUT_WRITES_Z(BufferSize)    char*           Buffer,
+    IN                          DWORD           BufferSize
+    )
+{
+    PDATETIME pDateTimeToFormat;
+    DATETIME dateTime;
+
+    if (NULL == DateTime)
+    {
+        dateTime = OsTimeGetCurrentDateTime();
+
+        pDateTimeToFormat = &dateTime;
+    }
+    else
+    {
+        pDateTimeToFormat = DateTime;
+    }
+
+    return TimeGetStringFormattedBuffer(*pDateTimeToFormat,
+                                        Buffer,
+                                        BufferSize
+                                        );
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/pci_system.c b/src_proiect/HAL9000/src/pci_system.c
new file mode 100644
index 0000000..57a3fd5
--- /dev/null
+++ b/src_proiect/HAL9000/src/pci_system.c
@@ -0,0 +1,856 @@
+#include "HAL9000.h"
+#include "list.h"
+#include "pci_system.h"
+#include "acpi_interface.h"
+#include "io.h"
+#include "pcie.h"
+
+/// to remove
+#include "dmp_pci.h"
+
+typedef struct _PCI_ROOT_COMPLEX_ENTRY
+{
+    PCI_ROOT_COMPLEX    RootComplex;
+
+    LIST_ENTRY          ListEntry;
+} PCI_ROOT_COMPLEX_ENTRY, *PPCI_ROOT_COMPLEX_ENTRY;
+
+typedef struct _PCI_SYSTEM_DATA
+{
+    BOOLEAN             PciExpressSupport;
+
+    LIST_ENTRY          PciRootComplexList;
+} PCI_SYSTEM_DATA, *PPCI_SYSTEM_DATA;
+
+static PCI_SYSTEM_DATA  m_pciSystemData;
+
+static
+__forceinline
+PTR_SUCCESS
+PPCI_ROOT_COMPLEX
+_PciSystemFindRootComplexForDevice(
+    IN          PCI_DEVICE_LOCATION         DeviceLocation
+    )
+{
+    PLIST_ENTRY pEntry;
+
+    for( pEntry = m_pciSystemData.PciRootComplexList.Flink;
+        pEntry != &m_pciSystemData.PciRootComplexList;
+        pEntry = pEntry->Flink)
+    {
+        PPCI_ROOT_COMPLEX_ENTRY pRootComplex = CONTAINING_RECORD(pEntry, PCI_ROOT_COMPLEX_ENTRY, ListEntry);
+
+        if ( ( pRootComplex->RootComplex.StartBusNumber <= DeviceLocation.Bus ) && ( DeviceLocation.Bus <= pRootComplex->RootComplex.EndBusNumber ) )
+        {
+            return &pRootComplex->RootComplex;
+        }
+    }
+
+    return NULL;
+}
+
+static
+STATUS
+_PciSystemReadConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    OUT     DWORD*                  Value
+    );
+
+static
+STATUS
+_PciSystemWriteConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      DWORD                   Value
+    );
+
+static
+STATUS
+_PciSystemInitRootComplexEntry(
+    IN          ACPI_MCFG_ALLOCATION*       AcpiEntry,
+    OUT_PTR     PPCI_ROOT_COMPLEX_ENTRY*    RootComplexEntry
+    );
+
+static
+STATUS
+_PciSystemRetrievePciExpressDevices(
+    INOUT   PLIST_ENTRY     PciDeviceList,
+    OUT     PDWORD          NumberOfDevices
+    );
+
+static
+STATUS
+_PciSystemRetrievePciDevices(
+    INOUT   PLIST_ENTRY     PciDeviceList,
+    OUT     PDWORD          NumberOfDevices
+    );
+
+static
+STATUS
+_PciSystemRetrieveParentForDevice(
+    IN      PLIST_ENTRY                 BridgeList,
+    IN      BYTE                        Bus,
+    OUT     PPCI_DEVICE_DESCRIPTION*    ParentDevice
+    );
+
+void
+PciSystemPreinit(
+    void
+    )
+{
+    memzero(&m_pciSystemData, sizeof(PCI_SYSTEM_DATA));
+
+    InitializeListHead(&m_pciSystemData.PciRootComplexList);
+}
+
+STATUS
+PciSystemInit(
+    void
+    )
+{
+    STATUS status;
+    BOOLEAN bRestartSearch;
+    ACPI_MCFG_ALLOCATION* pEntry;
+    PCI_ROOT_COMPLEX_ENTRY* pMcfg;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    bRestartSearch = TRUE;
+    pEntry = FALSE;
+    pMcfg = NULL;
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        ASSERT( NULL == pMcfg);
+
+        status = AcpiRetrieveNextMcfgEntry(bRestartSearch, &pEntry);
+        if (STATUS_NO_MORE_OBJECTS == status)
+        {
+            LOGL("Reached end of MCFG list\n");
+            status = STATUS_SUCCESS;
+            break;
+        }
+
+        status = _PciSystemInitRootComplexEntry(pEntry, &pMcfg);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_PciSystemInitRootComplexEntry", status);
+            return status;
+        }
+
+        InsertTailList(&m_pciSystemData.PciRootComplexList, &pMcfg->ListEntry);
+
+        bRestartSearch = FALSE;
+        pMcfg = NULL;
+    }
+
+    // we have at least one 1 MCFG structure => we have PCI express support
+    m_pciSystemData.PciExpressSupport = !IsListEmpty(&m_pciSystemData.PciRootComplexList);
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+PciSystemRetrieveDevices(
+    INOUT   PLIST_ENTRY     PciDeviceList
+    )
+{
+    STATUS status;
+    DWORD noOfDevicesRetrieved;
+
+    if (NULL == PciDeviceList)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+    noOfDevicesRetrieved = 0;
+
+    LOGL("PCI Express support is %s available\n", 
+         !m_pciSystemData.PciExpressSupport ? "NOT" : "" );
+
+    if (m_pciSystemData.PciExpressSupport)
+    {
+        status = _PciSystemRetrievePciExpressDevices(PciDeviceList, &noOfDevicesRetrieved);
+    }
+    else
+    {
+        status = _PciSystemRetrievePciDevices(PciDeviceList, &noOfDevicesRetrieved);
+    }
+    if (!SUCCEEDED(status))
+    {
+        LOG_ERROR("Failed to retrieved PCI devices with status: 0x%x\n", status);
+        return status;
+    }
+
+
+    LOG("Retrieved %d PCI %s devices\n", 
+        noOfDevicesRetrieved,
+        m_pciSystemData.PciExpressSupport ? "Express" : "" );
+
+    return status;
+}
+
+void
+PciSystemEstablishHierarchy(
+    IN      PLIST_ENTRY     PciDeviceList,
+    INOUT   PLIST_ENTRY     PciBridgeList
+    )
+{
+    ASSERT(NULL != PciDeviceList);
+    ASSERT(NULL != PciBridgeList);
+
+    for (PLIST_ENTRY pEntry = PciDeviceList->Flink;
+         pEntry != PciDeviceList;
+         pEntry = pEntry->Flink)
+    {
+        PPCI_DEVICE_LIST_ENTRY pDevice = CONTAINING_RECORD(pEntry, PCI_DEVICE_LIST_ENTRY, ListEntry);
+
+        if(pDevice->PciDevice.DeviceData->Header.HeaderType.Layout == PCI_HEADER_LAYOUT_PCI_TO_PCI)
+        {
+            LOG_TRACE_PCI("Added bridge device (%u.%u.%u)\n",
+                pDevice->PciDevice.DeviceLocation.Bus,
+                pDevice->PciDevice.DeviceLocation.Device,
+                pDevice->PciDevice.DeviceLocation.Function);
+            InsertTailList(PciBridgeList, &pDevice->BridgeEntry);
+        }
+
+        if(pDevice->PciDevice.DeviceLocation.Bus != 0)
+        {
+            // find parent bus
+            STATUS status = _PciSystemRetrieveParentForDevice(PciBridgeList, 
+                                                              pDevice->PciDevice.DeviceLocation.Bus,
+                                                              &pDevice->PciDevice.Parent);
+            if(!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_PciSystemRetrieveParentForDevice", status);
+                NOT_REACHED;
+            }
+
+            LOG_TRACE_PCI("Found parent (%u.%u.%u) for device (%u.%u.%u)\n",
+                pDevice->PciDevice.Parent->DeviceLocation.Bus,
+                pDevice->PciDevice.Parent->DeviceLocation.Device,
+                pDevice->PciDevice.Parent->DeviceLocation.Function,
+                pDevice->PciDevice.DeviceLocation.Bus,
+                pDevice->PciDevice.DeviceLocation.Device,
+                pDevice->PciDevice.DeviceLocation.Function);
+        }
+    }
+}
+
+STATUS
+PciSystemFindDevicesMatchingSpecification(
+    IN      PLIST_ENTRY     PciDeviceList,
+    IN      PCI_SPEC        Specification,
+    OUT_WRITES_OPT(*NumberOfDevices) 
+            PPCI_DEVICE_DESCRIPTION*    PciDevices,
+    _When_(NULL == PciDevices, OUT)
+    _When_(NULL != PciDevices, INOUT)
+            DWORD*          NumberOfDevices
+    )
+{
+    PLIST_ENTRY pCurEntry;
+    DWORD noOfDevicesFound;
+
+    if (NULL == PciDeviceList)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == NumberOfDevices)
+    {
+        return STATUS_INVALID_PARAMETER5;
+    }
+
+    noOfDevicesFound = 0;
+
+    for (pCurEntry = PciDeviceList->Flink;
+        pCurEntry != PciDeviceList;
+        pCurEntry = pCurEntry->Flink)
+    {
+        PPCI_DEVICE_LIST_ENTRY pDevice = CONTAINING_RECORD(pCurEntry, PCI_DEVICE_LIST_ENTRY, ListEntry);
+
+        if (!Specification.MatchClass || pDevice->PciDevice.DeviceData->Header.ClassCode == Specification.Description.ClassCode )
+        {
+            if (!Specification.MatchSubclass || pDevice->PciDevice.DeviceData->Header.Subclass ==  Specification.Description.Subclass)
+            {
+                if (!Specification.MatchVendor || pDevice->PciDevice.DeviceData->Header.VendorID == Specification.Description.VendorId)
+                {
+                    if (!Specification.MatchDevice || pDevice->PciDevice.DeviceData->Header.DeviceID ==  Specification.Description.DeviceId)
+                    {
+                        if (NULL != PciDevices)
+                        {
+                            if (noOfDevicesFound > *NumberOfDevices)
+                            {
+                                return STATUS_BUFFER_TOO_SMALL;
+                            }
+
+                            PciDevices[noOfDevicesFound] = &pDevice->PciDevice;
+                        }
+                        noOfDevicesFound = noOfDevicesFound + 1;
+                    }
+                }
+            }
+        }
+    }
+
+    *NumberOfDevices = noOfDevicesFound;
+
+    return (0 != noOfDevicesFound) ? STATUS_SUCCESS : STATUS_ELEMENT_NOT_FOUND;
+}
+
+STATUS
+PciSystemFindDevicesMatchingLocation(
+    IN      PLIST_ENTRY                 PciDeviceList,
+    IN      PCI_SPEC_LOCATION           Specification,
+    OUT_WRITES_OPT(*NumberOfDevices) 
+            PPCI_DEVICE_DESCRIPTION*    PciDevices,
+    _When_(NULL == PciDevices, OUT)
+    _When_(NULL != PciDevices, INOUT)
+            DWORD*                      NumberOfDevices
+    )
+{
+    PLIST_ENTRY pCurEntry;
+    DWORD noOfDevicesFound;
+
+    if (NULL == PciDeviceList)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == NumberOfDevices)
+    {
+        return STATUS_INVALID_PARAMETER5;
+    }
+
+    noOfDevicesFound = 0;
+
+    for (pCurEntry = PciDeviceList->Flink;
+         pCurEntry != PciDeviceList;
+         pCurEntry = pCurEntry->Flink)
+    {
+        PPCI_DEVICE_LIST_ENTRY pDevice = CONTAINING_RECORD(pCurEntry, PCI_DEVICE_LIST_ENTRY, ListEntry);
+
+        if (!Specification.MatchBus || pDevice->PciDevice.DeviceLocation.Bus == Specification.Location.Bus)
+        {
+            if (!Specification.MatchDevice || pDevice->PciDevice.DeviceLocation.Device == Specification.Location.Device)
+            {
+                if (!Specification.MatchFunction || pDevice->PciDevice.DeviceLocation.Function == Specification.Location.Function)
+                {
+                    if (NULL != PciDevices)
+                    {
+                        if (noOfDevicesFound > *NumberOfDevices)
+                        {
+                            return STATUS_BUFFER_TOO_SMALL;
+                        }
+
+                        PciDevices[noOfDevicesFound] = &pDevice->PciDevice;
+                    }
+                    noOfDevicesFound = noOfDevicesFound + 1;
+                }
+            }
+        }
+    }
+
+    *NumberOfDevices = noOfDevicesFound;
+
+    return (0 != noOfDevicesFound) ? STATUS_SUCCESS : STATUS_ELEMENT_NOT_FOUND;
+}
+
+STATUS
+PciSystemReadConfigurationSpaceGeneric(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      BYTE                    Width,
+    OUT     QWORD*                  Value
+    )
+{
+    DWORD value;
+    STATUS status;
+
+    if (!IsAddressAligned(Register, Width / BITS_PER_BYTE))
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (NULL == Value)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_PCI("(%u.%u.%u) Register: 0x%x\n", DeviceLocation.Bus,
+                   DeviceLocation.Device, DeviceLocation.Function, Register);
+
+    status = _PciSystemReadConfigurationSpace(DeviceLocation,
+                                             AlignAddressLower(Register, sizeof(DWORD)),
+                                             &value
+                                             );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemReadConfigurationSpace", status);
+        return AE_ERROR;
+    }
+
+    LOG_TRACE_PCI("Before shift 0x%x\n", value);
+    value = (value >> (AddressOffset(Register, sizeof(DWORD)) * 8));
+    LOG_TRACE_PCI("After shift 0x%x\n", value);
+
+    switch (Width)
+    {
+    case BITS_FOR_STRUCTURE(BYTE):
+        *Value = value & MAX_BYTE;
+        break;
+    case BITS_FOR_STRUCTURE(WORD):
+        *Value = value & MAX_WORD;
+        break;
+    case BITS_FOR_STRUCTURE(DWORD):
+        *Value = value & MAX_DWORD;
+        break;
+    case BITS_FOR_STRUCTURE(QWORD):
+        {
+            DWORD valueHigh;
+
+            status = _PciSystemReadConfigurationSpace(DeviceLocation,
+                                                     (WORD)Register + 4,
+                                                     &valueHigh
+                                                     );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("PciSystemReadConfigurationSpace", status);
+                return AE_ERROR;
+            }
+            *Value = DWORDS_TO_QWORD(valueHigh, value);
+        }
+        break;
+    default:
+        return AE_BAD_PARAMETER;
+    }
+
+    LOG_TRACE_PCI("Placed value: 0x%X [%u]\n", *Value, Width);
+
+    LOG_FUNC_END;
+
+
+    return AE_OK;
+}
+
+STATUS
+PciSystemWriteConfigurationSpaceGeneric(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      BYTE                    Width,
+    IN      QWORD                   Value
+    )
+{
+    STATUS status;
+    DWORD initialValue;
+    DWORD alignedRegister;
+    BYTE offsetInRegisterBits;
+    DWORD valueToWrite;
+
+    if (!IsAddressAligned(Register, Width / BITS_PER_BYTE))
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    initialValue = 0;
+    alignedRegister = AlignAddressLower(Register, sizeof(DWORD));
+    ASSERT(alignedRegister <= MAX_WORD);
+
+    offsetInRegisterBits = (BYTE)((Register - alignedRegister) * BITS_PER_BYTE);
+    valueToWrite = 0;
+    status = STATUS_SUCCESS;
+
+    LOG_FUNC_START;
+
+    LOG_TRACE_PCI("(%u.%u.%u) Register: 0x%x\n", DeviceLocation.Bus,
+                 DeviceLocation.Device, DeviceLocation.Function, Register);
+    LOG_TRACE_PCI("Value to write: 0x%X [%u]\n", Value, Width);
+
+    // for DWORD and QWORD accesses there is no need to read previous value
+    if (Width < BITS_FOR_STRUCTURE(DWORD))
+    {
+        status = _PciSystemReadConfigurationSpace(DeviceLocation,
+                                                 (WORD)alignedRegister,
+                                                 &initialValue
+                                                 );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("PciSystemReadConfigurationSpace", status);
+            return AE_ERROR;
+        }
+    }
+
+
+
+    switch (Width)
+    {
+    case BITS_FOR_STRUCTURE(BYTE):
+        valueToWrite = (initialValue & ~(MAX_BYTE << offsetInRegisterBits)) | ((Value & MAX_BYTE) << offsetInRegisterBits);
+        break;
+    case BITS_FOR_STRUCTURE(WORD):
+        valueToWrite = (initialValue & ~(MAX_WORD << offsetInRegisterBits)) | ((Value & MAX_WORD) << offsetInRegisterBits);
+        break;
+    case BITS_FOR_STRUCTURE(DWORD):
+    case BITS_FOR_STRUCTURE(QWORD):
+        valueToWrite = QWORD_LOW(Value);
+        break;
+    }
+
+    LOG_TRACE_PCI("Initial value was: 0x%x, Value to write is: 0x%x\n", initialValue, valueToWrite);
+
+    status = _PciSystemWriteConfigurationSpace(DeviceLocation,
+                                              (WORD)alignedRegister,
+                                              (DWORD)valueToWrite
+                                              );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("PciSystemWriteConfigurationSpace", status);
+        return AE_ERROR;
+    }
+
+    if (Width == BITS_FOR_STRUCTURE(QWORD))
+    {
+        LOG_TRACE_PCI("Will write to upper part 0x%x!\n", QWORD_HIGH(Value));
+        status = _PciSystemWriteConfigurationSpace(DeviceLocation,
+                                                 (WORD)alignedRegister + sizeof(DWORD),
+                                                  QWORD_HIGH(Value)
+                                                 );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("PciSystemWriteConfigurationSpace", status);
+            return AE_ERROR;
+        }
+    }
+
+    LOG_FUNC_END;
+
+    return AE_OK;
+
+}
+
+STATUS
+_PciSystemReadConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    OUT     DWORD*                  Value
+    )
+{
+    if( NULL == Value )
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    ASSERT( IsAddressAligned(Register, sizeof(DWORD)));
+
+    if( m_pciSystemData.PciExpressSupport )
+    {
+        if( Register >= PREDEFINED_PCI_EXPRESS_DEVICE_SPACE_SIZE )
+        {
+            LOG_ERROR("PCI express device configuration space is 4096 bytes!\n");
+            return STATUS_DEVICE_SPACE_RANGE_EXCEEDED;
+        }
+
+        PPCI_ROOT_COMPLEX pPciRootComplex = _PciSystemFindRootComplexForDevice(DeviceLocation);
+        if( NULL == pPciRootComplex )
+        {
+            LOG_ERROR("Cannot find PCI root complex for device (%u.%u.%u)\n",
+                      DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function );
+            return STATUS_DEVICE_NOT_CONNECTED;
+        }
+        LOG_TRACE_PCI("Pci device (%u.%u.%u) belongs to root complex [%u,%u]\n",
+                     DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function,
+                     pPciRootComplex->StartBusNumber, pPciRootComplex->EndBusNumber );
+
+        *Value = PciExpressReadConfigurationSpace(pPciRootComplex,DeviceLocation,Register);
+    }
+    else
+    {
+        if( Register >= PREDEFINED_PCI_DEVICE_SPACE_SIZE )
+        {
+            LOG_ERROR("Legacy PCI device configuration space is 256 bytes!\n");
+            return STATUS_DEVICE_SPACE_RANGE_EXCEEDED;
+        }
+
+        *Value = PciReadConfigurationSpace(DeviceLocation, (BYTE) Register);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+_PciSystemWriteConfigurationSpace(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      DWORD                   Value
+    )
+{
+    ASSERT(IsAddressAligned(Register, sizeof(DWORD)));
+
+    if (m_pciSystemData.PciExpressSupport)
+    {
+        if (Register >= PREDEFINED_PCI_EXPRESS_DEVICE_SPACE_SIZE)
+        {
+            LOG_ERROR("PCI express device configuration space is 4096 bytes!\n");
+            return STATUS_DEVICE_SPACE_RANGE_EXCEEDED;
+        }
+
+        PPCI_ROOT_COMPLEX pPciRootComplex = _PciSystemFindRootComplexForDevice(DeviceLocation);
+        if (NULL == pPciRootComplex)
+        {
+            LOG_ERROR("Cannot find PCI root complex for device (%u.%u.%u)\n",
+                      DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function);
+            return STATUS_DEVICE_NOT_CONNECTED;
+        }
+        LOG_TRACE_PCI("Pci device (%u.%u.%u) belongs to root complex [%u,%u]\n",
+                     DeviceLocation.Bus, DeviceLocation.Device, DeviceLocation.Function,
+                     pPciRootComplex->StartBusNumber, pPciRootComplex->EndBusNumber);
+
+        PciExpressWriteConfigurationSpace(pPciRootComplex, DeviceLocation, Register, Value);
+    }
+    else
+    {
+        if (Register >= PREDEFINED_PCI_DEVICE_SPACE_SIZE)
+        {
+            LOG_ERROR("Legacy PCI device configuration space is 256 bytes!\n");
+            return STATUS_DEVICE_SPACE_RANGE_EXCEEDED;
+        }
+
+        PciWriteConfigurationSpace(DeviceLocation, (BYTE)Register, Value);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_PciSystemInitRootComplexEntry(
+    IN          ACPI_MCFG_ALLOCATION*       AcpiEntry,
+    OUT_PTR     PPCI_ROOT_COMPLEX_ENTRY*    RootComplexEntry
+    )
+{
+    PCI_ROOT_COMPLEX_ENTRY* pRootComplexEntry;
+    DWORD bytesToMap;
+
+    ASSERT(NULL != AcpiEntry);
+    ASSERT(NULL != RootComplexEntry);
+    ASSERT(AcpiEntry->PciSegment == 0);
+
+    pRootComplexEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PCI_ROOT_COMPLEX_ENTRY), HEAP_PCI_TAG, 0 );
+    if (NULL == pRootComplexEntry)
+    {
+        LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PCI_ROOT_COMPLEX_ENTRY));
+        return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+    }
+
+    pRootComplexEntry->RootComplex.StartBusNumber = AcpiEntry->StartBusNumber;
+    pRootComplexEntry->RootComplex.EndBusNumber = AcpiEntry->EndBusNumber;
+
+    bytesToMap = ( pRootComplexEntry->RootComplex.EndBusNumber - pRootComplexEntry->RootComplex.StartBusNumber + 1 ) * MB_SIZE;
+
+    LOGL("Will map %u bytes at PA 0x%X\n", bytesToMap, AcpiEntry->Address );
+    pRootComplexEntry->RootComplex.BaseAddress = IoMapMemory((PHYSICAL_ADDRESS) AcpiEntry->Address,
+                                                             bytesToMap,
+                                                             PAGE_RIGHTS_READWRITE
+                                                             );
+    if (NULL == pRootComplexEntry->RootComplex.BaseAddress)
+    {
+        LOG_ERROR("IoMapMemory failed for mapping 0x%x bytes at address 0x%X\n", bytesToMap, AcpiEntry->Address );
+        return STATUS_MEMORY_CANNOT_BE_MAPPED;
+    }
+
+    *RootComplexEntry = pRootComplexEntry;
+                                            
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_PciSystemRetrievePciExpressDevices(
+    INOUT   PLIST_ENTRY     PciDeviceList,
+    OUT     PDWORD          NumberOfDevices
+    )
+{
+    STATUS status;
+    PLIST_ENTRY pEntry;
+    DWORD noOfDevicesRetrieved;
+
+    ASSERT( NULL != PciDeviceList );
+    ASSERT( NULL != NumberOfDevices);
+
+    status = STATUS_SUCCESS;
+    noOfDevicesRetrieved = 0;
+
+    for (pEntry = m_pciSystemData.PciRootComplexList.Flink;
+         pEntry != &m_pciSystemData.PciRootComplexList;
+         pEntry = pEntry->Flink)
+    {
+        PCI_ROOT_COMPLEX_ENTRY* pRootComplex = CONTAINING_RECORD(pEntry, PCI_ROOT_COMPLEX_ENTRY, ListEntry);
+        BOOLEAN bRestartSearch = TRUE;
+        PCI_DEVICE_LIST_ENTRY* pPciDeviceEntry = NULL;
+
+#pragma warning(suppress:4127)
+        while (TRUE)
+        {
+            ASSERT(NULL == pPciDeviceEntry);
+
+            pPciDeviceEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PCI_DEVICE_LIST_ENTRY), HEAP_PCI_TAG, 0);
+            if (NULL == pPciDeviceEntry)
+            {
+                LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(PCI_DEVICE_LIST_ENTRY));
+                return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            }
+
+                status = PciExpressRetrieveNextDevice(&pRootComplex->RootComplex, bRestartSearch, &pPciDeviceEntry->PciDevice);
+                if (STATUS_DEVICE_NO_MORE_DEVICES == status)
+                {
+                    // exhausted PCI device space
+                    status = STATUS_SUCCESS;
+                    break;
+                }
+
+                if (!SUCCEEDED(status))
+                {
+                    // we failed, why?
+                    LOG_FUNC_ERROR("PciExpressRetrieveNextDevice", status);
+                    break;
+                }
+
+
+            // if we're here we succeeded => we can add entry to linked list
+            InsertTailList(PciDeviceList, &pPciDeviceEntry->ListEntry);
+            noOfDevicesRetrieved = noOfDevicesRetrieved + 1;
+            if (LogIsComponentTraced(LogComponentPci))
+            {
+                DumpPciDevice(&pPciDeviceEntry->PciDevice);
+            }
+
+            // set to NULL so we won't free it at the end
+            pPciDeviceEntry = NULL;
+
+            bRestartSearch = FALSE;
+        }
+
+        if (NULL != pPciDeviceEntry)
+        {
+            ExFreePoolWithTag(pPciDeviceEntry, HEAP_PCI_TAG);
+            pPciDeviceEntry = NULL;
+        }
+    }
+
+    *NumberOfDevices = noOfDevicesRetrieved;
+
+    return status;
+}
+
+static
+STATUS
+_PciSystemRetrievePciDevices(
+    INOUT   PLIST_ENTRY     PciDeviceList,
+    OUT     PDWORD          NumberOfDevices
+    )
+{
+    STATUS status;
+    DWORD noOfDevicesRetrieved;
+    PPCI_DEVICE_LIST_ENTRY pPciDeviceEntry;
+    BOOLEAN bRestartSearch;
+
+    ASSERT(NULL != PciDeviceList);
+    ASSERT(NULL != NumberOfDevices);
+
+    noOfDevicesRetrieved = 0;
+    pPciDeviceEntry = NULL;
+    bRestartSearch = TRUE;
+    status = STATUS_SUCCESS;
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        ASSERT(NULL == pPciDeviceEntry);
+
+        pPciDeviceEntry = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PCI_DEVICE_LIST_ENTRY) + PREDEFINED_PCI_DEVICE_SPACE_SIZE, HEAP_PCI_TAG, 0);
+        if (NULL == pPciDeviceEntry)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(PCI_DEVICE_LIST_ENTRY));
+            return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+        }
+
+        pPciDeviceEntry->PciDevice.DeviceData = (PPCI_DEVICE) ( (PBYTE) pPciDeviceEntry + sizeof(PCI_DEVICE_LIST_ENTRY) );
+        status = PciRetrieveNextDevice(bRestartSearch, PREDEFINED_PCI_DEVICE_SPACE_SIZE, &pPciDeviceEntry->PciDevice);
+        if (STATUS_DEVICE_NO_MORE_DEVICES == status)
+        {
+            // exhausted PCI device space
+            status = STATUS_SUCCESS;
+            break;
+        }
+
+        if (!SUCCEEDED(status))
+        {
+            // we failed, why?
+            LOG_FUNC_ERROR("PciRetrieveNextDevice", status);
+            break;
+        }
+
+        // if we're here we succeeded => we can add entry to linked list
+        InsertTailList(PciDeviceList, &pPciDeviceEntry->ListEntry);
+        noOfDevicesRetrieved = noOfDevicesRetrieved + 1;
+        if (LogIsComponentTraced(LogComponentPci))
+        {
+            DumpPciDevice(&pPciDeviceEntry->PciDevice);
+        }
+
+        // set to NULL so we won't free it at the end
+        pPciDeviceEntry = NULL;
+
+        bRestartSearch = FALSE;
+    }
+
+
+
+    if (NULL != pPciDeviceEntry)
+    {
+        ExFreePoolWithTag(pPciDeviceEntry, HEAP_PCI_TAG);
+        pPciDeviceEntry = NULL;
+    }
+
+    *NumberOfDevices = noOfDevicesRetrieved;
+    
+    return status;
+}
+
+static
+STATUS
+_PciSystemRetrieveParentForDevice(
+    IN      PLIST_ENTRY                 BridgeList,
+    IN      BYTE                        Bus,
+    OUT     PPCI_DEVICE_DESCRIPTION*    ParentDevice
+    )
+{
+    ASSERT(NULL != BridgeList);
+    ASSERT(0 != Bus);
+    ASSERT(NULL != ParentDevice);
+
+    for(PLIST_ENTRY pEntry = BridgeList->Flink;
+        pEntry != BridgeList;
+        pEntry = pEntry->Flink)
+    {
+        PPCI_DEVICE_LIST_ENTRY pDevice = CONTAINING_RECORD(pEntry, PCI_DEVICE_LIST_ENTRY, BridgeEntry);
+
+        ASSERT(pDevice->PciDevice.DeviceData->Header.HeaderType.Layout == PCI_HEADER_LAYOUT_PCI_TO_PCI);
+
+        if( pDevice->PciDevice.DeviceData->Header.Bridge.SecondaryBusNumber == Bus)
+        {
+            *ParentDevice = &pDevice->PciDevice;
+            return STATUS_SUCCESS;
+        }
+    }
+
+    return STATUS_ELEMENT_NOT_FOUND;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/perf_framework.c b/src_proiect/HAL9000/src/perf_framework.c
new file mode 100644
index 0000000..147964e
--- /dev/null
+++ b/src_proiect/HAL9000/src/perf_framework.c
@@ -0,0 +1,138 @@
+#include "HAL9000.h"
+#include "perf_framework.h"
+#include "iomu.h"
+#include "rtc.h"
+
+void
+RunPerformanceFunction(
+    IN      PFUNC_TestPerformance   Function,
+    IN_OPT  PVOID                   Context,
+    IN      DWORD                   IterationCount,
+    IN      BOOLEAN                 MeasureInUs,
+    OUT     PPERFORMANCE_STATS      PerfStats
+    )
+{
+    QWORD startTick;
+    QWORD endTick;
+    QWORD* allTimes;
+    QWORD totalTime;
+    QWORD minTime;
+    QWORD maxTime;
+    QWORD meanTime;
+    DWORD i;
+
+    ASSERT( NULL != Function );
+    ASSERT( NULL != PerfStats );
+
+    allTimes = NULL;
+
+    allTimes = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+                                     sizeof(QWORD) * IterationCount,
+                                     HEAP_TEST_TAG,
+                                     0
+                                     );
+
+    for (i = 0; i < IterationCount; ++i)
+    {
+        BOOLEAN logState;
+
+        logState = LogSetState(FALSE);
+        startTick = RtcGetTickCount();
+        Function(Context);
+        endTick = RtcGetTickCount();
+        LogSetState(logState);
+
+        if (endTick == startTick)
+        {
+            /// TODO: why the fuck does this happen?
+            LOG_ERROR("End tick: 0x%X\nStart tick: 0x%X\n", endTick, startTick);
+            endTick = endTick + 1;
+        }
+        ASSERT_INFO( endTick > startTick, 
+                    "End tick: 0x%X\nStart tick: 0x%X\n", endTick, startTick );
+        allTimes[i] = endTick - startTick;
+    }
+
+
+    ASSERT(NULL != allTimes);
+
+    totalTime = minTime = maxTime = allTimes[0];
+
+    for (i = 1; i < IterationCount; ++i)
+    {
+        if (allTimes[i] < minTime)
+        {
+            minTime = allTimes[i];
+        }
+        else if (allTimes[i] > maxTime)
+        {
+            maxTime = allTimes[i];
+        }
+
+        ASSERT (MAX_QWORD - allTimes[i] >= totalTime);
+
+        totalTime = totalTime + allTimes[i];
+    }
+    meanTime = totalTime / IterationCount;
+
+    PerfStats->Min = MeasureInUs ? IomuTickCountToUs(minTime) : minTime;
+    PerfStats->Max = MeasureInUs ? IomuTickCountToUs(maxTime) : maxTime;
+    PerfStats->Mean = MeasureInUs ? IomuTickCountToUs(meanTime) : meanTime;
+
+    if (NULL != allTimes)
+    {
+        ExFreePoolWithTag(allTimes, HEAP_TEST_TAG);
+        allTimes = NULL;
+    }
+}
+
+void
+DisplayPerformanceStats(
+    IN_READS(NumberOfStats)
+            PPERFORMANCE_STATS      PerfStats,
+    IN      DWORD                   NumberOfStats,
+    IN_READS(NumberOfStats)
+            char**                  StatNames
+    )
+{
+    BOOLEAN bExit;
+
+    bExit = FALSE;
+
+    for (DWORD i = 0; i < NumberOfStats; ++i)
+    {
+        LOG("%s performance\n", StatNames[i]);
+        LOG("Mean time: 0x%X\n", PerfStats[i].Mean);
+        LOG("Min time: 0x%X\n", PerfStats[i].Min);
+        LOG("Max time: 0x%X\n", PerfStats[i].Max);
+
+        if ((PerfStats[i].Mean == 0)
+            || (PerfStats[i].Min == 0)
+            || (PerfStats[i].Max == 0)
+            )
+        {
+            bExit = TRUE;
+        }
+    }
+
+    if (bExit)
+    {
+        return;
+    }
+
+    if (NumberOfStats == 2)
+    {
+        QWORD speedUp;
+
+        LOG("[%s] versus [%s]\n", StatNames[1], StatNames[0]);
+
+        speedUp = (PerfStats[0].Mean * 1000) / PerfStats[1].Mean;
+        LOG("Mean time speed-up: %2u.%03u\n", speedUp / 1000, speedUp % 1000);
+
+        speedUp = (PerfStats[0].Max * 1000) / PerfStats[1].Min;
+        LOG("Greatest speed-up: %2u.%03u\n", speedUp / 1000, speedUp % 1000);
+
+        speedUp = (PerfStats[0].Min * 1000) / PerfStats[1].Max;
+        LOG("Lowest speed-up: %2u.%03u\n", speedUp / 1000, speedUp % 1000);
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/pmm.c b/src_proiect/HAL9000/src/pmm.c
new file mode 100644
index 0000000..bbbc5fb
--- /dev/null
+++ b/src_proiect/HAL9000/src/pmm.c
@@ -0,0 +1,370 @@
+#include "HAL9000.h"
+#include "pmm.h"
+#include "int15.h"
+#include "bitmap.h"
+#include "synch.h"
+
+typedef struct _MEMORY_REGION_LIST
+{
+    MEMORY_MAP_TYPE     Type;
+    DWORD               NumberOfEntries;
+} MEMORY_REGION_LIST, *PMEMORY_REGION_LIST;
+
+typedef struct _PMM_DATA
+{
+    // Both of the highest physical address values are setup on initialization and
+    // remain unchanged, i.e. if the highest available address becomes later reserved
+    // HighestPhysicalAddressAvailable will not change.
+
+    // This points to the end of the highest physical address available in the system
+    // i.e. this is not reserved and can be used
+    // E.g: if the last available memory region starts at 0xFFFE'0000 and occupies a
+    // page HighestPhysicalAddressAvailable will be 0xFFFE'1000
+    PHYSICAL_ADDRESS    HighestPhysicalAddressAvailable;
+
+    // This includes the memory already reserved in the system, it is greater than or
+    // equal to HighestPhysicalAddressAvailable, depending on the arrangement of
+    // memory in the system.
+    PHYSICAL_ADDRESS    HighestPhysicalAddressPresent;
+
+    // Total size of available memory over 1MB
+    QWORD               PhysicalMemorySize;
+
+    MEMORY_REGION_LIST  MemoryRegionList[MemoryMapTypeMax];
+
+    LOCK                AllocationLock;
+
+    _Guarded_by_(AllocationLock)
+    BITMAP              AllocationBitmap;
+} PMM_DATA, *PPMM_DATA;
+
+static PMM_DATA m_pmmData;
+
+static
+void
+_PmmDetermineMemoryLimits(
+    IN_READS(NoOfEntries)               INT15_MEMORY_MAP_ENTRY*     MemoryMap,
+    IN_RANGE_LOWER(1)                   DWORD                       NoOfEntries,
+    OUT                                 QWORD*                      AvailableSystemMemory,
+    OUT                                 PHYSICAL_ADDRESS*           HighestPresentPhysicalAddress,
+    OUT                                 PHYSICAL_ADDRESS*           HighestAvailablePhysicalAddress,
+    INOUT_UPDATES_ALL(MemoryMapTypeMax) PMEMORY_REGION_LIST         MemoryRegions
+    );
+
+static
+void
+_PmmInitializeAllocationBitmap(
+    IN                          PVOID                       CurrentVirtualAddress,
+    IN                          QWORD                       HighestMemoryAddress,
+    IN                          PINT15_MEMORY_MAP_ENTRY     MemoryEntries,
+    IN                          DWORD                       NumberOfMemoryEntries,
+    OUT                         PBITMAP                     Bitmap,
+    OUT                         DWORD*                      SizeReserved
+    );
+
+_No_competing_thread_
+void
+PmmPreinitSystem(
+    void
+    )
+{
+    DWORD i;
+
+    memzero(&m_pmmData, sizeof(PMM_DATA));
+
+    for (i = MemoryMapTypeUsableRAM; i < MemoryMapTypeMax; ++i)
+    {
+        m_pmmData.MemoryRegionList[i].Type = i;
+    }
+
+    LockInit(&m_pmmData.AllocationLock);
+}
+
+_No_competing_thread_
+STATUS
+PmmInitSystem(
+    IN          PVOID                   BaseAddress,
+    IN          PINT15_MEMORY_MAP_ENTRY MemoryEntries,
+    IN          DWORD                   NumberOfMemoryEntries,
+    OUT         DWORD*                  SizeReserved
+    )
+{
+    QWORD pagingStructuresSize;
+    DWORD sizeReserved;
+
+    if (NULL == BaseAddress)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == MemoryEntries)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == NumberOfMemoryEntries)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (NULL == SizeReserved)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    pagingStructuresSize = 0;
+    sizeReserved = 0;
+
+    _PmmDetermineMemoryLimits(MemoryEntries,
+                              NumberOfMemoryEntries,
+                              &m_pmmData.PhysicalMemorySize,
+                              &m_pmmData.HighestPhysicalAddressPresent,
+                              &m_pmmData.HighestPhysicalAddressAvailable,
+                              m_pmmData.MemoryRegionList
+                              );
+
+    LOG("Physical memory size: 0x%X\n", m_pmmData.PhysicalMemorySize );
+    LOG("Highest Physical address present: 0x%X\n", m_pmmData.HighestPhysicalAddressPresent);
+    LOG("Highest Physical address available: 0x%X\n", m_pmmData.HighestPhysicalAddressAvailable);
+
+    _PmmInitializeAllocationBitmap(BaseAddress,
+                                   (QWORD) m_pmmData.HighestPhysicalAddressPresent,
+                                   MemoryEntries,
+                                   NumberOfMemoryEntries,
+                                   &m_pmmData.AllocationBitmap,
+                                   &sizeReserved
+                                   );
+
+    LOG("_PmmInitializeAllocationBitmap completed successfully\n");
+
+    *SizeReserved = AlignAddressUpper( sizeReserved, PAGE_SIZE );
+
+    return STATUS_SUCCESS;
+}
+
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+PmmReserveMemoryEx(
+    IN          DWORD                   NoOfFrames,
+    IN_OPT      PHYSICAL_ADDRESS        MinPhysAddr
+    )
+{
+    DWORD idx;
+    QWORD startIdx;
+
+    INTR_STATE oldState;
+
+    if( 0 == NoOfFrames )
+    {
+        return NULL;
+    }
+
+    if (!IsAddressAligned(MinPhysAddr, PAGE_SIZE))
+    {
+        return NULL;
+    }
+
+    startIdx = (QWORD) MinPhysAddr / PAGE_SIZE;
+    if (startIdx > MAX_DWORD)
+    {
+        return NULL;
+    }
+
+    LockAcquire( &m_pmmData.AllocationLock, &oldState);
+    idx = BitmapScanFromAndFlip(&m_pmmData.AllocationBitmap, (DWORD) startIdx, NoOfFrames, FALSE );
+    if (MAX_DWORD == idx)
+    {
+        LockRelease( &m_pmmData.AllocationLock, oldState);
+        return NULL;
+    }
+
+    LockRelease( &m_pmmData.AllocationLock, oldState);
+
+    return (PHYSICAL_ADDRESS) ( (QWORD) idx * PAGE_SIZE );
+}
+
+void
+PmmReleaseMemory(
+    IN          PHYSICAL_ADDRESS        PhysicalAddr,
+    IN          DWORD                   NoOfFrames
+    )
+{
+    QWORD index;
+    INTR_STATE oldState;
+
+    ASSERT( IsAddressAligned(PhysicalAddr, PAGE_SIZE));
+
+    index = (QWORD) PhysicalAddr / PAGE_SIZE;
+
+    ASSERT( index <= MAX_DWORD);
+
+    LockAcquire( &m_pmmData.AllocationLock, &oldState);
+    BitmapClearBits(&m_pmmData.AllocationBitmap, (DWORD) index, NoOfFrames);
+    LockRelease( &m_pmmData.AllocationLock, oldState);
+}
+
+QWORD
+PmmGetTotalSystemMemory(
+    void
+    )
+{
+    return m_pmmData.PhysicalMemorySize;
+}
+
+PHYSICAL_ADDRESS
+PmmGetHighestPhysicalMemoryAddressPresent(
+    void
+    )
+{
+    return m_pmmData.HighestPhysicalAddressPresent;
+}
+
+PHYSICAL_ADDRESS
+PmmGetHighestPhysicalMemoryAddressAvailable(
+    void
+    )
+{
+    return m_pmmData.HighestPhysicalAddressAvailable;
+}
+
+static
+void
+_PmmDetermineMemoryLimits(
+    IN_READS(NoOfEntries)               INT15_MEMORY_MAP_ENTRY*     MemoryMap,
+    IN_RANGE_LOWER(1)                   DWORD                       NoOfEntries,
+    OUT                                 QWORD*                      AvailableSystemMemory,
+    OUT                                 PHYSICAL_ADDRESS*           HighestPresentPhysicalAddress,
+    OUT                                 PHYSICAL_ADDRESS*           HighestAvailablePhysicalAddress,
+    INOUT_UPDATES_ALL(MemoryMapTypeMax) PMEMORY_REGION_LIST         MemoryRegions
+    )
+{
+    DWORD i;
+    QWORD sizeOfAvailableMemory;
+    QWORD highestMemoryAddressPresent;
+    QWORD highestMemoryAddressAvailable;
+    DWORD memoryType;
+
+    ASSERT(NULL != MemoryMap);
+    ASSERT(0 != NoOfEntries);
+    ASSERT(NULL != AvailableSystemMemory);
+    ASSERT(NULL != HighestPresentPhysicalAddress);
+    ASSERT(NULL != HighestAvailablePhysicalAddress);
+    ASSERT(NULL != MemoryRegions);
+
+    sizeOfAvailableMemory = 0;
+    highestMemoryAddressPresent = 0;
+    highestMemoryAddressAvailable = 0;
+
+    for (i = 0; i < NoOfEntries; ++i)
+    {
+        memoryType = MemoryMap[i].Type;
+
+        if (MemoryMap[i].BaseAddress + MemoryMap[i].Length > highestMemoryAddressPresent)
+        {
+            highestMemoryAddressPresent = MemoryMap[i].BaseAddress + MemoryMap[i].Length;
+        }
+
+        if (!IsBooleanFlagOn(MemoryMap[i].ExtendedAttributes, MEMORY_MAP_ENTRY_EA_VALID_ENTRY))
+        {
+            // if this flag is clear => entry should be ignored
+            continue;
+        }
+
+        MemoryRegions[memoryType].NumberOfEntries++;
+
+        if (MemoryMapTypeUsableRAM != memoryType)
+        {
+            // we only care about usable RAM memory
+            continue;
+        }
+
+        if (MemoryMap[i].BaseAddress + MemoryMap[i].Length > highestMemoryAddressAvailable)
+        {
+            highestMemoryAddressAvailable = MemoryMap[i].BaseAddress + MemoryMap[i].Length;
+        }
+
+        sizeOfAvailableMemory = sizeOfAvailableMemory + MemoryMap[i].Length;
+    }
+
+    *AvailableSystemMemory = sizeOfAvailableMemory;
+    *HighestPresentPhysicalAddress = (PHYSICAL_ADDRESS) highestMemoryAddressPresent;
+    *HighestAvailablePhysicalAddress = (PHYSICAL_ADDRESS) highestMemoryAddressAvailable;
+}
+
+static
+void
+_PmmInitializeAllocationBitmap(
+    IN                          PVOID                       CurrentVirtualAddress,
+    IN                          QWORD                       HighestMemoryAddress,
+    IN                          PINT15_MEMORY_MAP_ENTRY     MemoryEntries,
+    IN                          DWORD                       NumberOfMemoryEntries,
+    OUT                         PBITMAP                     Bitmap,
+    OUT                         DWORD*                      SizeReserved
+    )
+{
+    DWORD bitmapSize;
+    QWORD noOfPhysicalFrames;
+    DWORD i;
+    DWORD memoryType;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != CurrentVirtualAddress);
+    ASSERT( 0 != HighestMemoryAddress );
+    ASSERT( NULL != Bitmap );
+    ASSERT( NULL != SizeReserved );
+
+    noOfPhysicalFrames = HighestMemoryAddress / PAGE_SIZE;
+    ASSERT( noOfPhysicalFrames <= MAX_DWORD);
+
+    bitmapSize = BitmapPreinit(Bitmap, (DWORD) noOfPhysicalFrames);
+    BitmapInit(Bitmap, CurrentVirtualAddress );
+
+    LOG("Bitmap size: %u B\n", bitmapSize );
+
+    *SizeReserved = bitmapSize;
+
+    // The idea here is to reserve all possible physical memory
+    // PA 0 ----> HighestMemoryAddress
+    // and then mark as free only only usable RAM memory over 1MB
+    // This means in-existent and reserved system memory will never be used
+
+    PmmReserveMemory(BitmapGetMaxElementCount(Bitmap));
+
+    LOG("All memory is now reserved\n");
+
+    for (i = 0; i < NumberOfMemoryEntries; ++i)
+    {
+        memoryType = MemoryEntries[i].Type;
+
+        if (!IsBooleanFlagOn(MemoryEntries[i].ExtendedAttributes, MEMORY_MAP_ENTRY_EA_VALID_ENTRY))
+        {
+            // if this flag is clear => entry should be ignored
+            continue;
+        }
+
+        if (MemoryMapTypeUsableRAM != memoryType)
+        {
+            // we only care about usable RAM memory
+            continue;
+        }
+
+        if (MemoryEntries[i].BaseAddress < 1 * MB_SIZE)
+        {
+            // we won't be allocating any memory under 1MB
+            continue;
+        }
+
+        PHYSICAL_ADDRESS physAddr = (PHYSICAL_ADDRESS) AlignAddressUpper(MemoryEntries[i].BaseAddress, PAGE_SIZE);
+        QWORD noOfFrames = MemoryEntries[i].Length / PAGE_SIZE;
+
+        ASSERT( noOfFrames <= MAX_DWORD);
+
+        // here it is necessary to use PmmReleaseMemory
+        PmmReleaseMemory(physAddr, (DWORD) noOfFrames );
+
+        LOG("Releasing %d frames of memory starting from PA 0x%X\n", noOfFrames, physAddr );
+    }
+
+    LOG_FUNC_END;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/print.c b/src_proiect/HAL9000/src/print.c
new file mode 100644
index 0000000..be1dfc9
--- /dev/null
+++ b/src_proiect/HAL9000/src/print.c
@@ -0,0 +1,101 @@
+#include "HAL9000.h"
+#include "print.h"
+#include "display.h"
+#include "va_list.h"
+#include "synch.h"
+
+#define SCREEN_BUFFER_SIZE          MAX_PATH
+
+static char m_printBuffer[SCREEN_BUFFER_SIZE] = { 0 };
+static LOCK m_printLock;
+
+void
+printSystemPreinit(
+    IN_OPT  PVOID   DisplayAddress
+    )
+{
+    PVOID pAddr;
+
+    pAddr = NULL == DisplayAddress ? (PVOID) PA2VA(BASE_VIDEO_ADDRESS) : DisplayAddress;
+
+    DispPreinitScreen( pAddr, 1, LINES_PER_SCREEN - 1);
+    LockInit(&m_printLock);
+}
+
+static
+void
+_vprintColor(
+    IN_Z    char*   Format,
+    INOUT   va_list Args,
+    IN      BYTE    Color
+    )
+{
+    COLOR prevColor;
+    INTR_STATE oldState;
+
+    LockAcquire(&m_printLock, &oldState);
+
+    vsnprintf(m_printBuffer, SCREEN_BUFFER_SIZE, Format, Args);
+    
+    prevColor = DispGetColor();
+    DispSetColor(Color);
+    
+    DispPrintString(m_printBuffer);
+
+    DispSetColor(prevColor);
+
+    LockRelease(&m_printLock, oldState);
+}
+
+void
+perror(
+    IN_Z    char*   Format,
+    ...
+    )
+{
+    va_list argPtr;
+
+    va_start(argPtr, Format);
+
+    _vprintColor(Format, argPtr, RED_COLOR);
+}
+
+void
+pwarn(
+    IN_Z    char*   Format,
+    ...
+    )
+{
+    va_list argPtr;
+
+    va_start(argPtr, Format);
+
+    _vprintColor(Format, argPtr, YELLOW_COLOR);
+}
+
+void
+printf(
+    IN_Z    char*   Format,
+    ...
+    )
+{
+    va_list argPtr;
+
+    va_start(argPtr, Format);
+
+    _vprintColor(Format, argPtr, WHITE_COLOR);
+}
+
+void
+printColor(
+    IN      BYTE    Color,
+    IN_Z    char*   Format,
+    ...
+    )
+{
+    va_list argPtr;
+
+    va_start(argPtr, Format);
+
+    _vprintColor(Format, argPtr, Color);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/process.c b/src_proiect/HAL9000/src/process.c
new file mode 100644
index 0000000..e439b67
--- /dev/null
+++ b/src_proiect/HAL9000/src/process.c
@@ -0,0 +1,764 @@
+#include "HAL9000.h"
+#include "mutex.h"
+#include "thread_internal.h"
+#include "process_internal.h"
+#include "vmm.h"
+#include "um_application.h"
+#include "bitmap.h"
+#include "pte.h"
+#include "pe_exports.h"
+
+typedef struct _PROCESS_SYSTEM_DATA
+{
+    MUTEX           PidBitmapLock;
+
+    _Guarded_by_(PidBitmapLock)
+    BITMAP          PidBitmap;
+    BYTE            PidBitmapBuffer[PCID_TOTAL_NO_OF_VALUES/BITS_PER_BYTE];
+
+    PPROCESS        SystemProcess;
+
+    LIST_ENTRY      ProcessList;
+    MUTEX           ProcessListLock;
+} PROCESS_SYSTEM_DATA, *PPROCESS_SYSTEM_DATA;
+
+static PROCESS_SYSTEM_DATA m_processData;
+
+static
+__forceinline
+PID
+_ProcessSystemRetrieveNextPid(
+    void
+    )
+{
+    PID idx;
+
+    MutexAcquire(&m_processData.PidBitmapLock);
+    idx = BitmapScanAndFlip(&m_processData.PidBitmap, 1, FALSE);
+    MutexRelease(&m_processData.PidBitmapLock);
+
+    ASSERT(PCID_IS_VALID(idx));
+
+    return idx;
+}
+
+static
+__forceinline
+void
+_ProcessSystemFreePid(
+    IN      PID             ProcessId
+    )
+{
+    ASSERT(PCID_IS_VALID(ProcessId));
+
+    MutexAcquire(&m_processData.PidBitmapLock);
+    ASSERT_INFO(BitmapGetBitValue(&m_processData.PidBitmap, (DWORD) ProcessId),
+                "How can we free a process ID which is not used?!");
+    BitmapClearBit(&m_processData.PidBitmap, (DWORD) ProcessId);
+    MutexRelease(&m_processData.PidBitmapLock);
+}
+
+__forceinline
+static
+void
+_ProcessReference(
+    INOUT   PPROCESS        Process
+    )
+{
+    ASSERT(NULL != Process);
+
+    RfcReference(&Process->RefCnt);
+}
+
+__forceinline
+static
+void
+_ProcessDereference(
+    INOUT   PPROCESS        Process
+    )
+{
+    ASSERT(NULL != Process);
+
+    RfcDereference(&Process->RefCnt);
+}
+
+static
+STATUS
+_No_competing_thread_
+_ProcessInit(
+    IN_Z        char*       Name,
+    IN_OPT_Z    char*       Arguments,
+    OUT_PTR     PPROCESS*   Process
+    );
+
+static
+STATUS
+_ProcessParseCommandLine(
+    INOUT       PPROCESS    Process,
+    IN_OPT_Z    char*       CommandLine
+    );
+
+// Called when the reference count reaches zero
+static FUNC_FreeFunction            _ProcessDestroy;
+
+_No_competing_thread_
+void
+ProcessSystemPreinit(
+    void
+    )
+{
+    memzero(&m_processData, sizeof(PROCESS_SYSTEM_DATA));
+
+    ASSERT(ARRAYSIZE(m_processData.PidBitmapBuffer) == BitmapPreinit(&m_processData.PidBitmap, PCID_TOTAL_NO_OF_VALUES));
+
+    BitmapInit(&m_processData.PidBitmap, m_processData.PidBitmapBuffer);
+
+    // the value zero cannot be used when CR4.PCIDE == 1, i.e. when PCID are used
+    BitmapSetBit(&m_processData.PidBitmap, 0);
+
+    MutexInit(&m_processData.PidBitmapLock, FALSE);
+
+    MutexInit(&m_processData.ProcessListLock, FALSE);
+    InitializeListHead(&m_processData.ProcessList);
+}
+
+_No_competing_thread_
+STATUS
+ProcessSystemInitSystemProcess(
+    void
+    )
+{
+    STATUS status;
+    PPROCESS pProcess;
+
+    status = _ProcessInit("System", NULL, &pProcess);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_ProcessInit", status);
+        return status;
+    }
+
+    // This must be set here (as early as possible), it will be used by many process and MMU functions
+    // to validate they are called accordingly
+    m_processData.SystemProcess = pProcess;
+
+    LOG_TRACE_PROCESS("Will initialize virtual space for system process!\n");
+
+    MmuInitAddressSpaceForSystemProcess();
+
+    // When this function will be called only the BSP will be active and only its main
+    // thread will be running
+    ProcessInsertThreadInList(pProcess, GetCurrentThread());
+
+    return status;
+}
+
+PPROCESS
+ProcessRetrieveSystemProcess(
+    void
+    )
+{
+    return m_processData.SystemProcess;
+}
+
+STATUS
+ProcessExecuteForEachProcessEntry(
+    IN      PFUNC_ListFunction  Function,
+    IN_OPT  PVOID               Context
+    )
+{
+    STATUS status;
+
+    if (NULL == Function)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+
+    MutexAcquire(&m_processData.ProcessListLock);
+    status = ForEachElementExecute(&m_processData.ProcessList,
+                                   Function,
+                                   Context,
+                                   FALSE
+                                   );
+    MutexRelease(&m_processData.ProcessListLock);
+
+    return status;
+}
+
+//  warning C26130: Missing annotation _Requires_lock_held_(Process->PagingData->Lock) or _No_competing_thread_ at function 'ProcessActivatePagingTables'.
+// Otherwise it could be a race condition. Variable 'Process->PagingData->Data' should be protected by lock 'Process->PagingData->Lock'.
+// I do remember having a look at this function a lot of times, it's OK (I don't remember what the problem is though :( )
+#pragma warning(push)
+#pragma warning(disable:26130)
+
+void
+ProcessActivatePagingTables(
+    IN      PPROCESS            Process,
+    IN      BOOLEAN             InvalidateAddressSpace
+    )
+{
+    ASSERT(Process != NULL);
+
+    ASSERT(PCID_IS_VALID(Process->Id));
+
+    VmmChangeCr3(Process->PagingData->Data.BasePhysicalAddress,
+                 (PCID)Process->Id,
+                 InvalidateAddressSpace);
+}
+#pragma warning(pop)
+
+STATUS
+ProcessCreate(
+    IN_Z        char*       PathToExe,
+    IN_OPT_Z    char*       Arguments,
+    OUT_PTR     PPROCESS*   Process
+    )
+{
+    STATUS status;
+    PPROCESS pProcess;
+
+    if (PathToExe == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (Process == NULL)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pProcess = NULL;
+
+    __try
+    {
+        // It's impossible to create a process (ATM) without specifying a full PATH
+        // => it's ok to add +1
+        // Even if it were a relative path (in the current folder) it's not a problem:
+        // the commonlib implementation of strrchr returns a pointer to the initial string
+        // if the character is not found
+        status = _ProcessInit(strrchr(PathToExe, '\\') + 1,
+                              Arguments,
+                              &pProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_ProcessInit", status);
+            __leave;
+        }
+        LOG_TRACE_PROCESS("Successfully initialized process!\n");
+
+        // This function must be called before MmuCreateAddressSpaceForProcess to be able to
+        // determine the address from which the VA allocations should start (so they'll not
+        // conflict with the PE image)
+        status = UmApplicationRetrieveHeader(PathToExe, pProcess->HeaderInfo);
+        if (!SUCCEEDED(status))
+        {
+            LOG_TRACE_USERMODE("[ERROR]UmApplicationRetrieveHeader failed with status 0x%x\n", status);
+            __leave;
+        }
+        LOG_TRACE_PROCESS("Successfully retrieved process NT header!\n");
+
+        status = MmuCreateAddressSpaceForProcess(pProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("MmuCreateVirtualSpaceForProcess", status);
+            __leave;
+        }
+        LOG_TRACE_PROCESS("Successfully created VA space for process!\n");
+
+        // Start execution
+        status = UmApplicationRun(pProcess, FALSE, NULL);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmApplicationRun", status);
+            __leave;
+        }
+
+        LOG_TRACE_PROCESS("Successfully ran UM application!\n");
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (pProcess != NULL)
+            {
+                _ProcessDereference(pProcess);
+                pProcess = NULL;
+            }
+        }
+        else
+        {
+            ASSERT(pProcess != NULL);
+
+            // Increment the reference count so the process will still be valid even if it
+            // terminates (i.e. the number of threads reach 0) - this is required because
+            // we return the process pointer and we expect an explicit call to ProcessCloseHandle
+            // to be able to destroy the object (i.e. for its ref count to reach zero)
+            _ProcessReference(pProcess);
+            *Process = pProcess;
+        }
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+void
+ProcessWaitForTermination(
+    IN          PPROCESS    Process,
+    OUT         STATUS*     TerminationStatus
+    )
+{
+    ASSERT(Process != NULL);
+    ASSERT(TerminationStatus != NULL);
+
+    ExEventWaitForSignal(&Process->TerminationEvt);
+    *TerminationStatus = Process->TerminationStatus;
+}
+
+void
+ProcessCloseHandle(
+    _Pre_valid_ _Post_invalid_
+                PPROCESS    Process
+    )
+{
+    ASSERT(Process != NULL);
+
+    _ProcessDereference(Process);
+}
+
+const
+char*
+ProcessGetName(
+    IN_OPT      PPROCESS    Process
+    )
+{
+    return (Process == NULL) ? GetCurrentThread()->Process->ProcessName : Process->ProcessName;
+}
+
+PID
+ProcessGetId(
+    IN_OPT      PPROCESS    Process
+    )
+{
+    return (Process == NULL) ? GetCurrentThread()->Process->Id : Process->Id;
+}
+
+BOOLEAN
+ProcessIsSystem(
+    IN_OPT      PPROCESS    Process
+    )
+{
+    PID pid = (Process == NULL) ? GetCurrentThread()->Process->Id : Process->Id;
+
+    return m_processData.SystemProcess->Id == pid;
+}
+
+void
+ProcessTerminate(
+    INOUT       PPROCESS    Process
+    )
+{
+    PTHREAD pCurrentThread;
+    BOOLEAN bFoundCurThreadInProcess;
+    INTR_STATE oldState;
+
+    if (NULL == Process)
+    {
+        Process = GetCurrentProcess();
+    }
+
+    ASSERT(Process != NULL);
+    ASSERT(!ProcessIsSystem(Process));
+
+    pCurrentThread = GetCurrentThread();
+    bFoundCurThreadInProcess = FALSE;
+
+    // Go through the list of threads and notify each thread of termination
+    // For the current thread (if it belongs to the process being terminated)
+    // explicitly call ThreadExit
+    LockAcquire(&Process->ThreadListLock, &oldState);
+    for (PLIST_ENTRY pEntry = Process->ThreadList.Flink;
+         pEntry != &Process->ThreadList;
+         pEntry = pEntry->Flink)
+    {
+        PTHREAD pThread = CONTAINING_RECORD(pEntry, THREAD, ProcessList);
+
+        if (pThread == pCurrentThread)
+        {
+            LOG_TRACE_PROCESS("Current thread in process we are about to terminate, will use ThreadExit at the end of the loop!\n");
+            bFoundCurThreadInProcess = TRUE;
+            continue;
+        }
+
+        ThreadTerminate(pThread);
+    }
+    LockRelease(&Process->ThreadListLock, oldState);
+
+    if (bFoundCurThreadInProcess)
+    {
+        /// TODO: find out if we should also dereference the process here
+        /// the idea is that the calling thread certainly didn't close the process handle
+        /// => there is that extra reference hanging in the air
+        ThreadExit(STATUS_JOB_INTERRUPTED);
+        NOT_REACHED;
+    }
+}
+
+PPROCESS
+GetCurrentProcess(
+    void
+    )
+{
+    PTHREAD pThread = GetCurrentThread();
+    ASSERT(pThread != NULL);
+
+    return pThread->Process;
+}
+
+static
+STATUS
+_No_competing_thread_
+_ProcessInit(
+    IN_Z        char*       Name,
+    IN_OPT_Z    char*       Arguments,
+    OUT_PTR     PPROCESS*   Process
+    )
+{
+    PPROCESS pProcess;
+    STATUS status;
+    DWORD nameSize;
+    BOOLEAN bRefCntInitialized;
+
+    ASSERT(Name != NULL);
+    ASSERT(Process != NULL);
+
+    pProcess = NULL;
+    status = STATUS_SUCCESS;
+
+    // we add +1 because of the NULL terminator
+    nameSize = (strlen(Name)+1)*sizeof(char);
+    bRefCntInitialized = FALSE;
+
+    __try
+    {
+        pProcess = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PROCESS), HEAP_PROCESS_TAG, 0);
+        if (pProcess == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PROCESS));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        RfcPreInit(&pProcess->RefCnt);
+
+        status = RfcInit(&pProcess->RefCnt, _ProcessDestroy, NULL);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("RfcInit", status);
+            __leave;
+        }
+
+        // It's ok to call ProcessDerefence from this point (the reference counter is initialized)
+        bRefCntInitialized = TRUE;
+
+        status = ExEventInit(&pProcess->TerminationEvt,
+                             ExEventTypeNotification,
+                             FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("ExEventInit", status);
+            __leave;
+        }
+
+        InitializeListHead(&pProcess->NextProcess);
+
+        pProcess->HeaderInfo = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PE_NT_HEADER_INFO), HEAP_PROCESS_TAG, 0);
+        if (NULL == pProcess->HeaderInfo)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PE_NT_HEADER_INFO));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        pProcess->ProcessName = ExAllocatePoolWithTag(PoolAllocateZeroMemory, nameSize, HEAP_PROCESS_TAG, 0);
+        if (NULL == pProcess->ProcessName)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", nameSize);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+        strcpy(pProcess->ProcessName, Name);
+
+        // Setup Process->FullCommandLine
+        status = _ProcessParseCommandLine(pProcess, Arguments);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_ProcessParseCommandLine", status);
+            __leave;
+        }
+        LOG_TRACE_PROCESS("Successfully parsed process command line!\n");
+
+        InitializeListHead(&pProcess->ThreadList);
+        LockInit(&pProcess->ThreadListLock);
+
+        // Do this as late as possible - we want to interfere as little as possible
+        // with the system management in case something goes wrong (PID + full process
+        // list management)
+        pProcess->Id = _ProcessSystemRetrieveNextPid();
+
+        MutexAcquire(&m_processData.ProcessListLock);
+        InsertTailList(&m_processData.ProcessList, &pProcess->NextProcess);
+        MutexRelease(&m_processData.ProcessListLock);
+
+        LOG_TRACE_PROCESS("Process with PID 0x%X created\n", pProcess->Id);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (pProcess != NULL)
+            {
+                bRefCntInitialized ? _ProcessDereference(pProcess) : _ProcessDestroy(pProcess, NULL);
+                pProcess = NULL;
+            }
+        }
+        else
+        {
+            *Process = pProcess;
+        }
+    }
+
+    return status;
+}
+
+static
+STATUS
+_ProcessParseCommandLine(
+    INOUT       PPROCESS    Process,
+    IN_OPT_Z    char*       CommandLine
+    )
+{
+    DWORD fullCmdLineSize;
+    STATUS status;
+    char* pFullCmdLine;
+    DWORD noOfArgs;
+
+    ASSERT(Process != NULL);
+    ASSERT(Process->ProcessName != NULL);
+
+    // strlen(CommandLine) + 1 because we have to add a space char between the program name and the last of the command line
+    // +1 at the end because strlen(Process->ProcessName) returns the length of the process name without the NULL terminator
+    fullCmdLineSize = strlen(Process->ProcessName) +
+                        (CommandLine != NULL ? strlen(CommandLine) + 1 : 0) +
+                        1;
+    pFullCmdLine = NULL;
+    status = STATUS_SUCCESS;
+    noOfArgs = 0;
+
+    __try
+    {
+        pFullCmdLine = ExAllocatePoolWithTag(PoolAllocateZeroMemory, fullCmdLineSize, HEAP_PROCESS_TAG, 0);
+        if (pFullCmdLine == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", fullCmdLineSize);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        status = snprintf(pFullCmdLine, fullCmdLineSize,
+                          CommandLine != NULL ? "%s %s" : "%s",
+                          Process->ProcessName, CommandLine);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("snprintf", status);
+            __leave;
+        }
+
+        LOG_TRACE_PROCESS("Full process command line is [%s]\n", pFullCmdLine);
+
+        noOfArgs = ((CommandLine != NULL) ? strcelem(CommandLine, ' ') : 0);
+        ASSERT(noOfArgs != INVALID_STRING_SIZE);
+
+        LOG_TRACE_PROCESS("Process has %u arguments without the process name!\n", noOfArgs);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (pFullCmdLine != NULL)
+            {
+                ExFreePoolWithTag(pFullCmdLine, HEAP_PROCESS_TAG);
+                pFullCmdLine = NULL;
+            }
+        }
+        else
+        {
+            Process->FullCommandLine = pFullCmdLine;
+
+            // +1 for the ProcessName
+            Process->NumberOfArguments = noOfArgs + 1;
+        }
+    }
+
+    return status;
+}
+
+void
+ProcessInsertThreadInList(
+    INOUT   PPROCESS            Process,
+    INOUT   struct _THREAD*     Thread
+    )
+{
+    DWORD activeThreads;
+    INTR_STATE oldState;
+
+    ASSERT(Process != NULL);
+    ASSERT(Thread != NULL);
+
+    LOG_TRACE_PROCESS("Will insert thread [%s] in process [%s]\n",
+                      ThreadGetName(Thread), ProcessGetName(Process));
+
+    Thread->Process = Process;
+
+    LockAcquire(&Process->ThreadListLock, &oldState);
+
+    ASSERT(Process->NumberOfThreads < MAX_DWORD);
+    Process->NumberOfThreads++;
+
+    activeThreads = _InterlockedIncrement(&Process->ActiveThreads);
+    ASSERT(activeThreads <= Process->NumberOfThreads);
+
+    InsertTailList(&Process->ThreadList, &Thread->ProcessList);
+
+    // While there are still threads running the process MUST not be
+    // destroyed => reference it
+    _ProcessReference(Process);
+
+    LockRelease(&Process->ThreadListLock, oldState);
+}
+
+void
+ProcessNotifyThreadTermination(
+    IN      struct _THREAD*     Thread
+    )
+{
+    PPROCESS pProcess;
+    DWORD activeThreads;
+
+    ASSERT(Thread != NULL);
+
+    pProcess = Thread->Process;
+    ASSERT(pProcess != NULL);
+
+    activeThreads = _InterlockedDecrement(&pProcess->ActiveThreads);
+
+    // Once there are no more active threads in the process we need set the process exit
+    // status and signal the process termination event
+    if (activeThreads == 0)
+    {
+        LOG_TRACE_PROCESS("Last thread [%s] is finishing in process [%s]\n",
+                          Thread->Name, pProcess->ProcessName);
+
+        pProcess->TerminationStatus = Thread->ExitStatus;
+        ExEventSignal(&pProcess->TerminationEvt);
+    }
+}
+
+void
+ProcessRemoveThreadFromList(
+    INOUT   struct _THREAD*     Thread
+    )
+{
+    PPROCESS pProcess;
+    DWORD remainingThreads;
+    INTR_STATE oldState;
+
+    ASSERT(Thread != NULL);
+
+    pProcess = Thread->Process;
+    ASSERT(pProcess != NULL);
+
+    LockAcquire(&pProcess->ThreadListLock, &oldState);
+
+    remainingThreads = _InterlockedDecrement(&pProcess->NumberOfThreads);
+    ASSERT_INFO(remainingThreads != MAX_DWORD,
+                "If the process already had ZERO threads what thread can we remove??");
+
+    RemoveEntryList(&Thread->ProcessList);
+    _ProcessDereference(pProcess);
+
+    LockRelease(&pProcess->ThreadListLock, oldState);
+
+    // If the number of threads in the process has reached 0 it's clear that it's
+    // impossible for new threads to spawn => we can dereference the process
+    // The process might not be destroyed yet if there is still an open handle to it
+    if (remainingThreads == 0)
+    {
+        _ProcessDereference(pProcess);
+    }
+}
+
+static
+void
+_ProcessDestroy(
+    IN      PVOID                   Object,
+    IN_OPT  PVOID                   Context
+    )
+{
+    PPROCESS Process = (PPROCESS) CONTAINING_RECORD(Object, PROCESS, RefCnt);
+
+    ASSERT(NULL != Process);
+    ASSERT(!ProcessIsSystem(Process));
+    ASSERT(NULL == Context);
+
+    // It would be really weird if we could destroy the process VAS while there are
+    // still some running threads
+    ASSERT(Process->NumberOfThreads == 0);
+
+    LOG_TRACE_PROCESS("Will destroy process with PID 0x%X\n", Process->Id);
+
+    // It's ok to use the remove entry list function because when we create the process we call
+    // InitializeListHead => the RemoveEntryList has no problem with an empty list as long as it
+    // is initialized :)
+    MutexAcquire(&m_processData.ProcessListLock);
+    RemoveEntryList(&Process->NextProcess);
+    MutexRelease(&m_processData.ProcessListLock);
+
+    if (NULL != Process->FullCommandLine)
+    {
+        ExFreePoolWithTag(Process->FullCommandLine, HEAP_PROCESS_TAG);
+        Process->FullCommandLine = NULL;
+    }
+
+    if (NULL != Process->ProcessName)
+    {
+        ExFreePoolWithTag(Process->ProcessName, HEAP_PROCESS_TAG);
+        Process->ProcessName = NULL;
+    }
+
+    if (NULL != Process->HeaderInfo)
+    {
+        ExFreePoolWithTag(Process->HeaderInfo, HEAP_PROCESS_TAG);
+        Process->HeaderInfo = NULL;
+    }
+
+    // Because the system process will never be destroyed it is ok to free
+    // these memory addresses unconditionally
+    MmuDestroyAddressSpaceForProcess(Process);
+
+    if (Process->Id != 0)
+    {
+        // This should be done only after MmuDestroyVirtualSpaceForProcess, that
+        // function is also responsible for destroying all cached translations for
+        // this process ID
+        _ProcessSystemFreePid(Process->Id);
+    }
+
+    ExFreePoolWithTag(Process, HEAP_PROCESS_TAG);
+}
diff --git a/src_proiect/HAL9000/src/serial_comm.c b/src_proiect/HAL9000/src/serial_comm.c
new file mode 100644
index 0000000..0cac69d
--- /dev/null
+++ b/src_proiect/HAL9000/src/serial_comm.c
@@ -0,0 +1,72 @@
+#include "HAL9000.h"
+#include "serial_comm.h"
+#include "serial.h"
+
+static WORD m_serialPortNumber = 0;
+
+STATUS
+SerialCommunicationInitialize(
+    IN_READS(NoOfPorts)     WORD*           Ports,
+    IN                      DWORD           NoOfPorts
+    )
+{
+    WORD currentPortAddress;
+    DWORD i;
+    
+    currentPortAddress = 0;
+    
+    if (0 != m_serialPortNumber)
+    {
+         // return an error warning
+         return STATUS_COMM_SERIAL_ALREADY_INITIALIZED;
+    }
+
+    for (i = 0; i < NoOfPorts; ++i)
+    {
+        currentPortAddress = Ports[i];
+        if (0 != currentPortAddress)
+        {
+            break;
+        }
+    }
+
+    if (0 == currentPortAddress)
+    {
+        return STATUS_COMM_SERIAL_NO_PORTS_AVAILABLE;
+    }
+    
+    SerialInitialize(currentPortAddress);
+    m_serialPortNumber = currentPortAddress;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SerialCommunicationReinitialize(
+    void
+    )
+{
+    if (0 == m_serialPortNumber)
+    {
+        return STATUS_COMM_SERIAL_NOT_INITIALIZED;
+    }
+
+    SerialInitialize(m_serialPortNumber);
+
+    return STATUS_SUCCESS;
+}
+
+void
+SerialCommWriteBuffer(
+    IN_Z char*  Buffer
+    )
+{
+    if (0 == m_serialPortNumber)
+    {
+        return;
+    }
+
+    ASSERT( NULL != Buffer );
+
+    SerialWriteBuffer(m_serialPortNumber, Buffer);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/smp.c b/src_proiect/HAL9000/src/smp.c
new file mode 100644
index 0000000..7a35f1e
--- /dev/null
+++ b/src_proiect/HAL9000/src/smp.c
@@ -0,0 +1,870 @@
+#include "HAL9000.h"
+#include "smp.h"
+#include "acpi_interface.h"
+#include "cpumu.h"
+#include "lapic_system.h"
+#include "synch.h"
+#include "ap_tramp.h"
+#include "pit.h"
+#include "io.h"
+#include "ex_event.h"
+#include "hw_fpu.h"
+
+extern void ApAsmStub();
+
+#define SIPI_VECTOR_SHIFT                       12
+
+#define INIT_SLEEP                              (10*MS_IN_US)   // 10 ms = 10000us sleep
+#define SIPI_SLEEP                              (200)           // 200 us sleep
+
+STATIC_ASSERT(SmpIpiSendToCpu == ApicDestinationShorthandNone);
+STATIC_ASSERT(SmpIpiSendToSelf == ApicDestinationShorthandSelf);
+STATIC_ASSERT(SmpIpiSendToAllIncludingSelf == ApicDestinationShorthandAll);
+STATIC_ASSERT(SmpIpiSendToAllExcludingSelf == ApicDestinationShorthandAllExcludingSelf);
+
+typedef struct _SMP_DATA
+{
+    RW_SPINLOCK             CpuLock;
+
+    _Guarded_by_(CpuLock)
+    LIST_ENTRY              CpuList;
+
+    DWORD                   NoOfCpus;
+    volatile DWORD          NoOfActiveCpus;
+
+    BYTE                    SipiVector;
+    EX_EVENT                ApStartupEvent;
+
+    BYTE                    ApicTimerVector;
+    BYTE                    IpcIpiVector;
+    BYTE                    AssertIpiVector;
+} SMP_DATA, *PSMP_DATA;
+
+static SMP_DATA m_smpData;
+
+__forceinline
+STATUS
+_SmpInstallInterruptRoutine(
+    IN      PFUNC_InterruptFunction     Function,
+    IN _Strict_type_match_
+            IRQL                        Irql,
+    OUT     PBYTE                       Vector
+    )
+{
+    IO_INTERRUPT ioInterrupt;
+
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    ioInterrupt.Type = IoInterruptTypeLapic;
+    ioInterrupt.Exclusive = TRUE;
+    ioInterrupt.ServiceRoutine = Function;
+    ioInterrupt.Irql = Irql;
+
+    return IoRegisterInterruptEx(&ioInterrupt, NULL, Vector);
+}
+
+__forceinline
+void
+static
+_SmpSendIpcIpi(
+    IN _Strict_type_match_
+            SMP_IPI_SEND_MODE       SendMode,
+    IN      SMP_DESTINATION         Destination
+    )
+{
+    BYTE vector = m_smpData.IpcIpiVector;
+    APIC_DESTINATION_SHORTHAND apicShorthand;
+    APIC_DESTINATION_MODE apicDestinationMode;
+    APIC_ID apicId;
+
+    apicShorthand = SendMode <= SmpIpiSendToAllExcludingSelf ? SendMode : ApicDestinationShorthandNone;
+    apicDestinationMode = SendMode != SmpIpiSendToGroup ? ApicDestinationModePhysical : ApicDestinationModeLogical;
+
+    apicId = 0;
+    if ( SmpIpiSendToCpu == SendMode )
+    {
+        apicId = Destination.Cpu.ApicId;
+    }
+    else if (SmpIpiSendToGroup == SendMode)
+    {
+        apicId = Destination.Group.Affinity;
+    }
+
+    LapicSystemSendIpi(apicId, ApicDeliveryModeFixed, apicShorthand, apicDestinationMode, &vector);
+}
+
+__forceinline
+static
+BOOLEAN
+_SmpDoesCpuMatchDestination(
+    IN _Strict_type_match_
+            SMP_IPI_SEND_MODE       SendMode,
+    IN      SMP_DESTINATION         Destination,
+    IN      PPCPU                   Cpu
+    )
+{
+    switch (SendMode)
+    {
+    case SmpIpiSendToAllExcludingSelf:
+        return Cpu->ApicId != CpuGetApicId();
+    case SmpIpiSendToAllIncludingSelf:
+        return TRUE;
+    case SmpIpiSendToSelf:
+        return Cpu->ApicId == CpuGetApicId();
+    case SmpIpiSendToCpu:
+        return Cpu->ApicId == Destination.Cpu.ApicId;
+    case SmpIpiSendToGroup:
+        return IsBooleanFlagOn( Destination.Group.Affinity, Cpu->LogicalApicId );
+    }
+
+    NOT_REACHED;
+
+    return FALSE;
+}
+
+static
+void
+_SmpSignalAllAPs(
+    IN      BYTE            SipiVector
+    );
+
+static
+STATUS
+_SmpInstallInterruptRoutines(
+    void
+    );
+
+static
+STATUS
+_SmpRetrieveMatchingCpus(
+    IN      SMP_DESTINATION         Destination,
+    IN _Strict_type_match_
+            SMP_IPI_SEND_MODE       SendMode,
+    IN      DWORD                   MaximumCpuMatches,
+    _Out_writes_to_opt_(MaximumCpuMatches,*NumberOfCpusMatching)
+            PPCPU*                  CpuList,
+    OUT     DWORD*                  NumberOfCpusMatching
+    );
+
+static
+void
+_SmpSetupInitialApStack(
+    IN      PVOID                   InitialStack,
+    IN      PCPU*                   CorrespondingCpu,
+    OUT_PTR PVOID*                  ResultingStack
+    );
+
+static FUNC_InterruptFunction       _SmpApicTimerIsr;
+static FUNC_InterruptFunction       _SmpAssertIpiIsr;
+static FUNC_InterruptFunction       _SmpIpcIpiIsr;
+
+_No_competing_thread_
+void
+SmpPreinit(
+    void
+    )
+{
+    memzero(&m_smpData, sizeof(SMP_DATA));
+
+    InitializeListHead(&m_smpData.CpuList);
+    RwSpinlockInit(&m_smpData.CpuLock);
+}
+
+STATUS
+_No_competing_thread_
+SmpInit(
+    void
+    )
+{
+    STATUS status;
+    DWORD noOfCpus;
+    BOOLEAN bRestartSearch;
+    ACPI_MADT_LOCAL_APIC* pDummy;
+
+    status = STATUS_SUCCESS;
+    noOfCpus = 0;
+    bRestartSearch = TRUE;
+
+    status = ExEventInit(&m_smpData.ApStartupEvent, ExEventTypeSynchronization, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("EvtInitialize", status);
+        return status;
+    }
+
+    // install ISRs
+    status = _SmpInstallInterruptRoutines();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_SmpInstallInterruptRoutines", status);
+        return status;
+    }
+
+    LOGL("SMP interrupt routines successfully registered!\n");
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        status = AcpiRetrieveNextCpu(bRestartSearch, &pDummy);
+        if (STATUS_NO_MORE_OBJECTS == status)
+        {
+            LOGL("Reached end of CPU list\n");
+            status = STATUS_SUCCESS;
+            break;
+        }
+
+        if (!SUCCEEDED(status))
+        {
+            // we failed, why?
+            LOG_FUNC_ERROR("AcpiRetrieveNextCpu", status);
+            break;
+        }
+
+        ASSERT(NULL != pDummy);
+
+        noOfCpus = noOfCpus + 1;
+        bRestartSearch = FALSE;
+    }
+
+    m_smpData.NoOfCpus = noOfCpus;
+
+    LOGL("The system has %u CPUs\n", m_smpData.NoOfCpus );
+
+    return status;
+}
+
+STATUS
+_No_competing_thread_
+SmpSetupLowerMemory(
+    IN          BYTE        NumberOfTssStacks
+    )
+{
+    STATUS status;
+    PPCPU pCpu;
+    BOOLEAN bRestartSearch;
+    ACPI_MADT_LOCAL_APIC* pEntry;
+    DWORD noOfCpus;
+    DWORD apTrampCodeAddress;
+    PEVENT pWakeUpEvent;
+
+    status = STATUS_SUCCESS;
+    pCpu = NULL;
+    bRestartSearch = TRUE;
+    pEntry = NULL;
+    noOfCpus = 0;
+    apTrampCodeAddress = 0;
+    pWakeUpEvent = NULL;
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        ASSERT(NULL == pCpu);
+
+        status = AcpiRetrieveNextCpu(bRestartSearch, &pEntry);
+        if (STATUS_NO_MORE_OBJECTS == status)
+        {
+            LOGL("Reached end of CPU list\n");
+            status = STATUS_SUCCESS;
+            break;
+        }
+
+        if (!SUCCEEDED(status))
+        {
+            // we failed, why?
+            LOG_FUNC_ERROR("AcpiRetrieveNextCpu", status);
+            break;
+        }
+
+        ASSERT(NULL != pEntry);
+
+        if (CpuGetApicId() == pEntry->Id)
+        {
+            // this is the BSP
+            pCpu = GetCurrentPcpu();
+            ASSERT(NULL != pCpu);
+
+            pCpu->BspProcessor = TRUE;
+        }
+        else
+        {
+            // this is an AP
+            status = CpuMuAllocCpu(&pCpu,
+            // C28039: The type of actual parameter 'pEntry->Id' should exactly match the type 'APIC_ID'
+#pragma warning(suppress: 28039)
+                                   (APIC_ID) pEntry->Id,
+                                   STACK_DEFAULT_SIZE,
+                                   NumberOfTssStacks
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("CpuMuAllocAndInitCpu", status);
+                return status;
+            }
+
+            _SmpSetupInitialApStack(pCpu->StackTop, pCpu, &pCpu->StackTop);
+        }
+
+
+        InsertTailList(&m_smpData.CpuList, &pCpu->ListEntry);
+        noOfCpus = noOfCpus + 1;
+
+        pCpu = NULL;
+        bRestartSearch = FALSE;
+    }
+
+    status = ApTrampSetupLowerMemory(&m_smpData.CpuList, &apTrampCodeAddress);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_SmpSetupLowerMemory", status);
+        return status;
+    }
+
+    ASSERT(IsAddressAligned(apTrampCodeAddress, PAGE_SIZE));
+    ASSERT(apTrampCodeAddress < MB_SIZE);
+
+    m_smpData.SipiVector = (BYTE)(apTrampCodeAddress >> SIPI_VECTOR_SHIFT);
+
+    ASSERT(m_smpData.NoOfCpus == noOfCpus);
+
+    return status;
+}
+
+void
+_No_competing_thread_
+SmpWakeupAps(
+    void
+    )
+{
+    if (m_smpData.NoOfCpus > 1)
+    {
+        LOGL("Will signal APs\n");
+        _SmpSignalAllAPs(m_smpData.SipiVector);
+        LOGL("APs were signaled\n");
+
+        ExEventWaitForSignal(&m_smpData.ApStartupEvent);
+
+        LOGL("Aps have waken UP\n");
+    }
+    else
+    {
+        LOGL("This is not a SMP system! :(\n");
+    }
+}
+
+void
+_No_competing_thread_
+SmpCleanupLowerMemory(
+    void
+    )
+{
+    ApTrampCleanupLowerMemory(&m_smpData.CpuList);
+}
+
+void
+SmpSendPanic(
+    void
+    )
+{
+    BYTE vector = m_smpData.AssertIpiVector;
+
+    LapicSystemSendIpi(0, ApicDeliveryModeFixed, ApicDestinationShorthandAllExcludingSelf, ApicDestinationModePhysical, &vector);
+}
+
+STATUS
+SmpSendGenericIpi(
+    IN      PFUNC_IpcProcessEvent   BroadcastFunction,
+    IN_OPT  PVOID                   Context,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   FreeContext,
+    IN      BOOLEAN                 WaitForHandling
+    )
+{
+    SMP_DESTINATION dest = { 0 };
+
+    return SmpSendGenericIpiEx(BroadcastFunction,
+                               Context,
+                               FreeFunction,
+                               FreeContext,
+                               WaitForHandling,
+                               SmpIpiSendToAllExcludingSelf,
+                               dest
+                               );
+}
+
+STATUS
+SmpSendGenericIpiEx(
+    IN      PFUNC_IpcProcessEvent   BroadcastFunction,
+    IN_OPT  PVOID                   Context,
+    IN_OPT  PFUNC_FreeFunction      FreeFunction,
+    IN_OPT  PVOID                   FreeContext,
+    IN      BOOLEAN                 WaitForHandling,
+    IN _Strict_type_match_
+            SMP_IPI_SEND_MODE       SendMode,
+    _When_(SendMode == SmpIpiSendToCpu || SendMode == SmpIpiSendToGroup, IN)
+            SMP_DESTINATION         Destination
+    )
+{
+    PIPC_EVENT_CPU pCpuEvents;
+    STATUS status;
+    DWORD noOfMatchingCpus;
+    DWORD i;
+    PPCPU* pMatchingCpus;
+    DWORD tempResult;
+    BOOLEAN bSelfInDestination;
+    APIC_ID apicId;
+
+    LOG_FUNC_START;
+
+    if (NULL == BroadcastFunction)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (SendMode > SmpIpiSendMax)
+    {
+        return STATUS_INVALID_PARAMETER6;
+    }
+
+    status = STATUS_SUCCESS;
+    pCpuEvents = NULL;
+    pMatchingCpus = NULL;
+    bSelfInDestination = FALSE;
+
+    LOG_TRACE_CPU("Send mode 0x%x to destination 0x%02x [0x%02]\n",
+                  SendMode, Destination.Cpu.ApicId, Destination.Group.Affinity );
+
+    status = _SmpRetrieveMatchingCpus(Destination,
+                                      SendMode,
+                                      0,
+                                      NULL,
+                                      &noOfMatchingCpus
+                                      );
+    if (STATUS_BUFFER_TOO_SMALL == status)
+    {
+        status = STATUS_SUCCESS;
+    }
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_SmpRetrieveMatchingCpus", status );
+        return status;
+    }
+
+    if (0 == noOfMatchingCpus)
+    {
+        LOG_WARNING("There are no CPUs which match IPI destination! :(\n");
+        return STATUS_CPU_NO_MATCHES;
+    }
+
+    apicId = CpuGetApicId();
+
+    __try
+    {
+        // in the future we may have a preallocated array of pointers allocated in each
+        // PCPU structure. This would remove the need of memory allocation when sending
+        // IPIs and because the number of CPUs is limited not much memory is wasted
+        // E.g: even if there are 256 CPUs * sizeof(PVOID) => only 2KB of memory is used
+        // per CPU => 262KB extra
+        pMatchingCpus = ExAllocatePoolWithTag(0,
+                                              sizeof(PCPU*) * noOfMatchingCpus,
+                                              HEAP_TEMP_TAG,
+                                              0
+        );
+        ASSERT(NULL != pMatchingCpus);
+
+        status = _SmpRetrieveMatchingCpus(Destination,
+                                          SendMode,
+                                          noOfMatchingCpus,
+                                          pMatchingCpus,
+                                          &tempResult
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_SmpRetrieveMatchingCpus", status);
+            __leave;
+        }
+        ASSERT(tempResult == noOfMatchingCpus);
+
+        pCpuEvents = IpcGenerateEvent(BroadcastFunction,
+                                      Context,
+                                      FreeFunction,
+                                      FreeContext,
+                                      WaitForHandling,
+                                      noOfMatchingCpus
+        );
+        if (NULL == pCpuEvents)
+        {
+            status = STATUS_UNSUCCESSFUL;
+            LOG_FUNC_ERROR("IpcGenerateEvent", status);
+            __leave;
+        }
+        LOG_TRACE_CPU("Successfully generated event at 0x%X\n", pCpuEvents);
+
+        for (i = 0; i < noOfMatchingCpus; ++i)
+        {
+            INTR_STATE intrState;
+            PCPU* pCpu = pMatchingCpus[i];
+
+            LOG_TRACE_CPU("Will process CPU 0x%02x [0x%02x]\n", pCpu->ApicId, pCpu->LogicalApicId);
+
+            if (apicId == pCpu->ApicId)
+            {
+                bSelfInDestination = TRUE;
+            }
+
+            LockAcquire(&pCpu->EventListLock, &intrState);
+            InsertTailList(&pCpu->EventList, &(pCpuEvents[i].ListEntry));
+            pCpu->NoOfEventsInList++;
+            LockRelease(&pCpu->EventListLock, intrState);
+        }
+
+        // notify processors
+        _SmpSendIpcIpi(SendMode, Destination);
+
+        if (WaitForHandling)
+        {
+            /// if we sent the event to ourselves as well and we want to wait for handling completion
+            /// it is MANDATORY for INTERRUPTS to be turned ON and for our processor priority
+            /// to be strictly below IrqlIpiLevel
+            if (bSelfInDestination)
+            {
+                ASSERT(INTR_ON == CpuIntrGetState());
+                ASSERT(LapicSystemGetPpr() < IrqlIpiLevel);
+            }
+
+            // if WaitForHandling is FALSE it is possible for the event to already be
+            // de-allocated => not safe to call function
+            IpcWaitForEventHandling(pCpuEvents);
+        }
+        pCpuEvents = NULL;
+    }
+    __finally
+    {
+        if( NULL != pMatchingCpus )
+        {
+            ExFreePoolWithTag(pMatchingCpus, HEAP_TEMP_TAG);
+            pMatchingCpus = NULL;
+        }
+
+        ASSERT( NULL == pCpuEvents );
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+STATUS
+SmpCpuInit(
+    void
+    )
+{
+    STATUS status;
+
+    status = STATUS_SUCCESS;
+
+    // initialize APIC
+    status = LapicSystemInitializeCpu(m_smpData.ApicTimerVector);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ApicMapRegister", status);
+        return status;
+    }
+
+    // make sure TPR is 0
+    __writecr8(0);
+
+    return STATUS_SUCCESS;
+}
+
+void
+_No_competing_thread_
+SmpGetCpuList(
+    OUT_PTR      PLIST_ENTRY*     CpuList
+    )
+{
+    *CpuList = &m_smpData.CpuList;
+}
+
+DWORD
+SmpGetNumberOfActiveCpus(
+    void
+    )
+{
+    return m_smpData.NoOfActiveCpus;
+}
+
+void
+SmpNotifyCpuWakeup(
+    void
+    )
+{
+    DWORD noOfActiveCpus;
+
+    LOG_FUNC_START_CPU;
+
+    noOfActiveCpus = _InterlockedIncrement(&m_smpData.NoOfActiveCpus);
+
+    LOGPL("Number of active CPUs: %u/%u\n", noOfActiveCpus, m_smpData.NoOfCpus );
+
+    if( noOfActiveCpus == m_smpData.NoOfCpus )
+    {
+        LOGPL("All CPUs woke up, will signal BSP\n");
+        ExEventSignal(&m_smpData.ApStartupEvent);
+    }
+
+    LOG_FUNC_END_CPU;
+}
+
+static
+void
+_SmpSignalAllAPs(
+    IN      BYTE            SipiVector
+    )
+{
+    LapicSystemSendIpi(0, ApicDeliveryModeINIT, ApicDestinationShorthandAllExcludingSelf, ApicDestinationModePhysical, NULL);
+    PitSleep(INIT_SLEEP);
+
+    LapicSystemSendIpi(0, ApicDeliveryModeSIPI, ApicDestinationShorthandAllExcludingSelf, ApicDestinationModePhysical, &SipiVector);
+    PitSleep(SIPI_SLEEP);
+
+    LapicSystemSendIpi(0, ApicDeliveryModeSIPI, ApicDestinationShorthandAllExcludingSelf, ApicDestinationModePhysical, &SipiVector);
+    PitSleep(SIPI_SLEEP);
+}
+
+static
+STATUS
+_SmpInstallInterruptRoutines(
+    void
+    )
+{
+    STATUS status;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    // install APIC timer ISR
+    status = _SmpInstallInterruptRoutine( _SmpApicTimerIsr, IrqlClockLevel, &m_smpData.ApicTimerVector );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_SmpInstallInterruptRoutine", status);
+        return status;
+    }
+
+    status = _SmpInstallInterruptRoutine(_SmpAssertIpiIsr, IrqlAssertLevel, &m_smpData.AssertIpiVector );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_SmpInstallInterruptRoutine", status);
+        return status;
+    }
+
+    status = _SmpInstallInterruptRoutine(_SmpIpcIpiIsr, IrqlIpiLevel, &m_smpData.IpcIpiVector );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_SmpInstallInterruptRoutine", status);
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_SmpRetrieveMatchingCpus(
+    IN      SMP_DESTINATION         Destination,
+    IN  _Strict_type_match_
+            SMP_IPI_SEND_MODE       SendMode,
+    IN      DWORD                   MaximumCpuMatches,
+    _Out_writes_to_opt_(MaximumCpuMatches,*NumberOfCpusMatching)
+            PPCPU*                  CpuList,
+    OUT     DWORD*                  NumberOfCpusMatching
+    )
+{
+    PLIST_ENTRY pEntry;
+    INTR_STATE oldState;
+    DWORD noOfMatches;
+
+    if (NULL == NumberOfCpusMatching)
+    {
+        return STATUS_INVALID_PARAMETER5;
+    }
+
+    noOfMatches = 0;
+
+    RwSpinlockAcquireShared(&m_smpData.CpuLock, &oldState);
+    for(pEntry = m_smpData.CpuList.Flink;
+        pEntry != &m_smpData.CpuList;
+        pEntry = pEntry->Flink)
+    {
+        PCPU* pCpu = CONTAINING_RECORD(pEntry, PCPU, ListEntry);
+
+        if(_SmpDoesCpuMatchDestination(SendMode,
+                                       Destination,
+                                       pCpu))
+        {
+            noOfMatches++;
+
+            if (noOfMatches <= MaximumCpuMatches)
+            {
+                if (NULL != CpuList)
+                {
+                    LOG_TRACE_CPU("Will insert CPU 0x%02x [0x%02x] into list\n", pCpu->ApicId, pCpu->LogicalApicId );
+                    CpuList[noOfMatches - 1] = pCpu;
+                }
+            }
+        }
+    }
+    RwSpinlockReleaseShared(&m_smpData.CpuLock, oldState);
+
+    *NumberOfCpusMatching = noOfMatches;
+
+    return noOfMatches > MaximumCpuMatches ? STATUS_BUFFER_TOO_SMALL : STATUS_SUCCESS;
+}
+
+//  STACK TOP
+//  -----------------------------------------------------------------
+//  |                                                               |
+//  |       Shadow Space                                            |
+//  |                                                               |
+//  |     1st Param = (PCPU) Cpu                                    |
+//  -----------------------------------------------------------------
+//  |     Dummy Function RA = 0xDEADC0DE'DEADC0DE                   |
+//  -----------------------------------------------------------------
+//  |     ApInitCpu                                                 |
+//  -----------------------------------------------------------------
+//  |                                                               |
+//  |       Shadow Space                                            |
+//  |                                                               |
+//  |                                                               |
+//  -----------------------------------------------------------------
+//  |     Function RA = ApAsmStub                                   |
+//  -----------------------------------------------------------------
+//  |     HalActivateFpu                                            |
+//  -----------------------------------------------------------------
+static
+void
+_SmpSetupInitialApStack(
+    IN      PVOID                   InitialStack,
+    IN      PCPU*                   CorrespondingCpu,
+    OUT_PTR PVOID*                  ResultingStack
+    )
+{
+    PBYTE pStackTop;
+
+    ASSERT(InitialStack != NULL);
+    ASSERT(IsAddressAligned(InitialStack, PAGE_SIZE));
+    ASSERT(CorrespondingCpu != NULL);
+    ASSERT(ResultingStack != NULL);
+
+    pStackTop = InitialStack;
+
+    // setup 'return' stack
+    // 4 * sizeof(PVOID) for arguments
+    // sizeof(PVOID) for RA
+    // sizeof(PVOID) for proper alignment
+    pStackTop = (pStackTop - SHADOW_STACK_SIZE - sizeof(PVOID) - sizeof(PVOID));
+    *((PQWORD)pStackTop) = (QWORD)ApInitCpu;
+    *((PQWORD)pStackTop + 1) = 0xDEADC0DE'DEADC0DE;
+    *((PQWORD)pStackTop + 2) = (QWORD)CorrespondingCpu;
+
+    pStackTop = (pStackTop - SHADOW_STACK_SIZE - sizeof(PVOID) - sizeof(PVOID));
+
+    *((PQWORD)pStackTop) = (QWORD)HalActivateFpu;
+    *((PQWORD)pStackTop + 1) = (QWORD)ApAsmStub;
+
+    *ResultingStack = pStackTop;
+}
+
+static
+BOOLEAN
+(__cdecl _SmpApicTimerIsr)(
+    IN        PDEVICE_OBJECT           Device
+    )
+{
+    ASSERT( NULL != Device );
+
+    LOGPL("What are we doing here??\n");
+
+    return FALSE;
+}
+
+static
+BOOLEAN
+(__cdecl _SmpAssertIpiIsr)(
+    IN        PDEVICE_OBJECT           Device
+    )
+{
+    ASSERT( NULL != Device );
+
+    AssertInfo("Received ASSERT IPI\n");
+    NOT_REACHED;
+
+    return FALSE;
+}
+
+static
+BOOLEAN
+(__cdecl _SmpIpcIpiIsr)(
+    IN        PDEVICE_OBJECT           Device
+    )
+{
+    PCPU* pCpu;
+    INTR_STATE dummy;
+    PLIST_ENTRY pListEntry;
+    PIPC_EVENT_CPU pCpuEvent;
+    STATUS status;
+    STATUS funcStatus;
+
+    ASSERT(NULL != Device);
+
+    LOG_FUNC_START;
+
+    pListEntry = NULL;
+    status = STATUS_SUCCESS;
+    pCpuEvent = NULL;
+
+    pCpu = GetCurrentPcpu();
+    ASSERT( NULL != pCpu );
+
+    LockAcquire(&pCpu->EventListLock, &dummy);
+    if (pCpu->NoOfEventsInList > 0)
+    {
+        LOG_TRACE_CPU("Will remove event from list at 0x%X\n", &pCpu->EventList);
+        pListEntry = RemoveHeadList(&pCpu->EventList);
+        ASSERT( pListEntry != &pCpu->EventList );
+        pCpu->NoOfEventsInList--;
+    }
+    LockRelease(&pCpu->EventListLock, INTR_OFF);
+
+    ASSERT(NULL != pListEntry);
+
+    pCpuEvent = CONTAINING_RECORD(pListEntry, IPC_EVENT_CPU, ListEntry);
+    LOG_TRACE_CPU("Removed element at 0x%X\n", pCpuEvent);
+
+    __try
+    {
+        status = IpcProcessEvent(pCpuEvent, &funcStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IpcProcessEvent", status);
+            __leave;
+        }
+
+        status = funcStatus;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("Event processing failed", status);
+            __leave;
+        }
+
+        pListEntry = NULL;
+    }
+    __finally
+    {
+        LOG_FUNC_END;
+    }
+
+    return SUCCEEDED(status);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/structs.yasm b/src_proiect/HAL9000/src/structs.yasm
new file mode 100644
index 0000000..45ba0b9
--- /dev/null
+++ b/src_proiect/HAL9000/src/structs.yasm
@@ -0,0 +1,127 @@
+%ifndef _STRUCTS_ASM_
+%define _STRUCTS_ASM_
+
+;-----------------------------------------------------------------------;
+; STRUCTURE DEFINITIONS
+;-----------------------------------------------------------------------;
+
+
+struc ASM_PARAMETERS
+    .MultibootInformation               resq    1                           ; 0x00
+    .KernelBaseAddress                  resq    1                           ; 0x08
+    .KernelSize                         resq    1                           ; 0x10
+    .VirtualToPhysicalOffset            resq    1                           ; 0x18
+    .MemoryMapAddress                   resq    1                           ; 0x20
+    .MemoryMapEntries                   resd    1                           ; 0x28
+    .BiosSerialPorts                    resw    4                           ; 0x2C
+                                                                            ; 0x34
+endstruc
+
+struc XSAVE_LEGACY_REGION
+    .ControlWord                        resw    1                           ; 0x00
+    .StatusWord                         resw    1                           ; 0x02
+    .TagWord                            resb    1                           ; 0x04
+    .Reserved1                          resb    1                           ; 0x05
+    .ErrorOpcode                        resw    1                           ; 0x06
+    .ErrorOffset                        resd    1                           ; 0x08
+    .ErrorSelector                      resw    1                           ; 0x0C
+    .Reserved2                          resw    1                           ; 0x0E
+    .DataOffset                         resd    1                           ; 0x10
+    .DataSelector                       resw    1                           ; 0x14
+    .Reserved3                          resw    1                           ; 0x16
+    .MxCsr                              resd    1                           ; 0x18
+    .MxCsr_Mask                         resd    1                           ; 0x1C
+    .FloatRegisters                     resq    16;                         ; 0x20
+    .XmmRegisters                       resq    32;                         ; 0xA0
+    .Reserved4                          resb    96;                         ; 0x1A0
+                                                                            ; 0x200
+endstruc
+
+struc XSAVE_AREA_HEADER
+    .Mask                               resq    1                           ; 0x00
+    .Reserved                           resq    7                           ; 0x08
+                                                                            ; 0x40
+endstruc
+
+%define XSAVE_AREA_REQUIRED_ALIGNMENT           0x40
+
+struc XSAVE_AREA
+    .LegacyState                        resb    XSAVE_LEGACY_REGION_size    ; 0x00
+    .Header                             resb    XSAVE_AREA_HEADER_size      ; 0x200
+
+    .__Reserved                         resb    0x1C0                       ; 0x240
+                                                                            ; 0x400
+endstruc
+
+struc REGISTER_AREA
+    .Rax                                resq    1
+    .Rcx                                resq    1
+    .Rdx                                resq    1
+    .Rbx                                resq    1
+    .Rsp                                resq    1
+    .Rbp                                resq    1
+    .Rsi                                resq    1
+    .Rdi                                resq    1
+    .R8                                 resq    1
+    .R9                                 resq    1
+    .R10                                resq    1
+    .R11                                resq    1
+    .R12                                resq    1
+    .R13                                resq    1
+    .R14                                resq    1
+    .R15                                resq    1
+
+    .Rip                                resq    1
+    .Rflags                             resq    1
+endstruc
+
+struc COMPLETE_PROCESSOR_STATE
+    .XsaveArea                          resb    XSAVE_AREA_size
+
+    .RegisterArea                       resb    REGISTER_AREA_size
+endstruc
+
+; 4 byte aligned
+struc DISK_ADDRESS_PACKET
+    .Size                               resb    1
+    .Reserved                           resb    1
+    .SectorsToTransfer                  resw    1
+    .BufferOffset                       resw    1       ; 2 byte aligned
+    .BufferSegment                      resw    1
+    .StartingLBA                        resd    1
+    .UpperLBAPart                       resd    1
+endstruc
+
+struc INT15_MEMORY_MAP_ENTRY
+    .BaseAddress                        resq    1
+    .Length                             resq    1
+    .Type                               resd    1
+    .ExtendedAttributes                 resd    1
+endstruc
+
+struc TRANSITION_CONFIG
+    .GdtrPhysicalAddress                resd    1
+    .StackPhysicalAddress               resd    1
+    .Pml4PhysicalAddress                resd    1
+    .CodeSelector                       resw    1
+    .DataSelector                       resw    1
+    .StackVirtualAddress                resq    1
+endstruc
+
+struc SYSTEM_CONFIG
+    .LowGdt                             resb    6
+    .HighGdt                            resb    10
+    .Pml4PhysicalAddress                resd    1
+    .Code32Selector                     resw    1
+    .Data32Selector                     resw    1
+    .Code64Selector                     resw    1
+    .Data64Selector                     resw    1
+endstruc
+
+struc AP_CONFIG_ENTRY
+    .StackPhysicalAddress               resd    1
+    .Reserved0                          resd    1
+    .StackVirtualAddress                resq    1
+endstruc
+
+%endif ; _MACROS_ASM_
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/syscall.c b/src_proiect/HAL9000/src/syscall.c
new file mode 100644
index 0000000..b01e62b
--- /dev/null
+++ b/src_proiect/HAL9000/src/syscall.c
@@ -0,0 +1,172 @@
+#include "HAL9000.h"
+#include "syscall.h"
+#include "gdtmu.h"
+#include "syscall_defs.h"
+#include "syscall_func.h"
+#include "syscall_no.h"
+#include "mmu.h"
+#include "process_internal.h"
+#include "dmp_cpu.h"
+
+extern void SyscallEntry();
+
+#define SYSCALL_IF_VERSION_KM       SYSCALL_IMPLEMENTED_IF_VERSION
+
+void
+SyscallHandler(
+    INOUT   COMPLETE_PROCESSOR_STATE    *CompleteProcessorState
+    )
+{
+    SYSCALL_ID sysCallId;
+    PQWORD pSyscallParameters;
+    PQWORD pParameters;
+    STATUS status;
+    REGISTER_AREA* usermodeProcessorState;
+
+    ASSERT(CompleteProcessorState != NULL);
+
+    // It is NOT ok to setup the FMASK so that interrupts will be enabled when the system call occurs
+    // The issue is that we'll have a user-mode stack and we wouldn't want to receive an interrupt on
+    // that stack. This is why we only enable interrupts here.
+    ASSERT(CpuIntrGetState() == INTR_OFF);
+    CpuIntrSetState(INTR_ON);
+
+    LOG_TRACE_USERMODE("The syscall handler has been called!\n");
+
+    status = STATUS_SUCCESS;
+    pSyscallParameters = NULL;
+    pParameters = NULL;
+    usermodeProcessorState = &CompleteProcessorState->RegisterArea;
+
+    __try
+    {
+        if (LogIsComponentTraced(LogComponentUserMode))
+        {
+            DumpProcessorState(CompleteProcessorState);
+        }
+
+        // Check if indeed the shadow stack is valid (the shadow stack is mandatory)
+        pParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp];
+        status = MmuIsBufferValid(pParameters, SHADOW_STACK_SIZE, PAGE_RIGHTS_READ, GetCurrentProcess());
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("MmuIsBufferValid", status);
+            __leave;
+        }
+
+        sysCallId = usermodeProcessorState->RegisterValues[RegisterR8];
+
+        LOG_TRACE_USERMODE("System call ID is %u\n", sysCallId);
+
+        // The first parameter is the system call ID, we don't care about it => +1
+        pSyscallParameters = (PQWORD)usermodeProcessorState->RegisterValues[RegisterRbp] + 1;
+
+        // Dispatch syscalls
+        switch (sysCallId)
+        {
+        case SyscallIdIdentifyVersion:
+            status = SyscallValidateInterface((SYSCALL_IF_VERSION)*pSyscallParameters);
+            break;
+        // STUDENT TODO: implement the rest of the syscalls
+        default:
+            LOG_ERROR("Unimplemented syscall called from User-space!\n");
+            status = STATUS_UNSUPPORTED;
+            break;
+        }
+
+    }
+    __finally
+    {
+        LOG_TRACE_USERMODE("Will set UM RAX to 0x%x\n", status);
+
+        usermodeProcessorState->RegisterValues[RegisterRax] = status;
+
+        CpuIntrSetState(INTR_OFF);
+    }
+}
+
+void
+SyscallPreinitSystem(
+    void
+    )
+{
+
+}
+
+STATUS
+SyscallInitSystem(
+    void
+    )
+{
+    return STATUS_SUCCESS;
+}
+
+STATUS
+SyscallUninitSystem(
+    void
+    )
+{
+    return STATUS_SUCCESS;
+}
+
+void
+SyscallCpuInit(
+    void
+    )
+{
+    IA32_STAR_MSR_DATA starMsr;
+    WORD kmCsSelector;
+    WORD umCsSelector;
+
+    memzero(&starMsr, sizeof(IA32_STAR_MSR_DATA));
+
+    kmCsSelector = GdtMuGetCS64Supervisor();
+    ASSERT(kmCsSelector + 0x8 == GdtMuGetDS64Supervisor());
+
+    umCsSelector = GdtMuGetCS32Usermode();
+    /// DS64 is the same as DS32
+    ASSERT(umCsSelector + 0x8 == GdtMuGetDS32Usermode());
+    ASSERT(umCsSelector + 0x10 == GdtMuGetCS64Usermode());
+
+    // Syscall RIP <- IA32_LSTAR
+    __writemsr(IA32_LSTAR, (QWORD) SyscallEntry);
+
+    LOG_TRACE_USERMODE("Successfully set LSTAR to 0x%X\n", (QWORD) SyscallEntry);
+
+    // Syscall RFLAGS <- RFLAGS & ~(IA32_FMASK)
+    __writemsr(IA32_FMASK, RFLAGS_INTERRUPT_FLAG_BIT);
+
+    LOG_TRACE_USERMODE("Successfully set FMASK to 0x%X\n", RFLAGS_INTERRUPT_FLAG_BIT);
+
+    // Syscall CS.Sel <- IA32_STAR[47:32] & 0xFFFC
+    // Syscall DS.Sel <- (IA32_STAR[47:32] + 0x8) & 0xFFFC
+    starMsr.SyscallCsDs = kmCsSelector;
+
+    // Sysret CS.Sel <- (IA32_STAR[63:48] + 0x10) & 0xFFFC
+    // Sysret DS.Sel <- (IA32_STAR[63:48] + 0x8) & 0xFFFC
+    starMsr.SysretCsDs = umCsSelector;
+
+    __writemsr(IA32_STAR, starMsr.Raw);
+
+    LOG_TRACE_USERMODE("Successfully set STAR to 0x%X\n", starMsr.Raw);
+}
+
+// SyscallIdIdentifyVersion
+STATUS
+SyscallValidateInterface(
+    IN  SYSCALL_IF_VERSION          InterfaceVersion
+)
+{
+    LOG_TRACE_USERMODE("Will check interface version 0x%x from UM against 0x%x from KM\n",
+        InterfaceVersion, SYSCALL_IF_VERSION_KM);
+
+    if (InterfaceVersion != SYSCALL_IF_VERSION_KM)
+    {
+        LOG_ERROR("Usermode interface 0x%x incompatible with KM!\n", InterfaceVersion);
+        return STATUS_INCOMPATIBLE_INTERFACE;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+// STUDENT TODO: implement the rest of the syscalls
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/system.c b/src_proiect/HAL9000/src/system.c
new file mode 100644
index 0000000..6cf5bcc
--- /dev/null
+++ b/src_proiect/HAL9000/src/system.c
@@ -0,0 +1,330 @@
+#include "HAL9000.h"
+#include "multiboot.h"
+#include "system.h"
+#include "idt.h"
+#include "iomu.h"
+#include "os_info.h"
+#include "cpumu.h"
+#include "smp.h"
+#include "print.h"
+#include "synch.h"
+#include "mmu.h"
+#include "thread_internal.h"
+#include "gdtmu.h"
+#include "lapic_system.h"
+#include "idt_handlers.h"
+#include "serial_comm.h"
+#include "core.h"
+#include "acpi_interface.h"
+#include "network_stack.h"
+#include "dmp_common.h"
+#include "ex_system.h"
+#include "process_internal.h"
+#include "boot_module.h"
+
+#define NO_OF_TSS_STACKS             7
+STATIC_ASSERT(NO_OF_TSS_STACKS <= NO_OF_IST);
+
+typedef struct _SYSTEM_DATA
+{
+    BYTE        NumberOfTssStacks;
+} SYSTEM_DATA, *PSYSTEM_DATA;
+
+static SYSTEM_DATA m_systemData;
+
+QWORD gVirtualToPhysicalOffset;
+
+void
+SystemPreinit(
+    void
+    )
+{
+    memzero(&m_systemData, sizeof(SYSTEM_DATA));
+
+    m_systemData.NumberOfTssStacks = NO_OF_TSS_STACKS;
+
+    BootModulesPreinit();
+    DumpPreinit();
+    ThreadSystemPreinit();
+    printSystemPreinit(NULL);
+    LogSystemPreinit();
+    OsInfoPreinit();
+    MmuPreinitSystem();
+    IomuPreinitSystem();
+    AcpiInterfacePreinit();
+    SmpPreinit();
+    PciSystemPreinit();
+    CorePreinit();
+    NetworkStackPreinit();
+    ProcessSystemPreinit();
+}
+
+STATUS
+SystemInit(
+    IN  ASM_PARAMETERS*     Parameters
+    )
+{
+    STATUS status;
+    PCPU* pCpu;
+
+    status = STATUS_SUCCESS;
+    pCpu = NULL;
+
+    LogSystemInit(LogLevelInfo,
+                  LogComponentInterrupt | LogComponentIo | LogComponentAcpi,
+                  TRUE
+                  );
+
+    // if validation fails => the system will HALT
+    CpuMuValidateConfiguration();
+
+    HalInitialize();
+
+    // install new GDT table
+    status = GdtMuInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("GdtMuInit", status);
+        return status;
+    }
+
+    // initialize serial communication
+    status = SerialCommunicationInitialize(Parameters->BiosSerialPorts, BIOS_MAX_NO_OF_SERIAL_PORTS);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SerialCommunicationInitialize", status);
+        return status;
+    }
+
+    LOG("Serial communications initialized\n");
+    LOG("Running HAL9000 %s version %s built on %s\n",
+        OsGetBuildType(),
+        OsGetVersion(),
+        OsGetBuildDate()
+        );
+
+    status = OsInfoInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("OsInfoInit", status);
+        return status;
+    }
+
+    LOGL("OsInfoInit succeeded\n");
+
+    status = CpuMuActivateFpuFeatures();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("CpuMuActivateFpuFeatures", status);
+        return status;
+    }
+
+    LOGL("CpuMuActivateFpuFeatures succeeded\n");
+
+    // IDT handlers need to be initialized before
+    // MmuInitSystem is called because the VMM
+    // needs page fault handling to allocate memory
+    status = InitIdtHandlers(GdtMuGetCS64Supervisor(), 0);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("InitIdtHandlers", status);
+        return status;
+    }
+
+    LOGL("InitIdtHandlers succeeded\n");
+
+    status = MmuInitSystem(Parameters->KernelBaseAddress,
+                           (DWORD) Parameters->KernelSize,
+                           Parameters->MemoryMapAddress,
+                           Parameters->MemoryMapEntries
+                           );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("MmuInitSystem", status);
+        return status;
+    }
+
+    LOGL("MmuInitSystem succeeded\n");
+
+    if (IsBooleanFlagOn(Parameters->MultibootInformation->Flags, MULTIBOOT_FLAG_BOOT_MODULES_PRESENT))
+    {
+        status = BootModulesInit((PHYSICAL_ADDRESS)(QWORD)Parameters->MultibootInformation->ModuleAddress,
+                                Parameters->MultibootInformation->ModuleCount);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("BootModulesMap", status);
+            return status;
+        }
+    }
+
+    status = IomuInitSystemDriver();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IomuInitSystemDriver", status);
+        return status;
+    }
+    LOGL("IomuInitSystemDriver suceeded\n");
+
+    // initialize ACPI interface
+    status = AcpiInterfaceInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("AcpiInterfaceInit", status);
+        return status;
+    }
+    LOGL("AcpiInterfaceInit suceeded\n");
+
+    status = LapicSystemInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("LapicSystemInit", status);
+        return status;
+    }
+    LOGL("LapicSystemInit suceeded\n");
+
+    status = SmpInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SmpInit", status);
+        return status;
+    }
+
+    LOGL("SmpInit succeded\n");
+
+    // allocate PCPU structure for the BSP
+    // this needs to be before the call to IomuInitSystem because
+    // by the time we enable interrupts we want our TSS descriptor to be installed
+    status = CpuMuAllocAndInitCpu(&pCpu,
+    // C28039: The type of actual parameter 'CpuGetApicId()' should exactly match the type 'APIC_ID'
+#pragma warning(suppress: 28039)
+                                  CpuGetApicId(),
+                                  STACK_DEFAULT_SIZE,
+                                  m_systemData.NumberOfTssStacks
+                                  );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("CpuMuAllocAndInitCpu", status);
+        return status;
+    }
+    LOGL("CpuMuAllocAndInitCpu succeeded\n");
+
+    // initialize IO system
+    // this also initializes the IDT
+    status = IomuInitSystem(GdtMuGetCS64Supervisor(),m_systemData.NumberOfTssStacks );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IomuInitSystem", status);
+        return status;
+    }
+
+    LOGL("IomuInitSystem succeeded\n");
+
+    status = CoreInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("CoreInit", status);
+        return status;
+    }
+
+    LOGL("CoreInit succeeded\n");
+
+    status = SmpSetupLowerMemory(m_systemData.NumberOfTssStacks);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SmpSetupLowerMemory", status);
+        return status;
+    }
+
+    LOGL("SmpSetupLowerMemory succeded\n");
+
+    status = ProcessSystemInitSystemProcess();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ProcessSystemInitSystemProcess", status);
+        return status;
+    }
+
+    LOGL("Successfully intiialized system process!\n");
+
+    status = ThreadSystemInitIdleForCurrentCPU();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ThreadSystemInitIdleForCurrentCPU", status);
+        return status;
+    }
+
+    LOGL("ThreadSystemInitIdleForCurrentCPU succeeded\n");
+
+    status = AcpiInterfaceLateInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("AcpiInterfaceLateInit", status);
+        return status;
+    }
+    LOGL("AcpiInterfaceLateInit succeeded\n");
+
+    SmpWakeupAps();
+    LOGL("SmpWakeupAps completed\n");
+
+    // finish IOMU initialization
+    status = IomuInitSystemAfterApWakeup();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IomuInitSystemAfterApWakeup", status);
+        return status;
+    }
+    LOGL("IomuInitSystemAfterApWakeup succeeded\n");
+
+    // we no longer need the lower memory mappings
+    SmpCleanupLowerMemory();
+
+    LOGL("SmpCleanupLowerMemory completed\n");
+
+    // After the APs have woken up we no longer need the 1:1 VA->PA mappings
+    MmuDiscardIdentityMappings();
+
+    LOGL("MmuDiscardIdentityMappings completed\n");
+
+    status = MmuInitThreadingSystem();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("MmuInitThreadingSystem", status );
+        return status;
+    }
+
+    LOGL("MmuInitThreadingSystem succeded\n");
+
+    // IOMU late initialization: drivers + system partition determination
+    status = IomuLateInit();
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IomuLateInit", status);
+        return status;
+    }
+
+    LOGL("IOMU late initialization successfully completed\n");
+
+    status = NetworkStackInit(FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NetworkStackInit", status);
+        return status;
+    }
+
+    LOGL("Network stack successfully initialized\n");
+
+    return status;
+}
+
+void
+SystemUninit(
+    void
+    )
+{
+    LOGL("Finished command execution\n");
+
+    LOGL("%s terminating!\n", OsInfoGetName());
+
+    // disable interrupts
+    CpuIntrDisable();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/system_driver.c b/src_proiect/HAL9000/src/system_driver.c
new file mode 100644
index 0000000..827a884
--- /dev/null
+++ b/src_proiect/HAL9000/src/system_driver.c
@@ -0,0 +1,25 @@
+#include "HAL9000.h"
+#include "io.h"
+#include "system_driver.h"
+
+STATUS
+(__cdecl SystemDriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    )
+{
+    PDEVICE_OBJECT pDev;
+
+    ASSERT( NULL != DriverObject );
+
+    LOG_FUNC_START;
+
+    pDev = IoCreateDevice(DriverObject,
+                          0,
+                          DeviceTypeSystem
+                          );
+    ASSERT( NULL != pDev );
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_bitmap.c b/src_proiect/HAL9000/src/test_bitmap.c
new file mode 100644
index 0000000..4caf558
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_bitmap.c
@@ -0,0 +1,118 @@
+#include "test_common.h"
+#include "test_bitmap.h"
+#include "bitmap.h"
+
+static const DWORD TST_BITMAP_NO_OF_ELEMENTS_TO_TEST_FOR[] = 
+{ 
+    BITS_FOR_STRUCTURE(BYTE), 
+    BITS_FOR_STRUCTURE(BYTE) * 10, 
+    BITS_FOR_STRUCTURE(BYTE) * 10 + 1, 
+    BITS_FOR_STRUCTURE(BYTE) * 10 + 31, 
+    212, 
+    1, 
+    491230 
+};
+static const DWORD NO_OF_ELEMENTS_TSTS = ARRAYSIZE(TST_BITMAP_NO_OF_ELEMENTS_TO_TEST_FOR);
+
+static
+void
+_TestBitmapForElements(
+    IN      DWORD       NumberOfElements
+    );
+
+void
+TestBitmap(
+    void
+    )
+{
+    DWORD i;
+
+    for (i = 0; i < NO_OF_ELEMENTS_TSTS; ++i)
+    {
+        LOGL("[%d]Will test bitmap for %d elements\n", i, TST_BITMAP_NO_OF_ELEMENTS_TO_TEST_FOR[i] );
+        _TestBitmapForElements(TST_BITMAP_NO_OF_ELEMENTS_TO_TEST_FOR[i]);
+    }
+}
+
+static
+void
+_TestBitmapForElements(
+    IN      DWORD       NumberOfElements
+    )
+{
+    BITMAP tstBitmap;
+    DWORD sizeOfStruct;
+    DWORD expectedSizeOfStruct;
+    PBYTE pBitmapBuffer;
+    STATUS status;
+    DWORD bitmapIndex;
+
+    LOG_FUNC_START;
+
+    ASSERT( 0 != NumberOfElements );
+
+    memzero(&tstBitmap, sizeof(BITMAP));
+    sizeOfStruct = 0;
+    expectedSizeOfStruct = ( AlignAddressUpper(NumberOfElements, BITS_FOR_STRUCTURE(BYTE)) / BITS_FOR_STRUCTURE(BYTE) ) * sizeof(BYTE);
+    status = STATUS_SUCCESS;
+    bitmapIndex = MAX_DWORD;
+
+    sizeOfStruct = BitmapPreinit(&tstBitmap, NumberOfElements );
+    ASSERT_INFO( sizeOfStruct == expectedSizeOfStruct,
+                                  "Size of bitmap buffer should be %d bytes, but it is %d bytes", expectedSizeOfStruct, sizeOfStruct );
+    ASSERT( 0 == sizeOfStruct % sizeof(BYTE));
+    LOGL("Buffer required: %d bytes\n", sizeOfStruct );
+
+    pBitmapBuffer = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, sizeOfStruct, HEAP_TEST_TAG, 0 );
+
+    BitmapInit(&tstBitmap, pBitmapBuffer );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, TRUE);
+    ASSERT_INFO(MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex);
+
+    bitmapIndex = BitmapScan(&tstBitmap, 1, FALSE);
+    ASSERT_INFO(0 == bitmapIndex, "Index: %d", bitmapIndex);
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, FALSE );
+    ASSERT_INFO( 0 == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements + 1, FALSE );
+    ASSERT_INFO( MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, TRUE);
+    ASSERT_INFO( MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScanAndFlip(&tstBitmap, NumberOfElements, TRUE);
+    ASSERT_INFO( MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScanAndFlip(&tstBitmap, NumberOfElements, FALSE);
+    ASSERT_INFO(0 == bitmapIndex, "Index: %d", bitmapIndex);
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, FALSE);
+    ASSERT_INFO( MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, TRUE);
+    ASSERT_INFO( 0 == bitmapIndex, "Index: %d", bitmapIndex );
+
+    BitmapClearBits(&tstBitmap, 0, NumberOfElements );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, FALSE);
+    ASSERT_INFO( 0 == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, TRUE);
+    ASSERT_INFO( MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex );
+
+    BitmapSetBits(&tstBitmap, 0, NumberOfElements );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, FALSE);
+    ASSERT_INFO( MAX_DWORD == bitmapIndex, "Index: %d", bitmapIndex );
+
+    bitmapIndex = BitmapScan(&tstBitmap, NumberOfElements, TRUE);
+    ASSERT_INFO( 0 == bitmapIndex, "Index: %d", bitmapIndex );
+
+    ExFreePoolWithTag(pBitmapBuffer, HEAP_TEST_TAG);
+
+    BitmapUninit(&tstBitmap);
+
+    LOG_FUNC_END;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_common.c b/src_proiect/HAL9000/src/test_common.c
new file mode 100644
index 0000000..26ebf42
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_common.c
@@ -0,0 +1,31 @@
+#include "test_common.h"
+#include "test_bitmap.h"
+#include "test_pmm.h"
+#include "test_vmm.h"
+#include "test_file_io.h"
+#include "test_dma.h"
+#include "test_thread.h"
+#include "smp.h"
+
+#define TEST_HEAP_ALLOCATION_SIZE           0x100
+
+void
+TestRunAllFunctional(
+    void
+    )
+{
+    TestBitmap();
+    TestPmmReserveAndReleaseFunctions();
+    TestVmmAllocAndFreeFunctions();
+    TestFileRead();
+    TestAllThreadFunctionalities(SmpGetNumberOfActiveCpus() * 2 );
+}
+
+void
+TestRunAllPerformance(
+    void
+    )
+{
+    TestFileReadPerformance();
+    TestDmaPerformance();
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_dma.c b/src_proiect/HAL9000/src/test_dma.c
new file mode 100644
index 0000000..ce9b7e0
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_dma.c
@@ -0,0 +1,128 @@
+#include "HAL9000.h"
+#include "test_dma.h"
+#include "perf_framework.h"
+#include "io.h"
+#include "mmu.h"
+#include "cpumu.h"
+
+#define DMA_TEST_ITERATION_COUNT            10
+
+typedef struct _RAW_TEST_CTX
+{
+    QWORD           BytesToRead;
+    BOOLEAN         Asynchronous;
+    PDEVICE_OBJECT  Device;
+    PVOID           Buffer;
+} RAW_TEST_CTX, *PRAW_TEST_CTX;
+
+static FUNC_TestPerformance     _TestRawReadPerformance;
+
+static const DWORD BYTES_TO_READ[] = { SECTOR_SIZE, PAGE_SIZE, 4 * PAGE_SIZE, 8 * PAGE_SIZE, 15 * PAGE_SIZE };
+static const DWORD NO_OF_BYTES_VALUES = ARRAYSIZE(BYTES_TO_READ);
+static const char* STAT_NAMES[2] = { "SYNCHRONOUS", "ASYNCHRONOUS" };
+
+void
+TestDmaPerformance(
+    void
+    )
+{
+    RAW_TEST_CTX ctx;
+    PERFORMANCE_STATS perfStats[2];
+    DWORD i;
+    DWORD async;
+    DWORD bytesToRead;
+    PVOID pBuffer;
+    PDEVICE_OBJECT pVolumeDevice;
+    STATUS status;
+    PDEVICE_OBJECT* pDeviceObjects;
+    DWORD noOfDevices;
+
+    memzero(&ctx, sizeof(RAW_TEST_CTX));
+    bytesToRead = 0;
+    pBuffer = NULL;
+    pVolumeDevice = NULL;
+
+    status = IoGetDevicesByType(DeviceTypeVolume,
+                                &pDeviceObjects,
+                                &noOfDevices
+                                );
+    ASSERT(SUCCEEDED(status));
+    ASSERT( NULL != pDeviceObjects );
+    ASSERT(noOfDevices > 0 );
+
+    pVolumeDevice = pDeviceObjects[0];
+    ctx.Device = pVolumeDevice;
+
+    IoFreeTemporaryData(pDeviceObjects);
+    pDeviceObjects = NULL;
+
+    for (i = 0; i < NO_OF_BYTES_VALUES; ++i)
+    {
+        memzero(&perfStats, sizeof(perfStats));
+
+        bytesToRead = BYTES_TO_READ[i];
+
+        if (NULL != pBuffer)
+        {
+            ExFreePoolWithTag(pBuffer, HEAP_TEST_TAG);
+            pBuffer = NULL;
+        }
+
+        pBuffer = ExAllocatePoolWithTag(PoolAllocateZeroMemory, bytesToRead, HEAP_TEST_TAG, 0 );
+        ASSERT( NULL != pBuffer );
+
+        MmuProbeMemory(pBuffer, bytesToRead );
+
+        ctx.BytesToRead = bytesToRead;
+        ctx.Buffer = pBuffer;
+        for (async = 0; async < 2; ++async)
+        {
+            ctx.Asynchronous = (BOOLEAN) async;
+
+            RunPerformanceFunction(_TestRawReadPerformance,
+                                   &ctx,
+                                   DMA_TEST_ITERATION_COUNT,
+                                   FALSE,
+                                   &perfStats[async]
+                                   );
+        }
+
+        LOGL("Volume read with chunk size 0x%x bytes\n", bytesToRead);
+        DisplayPerformanceStats(perfStats, 2, STAT_NAMES);
+    }
+
+    if (NULL != pBuffer)
+    {
+        ExFreePoolWithTag(pBuffer, HEAP_TEST_TAG);
+        pBuffer = NULL;
+    }
+}
+
+
+void
+(__cdecl _TestRawReadPerformance)(
+    IN_OPT  PVOID       Context
+    )
+{
+    PRAW_TEST_CTX pCtx;
+    QWORD bytesToRead;
+    STATUS status;
+
+    LOG_FUNC_START_CPU;
+
+    ASSERT( NULL != Context );
+
+    pCtx = (PRAW_TEST_CTX) Context;
+    bytesToRead = pCtx->BytesToRead;
+
+    status = IoReadDeviceEx(pCtx->Device,
+                            pCtx->Buffer,
+                            &bytesToRead,
+                            0,
+                            pCtx->Asynchronous
+                            );
+    ASSERT(SUCCEEDED(status));
+    ASSERT( bytesToRead == pCtx->BytesToRead );
+
+    LOG_FUNC_END_CPU;
+}
diff --git a/src_proiect/HAL9000/src/test_file_io.c b/src_proiect/HAL9000/src/test_file_io.c
new file mode 100644
index 0000000..39731da
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_file_io.c
@@ -0,0 +1,503 @@
+#include "HAL9000.h"
+#include "test_file_io.h"
+#include "io.h"
+#include "perf_framework.h"
+#include "mmu.h"
+#include "rtc.h"
+
+static const char FILES_TO_READ[][MAX_PATH] = { "C:\\WINLOA~1.RAR",
+                                                "D:\\cacheset.exe",
+                                                "D:\\procexp.exe"
+                                                };
+static const DWORD NO_OF_FILES = ARRAYSIZE(FILES_TO_READ);
+
+static const DWORD READ_CHUNK_SIZES[] = { PAGE_SIZE, 4 * PAGE_SIZE, 8 * PAGE_SIZE, 32 * PAGE_SIZE, 63 * PAGE_SIZE };
+static const DWORD NO_OF_CHUNK_SIZES = ARRAYSIZE(READ_CHUNK_SIZES);
+static const char* STAT_NAMES[2] = { "SYNCHRONOUS", "ASYNCHRONOUS" };
+
+#define FILE_TEST_PERFORMANCE_NO_OF_ITERATIONS          5
+
+static
+STATUS
+_TestSingleFileRead(
+    IN      PFILE_OBJECT        File,
+    IN      QWORD               FileSize,
+    IN      PVOID               Buffer,
+    IN      DWORD               BufferSize
+    );
+
+static
+STATUS
+_TestFileRead(
+    IN_Z    char*               Filename,
+    IN      PVOID               Buffer,
+    IN      DWORD               BufferSize,
+    IN      BOOLEAN             Asynchronous,
+    IN      DWORD               Iterations,
+    OUT     PPERFORMANCE_STATS  PerfStats
+    );
+
+BOOLEAN
+TestFileRead(
+    void
+    )
+{
+    PFILE_OBJECT syncFile;
+    PFILE_OBJECT asyncFile;
+    STATUS status;
+    STATUS statusSup;
+    DWORD i;
+    DWORD j;
+    PVOID pSyncBuffer;
+    PVOID pAsyncBuffer;
+    QWORD fileOffset;
+    QWORD bytesRemaining;
+    FILE_INFORMATION fileInformation;
+
+    syncFile = asyncFile = NULL;
+    pSyncBuffer = pAsyncBuffer = NULL;
+    status = STATUS_SUCCESS;
+    statusSup = STATUS_SUCCESS;
+    memzero(&fileInformation, sizeof(FILE_INFORMATION));
+
+    __try
+    {
+        for (i = 0; i < NO_OF_FILES; ++i)
+        {
+            if (NULL != syncFile)
+            {
+                status = IoCloseFile(syncFile);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("IoCloseFile", status);
+                    __leave;
+                }
+
+                syncFile = NULL;
+            }
+
+            if (NULL != asyncFile)
+            {
+                status = IoCloseFile(asyncFile);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("IoCloseFile", status);
+                    __leave;
+                }
+
+                asyncFile = NULL;
+            }
+
+            status = IoCreateFile(&syncFile,
+                                  FILES_TO_READ[i],
+                                  FALSE,
+                                  FALSE,
+                                  FALSE
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoCreateFile", status);
+                continue;
+            }
+
+            status = IoCreateFile(&asyncFile,
+                                  FILES_TO_READ[i],
+                                  FALSE,
+                                  FALSE,
+                                  TRUE
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoCreateFile", status);
+                continue;
+            }
+
+            status = IoQueryInformationFile(syncFile,
+                                            &fileInformation
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoQueryInformationFile", status);
+                __leave;
+            }
+
+            fileOffset = 0;
+            bytesRemaining = fileInformation.FileSize;
+
+            for (j = 0; j < NO_OF_CHUNK_SIZES; ++j)
+            {
+                DWORD allocationSize = READ_CHUNK_SIZES[j];
+
+                LOGL("Running on file [%s] with chunk size 0x%x bytes\n", FILES_TO_READ[i], allocationSize);
+
+                if (NULL != pSyncBuffer)
+                {
+                    ExFreePoolWithTag(pSyncBuffer, HEAP_TEST_TAG);
+                    pSyncBuffer = NULL;
+                }
+
+                if (NULL != pAsyncBuffer)
+                {
+                    ExFreePoolWithTag(pAsyncBuffer, HEAP_TEST_TAG);
+                    pAsyncBuffer = NULL;
+                }
+
+                pSyncBuffer = ExAllocatePoolWithTag(PoolAllocateZeroMemory, allocationSize, HEAP_TEST_TAG, 0);
+                if (NULL == pSyncBuffer)
+                {
+                    LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", allocationSize);
+                    status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                    __leave;
+                }
+
+                pAsyncBuffer = ExAllocatePoolWithTag(PoolAllocateZeroMemory, allocationSize, HEAP_TEST_TAG, 0);
+                if (NULL == pAsyncBuffer)
+                {
+                    LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", allocationSize);
+                    status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                    __leave;
+                }
+
+                while (0 != bytesRemaining)
+                {
+                    QWORD bytesRead;
+                    QWORD bytesToRead = (DWORD)min(bytesRemaining, allocationSize);
+
+                    LogSetState(FALSE);
+
+                    status = IoReadFile(syncFile,
+                                        bytesToRead,
+                                        &fileOffset,
+                                        pSyncBuffer,
+                                        &bytesRead
+                    );
+                    if (!SUCCEEDED(status))
+                    {
+                        LOG_FUNC_ERROR("IoReadFile", status);
+                        __leave;
+                    }
+                    ASSERT(bytesToRead == bytesRead);
+
+                    status = IoReadFile(asyncFile,
+                                        bytesToRead,
+                                        &fileOffset,
+                                        pAsyncBuffer,
+                                        &bytesRead
+                    );
+                    if (!SUCCEEDED(status))
+                    {
+                        LOG_FUNC_ERROR("IoReadFile", status);
+                        __leave;
+                    }
+                    ASSERT(bytesToRead == bytesRead);
+
+                    LogSetState(TRUE);
+
+                    ASSERT(bytesRead <= MAX_DWORD);
+                    if (0 != memcmp(pAsyncBuffer, pSyncBuffer, (DWORD)bytesRead))
+                    {
+                        LOG_ERROR("Async buffers differs from sync buffer at file offset 0x%X\n", fileOffset);
+                    }
+
+                    bytesRemaining = bytesRemaining - bytesRead;
+                    fileOffset = fileOffset + bytesRead;
+                }
+            }
+
+        }
+    }
+    __finally
+    {
+        if (NULL != syncFile)
+        {
+            statusSup = IoCloseFile(syncFile);
+            if (!SUCCEEDED(statusSup))
+            {
+                LOG_FUNC_ERROR("IoCloseFile", statusSup);
+            }
+
+            syncFile = NULL;
+        }
+
+        if (NULL != asyncFile)
+        {
+            statusSup = IoCloseFile(asyncFile);
+            if (!SUCCEEDED(statusSup))
+            {
+                LOG_FUNC_ERROR("IoCloseFile", statusSup);
+            }
+
+            asyncFile = NULL;
+        }
+
+        if (NULL != pSyncBuffer)
+        {
+            ExFreePoolWithTag(pSyncBuffer, HEAP_TEST_TAG);
+            pSyncBuffer = NULL;
+        }
+
+        if (NULL != pAsyncBuffer)
+        {
+            ExFreePoolWithTag(pAsyncBuffer, HEAP_TEST_TAG);
+            pAsyncBuffer = NULL;
+        }
+    }
+
+    return SUCCEEDED(status);
+}
+
+void
+TestFileReadPerformance(
+    void
+    )
+{
+    STATUS status;
+    DWORD i;
+    DWORD j;
+    BOOLEAN async;
+    PVOID pBuffer;
+    PERFORMANCE_STATS perfStats[2];
+
+    pBuffer = NULL;
+    status = STATUS_SUCCESS;
+
+    __try
+    {
+        for (i = 0; i < NO_OF_FILES; ++i)
+        {
+            for (j = 0; j < NO_OF_CHUNK_SIZES; ++j)
+            {
+                DWORD allocationSize = READ_CHUNK_SIZES[j];
+
+                LOGL("Running on file [%s] with chunk size 0x%x bytes\n", FILES_TO_READ[i], allocationSize);
+
+                if (NULL != pBuffer)
+                {
+                    ExFreePoolWithTag(pBuffer, HEAP_TEST_TAG);
+                    pBuffer = NULL;
+                }
+
+                pBuffer = ExAllocatePoolWithTag(PoolAllocateZeroMemory, allocationSize, HEAP_TEST_TAG, 0);
+                if (NULL == pBuffer)
+                {
+                    LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", allocationSize);
+                    status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                    __leave;
+                }
+
+                // this is done so we won't have page faults
+                // when reading the buffers
+                MmuProbeMemory(pBuffer, allocationSize);
+
+                memzero(&perfStats, sizeof(perfStats));
+                LogSetState(FALSE);
+                for (async = 0; async < 2; ++async)
+                {
+                    status = _TestFileRead(FILES_TO_READ[i],
+                                           pBuffer,
+                                           allocationSize,
+                                           async,
+                                           FILE_TEST_PERFORMANCE_NO_OF_ITERATIONS,
+                                           &perfStats[async]
+                                           );
+                    if (!SUCCEEDED(status))
+                    {
+                        LogSetState(TRUE);
+                        LOG_FUNC_ERROR("_TestFileRead", status);
+                        continue;
+                    }
+                }
+                LogSetState(TRUE);
+
+                LOGL("File [%s] with chunk size 0x%x bytes\n", FILES_TO_READ[i], allocationSize);
+                DisplayPerformanceStats(perfStats, 2, STAT_NAMES);
+            }
+
+        }
+    }
+    __finally
+    {
+        if (NULL != pBuffer)
+        {
+            ExFreePoolWithTag(pBuffer, HEAP_TEST_TAG);
+            pBuffer = NULL;
+        }
+    }
+}
+
+static
+STATUS
+_TestSingleFileRead(
+    IN      PFILE_OBJECT        File,
+    IN      QWORD               FileSize,
+    IN      PVOID               Buffer,
+    IN      DWORD               BufferSize
+    )
+{
+    STATUS status;
+    QWORD bytesRemaining;
+    QWORD fileOffset;
+
+    ASSERT( NULL != File );
+    ASSERT( 0 != FileSize );
+    ASSERT( NULL != Buffer );
+    ASSERT( 0 != BufferSize );
+
+    bytesRemaining = FileSize;
+    fileOffset = 0;
+
+    while (0 != bytesRemaining)
+    {
+        QWORD bytesRead;
+        QWORD bytesToRead = min(bytesRemaining, BufferSize);
+
+        status = IoReadFile(File,
+                            bytesToRead,
+                            &fileOffset,
+                            Buffer,
+                            &bytesRead
+                            );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadFile", status);
+            return status;
+        }
+        ASSERT(bytesToRead == bytesRead);
+
+        bytesRemaining = bytesRemaining - bytesRead;
+        fileOffset = fileOffset + bytesRead;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+_TestFileRead(
+    IN_Z    char*               Filename,
+    IN      PVOID               Buffer,
+    IN      DWORD               BufferSize,
+    IN      BOOLEAN             Asynchronous,
+    IN      DWORD               Iterations,
+    OUT     PPERFORMANCE_STATS  PerfStats
+    )
+{
+    STATUS status;
+    STATUS statusSup;
+    PFILE_OBJECT pFile;
+    DWORD i;
+    FILE_INFORMATION fileInfo;
+    QWORD* allTimes;
+    QWORD startTime;
+    QWORD endTime;
+
+    ASSERT( NULL != Filename );
+    ASSERT( NULL != Buffer );
+    ASSERT( 0 != BufferSize );
+    ASSERT( NULL != PerfStats );
+
+    status = STATUS_SUCCESS;
+    statusSup = STATUS_SUCCESS;
+    pFile = NULL;
+    memzero(&fileInfo, sizeof(FILE_INFORMATION));
+    memzero( PerfStats, sizeof(PERFORMANCE_STATS));
+    allTimes = NULL;
+
+    __try
+    {
+        status = IoCreateFile(&pFile,
+                              Filename,
+                              FALSE,
+                              FALSE,
+                              Asynchronous
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCreateFile", status);
+            __leave;
+        }
+
+        status = IoQueryInformationFile(pFile, &fileInfo);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoQueryInformationFile", status);
+            __leave;
+        }
+
+        allTimes = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(QWORD) * Iterations, HEAP_TEST_TAG, 0);
+        if (NULL == allTimes)
+        {
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", status);
+            __leave;
+        }
+
+        for (i = 0; i < Iterations; ++i)
+        {
+            startTime = RtcGetTickCount();
+            status = _TestSingleFileRead(pFile,
+                                         fileInfo.FileSize,
+                                         Buffer,
+                                         BufferSize
+            );
+            endTime = RtcGetTickCount();
+            LOGL("Finished iteration %d\n", i);
+
+            allTimes[i] = endTime - startTime;
+        }
+    }
+    __finally
+    {
+        if (SUCCEEDED(status))
+        {
+            QWORD totalTime;
+            QWORD minTime;
+            QWORD maxTime;
+
+            ASSERT(NULL != allTimes);
+
+            totalTime = minTime = maxTime = allTimes[0];
+
+            for (i = 1; i < Iterations; ++i)
+            {
+                if (allTimes[i] < minTime)
+                {
+                    minTime = allTimes[i];
+                }
+                else if (allTimes[i] > maxTime)
+                {
+                    maxTime = allTimes[i];
+                }
+
+                if (MAX_QWORD - allTimes[i] < totalTime)
+                {
+                    // we will overflow
+                    NOT_REACHED;
+                }
+
+                totalTime = totalTime + allTimes[i];
+            }
+
+            PerfStats->Min = minTime;
+            PerfStats->Max = maxTime;
+            PerfStats->Mean = totalTime / Iterations;
+        }
+
+        if (NULL != pFile)
+        {
+            statusSup = IoCloseFile(pFile);
+            if (!SUCCEEDED(statusSup))
+            {
+                LOG_FUNC_ERROR("IoCloseFile", statusSup);
+            }
+        }
+
+        if (NULL != allTimes)
+        {
+            ExFreePoolWithTag(allTimes, HEAP_TEST_TAG);
+            allTimes = NULL;
+        }
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_net_stack.c b/src_proiect/HAL9000/src/test_net_stack.c
new file mode 100644
index 0000000..32ddf86
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_net_stack.c
@@ -0,0 +1,329 @@
+#include "test_common.h"
+#include "test_net_stack.h"
+#include "io.h"
+#include "thread.h"
+#include "dmp_memory.h"
+#include "dmp_network.h"
+#include "keyboard.h"
+#include "keyboard_utils.h"
+#include "cpu.h"
+
+#define RECEIVE_THREAD_INITIAL_BUFFER_SIZE                  sizeof(NET_RECEIVE_FRAME_OUTPUT)//64*KB_SIZE
+#define TRANSMIT_THREAD_BUFFER_SIZE                         1*KB_SIZE
+
+#define BUFFER_TO_SEND                                      "This is the c00le$t buffer ev4r made!!!!!"
+
+typedef struct _NET_TRAFFIC_THREAD_CONTEXT
+{
+    DEVICE_ID               NetworkDevice;
+    volatile BOOLEAN*       StopRequests;
+
+    // valid only for receive thread
+    BOOLEAN                 ResendRequests;
+} NET_TRAFFIC_THREAD_CONTEXT, *PNET_TRAFFIC_THREAD_CONTEXT;
+
+static FUNC_ThreadStart _TestReceivePacketsForAdapter;
+
+static FUNC_ThreadStart _TestTransmitPacketsForAdapter;
+
+_No_competing_thread_
+BOOLEAN
+TestNetwork(
+        IN      BOOLEAN         Transmit,
+    _When_(Transmit, _Reserved_)
+    _When_(!Transmit, IN)
+        IN      BOOLEAN         ResendRequets
+    )
+{
+    STATUS status;
+    DWORD noOfDevices;
+    DWORD i;
+    char threadName[MAX_PATH];
+    PTHREAD* pThreads;
+    PNET_TRAFFIC_THREAD_CONTEXT pThreadContexts;
+    volatile BOOLEAN bStopRequests;
+    DWORD temp;
+    PNETWORK_DEVICE_INFO pNetDevices;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    noOfDevices = 0;
+    pThreads = NULL;
+    pThreadContexts = NULL;
+    pNetDevices = NULL;
+    // C28113: Accessing a local variable via an Interlocked function : This is an unusual usage which could be reconsidered
+#pragma warning(suppress: 28113)
+    _InterlockedExchange8(&bStopRequests, FALSE);
+
+    status = NetGetNetworkDevices(NULL, &noOfDevices);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NetGetNetworkDevices", status );
+        return FALSE;
+    }
+    if (noOfDevices == 0)
+    {
+        LOG_WARNING("No network devices found!\n");
+        return TRUE;
+    }
+
+    __try
+    {
+        pNetDevices = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(NETWORK_DEVICE_INFO) * noOfDevices, HEAP_TEST_TAG, 0);
+        ASSERT(NULL != pNetDevices);
+
+        temp = noOfDevices;
+        status = NetGetNetworkDevices(pNetDevices, &temp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NetGetNetworkDevices", status);
+            __leave;
+        }
+        ASSERT(temp == noOfDevices);
+
+
+        pThreads = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PTHREAD) * noOfDevices, HEAP_TEST_TAG, 0);
+        ASSERT(NULL != pThreads);
+
+        pThreadContexts = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(NET_TRAFFIC_THREAD_CONTEXT) * noOfDevices, HEAP_TEST_TAG, 0);
+        ASSERT(NULL != pThreadContexts);
+
+        for (i = 0; i < noOfDevices; ++i)
+        {
+            pThreadContexts[i].NetworkDevice = pNetDevices[i].DeviceId;
+
+            // A variable which is accessed via an Interlocked function must always be accessed via an Interlocked function
+            /// there is no access to memory, SAL is just being crazy
+#pragma warning(suppress: 28112)
+            pThreadContexts[i].StopRequests = &bStopRequests;
+            pThreadContexts[i].ResendRequests = ResendRequets;
+
+            snprintf(threadName,
+                     MAX_PATH,
+                     Transmit ? "Network transmit-%02x" : "Network receive-%02x",
+                     i
+            );
+            status = ThreadCreate(threadName,
+                                  ThreadPriorityDefault,
+                                  Transmit ? _TestTransmitPacketsForAdapter : _TestReceivePacketsForAdapter,
+                                  &pThreadContexts[i],
+                                  &pThreads[i]
+            );
+            ASSERT(SUCCEEDED(status));
+        }
+
+        // wait for a space key press
+        while (KEY_SPACE != getch());
+
+
+        LOG("Will stop receiver threads\n");
+
+        // C28113: Accessing a local variable via an Interlocked function : This is an unusual usage which could be reconsidered
+#pragma warning(suppress: 28113)
+        _InterlockedExchange8(&bStopRequests, 1);
+
+        for (i = 0; i < noOfDevices; ++i)
+        {
+            LOG("Waiting for thread 0x%x termination\n", ThreadGetId(pThreads[i]));
+            ThreadWaitForTermination(pThreads[i], &status);
+            LOG("Thread 0x%x terminated with status 0x%x\n", ThreadGetId(pThreads[i]), status);
+            ASSERT(SUCCEEDED(status));
+        }
+
+        LOG("Receiver threads terminated\n");
+    }
+    __finally
+    {
+        if (NULL != pThreads)
+        {
+            for (i = 0; i < noOfDevices; ++i)
+            {
+                if (NULL != pThreads[i])
+                {
+                    ThreadCloseHandle(pThreads[i]);
+                    pThreads[i] = NULL;
+                }
+            }
+
+            ExFreePoolWithTag(pThreads, HEAP_TEST_TAG);
+            pThreads = NULL;
+        }
+
+        if (NULL != pThreadContexts)
+        {
+            ExFreePoolWithTag(pThreadContexts, HEAP_TEST_TAG);
+            pThreadContexts = NULL;
+        }
+
+        if (NULL != pNetDevices)
+        {
+            ExFreePoolWithTag(pNetDevices, HEAP_TEST_TAG);
+            pNetDevices = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return SUCCEEDED(status);
+}
+
+STATUS
+(__cdecl _TestReceivePacketsForAdapter)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    PNET_TRAFFIC_THREAD_CONTEXT pCtx;
+    DWORD bufferSize;
+    DWORD requiredBufferSize;
+    PETHERNET_FRAME pFrame;
+
+    ASSERT( NULL != Context );
+
+    LOG_FUNC_START_THREAD;
+
+    status = STATUS_SUCCESS;
+    pCtx = (PNET_TRAFFIC_THREAD_CONTEXT) Context;
+    pFrame = NULL;
+    bufferSize = RECEIVE_THREAD_INITIAL_BUFFER_SIZE;
+    requiredBufferSize = bufferSize;
+
+    while (!*pCtx->StopRequests)
+    {
+        if (bufferSize < requiredBufferSize)
+        {
+            bufferSize = requiredBufferSize;
+            ASSERT( NULL != pFrame );
+
+            ExFreePoolWithTag(pFrame, HEAP_TEST_TAG);
+            pFrame = NULL;
+        }
+
+        if (NULL == pFrame)
+        {
+            pFrame = ExAllocatePoolWithTag(PoolAllocateZeroMemory, bufferSize, HEAP_TEST_TAG, 0 );
+            ASSERT( NULL != pFrame );
+        }
+
+        status = NetReceiveFrame(pCtx->NetworkDevice,
+                                 pFrame,
+                                 bufferSize,
+                                 &requiredBufferSize
+                                 );
+        if (STATUS_BUFFER_TOO_SMALL == status)
+        {
+            status = STATUS_SUCCESS;
+            LOG_WARNING("IoCallDriver failed before buffer of size %u was too small, %u bytes are required\n", bufferSize, requiredBufferSize);
+            continue;
+        }
+        else if (STATUS_DEVICE_DISABLED == status)
+        {
+            status = STATUS_SUCCESS;
+            LOG("Device RX has been disabled!\n");
+            break;
+        }
+        else if (STATUS_DEVICE_NOT_CONNECTED == status)
+        {
+            status = STATUS_SUCCESS;
+            LOG("Device link is down!\n");
+            break;
+        }
+
+        ASSERT(SUCCEEDED(status));
+
+        DumpEthernetFrame(pFrame, requiredBufferSize);
+
+        if (pCtx->ResendRequests)
+        {
+            status = NetSendFrame(FALSE,
+                                  pCtx->NetworkDevice,
+                                  pFrame,
+                                  requiredBufferSize,
+                                  MAC_BROADCAST
+                                  );
+            if (STATUS_DEVICE_DISABLED == status)
+            {
+                LOG_WARNING("Could not send network frame because TX functionality is disabled! :(\n");
+                status = STATUS_SUCCESS;
+            }
+            else if (STATUS_DEVICE_NOT_CONNECTED == status)
+            {
+                status = STATUS_SUCCESS;
+                LOG("Device link is down!\n");
+                break;
+            }
+            ASSERT(SUCCEEDED(status));
+        }
+    }
+
+    LOGTPL("Exit status: 0x%x\n", status );
+    LOG_FUNC_END_THREAD;
+
+    return status;
+}
+
+STATUS
+(__cdecl _TestTransmitPacketsForAdapter)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    PNET_TRAFFIC_THREAD_CONTEXT pCtx;
+    PETHERNET_FRAME pFrame;
+    DWORD bufferSize;
+    QWORD packetIndex;
+
+    ASSERT(NULL != Context);
+
+    LOG_FUNC_START_THREAD;
+
+    status = STATUS_SUCCESS;
+    pCtx = (PNET_TRAFFIC_THREAD_CONTEXT)Context;
+    pFrame = NULL;
+    bufferSize = TRANSMIT_THREAD_BUFFER_SIZE;
+
+    pFrame = ExAllocatePoolWithTag(PoolAllocateZeroMemory, bufferSize, HEAP_TEST_TAG, 0 );
+    ASSERT( NULL != pFrame );
+
+    pFrame->Type = htonw(ETHERNET_FRAME_TYPE_IP4);
+    memcpy(pFrame->Data, BUFFER_TO_SEND, sizeof(BUFFER_TO_SEND));
+    packetIndex = 0;
+
+    while (!*pCtx->StopRequests)
+    {
+        memcpy(pFrame->Data + sizeof(BUFFER_TO_SEND), &packetIndex, sizeof(QWORD));
+        status = NetSendFrame(FALSE,
+                              pCtx->NetworkDevice,
+                              pFrame,
+                              bufferSize,
+                              pFrame->Destination
+                              );
+        if (STATUS_DEVICE_DISABLED == status)
+        {
+            status = STATUS_SUCCESS;
+            LOG("Device TX has been disabled!\n");
+            break;
+        }
+        else if (STATUS_DEVICE_NOT_CONNECTED == status)
+        {
+            status = STATUS_SUCCESS;
+            LOG("Device link is down!\n");
+            break;
+        }
+
+        ASSERT(SUCCEEDED(status));
+        packetIndex++;
+    }
+
+    if (NULL != pFrame)
+    {
+        ExFreePoolWithTag(pFrame, HEAP_TEST_TAG);
+        pFrame = NULL;
+    }
+
+    LOGTPL("Exit status: 0x%x\n", status);
+    LOG_FUNC_END_THREAD;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_pmm.c b/src_proiect/HAL9000/src/test_pmm.c
new file mode 100644
index 0000000..dfdf816
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_pmm.c
@@ -0,0 +1,111 @@
+#include "test_common.h"
+#include "test_pmm.h"
+
+static const DWORD TST_PMM_ALLOCATION_FRAMES[] =
+{
+    1,
+    3,
+    16,
+    0
+};
+static const DWORD TST_PMM_NO_OF_SIZES = ARRAYSIZE(TST_PMM_ALLOCATION_FRAMES);
+
+static
+STATUS
+_TstPmmReservationAndRelease(
+    IN          DWORD               NoOfFrames,
+    IN_OPT      PHYSICAL_ADDRESS    MinimumAddress
+    );
+
+void
+TestPmmReserveAndReleaseFunctions(
+    void
+    )
+{
+    DWORD i;
+    BYTE specifyAddress;
+    PHYSICAL_ADDRESS minPa;
+    STATUS status;
+    QWORD totalSystemMemory;
+
+    totalSystemMemory = PmmGetTotalSystemMemory();
+
+    LOGL("Total system memory: %U KB\n", totalSystemMemory / KB_SIZE );
+
+    for (specifyAddress = 0; specifyAddress < 2; ++specifyAddress)
+    {
+        minPa = specifyAddress ? (PHYSICAL_ADDRESS) AlignAddressLower( ( totalSystemMemory / 2 ), PAGE_SIZE ) : NULL;
+
+        for (i = 0; i < TST_PMM_NO_OF_SIZES; ++i)
+        {
+            LOGL("Will call _TstPmmReservationAndRelease for %u frames with minimum address: 0x%X\n", TST_PMM_ALLOCATION_FRAMES[i], minPa);
+            status = _TstPmmReservationAndRelease(TST_PMM_ALLOCATION_FRAMES[i], minPa);
+            LOGL("_TstPmmReservationAndRelease finished with status: 0x%x\n", status);
+        }
+    }
+}
+
+static
+STATUS
+_TstPmmReservationAndRelease(
+    IN          DWORD               NoOfFrames,
+    IN_OPT      PHYSICAL_ADDRESS    MinimumAddress
+    )
+{
+    STATUS status;
+    PHYSICAL_ADDRESS pa;
+    PHYSICAL_ADDRESS initialPa;
+
+    status = STATUS_SUCCESS;
+    initialPa = NULL;
+
+    LOGL("About to reserve physical memory\n");
+    pa = PmmReserveMemoryEx(NoOfFrames, MinimumAddress );
+    if (NULL == pa)
+    {
+        if (0 != NoOfFrames)
+        {
+            LOG_ERROR("PmmReserveMemoryEx failed for %u frames starting from PA: 0x%X\n", NoOfFrames, MinimumAddress );
+            return STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE;
+        }
+        else
+        {
+            return STATUS_SUCCESS;
+        }
+    }
+
+    if (pa < MinimumAddress)
+    {
+        LOG_ERROR("Physical address returned 0x%X is lower than the minimum request 0x%X\n", pa, MinimumAddress );
+        return STATUS_UNSUCCESSFUL;
+    }
+    initialPa = pa;
+
+    LOGL("About to release previously reserved memory\n");
+    PmmReleaseMemory(pa, NoOfFrames );
+
+    LOGL("About to reserve physical memory\n");
+    pa = PmmReserveMemoryEx(NoOfFrames, MinimumAddress );
+    if (NULL == pa)
+    {
+        LOG_ERROR("PmmReserveMemoryEx failed for %u frames starting from PA: 0x%X\n", NoOfFrames, MinimumAddress );
+        return STATUS_PHYSICAL_MEMORY_NOT_AVAILABLE;
+    }
+
+    if (pa < MinimumAddress)
+    {
+        LOG_ERROR("Physical address returned 0x%X is lower than the minimum request 0x%X\n", pa, MinimumAddress);
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    if (initialPa != pa)
+    {
+        LOG_ERROR("After request another frame of memory the initial physical address 0x%X was not returned again 0x%X\n", initialPa, pa );
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    LOGL("About to release previously reserved memory\n");
+    PmmReleaseMemory(pa, NoOfFrames);
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_priority_donation.c b/src_proiect/HAL9000/src/test_priority_donation.c
new file mode 100644
index 0000000..e054afa
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_priority_donation.c
@@ -0,0 +1,595 @@
+#include "test_common.h"
+#include "test_thread.h"
+#include "test_priority_donation.h"
+#include "mutex.h"
+#include "thread_internal.h"
+#include "pit.h"
+#include "checkin_queue.h"
+
+// warning C26165: Possibly failing to release lock '* pCtx->FirstMutex' in function '_ThreadChainer'.
+// Noone cares about these mutexes, noone uses them besides the tests => no deadlock
+#pragma warning(push)
+#pragma warning(disable:26165)
+
+typedef struct _TEST_PRIORITY_DONATION_MUTEX_CTX
+{
+    CHECKIN_QUEUE           SynchronizationContext;
+
+    MUTEX                   Mutex;
+} TEST_PRIORITY_DONATION_MUTEX_CTX, * PTEST_PRIORITY_DONATION_MUTEX_CTX;
+
+#define TEST_SLEEP_TILL_EXECUTION       (50*MS_IN_US)
+#define TEST_SLEEP_TIME_US              (1*MS_IN_US)
+
+static FUNC_ThreadStart _ThreadTakeMutex;
+static FUNC_ThreadStart _ThreadChainer;
+
+//******************************************************************************
+// Function:     _ThreadValidatePriority
+// Description:  Validates the priority of the current thread to match
+//               ExpectedPriority.
+// Returns:      BOOLEAN - TRUE if the priorities match, FALSE otherwise
+// Parameter:    IN THREAD_PRIORITY ExpectedPriority
+//******************************************************************************
+static
+__forceinline
+BOOLEAN
+_ThreadValidatePriority(
+    IN          THREAD_PRIORITY     ExpectedPriority
+    )
+{
+    if (ThreadGetPriority(NULL) != ExpectedPriority)
+    {
+        LOG_ERROR("Thread should have priority %u, actual priority is %u\n",
+                  ExpectedPriority, ThreadGetPriority(NULL));
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+//******************************************************************************
+// Function:     _SpawnThreadAndCheckPriority
+// Description:  Creates a new thread and validates that after the new thread
+//               was created the initial thread has priority Priority.
+// Returns:      STATUS
+// Parameter:    IN PFUNC_ThreadStart ThreadFunction
+// Parameter:    IN_OPT PVOID Context
+// Parameter:    IN THREAD_PRIORITY Priority
+// Parameter:    IN PCHECKIN_QUEUE Synch,
+// Parameter:    OUT PTHREAD * Thread
+// Parameter:    OUT BOOLEAN * PriorityCheckFailed
+//******************************************************************************
+static
+STATUS
+_SpawnThreadAndCheckPriority(
+    IN          PFUNC_ThreadStart   ThreadFunction,
+    IN_OPT      PVOID               Context,
+    IN          THREAD_PRIORITY     Priority,
+    OUT         PTHREAD*            Thread,
+    OUT         BOOLEAN*            PriorityCheckFailed
+    )
+{
+    PTHREAD pThread;
+    STATUS status;
+    BOOLEAN bPriorityCheckFailed;
+    PCHECKIN_QUEUE pContext;
+
+    ASSERT(ThreadFunction != NULL);
+    ASSERT(Thread != NULL);
+    ASSERT(PriorityCheckFailed != NULL);
+    ASSERT(Context != NULL);
+
+    pContext = (PCHECKIN_QUEUE)Context;
+    ASSERT(pContext->Array != NULL);
+
+    pThread = NULL;
+    status = STATUS_SUCCESS;
+    bPriorityCheckFailed = FALSE;
+
+    __try
+    {
+        status = ThreadCreate("Donator",
+                              Priority,
+                              ThreadFunction,
+                              Context,
+                              &pThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("ThreadCreate", status);
+            __leave;
+        }
+
+        /// This is to make sure the new thread has time to be scheduled
+        /// and to donate its priority to us
+        /// Always wait for one single thread as we spawn only one.
+        CheckinQueueWaitOn(pContext, FALSE, 1);
+
+        // Little wait here
+        PitSleep(TEST_SLEEP_TIME_US);
+
+        if (!_ThreadValidatePriority(Priority))
+        {
+            bPriorityCheckFailed = TRUE;
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (SUCCEEDED(status))
+        {
+            *Thread = pThread;
+            *PriorityCheckFailed = bPriorityCheckFailed;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+(__cdecl TestThreadPriorityDonationBasic)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    PTHREAD pThread;
+    BOOLEAN bCheckFuncCall;
+    BOOLEAN bCheckFailed;
+    TEST_PRIORITY_DONATION_MUTEX_CTX synchContext;
+
+    ASSERT(Context != NULL);
+
+    ASSERT(ThreadGetPriority(NULL) == ThreadPriorityDefault);
+
+    bCheckFuncCall = *((BOOLEAN*) Context);
+
+    DWORD bufferSize = CheckinQueuePreInit(&synchContext.SynchronizationContext, 1);
+
+    PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+        bufferSize, HEAP_TEST_TAG, 0);
+
+    CheckinQueueInit(&synchContext.SynchronizationContext, buffer);
+
+    MutexInit(&synchContext.Mutex, FALSE);
+    MutexAcquire(&synchContext.Mutex);
+
+    status = STATUS_SUCCESS;
+    pThread = NULL;
+
+    __try
+    {
+        // Creates a thread to take the mutex and validates that the created thread
+        // donated its priority to this thread
+        status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
+                                              &synchContext,
+                                              ThreadPriorityMaximum,
+                                              &pThread,
+                                              &bCheckFailed);
+        if (!SUCCEEDED(status) || bCheckFailed)
+        {
+            status = STATUS_ASSERTION_FAILURE;
+            __leave;
+        }
+
+        if (bCheckFuncCall)
+        {
+            // Checks to see if its possible to lower the current thread's priority even if a higher priority thread
+            // donated its priority: it must NOT be possible.
+            ThreadSetPriority(ThreadPriorityLowest);
+
+            if (!_ThreadValidatePriority(ThreadPriorityMaximum))
+            {
+                LOG_ERROR("Main thread should not be able to lower its priority to %u while it received a donation!\n",
+                          ThreadGetPriority(NULL));
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+        }
+
+        LOG_TEST_PASS;
+    }
+    __finally
+    {
+        MutexRelease(&synchContext.Mutex);
+
+        ExFreePoolWithTag((PVOID)synchContext.SynchronizationContext.Array, HEAP_TEST_TAG);
+
+        CheckinQueueUninit(&synchContext.SynchronizationContext);
+
+        if (pThread != NULL)
+        {
+            STATUS exitStatus;
+
+            ThreadWaitForTermination(pThread, &exitStatus);
+
+            ThreadCloseHandle(pThread);
+            pThread = NULL;
+        }
+    }
+
+    return status;
+}
+
+// warning C28199: Using possibly uninitialized memory 'pThreads':  The variable has had its address taken but no assignment to it has been discovered.
+// nope, pThreads array is initialized to a NULL pointer, which the cleanup does check :)
+#pragma warning(push)
+#pragma warning(disable:28199)
+
+STATUS
+(__cdecl TestThreadPriorityDonationMultiple)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    TEST_PRIORITY_DONATION_MUTEX_CTX contexes[2];
+    BOOLEAN bReleasedMutexes[2];
+    PTHREAD pThreads[3];
+    TEST_PRIORITY_DONATION_MULTIPLE testType;
+    BOOLEAN bTwoThreadsOnAlock;
+    BOOLEAN bInverseRelease;
+    BOOLEAN bCheckFailed;
+
+    ASSERT(Context != NULL);
+
+    ASSERT(ThreadGetPriority(NULL) == ThreadPriorityDefault);
+
+    testType = *((TEST_PRIORITY_DONATION_MULTIPLE*)Context);
+    bTwoThreadsOnAlock = (testType == TestPriorityDonationMultipleTwoThreadsPerLock) ||
+                         (testType == TestPriorityDonationMultipleTwoThreadsPerLockInverseRelease);
+    bInverseRelease = (testType == TestPriorityDonationMultipleOneThreadPerLockInverseRelease) ||
+                      (testType == TestPriorityDonationMultipleTwoThreadsPerLockInverseRelease);
+
+    LOG_TEST_LOG("Will check scenario 0x%x\n", testType);
+
+    for (DWORD i = 0; i < ARRAYSIZE(contexes); i++)
+    {
+        DWORD bufferSize = CheckinQueuePreInit(&contexes[i].SynchronizationContext, 1);
+
+        PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+            bufferSize, HEAP_TEST_TAG, 0);
+
+        CheckinQueueInit(&contexes[i].SynchronizationContext, buffer);
+
+        MutexInit(&contexes[i].Mutex, FALSE);
+        MutexAcquire(&contexes[i].Mutex);
+    }
+
+    status = STATUS_SUCCESS;
+    memzero(pThreads, ARRAYSIZE(pThreads) * sizeof(PTHREAD));
+    memzero(bReleasedMutexes, ARRAYSIZE(bReleasedMutexes) * sizeof(BOOLEAN));
+    STATIC_ASSERT(ARRAYSIZE(bReleasedMutexes) == ARRAYSIZE(contexes));
+
+    __try
+    {
+        status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
+                                                   &contexes[0],
+                                                   ThreadPriorityDefault + 4,
+                                                   &pThreads[0],
+                                                   &bCheckFailed);
+        if (!SUCCEEDED(status) || bCheckFailed)
+        {
+            status = STATUS_ASSERTION_FAILURE;
+            __leave;
+        }
+
+        status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
+                                                   &contexes[1],
+                                                   ThreadPriorityDefault + 8,
+                                                   &pThreads[1],
+                                                   &bCheckFailed);
+        if (!SUCCEEDED(status) || bCheckFailed)
+        {
+            status = STATUS_ASSERTION_FAILURE;
+            __leave;
+        }
+
+        if (bTwoThreadsOnAlock)
+        {
+            // reset the checkin_queue for this second thread
+            contexes[1].SynchronizationContext.Array[0] = FALSE;
+
+            status = _SpawnThreadAndCheckPriority(_ThreadTakeMutex,
+                                                       &contexes[1],
+                                                       ThreadPriorityDefault + 12,
+                                                       &pThreads[2],
+                                                       &bCheckFailed);
+            if (!SUCCEEDED(status) || bCheckFailed)
+            {
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+        }
+
+        if (!bInverseRelease)
+        {
+            MutexRelease(&contexes[1].Mutex);
+            bReleasedMutexes[1] = TRUE;
+
+            if (!_ThreadValidatePriority(ThreadPriorityDefault + 4))
+            {
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+
+            MutexRelease(&contexes[0].Mutex);
+            bReleasedMutexes[0] = TRUE;
+
+            if (!_ThreadValidatePriority(ThreadPriorityDefault))
+            {
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+        }
+        else
+        {
+            MutexRelease(&contexes[0].Mutex);
+            bReleasedMutexes[0] = TRUE;
+
+            if (!_ThreadValidatePriority(bTwoThreadsOnAlock ? ThreadPriorityDefault + 12 : ThreadPriorityDefault + 8))
+            {
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+
+            MutexRelease(&contexes[1].Mutex);
+            bReleasedMutexes[1] = TRUE;
+
+            if (!_ThreadValidatePriority(ThreadPriorityDefault))
+            {
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+        }
+
+        LOG_TEST_PASS;
+    }
+    __finally
+    {
+        for (DWORD i = 0; i < ARRAYSIZE(contexes); ++i)
+        {
+            if (!bReleasedMutexes[i])
+            {
+                MutexRelease(&contexes[i].Mutex);
+                bReleasedMutexes[i] = TRUE;
+            }
+
+            ExFreePoolWithTag((PVOID)contexes[i].SynchronizationContext.Array, HEAP_TEST_TAG);
+
+            CheckinQueueUninit(&contexes[i].SynchronizationContext);
+        }
+
+        for (DWORD i = 0; i < ARRAYSIZE(pThreads); ++i)
+        {
+            if (pThreads[i] != NULL)
+            {
+                STATUS exitStatus;
+
+                ThreadWaitForTermination(pThreads[i], &exitStatus);
+
+                ThreadCloseHandle(pThreads[i]);
+                pThreads[i] = NULL;
+            }
+        }
+    }
+
+    return status;
+}
+
+#pragma warning(pop)
+
+typedef struct _DONATION_CHAIN_THREAD_CTX
+{
+    CHECKIN_QUEUE               SynchronizationContext;
+    PMUTEX                      FirstMutex;
+    PMUTEX                      SecondMutex;
+    THREAD_PRIORITY             ExpectedPriority;
+} DONATION_CHAIN_THREAD_CTX, *PDONATION_CHAIN_THREAD_CTX;
+
+typedef struct _DONATION_CHAIN_THREAD_DATA
+{
+    PTHREAD                     Thread;
+    MUTEX                       ThreadMutex;
+    DONATION_CHAIN_THREAD_CTX   ThreadContext;
+} DONATION_CHAIN_THREAD_DATA, *PDONATION_CHAIN_THREAD_DATA;
+
+STATUS
+(__cdecl TestThreadPriorityDonationChain)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    DWORD noOfThreads;
+    PDONATION_CHAIN_THREAD_DATA pDonationChainData;
+    BOOLEAN bMutexAcquired;
+
+    ASSERT(Context != NULL);
+
+    ASSERT(ThreadGetPriority(NULL) == ThreadPriorityDefault);
+
+    status = STATUS_SUCCESS;
+    noOfThreads = *((DWORD*)Context) + 1;
+    pDonationChainData = NULL;
+    bMutexAcquired = FALSE;
+
+    LOG_TEST_LOG("Will run test for 0x%x threads!\n", noOfThreads);
+
+    __try
+    {
+        pDonationChainData = ExAllocatePoolWithTag(PoolAllocatePanicIfFail | PoolAllocateZeroMemory,
+                                                   sizeof(DONATION_CHAIN_THREAD_DATA) * noOfThreads,
+                                                   HEAP_TEST_TAG,
+                                                   0);
+
+        for (DWORD i = 0; i < noOfThreads; ++i)
+        {
+            // T[0] (main thread) will only take M[0]
+            // T[1] will take M[1] and M[0]
+            // T[2] will take M[2] and M[1]
+            // ...
+            DWORD nxtThIdx = (i-1) % noOfThreads;
+
+            MutexInit(&pDonationChainData[i].ThreadMutex, FALSE);
+
+            LOGL("Thread 0x%x will acquire mutex 0x%x and 0x%x\n", i, i, nxtThIdx);
+
+            pDonationChainData[i].ThreadContext.FirstMutex = &pDonationChainData[i].ThreadMutex;
+            pDonationChainData[i].ThreadContext.SecondMutex = &pDonationChainData[nxtThIdx].ThreadMutex;
+            pDonationChainData[i].ThreadContext.ExpectedPriority = ThreadPriorityDefault + (noOfThreads - 1);
+
+            DWORD bufferSize = CheckinQueuePreInit(&pDonationChainData[i].ThreadContext.SynchronizationContext, 1);
+
+            PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+                bufferSize, HEAP_TEST_TAG, 0);
+
+            CheckinQueueInit(&pDonationChainData[i].ThreadContext.SynchronizationContext, buffer);
+        }
+
+        MutexAcquire(pDonationChainData[0].ThreadContext.FirstMutex);
+        bMutexAcquired = TRUE;
+
+        for (DWORD i = 1; i < noOfThreads; ++i)
+        {
+            BOOLEAN bPriorityCheck;
+
+            // Each time the main thread creates a new thread it should have received a priority donation from it
+            status = _SpawnThreadAndCheckPriority(_ThreadChainer,
+                                                  &pDonationChainData[i].ThreadContext,
+                                                  ThreadPriorityDefault + i,
+                                                  &pDonationChainData[i].Thread,
+                                                  &bPriorityCheck);
+            if (!SUCCEEDED(status) || bPriorityCheck)
+            {
+                status = STATUS_ASSERTION_FAILURE;
+                __leave;
+            }
+        }
+
+        MutexRelease(pDonationChainData[0].ThreadContext.FirstMutex);
+        bMutexAcquired = FALSE;
+
+        if (!_ThreadValidatePriority(ThreadPriorityDefault))
+        {
+            status = STATUS_ASSERTION_FAILURE;
+            __leave;
+        }
+
+        LOG_TEST_PASS;
+    }
+    __finally
+    {
+        if (bMutexAcquired)
+        {
+            ASSERT(pDonationChainData != NULL);
+
+            MutexRelease(pDonationChainData[0].ThreadContext.FirstMutex);
+        }
+
+        if (pDonationChainData != NULL)
+        {
+            for (DWORD i = 1; i < noOfThreads; ++i)
+            {
+                if (pDonationChainData[i].Thread != NULL)
+                {
+                    STATUS exitStatus;
+
+                    ThreadWaitForTermination(pDonationChainData[i].Thread, &exitStatus);
+                    ThreadCloseHandle(pDonationChainData[i].Thread);
+                }
+
+                ExFreePoolWithTag((PVOID)pDonationChainData[i].ThreadContext.SynchronizationContext.Array, HEAP_TEST_TAG);
+
+                CheckinQueueUninit(&pDonationChainData[i].ThreadContext.SynchronizationContext);
+            }
+            // free this also for 0
+            ExFreePoolWithTag((PVOID)pDonationChainData[0].ThreadContext.SynchronizationContext.Array, HEAP_TEST_TAG);
+
+            CheckinQueueUninit(&pDonationChainData[0].ThreadContext.SynchronizationContext);
+
+            ExFreePoolWithTag(pDonationChainData, HEAP_TEST_TAG);
+            pDonationChainData = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+(__cdecl _ThreadTakeMutex)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PTEST_PRIORITY_DONATION_MUTEX_CTX pContext = (PTEST_PRIORITY_DONATION_MUTEX_CTX)Context;
+    ASSERT(pContext != NULL);
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    PMUTEX pMutex = (PMUTEX)&pContext->Mutex;
+    ASSERT(pMutex != NULL);
+
+    LOG_TEST_LOG("Donator thread with priority %u will attempt to take mutex!\n",
+                 ThreadGetPriority(NULL));
+
+    // mark my presence
+    CheckinQueueMarkPresence(&pContext->SynchronizationContext);
+
+    MutexAcquire(pMutex);
+
+    LOG_TEST_LOG("Donator thread with priority %u acquired mutex!\n",
+                 ThreadGetPriority(NULL));
+
+    MutexRelease(pMutex);
+
+    LOG_TEST_LOG("Donator thread with priority %u released mutex!\n",
+                 ThreadGetPriority(NULL));
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _ThreadChainer)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PDONATION_CHAIN_THREAD_CTX pCtx;
+    TID tid;
+    THREAD_PRIORITY originalPriority;
+
+    pCtx = Context;
+    ASSERT(pCtx != NULL);
+
+    tid = ThreadGetId(NULL);
+    originalPriority = ThreadGetPriority(NULL);
+
+    MutexAcquire(pCtx->FirstMutex);
+    LOG_TEST_LOG("Thread 0x%X got the first lock!\n", tid);
+
+    // mark my presence
+    CheckinQueueMarkPresence(&pCtx->SynchronizationContext);
+
+    MutexAcquire(pCtx->SecondMutex);
+    LOG_TEST_LOG("Thread 0x%X got the second lock\n", tid);
+
+    if (!_ThreadValidatePriority(pCtx->ExpectedPriority))
+    {
+        return STATUS_ASSERTION_FAILURE;
+    }
+
+    MutexRelease(pCtx->SecondMutex);
+    LOG_TEST_LOG("Thread 0x%X released the second lock\n", tid);
+
+    if (!_ThreadValidatePriority(pCtx->ExpectedPriority))
+    {
+        return STATUS_ASSERTION_FAILURE;
+    }
+
+    MutexRelease(pCtx->FirstMutex);
+    LOG_TEST_LOG("Thread 0x%X released the first lock\nIt should have reverted to its original priority!\n", tid);
+
+    if (!_ThreadValidatePriority(originalPriority))
+    {
+        return STATUS_ASSERTION_FAILURE;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+#pragma warning(pop)
diff --git a/src_proiect/HAL9000/src/test_priority_scheduler.c b/src_proiect/HAL9000/src/test_priority_scheduler.c
new file mode 100644
index 0000000..fba3ce2
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_priority_scheduler.c
@@ -0,0 +1,383 @@
+#include "test_common.h"
+#include "test_thread.h"
+#include "test_priority_scheduler.h"
+#include "ex_event.h"
+#include "mutex.h"
+#include "thread_internal.h"
+#include "checkin_queue.h"
+#include "pit.h"
+
+#define PRIORITY_SCHEDULER_NO_OF_ITERATIONS             16
+
+#pragma warning(push)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+typedef struct _TEST_PRIORITY_EXEC_CTX
+{
+    BOOLEAN                 MultipleThreads;
+
+    LOCK                    Lock;
+    DWORD                   CurrentIndex;
+    DWORD                   MaxIndex;
+
+    TID                     WakeupTids[0];
+} TEST_PRIORITY_EXEC_CTX, *PTEST_PRIORITY_EXEC_CTX;
+#pragma warning(pop)
+
+typedef struct _TEST_PRIORITY_WAKEUP_CTX
+{
+    CHECKIN_QUEUE           SynchronizationContext;
+
+    EX_EVENT                WakeupEvent;
+} TEST_PRIORITY_WAKEUP_CTX, *PTEST_PRIORITY_WAKEUP_CTX;
+
+typedef struct _TEST_PRIORITY_MUTEX_CTX
+{
+    CHECKIN_QUEUE           SynchronizationContext;
+
+    MUTEX                   Mutex;
+} TEST_PRIORITY_MUTEX_CTX, *PTEST_PRIORITY_MUTEX_CTX;
+
+void
+(__cdecl TestPrepareMutex)(
+    OUT_OPT_PTR     PVOID*              Context,
+    IN              DWORD               NumberOfThreads,
+    IN              PVOID               PrepareContext
+    )
+{
+    PMUTEX pMutex;
+    BOOLEAN acquireMutex;
+    PTEST_PRIORITY_MUTEX_CTX pWakeupCtx;
+
+    ASSERT(NULL != Context);
+    ASSERT(NumberOfThreads > 0);
+
+    pWakeupCtx = (PTEST_PRIORITY_MUTEX_CTX)Context;
+
+    pWakeupCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+        sizeof(TEST_PRIORITY_MUTEX_CTX),
+        HEAP_TEST_TAG, 0);
+
+    DWORD bufferSize = CheckinQueuePreInit(&pWakeupCtx->SynchronizationContext, NumberOfThreads);
+
+    PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+        bufferSize, HEAP_TEST_TAG, 0);
+
+    CheckinQueueInit(&pWakeupCtx->SynchronizationContext, buffer);
+
+    pMutex = &pWakeupCtx->Mutex;
+
+    // warning C4305: 'type cast': truncation from 'const PVOID' to 'BOOLEAN'
+#pragma warning(suppress:4305)
+    acquireMutex = (BOOLEAN) PrepareContext;
+
+    MutexInit(pMutex, FALSE);
+
+    if (acquireMutex)
+    {
+        MutexAcquire(pMutex);
+    }
+
+    *Context = pWakeupCtx;
+}
+
+void
+(__cdecl TestThreadPostCreateMutex)(
+    IN              PVOID               Context
+    )
+{
+    PTEST_PRIORITY_MUTEX_CTX pContext;
+    PMUTEX pMutex;
+
+    pContext = (PTEST_PRIORITY_MUTEX_CTX)Context;
+    ASSERT(pContext != NULL);
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    pMutex = (PMUTEX)&pContext->Mutex;
+    ASSERT(pMutex != NULL);
+
+    // wait on all threads to finish creation and mark presence before blocking on the mutex.
+    CheckinQueueWaitOn(&pContext->SynchronizationContext, TRUE, 0);
+
+    // little sleep to make sure even the last thread got blocked on the mutex.
+    PitSleep(10);
+
+    MutexRelease(pMutex);
+}
+
+STATUS
+(__cdecl TestThreadPriorityMutex)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PTEST_PRIORITY_MUTEX_CTX pContext;
+    PMUTEX pMutex;
+
+    pContext = (PTEST_PRIORITY_MUTEX_CTX)Context;
+    ASSERT(pContext != NULL);
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    pMutex = (PMUTEX)&pContext->Mutex;
+    ASSERT(pMutex != NULL);
+
+    // mark my presence
+    CheckinQueueMarkPresence(&pContext->SynchronizationContext);
+
+    MutexAcquire(pMutex);
+
+    LOG_TEST_LOG("Thread [%s] with priority %u received MUTEX!\n",
+                 ThreadGetName(NULL), ThreadGetPriority(NULL));
+
+    MutexRelease(pMutex);
+
+    return STATUS_SUCCESS;
+}
+
+void
+(__cdecl TestThreadPostFinishMutex)(
+    IN              PVOID               Context,
+    IN              DWORD               NumberOfThreads
+    )
+{
+    PTEST_PRIORITY_MUTEX_CTX pContext;
+
+    ASSERT(NULL != Context);
+    pContext = (PTEST_PRIORITY_MUTEX_CTX)Context;
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    UNREFERENCED_PARAMETER(NumberOfThreads);
+
+    ExFreePoolWithTag((PVOID)pContext->SynchronizationContext.Array, HEAP_TEST_TAG);
+
+    CheckinQueueUninit(&pContext->SynchronizationContext);
+
+    // This Context is freed outside in TestThreadFunctionality!!!!
+    //ExFreePoolWithTag((PVOID)pContext, HEAP_TEST_TAG);
+
+    pContext = NULL;
+}
+
+void
+(__cdecl TestThreadPrepareWakeupEvent)(
+    OUT_OPT_PTR     PVOID*              Context,
+    IN              DWORD               NumberOfThreads,
+    IN              PVOID               PrepareContext
+    )
+{
+    STATUS status;
+    PTEST_PRIORITY_WAKEUP_CTX pWakeupCtx;
+
+    ASSERT( NULL != Context );
+    ASSERT(PrepareContext == NULL);
+    ASSERT(NumberOfThreads > 0);
+
+    pWakeupCtx = (PTEST_PRIORITY_WAKEUP_CTX)Context;
+
+    pWakeupCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+        sizeof(TEST_PRIORITY_WAKEUP_CTX),
+        HEAP_TEST_TAG, 0);
+
+    DWORD bufferSize = CheckinQueuePreInit(&pWakeupCtx->SynchronizationContext, NumberOfThreads);
+
+    PBYTE buffer = (PBYTE)ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+        bufferSize, HEAP_TEST_TAG, 0);
+
+    CheckinQueueInit(&pWakeupCtx->SynchronizationContext, buffer);
+
+    status = ExEventInit(&pWakeupCtx->WakeupEvent,
+                         ExEventTypeSynchronization,
+                         FALSE);
+    ASSERT(SUCCEEDED(status));
+
+    *Context = pWakeupCtx;
+}
+
+void
+(__cdecl TestThreadPostCreateWakeup)(
+    IN              PVOID               Context
+    )
+{
+    PTEST_PRIORITY_WAKEUP_CTX pContext;
+    PEX_EVENT pWakeupEvent;
+
+    pContext = (PTEST_PRIORITY_WAKEUP_CTX)Context;
+    ASSERT(pContext != NULL);
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    pWakeupEvent = (PEX_EVENT)&pContext->WakeupEvent;
+    ASSERT(pWakeupEvent != NULL);
+
+    // wait on all threads to finish creation and mark presence before blocking on the event.
+    CheckinQueueWaitOn(&pContext->SynchronizationContext, TRUE, 0);
+
+    // little sleep to make sure even the last thread got blocked on the event.
+    PitSleep(10);
+
+    ExEventSignal(pWakeupEvent);
+}
+
+STATUS
+(__cdecl TestThreadPriorityWakeup)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PTEST_PRIORITY_WAKEUP_CTX pContext;
+    PEX_EVENT pWakeupEvent;
+
+    pContext = (PTEST_PRIORITY_WAKEUP_CTX)Context;
+    ASSERT(pContext != NULL);
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    pWakeupEvent = (PEX_EVENT)&pContext->WakeupEvent;
+    ASSERT(pWakeupEvent != NULL);
+
+    // mark my presence
+    CheckinQueueMarkPresence(&pContext->SynchronizationContext);
+
+    ExEventWaitForSignal(pWakeupEvent);
+
+    LOG_TEST_LOG("Thread [%s] with priority %u woke up!\n",
+                 ThreadGetName(NULL), ThreadGetPriority(NULL));
+
+    ExEventSignal(pWakeupEvent);
+
+    return STATUS_SUCCESS;
+}
+
+void
+(__cdecl TestThreadPostFinishWakeup)(
+    IN              PVOID               Context,
+    IN              DWORD               NumberOfThreads
+    )
+{
+    PTEST_PRIORITY_WAKEUP_CTX pContext;
+
+    ASSERT(NULL != Context);
+    pContext = (PTEST_PRIORITY_WAKEUP_CTX)Context;
+    ASSERT(pContext->SynchronizationContext.Array != NULL);
+
+    UNREFERENCED_PARAMETER(NumberOfThreads);
+
+    ExFreePoolWithTag((PVOID)pContext->SynchronizationContext.Array, HEAP_TEST_TAG);
+
+    CheckinQueueUninit(&pContext->SynchronizationContext);
+
+    // This Context is freed outside in TestThreadFunctionality!!!!
+    //ExFreePoolWithTag((PVOID)pContext, HEAP_TEST_TAG);
+
+    pContext = NULL;
+}
+
+STATUS
+(__cdecl TestThreadPriorityExecution)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PTEST_PRIORITY_EXEC_CTX pCtx;
+    TID tid;
+    THREAD_PRIORITY priority;
+    BOOLEAN bFailed;
+
+    ASSERT(Context != NULL);
+
+    pCtx = (PTEST_PRIORITY_EXEC_CTX) Context;
+
+    tid = ThreadGetId(NULL);
+    priority = ThreadGetPriority(NULL);
+    bFailed = FALSE;
+
+    for (QWORD i = 0; i < PRIORITY_SCHEDULER_NO_OF_ITERATIONS; ++i)
+    {
+        QWORD uninterruptedTicks = GetCurrentThread()->UninterruptedTicks;
+        INTR_STATE oldState;
+
+        LockAcquire(&pCtx->Lock, &oldState);
+        pCtx->WakeupTids[pCtx->CurrentIndex++] = tid;
+        LockRelease(&pCtx->Lock, oldState);
+        ThreadYield();
+
+        if (pCtx->MultipleThreads)
+        {
+            if (uninterruptedTicks != 0)
+            {
+                LOG_ERROR("The thread should not have any uninterrupted ticks, it should have yielded the CPU"
+                          "in a RR fashion to the next thread in list!\n");
+                bFailed = TRUE;
+                break;
+            }
+        }
+        else
+        {
+            if (uninterruptedTicks < i)
+            {
+                LOG_ERROR("The thread has %U uninterrupted ticks and it should have at least %U\n",
+                          uninterruptedTicks, i);
+                bFailed = TRUE;
+                break;
+            }
+        }
+    }
+
+    if (!pCtx->MultipleThreads && !bFailed)
+    {
+        // In the case of the round-robin test we still need to make some checks from the perl .check script
+        // however, in the case of the single thread high priority we can determine if it was uninterrupted that it
+        // was not de-scheduled when it yielded the CPU
+        LOG_TEST_PASS;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+void
+(__cdecl TestThreadPreparePriorityExecution)(
+    OUT_OPT_PTR     PVOID*              Context,
+    IN              DWORD               NumberOfThreads,
+    IN              PVOID               PrepareContext
+    )
+{
+    BOOLEAN bMultipleThreads;
+    PTEST_PRIORITY_EXEC_CTX pNewContext;
+
+    ASSERT(Context != NULL);
+
+    // warning C4305: 'type cast': truncation from 'const PVOID' to 'BOOLEAN'
+#pragma warning(suppress:4305)
+    bMultipleThreads = (BOOLEAN) PrepareContext;
+
+    pNewContext = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+                                        sizeof(TEST_PRIORITY_EXEC_CTX) + sizeof(TID) * NumberOfThreads *PRIORITY_SCHEDULER_NO_OF_ITERATIONS,
+                                        HEAP_TEST_TAG,
+                                        0);
+
+    pNewContext->CurrentIndex = 0;
+    pNewContext->MaxIndex = NumberOfThreads * PRIORITY_SCHEDULER_NO_OF_ITERATIONS;
+    pNewContext->MultipleThreads = bMultipleThreads;
+    LockInit(&pNewContext->Lock);
+
+    *Context = pNewContext;
+}
+
+void
+(__cdecl TestThreadPostPriorityExecution)(
+    IN              PVOID               Context,
+    IN              DWORD               NumberOfThreads
+    )
+{
+    PTEST_PRIORITY_EXEC_CTX pCtx;
+
+    UNREFERENCED_PARAMETER(NumberOfThreads);
+
+    pCtx = (PTEST_PRIORITY_EXEC_CTX) Context;
+    ASSERT(pCtx != NULL);
+
+    if (pCtx->MultipleThreads)
+    {
+        for (DWORD i = 0; i < pCtx->MaxIndex; ++i)
+        {
+            LOG_TEST_LOG("Thread 0x%X with priority %u has %u uninterrupted ticks!\n",
+                         pCtx->WakeupTids[i], ThreadPriorityMaximum, 0);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_process.c b/src_proiect/HAL9000/src/test_process.c
new file mode 100644
index 0000000..fff2aab
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_process.c
@@ -0,0 +1,199 @@
+#include "test_common.h"
+#include "test_process.h"
+#include "process.h"
+#include "iomu.h"
+
+#define MAX_PROCESSES_TO_SPAWN          16
+
+const PROCESS_TEST PROCESS_TESTS[] =
+{
+    // Project 2: Userprog
+
+    // arguments
+    { "TestUserArgsNone", "Args", NULL},
+    { "TestUserArgsOne", "Args", "Argument"},
+    { "TestUserArgsMany", "Args", "Johnny is a good kid"},
+    { "TestUserArgsAll", "Args", "a b c d e f g h i j k l m n o p r s t u v q x y z"},
+
+    // bad-actions
+    { "BadJumpKernel", "BadJumpKernel", NULL},
+    { "BadJumpNoncanonical", "BadJumpNoncanonical", NULL},
+    { "BadJumpNull", "BadJumpNull", NULL},
+
+    { "BadReadIoPort", "BadReadIoPort", NULL},
+    { "BadReadKernel", "BadReadKernel", NULL},
+    { "BadReadMsr", "BadReadMsr", NULL},
+    { "BadReadNonCanonical", "BadReadNonCanonical", NULL},
+    { "BadReadNull", "BadReadNull", NULL},
+
+    { "BadWriteIoPort", "BadWriteIoPort", NULL},
+    { "BadWriteKernel", "BadWriteKernel", NULL},
+    { "BadWriteMsr", "BadWriteMsr", NULL},
+    { "BadWriteNonCanonical", "BadWriteNonCanonical", NULL},
+    { "BadWriteNull", "BadWriteNull", NULL},
+
+    // file-syscalls
+    { "FileCloseBad", "FileCloseBad", NULL},
+    { "FileCloseNormal", "FileCloseNormal", NULL},
+    { "FileCloseStdout", "FileCloseStdout", NULL},
+    { "FileCloseTwice", "FileCloseTwice", NULL},
+
+    { "FileCreateBadPointer", "FileCreateBadPointer", NULL},
+    { "FileCreateEmptyPath", "FileCreateEmptyPath", NULL},
+    { "FileCreateExistent", "FileCreateExistent", NULL},
+    { "FileCreateMissing", "FileCreateMissing", NULL},
+    { "FileCreateNormal", "FileCreateNormal", NULL},
+    { "FileCreateNull", "FileCreateNull", NULL},
+    { "FileCreateTwice", "FileCreateTwice", NULL},
+
+    { "FileReadBadHandle", "FileReadBadHandle", NULL},
+    { "FileReadBadPointer", "FileReadBadPointer", NULL},
+    { "FileReadKernel", "FileReadKernel", NULL},
+    { "FileReadNormal", "FileReadNormal", NULL},
+    { "FileReadStdout", "FileReadStdout", NULL},
+    { "FileReadZero", "FileReadZero", NULL},
+
+    // process-syscalls
+    { "ProcessCloseFile", "ProcessCloseFile", NULL},
+    { "ProcessCloseNormal", "ProcessCloseNormal", NULL},
+    { "ProcessCloseParentHandle", "ProcessCloseParentHandle", NULL},
+    { "ProcessCloseTwice", "ProcessCloseTwice", NULL},
+
+    { "ProcessCreateBadPointer", "ProcessCreateBadPointer", NULL},
+    { "ProcessCreateMissingFile", "ProcessCreateMissingFile", NULL},
+    { "ProcessCreateMultiple", "ProcessCreateMultiple", NULL},
+    { "ProcessCreateOnce", "ProcessCreateOnce", NULL},
+    { "ProcessCreateWithArguments", "ProcessCreateWithArguments", NULL},
+
+    { "ProcessExit", "ProcessExit", NULL},
+    { "ProcessGetPid", "ProcessGetPid", NULL},
+
+    { "ProcessWaitBadHandle", "ProcessWaitBadHandle", NULL},
+    { "ProcessWaitClosedHandle", "ProcessWaitClosedHandle", NULL},
+    { "ProcessWaitNormal", "ProcessWaitNormal", NULL},
+    { "ProcessWaitTerminated", "ProcessWaitTerminated", NULL},
+
+    // thread-syscalls
+    { "ThreadCloseTwice", "ThreadCloseTwice", NULL},
+
+    { "ThreadCreateBadPointer", "ThreadCreateBadPointer", NULL},
+    { "ThreadCreateMultiple", "ThreadCreateMultiple", NULL},
+    { "ThreadCreateOnce", "ThreadCreateOnce", NULL},
+    { "ThreadCreateWithArguments", "ThreadCreateWithArguments", NULL},
+
+    { "ThreadExit", "ThreadExit", NULL},
+    { "ThreadGetTid", "ThreadGetTid", NULL},
+
+    { "ThreadWaitBadHandle", "ThreadWaitBadHandle", NULL},
+    { "ThreadWaitClosedHandle", "ThreadWaitClosedHandle", NULL},
+    { "ThreadWaitNormal", "ThreadWaitNormal", NULL},
+    { "ThreadWaitTerminated", "ThreadWaitTerminated", NULL},
+
+    // Project 3: Virtual Memory
+
+    // process-quota
+    { "ProcessQuotaGood", "ProcessQuotaGood", NULL},
+    { "ProcessQuotaJustRight", "ProcessQuotaJustRight", NULL},
+    { "ProcessQuotaMore", "ProcessQuotaMore", NULL},
+
+    // swap
+    { "SwapLinear", "SwapLinear", NULL},
+    { "SwapMultiple", "SwapLinear", NULL, 4},
+    { "SwapMultipleShared", "SwapMultipleShared", "0"},
+    { "SwapZeros", "SwapZeros", NULL},
+    { "SwapZerosWritten", "SwapZerosWritten", NULL},
+
+    // syscalls
+    { "VirtualAllocAccessFail", "VirtualAllocAccessFail", NULL},
+    { "VirtualAllocHugeEager", "VirtualAllocHugeEager", NULL},
+    { "VirtualAllocHugeLazy", "VirtualAllocHugeLazy", NULL},
+    { "VirtualAllocNormal", "VirtualAllocNormal", NULL},
+    { "VirtualAllocWriteExec", "VirtualAllocWriteExec", NULL},
+    { "VirtualAllocZeros", "VirtualAllocZeros", NULL },
+
+    //{ "VirtualFreeInvalid", "VirtualFreeInvalid", NULL },
+    //{ "VirtualFreeMore", "VirtualFreeMore", NULL },
+
+    { "VirtualSharedDifferentSize", "VirtualSharedNormal", "0 1 8 3" },
+    { "VirtualSharedHugeEager", "VirtualSharedNormal", "0 1 4096 4" },
+    { "VirtualSharedHugeLazy", "VirtualSharedNormal", "0 1 4096 5" },
+    { "VirtualSharedLessAccess", "VirtualSharedNormal", "0 1 8 1" },
+    { "VirtualSharedMoreAccess", "VirtualSharedNormal", "0 0 8 2" },
+    { "VirtualSharedNormal", "VirtualSharedNormal", "0 1 8 0" },
+
+    // stack-growth
+    { "StackGrowthVariables", "StackGrowthVariables", NULL },
+    { "StackGrowthRecursiveFunction", "StackGrowthRecursiveFunction", NULL },
+};
+
+const DWORD PROCESS_TOTAL_NO_OF_TESTS = ARRAYSIZE(PROCESS_TESTS);
+
+
+void
+TestProcessFunctionality(
+    IN      PROCESS_TEST*               ProcessTest
+    )
+{
+    STATUS status;
+    STATUS terminationStatus;
+    PPROCESS pProcesses[MAX_PROCESSES_TO_SPAWN];
+    char fullPath[MAX_PATH];
+    const char* pSystemPartition;
+    DWORD noOfProcesses;
+
+    pSystemPartition = IomuGetSystemPartitionPath();
+    noOfProcesses = (ProcessTest->NumberOfProcesses == 0) ? 1 : ProcessTest->NumberOfProcesses;
+    ASSERT(noOfProcesses <= MAX_PROCESSES_TO_SPAWN);
+
+    LOG_TEST_LOG("Test [%s] START!\n", ProcessTest->TestName);
+
+    __try
+    {
+        if (pSystemPartition == NULL)
+        {
+            LOG_ERROR("Cannot run user tests without knowing the system partition!\n");
+            __leave;
+        }
+
+        snprintf(fullPath, MAX_PATH,
+                 "%s%s\\%s.exe", pSystemPartition, "APPLICATIONS",
+                 ProcessTest->ProcessName);
+
+        printf("Full path is [%s]\n", fullPath);
+
+        for (DWORD i = 0; i < noOfProcesses; ++i)
+        {
+            status = ProcessCreate(fullPath,
+                                   ProcessTest->ProcessCommandLine,
+                                   &pProcesses[i]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("ProcessCreate", status);
+                __leave;
+            }
+        }
+
+        for (DWORD i = 0; i < noOfProcesses; ++i)
+        {
+            ProcessWaitForTermination(pProcesses[i], &terminationStatus);
+
+            ProcessCloseHandle(pProcesses[i]);
+            pProcesses[i] = NULL;
+        }
+    }
+    __finally
+    {
+        LOG_TEST_LOG("Test [%s] END!\n", ProcessTest->TestName);
+    }
+}
+
+void
+TestAllProcessFunctionalities(
+    void
+    )
+{
+    for (DWORD i = 0; i < PROCESS_TOTAL_NO_OF_TESTS; ++i)
+    {
+        TestProcessFunctionality(&PROCESS_TESTS[i]);
+    }
+}
diff --git a/src_proiect/HAL9000/src/test_thread.c b/src_proiect/HAL9000/src/test_thread.c
new file mode 100644
index 0000000..3ceb2dc
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_thread.c
@@ -0,0 +1,410 @@
+#include "test_common.h"
+#include "test_thread.h"
+#include "test_timer.h"
+#include "test_priority_scheduler.h"
+#include "test_priority_donation.h"
+
+#include "mutex.h"
+
+
+FUNC_ThreadStart                TestThreadYield;
+
+FUNC_ThreadStart                TestMutexes;
+
+FUNC_ThreadStart                TestCpuIntense;
+
+static FUNC_ThreadPrepareTest   _ThreadTestPassContext;
+
+const THREAD_TEST THREADS_TEST[] =
+{
+    // Tests just for fun
+    { "ThreadYield", TestThreadYield, NULL, NULL, NULL, NULL, FALSE, FALSE },
+    { "Mutex", TestMutexes, TestPrepareMutex, (PVOID) FALSE, NULL, NULL, FALSE, FALSE },
+    { "CpuIntense", TestCpuIntense, NULL, NULL, NULL, NULL, FALSE, FALSE },
+
+    // Actual tests used for validating the project
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //                                                  TIMER TESTS                                                   //
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    // Tests to see if an absolute timer set 50 ms in the future works properly
+    {   "TestThreadTimerAbsolute", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_ABSOLUTE, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Tests to see if an absolute timer set 50 ms in the past works properly (i.e. the ExTimerWait should
+    // return instantly)
+    {   "TestThreadTimerAbsolutePassed", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_ABSOLUTE_PASSED, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Tests to see if a relative periodic timer with a 50ms period works properly if waited on for 10 times
+    {   "TestThreadTimerPeriodicMultiple", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_PERIODIC_MULTIPLE, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Same as the "TestThreadTimerPeriodicMultiple" except it only waits once for the timer
+    {   "TestThreadTimerPeriodicOnce", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_PERIODIC_ONCE, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Checks to see if a periodic timer with period 0 works properly (i.e. ExTimerWait should return instantly
+    // each time)
+    {   "TestThreadTimerPeriodicZero", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_PERIODIC_ZERO, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Spawns multiple threads (default 16) to wait for the same relative once timer with a period of 50 ms.
+    // The test validates that each thread is woken up properly after the timer expires.
+    {   "TestThreadTimerMultipleThreads", TestThreadTimerMultiple,
+        TestThreadTimerPrepare, (PVOID)FALSE, NULL, TestThreadTimerMultipleThreadsPostFinish,
+        ThreadPriorityDefault, FALSE, FALSE, FALSE},
+
+    // Spawns multiple threads (default 16) to each wait for a different relative periodic timer with a different
+    // period. Thread[i] waits for a timer of period 50ms + i * 10ms 10 times.
+    // The test validates that the time in which the threads are woken up is monotonically increasing.
+    // The following wakeup times are valid:
+    // T[0] woke up at 10000 us system time
+    // T[1] woke up at 11000 us system time
+    // T[2] woke up at 12000 us system time
+    // T[0] woke up at 12000 us system time
+    // ...
+
+    // The following wakeup times are invalid:
+    // T[0] woke up at 10000 us system time
+    // T[1] woke up at 11000 us system time
+    // T[2] woke up at 12000 us system time
+    // T[0] woke up at 11750 us system time
+    // ...
+    {   "TestThreadTimerMultipleTimers", TestThreadTimerMultiple,
+        TestThreadTimerPrepare, (PVOID)TRUE, NULL, TestThreadTimerMultipleTimersPostFinish,
+        ThreadPriorityDefault, FALSE, FALSE, TRUE},
+
+    // Tests to see if a relative once timer works properly for a 50ms timeout period
+    {   "TestThreadTimerRelative", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_RELATIVE, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Tests to see if a relative once timer works properly for a 0ms timeout period (i.e. ExTimerWait should return
+    // instantly)
+    {   "TestThreadTimerRelativeZero", TestThreadTimerSleep,
+        _ThreadTestPassContext, (PVOID)TEST_TIMER_RELATIVE_ZERO, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //                                           PRIORITY SCHEDULER TESTS                                             //
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    // Spawns multiple threads (default 16) with increasing priorities (from ThreadPriorityLowest to
+    // ThreadPriorityLowest + no of threads - 1) and checks to see if the threads waiting for an EX_EVENT are woken
+    // up according to their priorities (i.e. the higher priorities threads should be woken up first)
+    {   "TestThreadPriorityWakeup", TestThreadPriorityWakeup,
+        TestThreadPrepareWakeupEvent, NULL, TestThreadPostCreateWakeup, TestThreadPostFinishWakeup,
+        ThreadPriorityLowest, TRUE, FALSE, FALSE},
+
+    // Same as "TestThreadPriorityWakeup" except MUTEXes are used instead of EX_EVENTs
+    {   "TestThreadPriorityMutex", TestThreadPriorityMutex,
+        TestPrepareMutex, (PVOID)TRUE, TestThreadPostCreateMutex, TestThreadPostFinishMutex,
+        ThreadPriorityLowest, TRUE, FALSE, FALSE},
+
+    // Spawns a highest priority thread and validates that the thread is not de-scheduled even if it tries to yield
+    // the CPU using the ThreadYield() function.
+    {   "TestThreadPriorityYield", TestThreadPriorityExecution,
+        TestThreadPreparePriorityExecution, (PVOID) FALSE, NULL, TestThreadPostPriorityExecution,
+        ThreadPriorityMaximum, FALSE, TRUE, FALSE},
+
+    // Spawns multiple threads (default 16) with highest priority and validates that each thread is relinquishes
+    // the CPU in a round-robin fashion when callin the ThreadYield() function (i.e. all threads with the same priority
+    // should be scheduled equally).
+    {   "TestThreadPriorityRoundRobin", TestThreadPriorityExecution,
+        TestThreadPreparePriorityExecution, (PVOID) TRUE, NULL, TestThreadPostPriorityExecution,
+        ThreadPriorityMaximum, FALSE, FALSE, FALSE},
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+    //                                            PRIORITY DONATION TESTS                                             //
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    // 1. A default priority thread is spawned
+    // 2. The default priority thread initializes and acquires a mutex
+    // 3. The default priority thread creates a higher priority thread
+    // 4. The higher priority thread tries to acquire the mutex taken by the lower priority thread and donates its
+    //    priority.
+    // 5. The default priority thread has now inherited the priority of the newly spawned thread. (THIS IS CHECKED)
+    {   "TestThreadPriorityDonationOnce", TestThreadPriorityDonationBasic,
+        _ThreadTestPassContext, (PVOID) FALSE, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // First, the same steps are taken as in "TestThreadPriorityDonationOnce", then:
+    // 6. The initial thread tries to lower its priority to ThreadPriorityLowest. Its priority should still remain the
+    //    one of the donators thread. (THIS IS CHECKED)
+    {   "TestThreadPriorityDonationLower", TestThreadPriorityDonationBasic,
+        _ThreadTestPassContext, (PVOID)TRUE, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // The main thread (ThreadPriorityDefault) creates and acquires 2 mutexes and spawns 2 additional threads with
+    // higher priorities: ThreadPriorityDefault + 4 and ThreadPriorityDefault + 8.
+    // The first spawned thread tries to acquire the first mutex, while the second one the second mutex. As a result,
+    // after each thread is spawned the main thread receives a priority donation.
+    // The main thread then releases the second mutex and validates if its priority is that of the first thread spawned
+    // after which it releases the first mutex and validates its priority to be the one with which it started execution.
+    {   "TestThreadPriorityDonationMulti", TestThreadPriorityDonationMultiple,
+        _ThreadTestPassContext, (PVOID) TestPriorityDonationMultipleOneThreadPerLock, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Same as "TestThreadPriorityDonationMulti", except the mutexes are released in a different order: the second mutex
+    // acquired is also the second one released and the first mutex acquired is the first one released.
+    {   "TestThreadPriorityDonationMultiInverted", TestThreadPriorityDonationMultiple,
+        _ThreadTestPassContext, (PVOID) TestPriorityDonationMultipleOneThreadPerLockInverseRelease, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Same as "TestThreadPriorityDonationMulti" except there are now 3 threads waiting on two mutexes. The two higher
+    // priority ones are waiting for the second mutex, while the first spawned thread is waiting on the first mutex.
+    {   "TestThreadPriorityDonationMultiThreads", TestThreadPriorityDonationMultiple,
+        _ThreadTestPassContext, (PVOID)TestPriorityDonationMultipleTwoThreadsPerLock, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Same as "TestThreadPriorityDonationMultiThreads", except the mutexes are released in a different order (as in
+    // the "TestThreadPriorityDonationMultiInverted" test).
+    {   "TestThreadPriorityDonationMultiThreadsInverted", TestThreadPriorityDonationMultiple,
+        _ThreadTestPassContext, (PVOID)TestPriorityDonationMultipleTwoThreadsPerLockInverseRelease, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // The main thread with ThreadPriorityDefault initializes 4 mutexes and acquires the first one (i.e. Mutex[0]). It
+    // then spawns 3 additional threads T[i]: each with priority ThreadPriorityDefault + i (where i is from 1 to 3).
+    // Each thread will acquire Mutex[i] and Mutex[i+1%4], i.e.:
+    // T[1] takes Mutex[1] and then tries to take Mutex[0]
+    // T[2] takes Mutex[2] and then tries to take Mutex[1]
+    // T[3] takes Mutex[3] and then tries to take Mutex[2]
+
+    // As a result of these operations the main thread will receive T[1]'s priority because it holds Mutex[0].
+    // T[1] also receives T[2]'s priority because it holds Mutex[1] and as a result T[2]'s priority will be donated to
+    // the main thread.
+    // The same happens for T[2]...
+    {   "TestThreadPriorityDonationNest", TestThreadPriorityDonationChain,
+        _ThreadTestPassContext, (PVOID) 3, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+
+    // Same scenario as in "TestThreadPriorityDonationNest", except the number of additional threads is 7.
+    {   "TestThreadPriorityDonationChain", TestThreadPriorityDonationChain,
+        _ThreadTestPassContext, (PVOID) 7, NULL, NULL,
+        ThreadPriorityDefault, FALSE, TRUE, FALSE},
+};
+
+const DWORD THREADS_TOTAL_NO_OF_TESTS = ARRAYSIZE(THREADS_TEST);
+
+#define CPU_INTENSE_MEMORY_SIZE         PAGE_SIZE
+
+typedef struct _TEST_THREAD_INFO
+{
+    PTHREAD                             Thread;
+    STATUS                              Status;
+} TEST_THREAD_INFO, *PTEST_THREAD_INFO;
+
+void
+TestThreadFunctionality(
+    IN      THREAD_TEST*                ThreadTest,
+    IN_OPT  PVOID                       ContextForTestFunction,
+    IN      DWORD                       NumberOfThreads
+    )
+{
+    DWORD i;
+    STATUS status;
+    char threadName[MAX_PATH];
+    PTEST_THREAD_INFO pThreadsInfo;
+    PVOID pCtx;
+    THREAD_PRIORITY currentPriority;
+    BYTE priorityIncrement;
+    DWORD noOfThreads;
+
+    LOG_FUNC_START_THREAD;
+
+    UNREFERENCED_PARAMETER(ContextForTestFunction);
+
+    ASSERT(NULL != ThreadTest);
+    ASSERT(NULL != ThreadTest->ThreadFunction);
+    ASSERT(NULL != ThreadTest->TestName);
+
+    pThreadsInfo = NULL;
+    pCtx = NULL;
+    currentPriority = ThreadTest->BasePriority;
+    priorityIncrement = ThreadTest->IncrementPriorities ? 1 : 0;
+
+    noOfThreads = ThreadTest->IgnoreThreadCount ? 1 : NumberOfThreads;
+    ASSERT(noOfThreads > 0);
+
+    pThreadsInfo = ExAllocatePoolWithTag(PoolAllocatePanicIfFail | PoolAllocateZeroMemory,
+                                         sizeof(TEST_THREAD_INFO) * noOfThreads,
+                                         HEAP_TEST_TAG,
+                                         0);
+
+    if (NULL != ThreadTest->ThreadPrepareFunction)
+    {
+        ThreadTest->ThreadPrepareFunction(&pCtx, noOfThreads, ThreadTest->PrepareFunctionContext);
+    }
+
+    LOG_TEST_LOG("Test [%s] START!\n", ThreadTest->TestName);
+    LOG_TEST_LOG("Will create %d threads for running test [%s]\n", noOfThreads, ThreadTest->TestName);
+    for (i = 0; i < noOfThreads; ++i)
+    {
+        snprintf(threadName, MAX_PATH, "%s-%02x", ThreadTest->TestName, i );
+        status = ThreadCreate(threadName,
+                              currentPriority,
+                              ThreadTest->ThreadFunction,
+                              ThreadTest->ArrayOfContexts ? ((PVOID*) pCtx)[i] : pCtx,
+                              &pThreadsInfo[i].Thread );
+        ASSERT(SUCCEEDED(status));
+
+        // increment priority with wrap around
+        currentPriority = (currentPriority + priorityIncrement) % ThreadPriorityReserved;
+    }
+
+    if (ThreadTest->ThreadPostCreateFunction != NULL)
+    {
+        ThreadTest->ThreadPostCreateFunction(pCtx);
+    }
+
+    for (i = 0; i < noOfThreads; ++i)
+    {
+        ThreadWaitForTermination(pThreadsInfo[i].Thread, &pThreadsInfo[i].Status);
+
+        LOG_TEST_LOG("Thread [%s] terminated with status: 0x%x\n",
+                     ThreadGetName(pThreadsInfo[i].Thread), pThreadsInfo[i].Status);
+
+        ThreadCloseHandle(pThreadsInfo[i].Thread);
+        pThreadsInfo[i].Thread = NULL;
+    }
+
+    if (ThreadTest->ThreadPostFinishFunction != NULL)
+    {
+        ThreadTest->ThreadPostFinishFunction(pCtx, noOfThreads);
+    }
+
+    LOG_TEST_LOG("Test [%s] END!\n", ThreadTest->TestName);
+
+    if (pCtx != NULL)
+    {
+        if (ThreadTest->ArrayOfContexts)
+        {
+            for (i = 0; i < noOfThreads; ++i)
+            {
+                ExFreePoolWithTag(((PVOID*)pCtx)[i], HEAP_TEST_TAG);
+                ((PVOID*)pCtx)[i] = NULL;
+            }
+        }
+
+        ExFreePoolWithTag(pCtx, HEAP_TEST_TAG);
+        pCtx = NULL;
+    }
+
+    ASSERT(NULL != pThreadsInfo)
+    ExFreePoolWithTag(pThreadsInfo, HEAP_TEST_TAG);
+    pThreadsInfo = NULL;
+
+    LOG_FUNC_END_THREAD;
+}
+
+void
+TestAllThreadFunctionalities(
+    IN      DWORD                       NumberOfThreads
+    )
+{
+    for (DWORD i = 0; i < THREADS_TOTAL_NO_OF_TESTS; ++i)
+    {
+        TestThreadFunctionality(&THREADS_TEST[i], NULL, NumberOfThreads );
+    }
+}
+
+STATUS
+(__cdecl TestThreadYield)(
+    IN_OPT      PVOID       Context
+    )
+{
+    DWORD i,j;
+
+    LOG_FUNC_START_THREAD;
+
+    UNREFERENCED_PARAMETER(Context);
+
+    for (i = 0; i < 0x100; ++i)
+    {
+        for (j = 0; j < 4; ++j)
+        {
+            printf("[%d]This is cool\n", i);
+        }
+        ThreadYield();
+    }
+
+    LOG_FUNC_END_THREAD;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl TestMutexes)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PMUTEX pMutex = (PMUTEX) Context;
+    static QWORD __value = 0;
+    DWORD i;
+
+    ASSERT( NULL != Context );
+    UNREFERENCED_PARAMETER(pMutex);
+
+
+    for (i = 0; i < 0x10000; ++i)
+    {
+        MutexAcquire(pMutex);
+        __value++;
+        MutexRelease(pMutex);
+    }
+
+    LOGTPL("Value: 0x%x\n", __value );
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl TestCpuIntense)(
+    IN_OPT      PVOID       Context
+    )
+{
+    volatile BYTE* pMemory;
+
+    ASSERT( NULL == Context );
+
+    pMemory = ExAllocatePoolWithTag(PoolAllocatePanicIfFail | PoolAllocateZeroMemory, CPU_INTENSE_MEMORY_SIZE, HEAP_TEST_TAG, 0 );
+
+    for (DWORD j = 0; j < 0x10000; ++j)
+    {
+        for (DWORD i = 0; i < CPU_INTENSE_MEMORY_SIZE; ++i)
+        {
+            pMemory[i] = pMemory[i] ^ 0x63;
+        }
+    }
+
+    ExFreePoolWithTag((PVOID)pMemory, HEAP_TEST_TAG);
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+(__cdecl _ThreadTestPassContext)(
+    OUT_OPT_PTR     PVOID*              Context,
+    IN              DWORD               NumberOfThreads,
+    IN              PVOID               PrepareContext
+    )
+{
+    PVOID pNewContext;
+    ASSERT(NULL != Context);
+
+    UNREFERENCED_PARAMETER(NumberOfThreads);
+
+    pNewContext = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, sizeof(PVOID), HEAP_TEST_TAG, 0);
+
+    memcpy(pNewContext, &PrepareContext, sizeof(PVOID));
+
+    *Context = pNewContext;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/test_timer.c b/src_proiect/HAL9000/src/test_timer.c
new file mode 100644
index 0000000..0d6fa48
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_timer.c
@@ -0,0 +1,297 @@
+#include "test_common.h"
+#include "test_thread.h"
+#include "test_timer.h"
+#include "ex_timer.h"
+#include "iomu.h"
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+
+#pragma pack(push, 1)
+typedef struct _TIMER_TEST_CTX
+{
+    WORD            TimesToWait;
+    INT32           UsToSleep;
+    BYTE            TimerType;
+    BYTE            __Reserved;
+} TIMER_TEST_CTX, *PTIMER_TEST_CTX;
+STATIC_ASSERT(sizeof(TIMER_TEST_CTX) == sizeof(PVOID));
+STATIC_ASSERT(FIELD_OFFSET(TIMER_TEST_CTX, UsToSleep) == SLEEP_TIME_BIT_OFFSET / BITS_PER_BYTE);
+STATIC_ASSERT(FIELD_OFFSET(TIMER_TEST_CTX, TimerType) == TIMER_TYPE_BIT_OFFSET / BITS_PER_BYTE);
+#pragma pack(pop)
+
+typedef
+_Struct_size_bytes_(sizeof(TID_WAKEUP) + NumberOfEntries * sizeof(QWORD))
+struct _TID_WAKEUP
+{
+    volatile DWORD      CurrentIndex;
+    DWORD               NumberOfEntries;
+
+    _Field_size_part_(NumberOfEntries, CurrentIndex)
+    QWORD               SystemWakeTimeUs[0];
+} TID_WAKEUP, *PTID_WAKEUP;
+
+typedef struct _TIMER_TEST_MULTIPLE_CTX
+{
+    BOOLEAN             ThreadsShareTimer;
+    union
+    {
+        // Used when the threads share the same timer
+        // "TestThreadTimerMultipleThreads"
+        struct
+        {
+            EX_TIMER    Timer;
+        } Same;
+
+        // Used when each thread has its own timer
+        // "TestThreadTimerMultipleTimers"
+        struct
+        {
+            QWORD       TimeToSleep;
+            DWORD       TimesToSleep;
+            DWORD       ThreadIndex;
+            PTID_WAKEUP WakeupArray;
+        } Different;
+    };
+} TIMER_TEST_MULTIPLE_CTX, *PTIMER_TEST_MULTIPLE_CTX;
+
+#pragma warning(pop)
+
+static
+void
+_TestThreadSleepWaitTimer(
+    IN          QWORD           Timestamp,
+    IN          EX_TIMER_TYPE   TimerType,
+    _When_(TimerType == ExTimerTypeRelativePeriodic, IN)
+    _When_(TimerType != ExTimerTypeRelativePeriodic, _Reserved_)
+                DWORD           TimesToWait
+)
+{
+    EX_TIMER timer;
+    STATUS status;
+    DWORD timesToWait;
+
+    timesToWait = (TimerType == ExTimerTypeRelativePeriodic) ? TimesToWait : 1;
+
+    status = ExTimerInit(&timer,
+                         TimerType,
+                         Timestamp);
+    ASSERT(SUCCEEDED(status));
+
+    ExTimerStart(&timer);
+
+    for (DWORD i = 0; i < TimesToWait; ++i)
+    {
+        ExTimerWait(&timer);
+    }
+
+    ExTimerStop(&timer);
+    ExTimerUninit(&timer);
+}
+
+STATUS
+(__cdecl TestThreadTimerSleep)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PTIMER_TEST_CTX pCtx;
+    QWORD timeStamp;
+
+    pCtx = (PTIMER_TEST_CTX) Context;
+
+    ASSERT(pCtx != NULL);
+
+    timeStamp = (pCtx->TimerType == ExTimerTypeAbsolute) ? IomuGetSystemTimeUs() + pCtx->UsToSleep : pCtx->UsToSleep;
+
+    _TestThreadSleepWaitTimer(timeStamp,
+                              pCtx->TimerType,
+                              pCtx->TimesToWait);
+    LOG_TEST_PASS;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl TestThreadTimerMultiple)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PTIMER_TEST_MULTIPLE_CTX pTimer;
+
+    pTimer = (PTIMER_TEST_MULTIPLE_CTX) Context;
+
+    ASSERT(pTimer != NULL);
+
+    if (pTimer->ThreadsShareTimer)
+    {
+        ExTimerWait(&pTimer->Same.Timer);
+
+        LOG_TEST_PASS;
+    }
+    else
+    {
+        EX_TIMER timer;
+        STATUS status;
+
+        // Each thread has its own timer, create it here
+        status = ExTimerInit(&timer,
+                             ExTimerTypeRelativePeriodic,
+                             pTimer->Different.TimeToSleep);
+        ASSERT(SUCCEEDED(status));
+
+        ExTimerStart(&timer);
+
+        for (DWORD i = 0; i < pTimer->Different.TimesToSleep; ++i)
+        {
+            ExTimerWait(&timer);
+
+            // Record the time each thread wakes up
+            DWORD curIdx = _InterlockedIncrement(&pTimer->Different.WakeupArray->CurrentIndex) - 1;
+
+            // Store the system time in which the current thread has woken up in an array
+            pTimer->Different.WakeupArray->SystemWakeTimeUs[curIdx] = IomuGetSystemTimeUs();
+        }
+
+        ExTimerStop(&timer);
+        ExTimerUninit(&timer);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+void
+(__cdecl TestThreadTimerPrepare)(
+    OUT_OPT_PTR     PVOID*              Context,
+    IN              DWORD               NumberOfThreads,
+    IN              PVOID               PrepareContext
+    )
+{
+    BOOLEAN bPrepareArray;
+
+    ASSERT(Context != NULL);
+
+    // warning C4305: 'type cast': truncation from 'const PVOID' to 'BOOLEAN'
+#pragma warning(suppress:4305)
+    bPrepareArray = (BOOLEAN) PrepareContext;
+
+    if (bPrepareArray)
+    {
+        // "TestThreadTimerMultipleTimers"
+        // Each thread has its own timer, but we need to hold a shared structure which will tell each thread what kind
+        // of timer it has to create (i.e. its timeout period) and how many times it should wait for it.
+        // This shared structure will also keep the system time in us when each thread is woken up.
+
+        PTID_WAKEUP pWakeupTimes = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+                                                         sizeof(TID_WAKEUP) + (sizeof(QWORD) * NumberOfThreads * TIMER_TEST_NO_OF_ITERATIONS),
+                                                         HEAP_TEST_TAG,
+                                                         0);
+
+        pWakeupTimes->NumberOfEntries = NumberOfThreads * TIMER_TEST_NO_OF_ITERATIONS;
+
+        PTIMER_TEST_MULTIPLE_CTX* pTimersCtx = ExAllocatePoolWithTag(PoolAllocateZeroMemory | PoolAllocatePanicIfFail,
+                                                   sizeof(PTIMER_TEST_MULTIPLE_CTX) * NumberOfThreads,
+                                                   HEAP_TEST_TAG,
+                                                   0);
+
+        for (DWORD i = 0; i < NumberOfThreads; ++i)
+        {
+            pTimersCtx[i] = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, sizeof(TIMER_TEST_MULTIPLE_CTX), HEAP_TEST_TAG, 0);
+
+            pTimersCtx[i]->ThreadsShareTimer = FALSE;
+            pTimersCtx[i]->Different.TimeToSleep = TIMER_TEST_SLEEP_TIME_IN_US + i * TIMER_TEST_SLEEP_INCREMENT;
+            pTimersCtx[i]->Different.TimesToSleep = TIMER_TEST_NO_OF_ITERATIONS;
+            pTimersCtx[i]->Different.ThreadIndex = i;
+            pTimersCtx[i]->Different.WakeupArray = pWakeupTimes;
+        }
+
+        *Context = pTimersCtx;
+    }
+    else
+    {
+        // "TestThreadTimerMultipleThreads"
+        // All the threads use the same timer, initialize and start it here
+
+        PTIMER_TEST_MULTIPLE_CTX pTimerCtx;
+        STATUS status;
+
+        pTimerCtx = ExAllocatePoolWithTag(PoolAllocatePanicIfFail, sizeof(TIMER_TEST_MULTIPLE_CTX), HEAP_TEST_TAG, 0);
+
+        pTimerCtx->ThreadsShareTimer = TRUE;
+
+        status = ExTimerInit(&pTimerCtx->Same.Timer, ExTimerTypeRelativeOnce, TIMER_TEST_SLEEP_TIME_IN_US);
+        ASSERT(SUCCEEDED(status));
+
+        *Context = pTimerCtx;
+
+        ExTimerStart(&pTimerCtx->Same.Timer);
+    }
+}
+
+
+void
+(__cdecl TestThreadTimerMultipleThreadsPostFinish)(
+    IN              PVOID               Context,
+    IN              DWORD               NumberOfThreads
+    )
+{
+    PTIMER_TEST_MULTIPLE_CTX pContext;
+
+    UNREFERENCED_PARAMETER(NumberOfThreads);
+
+    pContext = (PTIMER_TEST_MULTIPLE_CTX)Context;
+
+    ASSERT(pContext != NULL);
+
+    ExTimerUninit(&pContext->Same.Timer);
+}
+
+
+void
+(__cdecl TestThreadTimerMultipleTimersPostFinish)(
+    IN              PVOID               Context,
+    IN              DWORD               NumberOfThreads
+    )
+{
+    PTIMER_TEST_MULTIPLE_CTX* pContexts;
+    PTIMER_TEST_MULTIPLE_CTX pFirstContext;
+
+    UNREFERENCED_PARAMETER(NumberOfThreads);
+
+    pContexts = (PTIMER_TEST_MULTIPLE_CTX*) Context;
+
+    ASSERT(pContexts != NULL);
+
+    pFirstContext = pContexts[0];
+
+    ASSERT(pFirstContext != NULL);
+
+    __try
+    {
+        for (DWORD i = 1; i < pFirstContext->Different.WakeupArray->NumberOfEntries; ++i)
+        {
+            QWORD prevWakeTimeUs = pContexts[0]->Different.WakeupArray->SystemWakeTimeUs[i-1];
+
+            LOG_TEST_LOG("Thread woke up at %U us system time\n",
+                         pContexts[0]->Different.WakeupArray->SystemWakeTimeUs[i]);
+
+            if (pContexts[0]->Different.WakeupArray->SystemWakeTimeUs[i] < prevWakeTimeUs)
+            {
+                LOG_ERROR("Previous thread woke up at %U system time and the current one woke up at %U\n"
+                          "These values should be monotonically increasing!\n",
+                          prevWakeTimeUs, pContexts[0]->Different.WakeupArray->SystemWakeTimeUs[i]);
+                __leave;
+            }
+        }
+
+        LOG_TEST_PASS;
+    }
+    __finally
+    {
+
+    }
+}
diff --git a/src_proiect/HAL9000/src/test_vmm.c b/src_proiect/HAL9000/src/test_vmm.c
new file mode 100644
index 0000000..8f90bcb
--- /dev/null
+++ b/src_proiect/HAL9000/src/test_vmm.c
@@ -0,0 +1,133 @@
+#include "test_common.h"
+#include "test_vmm.h"
+
+#define TST_VMM_MAGIC_VALUE_TO_WRITE                0xAC
+#define TST_VMM_VA_TO_REQUEST                       (PtrOffset(gVirtualToPhysicalOffset,32 * TB_SIZE))
+
+static const DWORD TST_VMM_ALLOCATION_SIZES[] =
+{
+    PAGE_SIZE,
+    1,
+    1024,
+    PAGE_SIZE * 10,
+    1 * MB_SIZE
+};
+static const DWORD TST_VMM_NO_OF_SIZES = ARRAYSIZE(TST_VMM_ALLOCATION_SIZES);
+
+static
+STATUS
+_TstVmmAllocationAndDeallocation(
+    IN          DWORD       AllocationSize,
+    IN          BOOLEAN     SpecifyBase
+    );
+
+void
+TestVmmAllocAndFreeFunctions(
+    void
+    )
+{
+    DWORD i;
+    BYTE specifyAddress;
+    STATUS status;
+
+    for (specifyAddress = 0; specifyAddress < 2; ++specifyAddress)
+    {
+        for (i = 0; i < TST_VMM_NO_OF_SIZES; ++i)
+        {
+            LOGL("Will call _TstVmmAllocationAndDeallocation for size: %u B, specify address: %d\n", TST_VMM_ALLOCATION_SIZES[i], specifyAddress );
+            status = _TstVmmAllocationAndDeallocation(TST_VMM_ALLOCATION_SIZES[i], specifyAddress );
+            LOGL("_TstVmmAllocationAndDeallocation finished with status: 0x%x\n", status );
+        }
+    }
+}
+
+static
+STATUS
+_TstVmmAllocationAndDeallocation(
+    IN          DWORD       AllocationSize,
+    IN          BOOLEAN     SpecifyBase
+    )
+{
+    STATUS status;
+    PBYTE pBaseAddress;
+    PVOID pAddressToMap;
+
+    status = STATUS_SUCCESS;
+    pAddressToMap = SpecifyBase ? TST_VMM_VA_TO_REQUEST : NULL;
+
+    LOGL("About to reserve region of %u bytes\n", AllocationSize );
+    pBaseAddress = VmmAllocRegion(pAddressToMap,
+                                  AllocationSize,
+                                  VMM_ALLOC_TYPE_RESERVE,
+                                  PAGE_RIGHTS_READWRITE
+                                  );
+    if (NULL == pBaseAddress)
+    {
+        if (0 != AllocationSize)
+        {
+            status = STATUS_MEMORY_CANNOT_BE_RESERVED;
+            LOG_ERROR("VmmAllocRegion failed reserve: %u bytes of memory starting at address: 0x%X\n", AllocationSize, pAddressToMap);
+            return status;
+        }
+        else
+        {
+            return STATUS_SUCCESS;
+        }
+    }
+
+    LOGL("About to commit region of %u bytes\n", AllocationSize );
+    pBaseAddress = VmmAllocRegion(pBaseAddress,
+                                  AllocationSize,
+                                  VMM_ALLOC_TYPE_COMMIT,
+                                  PAGE_RIGHTS_READWRITE
+                                  );
+    if (NULL == pBaseAddress)
+    {
+        status = STATUS_MEMORY_CANNOT_BE_COMMITED;
+        LOG_ERROR("VmmAllocRegion failed commit: %u bytes of memory starting at address: 0x%X\n", AllocationSize, pAddressToMap);
+        return status;
+    }
+
+    LOGL("About to write to reserved region at address 0x%X\n", pBaseAddress );
+    *pBaseAddress = TST_VMM_MAGIC_VALUE_TO_WRITE;
+    if (TST_VMM_MAGIC_VALUE_TO_WRITE != *pBaseAddress)
+    {
+        LOG_ERROR("Value written does not correspond to value read\n");
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    LOGL("About to decommit region of %u bytes\n", AllocationSize );
+    VmmFreeRegion(pBaseAddress,
+                  AllocationSize,
+                  VMM_FREE_TYPE_DECOMMIT
+                  );
+
+    LOGL("About to eagerly commit region of %u bytes\n", AllocationSize );
+    pBaseAddress = VmmAllocRegion(pBaseAddress,
+                                  AllocationSize,
+                                  VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_NOT_LAZY,
+                                  PAGE_RIGHTS_READWRITE
+                                  );
+    if (NULL == pBaseAddress)
+    {
+        status = STATUS_MEMORY_CANNOT_BE_COMMITED;
+        LOG_ERROR("VmmAllocRegion failed eager commit: %u bytes of memory starting at address: 0x%X\n", AllocationSize, pAddressToMap);
+        return status;
+    }
+
+    LOGL("About to write to reserved region at address 0x%X\n", pBaseAddress );
+    *pBaseAddress = TST_VMM_MAGIC_VALUE_TO_WRITE;
+    if (TST_VMM_MAGIC_VALUE_TO_WRITE != *pBaseAddress)
+    {
+        LOG_ERROR("Value written does not correspond to value read\n");
+        return STATUS_UNSUCCESSFUL;
+    }
+
+    LOGL("About to release region of %u bytes\n", AllocationSize );
+    VmmFreeRegion(pBaseAddress,
+                  0,
+                  VMM_FREE_TYPE_RELEASE
+                  );
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/thread.c b/src_proiect/HAL9000/src/thread.c
new file mode 100644
index 0000000..3ec2095
--- /dev/null
+++ b/src_proiect/HAL9000/src/thread.c
@@ -0,0 +1,1241 @@
+#include "HAL9000.h"
+#include "thread_internal.h"
+#include "synch.h"
+#include "cpumu.h"
+#include "ex_event.h"
+#include "core.h"
+#include "vmm.h"
+#include "process_internal.h"
+#include "isr.h"
+#include "gdtmu.h"
+#include "pe_exports.h"
+
+#define TID_INCREMENT               4
+
+#define THREAD_TIME_SLICE           1
+
+extern void ThreadStart();
+
+typedef
+void
+(__cdecl FUNC_ThreadSwitch)(
+    OUT_PTR         PVOID*          OldStack,
+    IN              PVOID           NewStack
+    );
+
+extern FUNC_ThreadSwitch            ThreadSwitch;
+
+typedef struct _THREAD_SYSTEM_DATA
+{
+    LOCK                AllThreadsLock;
+
+    _Guarded_by_(AllThreadsLock)
+    LIST_ENTRY          AllThreadsList;
+
+    LOCK                ReadyThreadsLock;
+
+    _Guarded_by_(ReadyThreadsLock)
+    LIST_ENTRY          ReadyThreadsList;
+} THREAD_SYSTEM_DATA, *PTHREAD_SYSTEM_DATA;
+
+static THREAD_SYSTEM_DATA m_threadSystemData;
+
+__forceinline
+static
+TID
+_ThreadSystemGetNextTid(
+    void
+    )
+{
+    static volatile TID __currentTid = 0;
+
+    return _InterlockedExchangeAdd64(&__currentTid, TID_INCREMENT);
+}
+
+static
+STATUS
+_ThreadInit(
+    IN_Z        char*               Name,
+    IN          THREAD_PRIORITY     Priority,
+    OUT_PTR     PTHREAD*            Thread,
+    IN          BOOLEAN             AllocateKernelStack
+    );
+
+static
+STATUS
+_ThreadSetupInitialState(
+    IN      PTHREAD             Thread,
+    IN      PVOID               StartFunction,
+    IN      QWORD               FirstArgument,
+    IN      QWORD               SecondArgument,
+    IN      BOOLEAN             KernelStack
+    );
+
+static
+STATUS
+_ThreadSetupMainThreadUserStack(
+    IN      PVOID               InitialStack,
+    OUT     PVOID*              ResultingStack,
+    IN      PPROCESS            Process
+    );
+
+
+REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
+static
+void
+_ThreadSchedule(
+    void
+    );
+
+REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
+void
+ThreadCleanupPostSchedule(
+    void
+    );
+
+REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
+static
+_Ret_notnull_
+PTHREAD
+_ThreadGetReadyThread(
+    void
+    );
+
+static
+void
+_ThreadForcedExit(
+    void
+    );
+
+static
+void
+_ThreadReference(
+    INOUT   PTHREAD                 Thread
+    );
+
+static
+void
+_ThreadDereference(
+    INOUT   PTHREAD                 Thread
+    );
+
+static FUNC_FreeFunction            _ThreadDestroy;
+
+static
+void
+_ThreadKernelFunction(
+    IN      PFUNC_ThreadStart       Function,
+    IN_OPT  PVOID                   Context
+    );
+
+static FUNC_ThreadStart     _IdleThread;
+
+void
+_No_competing_thread_
+ThreadSystemPreinit(
+    void
+    )
+{
+    memzero(&m_threadSystemData, sizeof(THREAD_SYSTEM_DATA));
+
+    InitializeListHead(&m_threadSystemData.AllThreadsList);
+    LockInit(&m_threadSystemData.AllThreadsLock);
+
+    InitializeListHead(&m_threadSystemData.ReadyThreadsList);
+    LockInit(&m_threadSystemData.ReadyThreadsLock);
+}
+
+STATUS
+ThreadSystemInitMainForCurrentCPU(
+    void
+    )
+{
+    STATUS status;
+    PPCPU pCpu;
+    char mainThreadName[MAX_PATH];
+    PTHREAD pThread;
+    PPROCESS pProcess;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pCpu = GetCurrentPcpu();
+    pThread = NULL;
+    pProcess = ProcessRetrieveSystemProcess();
+
+    ASSERT( NULL != pCpu );
+
+    snprintf( mainThreadName, MAX_PATH, "%s-%02x", "main", pCpu->ApicId );
+
+    status = _ThreadInit(mainThreadName, ThreadPriorityDefault, &pThread, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_ThreadInit", status );
+        return status;
+    }
+    LOGPL("_ThreadInit succeeded\n");
+
+    pThread->InitialStackBase = pCpu->StackTop;
+    pThread->StackSize = pCpu->StackSize;
+
+    pThread->State = ThreadStateRunning;
+    SetCurrentThread(pThread);
+
+    // In case of the main thread of the BSP the process will be NULL so we need to handle that case
+    // When the system process will be initialized it will insert into its thread list the current thread (which will
+    // be the main thread of the BSP)
+    if (pProcess != NULL)
+    {
+        ProcessInsertThreadInList(pProcess, pThread);
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+ThreadSystemInitIdleForCurrentCPU(
+    void
+    )
+{
+    EX_EVENT idleStarted;
+    STATUS status;
+    PPCPU pCpu;
+    char idleThreadName[MAX_PATH];
+    PTHREAD idleThread;
+
+    ASSERT( INTR_OFF == CpuIntrGetState() );
+
+    LOG_FUNC_START_THREAD;
+
+    status = STATUS_SUCCESS;
+    pCpu = GetCurrentPcpu();
+
+    ASSERT(NULL != pCpu);
+
+    status = ExEventInit(&idleStarted, ExEventTypeSynchronization, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("EvtInitialize", status);
+        return status;
+    }
+    LOGPL("EvtInitialize succeeded\n");
+
+    snprintf(idleThreadName, MAX_PATH, "%s-%02x", "idle", pCpu->ApicId);
+
+    // create idle thread
+    status = ThreadCreate(idleThreadName,
+                          ThreadPriorityDefault,
+                          _IdleThread,
+                          &idleStarted,
+                          &idleThread
+                          );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ThreadCreate", status);
+        return status;
+    }
+    LOGPL("ThreadCreate for IDLE thread succeeded\n");
+
+    ThreadCloseHandle(idleThread);
+    idleThread = NULL;
+
+    LOGPL("About to enable interrupts\n");
+
+    // lets enable some interrupts :)
+    CpuIntrEnable();
+
+    LOGPL("Interrupts enabled :)\n");
+
+    // wait for idle thread
+    LOG_TRACE_THREAD("Waiting for idle thread signal\n");
+    ExEventWaitForSignal(&idleStarted);
+    LOG_TRACE_THREAD("Received idle thread signal\n");
+
+    LOG_FUNC_END_THREAD;
+
+    return status;
+}
+
+STATUS
+ThreadCreate(
+    IN_Z        char*               Name,
+    IN          THREAD_PRIORITY     Priority,
+    IN          PFUNC_ThreadStart   Function,
+    IN_OPT      PVOID               Context,
+    OUT_PTR     PTHREAD*            Thread
+    )
+{
+    return ThreadCreateEx(Name,
+                          Priority,
+                          Function,
+                          Context,
+                          Thread,
+                          ProcessRetrieveSystemProcess());
+}
+
+STATUS
+ThreadCreateEx(
+    IN_Z        char*               Name,
+    IN          THREAD_PRIORITY     Priority,
+    IN          PFUNC_ThreadStart   Function,
+    IN_OPT      PVOID               Context,
+    OUT_PTR     PTHREAD*            Thread,
+    INOUT       struct _PROCESS*    Process
+    )
+{
+    STATUS status;
+    PTHREAD pThread;
+    PPCPU pCpu;
+    BOOLEAN bProcessIniialThread;
+    PVOID pStartFunction;
+    QWORD firstArg;
+    QWORD secondArg;
+
+    if (NULL == Name)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == Function)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (NULL == Thread)
+    {
+        return STATUS_INVALID_PARAMETER5;
+    }
+
+    if (NULL == Process)
+    {
+        return STATUS_INVALID_PARAMETER6;
+    }
+
+    status = STATUS_SUCCESS;
+    pThread = NULL;
+    pCpu = GetCurrentPcpu();
+    bProcessIniialThread = FALSE;
+    pStartFunction = NULL;
+    firstArg = 0;
+    secondArg = 0;
+
+    ASSERT(NULL != pCpu);
+
+    status = _ThreadInit(Name, Priority, &pThread, TRUE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_ThreadInit", status);
+        return status;
+    }
+
+    ProcessInsertThreadInList(Process, pThread);
+
+    // the reference must be done outside _ThreadInit
+    _ThreadReference(pThread);
+
+    if (!Process->PagingData->Data.KernelSpace)
+    {
+        // Create user-mode stack
+        pThread->UserStack = MmuAllocStack(STACK_DEFAULT_SIZE,
+                                           TRUE,
+                                           FALSE,
+                                           Process);
+        if (pThread->UserStack == NULL)
+        {
+            status = STATUS_MEMORY_CANNOT_BE_COMMITED;
+            LOG_FUNC_ERROR_ALLOC("MmuAllocStack", STACK_DEFAULT_SIZE);
+            return status;
+        }
+
+        bProcessIniialThread = (Function == Process->HeaderInfo->Preferred.AddressOfEntryPoint);
+
+        // We are the first thread => we must pass the argc and argv parameters
+        // and the whole command line which spawned the process
+        if (bProcessIniialThread)
+        {
+            // It's one because we already incremented it when we called ProcessInsertThreadInList earlier
+            ASSERT(Process->NumberOfThreads == 1);
+
+            status = _ThreadSetupMainThreadUserStack(pThread->UserStack,
+                                                     &pThread->UserStack,
+                                                     Process);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_ThreadSetupUserStack", status);
+                return status;
+            }
+        }
+        else
+        {
+            pThread->UserStack = (PVOID) PtrDiff(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID));
+        }
+
+        pStartFunction = (PVOID) (bProcessIniialThread ? Process->HeaderInfo->Preferred.AddressOfEntryPoint : Function);
+        firstArg       = (QWORD) (bProcessIniialThread ? Process->NumberOfArguments : (QWORD) Context);
+        secondArg      = (QWORD) (bProcessIniialThread ? PtrOffset(pThread->UserStack, SHADOW_STACK_SIZE + sizeof(PVOID)) : 0);
+    }
+    else
+    {
+        // Kernel mode
+
+        // warning C4152: nonstandard extension, function/data pointer conversion in expression
+#pragma warning(suppress:4152)
+        pStartFunction = _ThreadKernelFunction;
+
+        firstArg =  (QWORD) Function;
+        secondArg = (QWORD) Context;
+    }
+
+    status = _ThreadSetupInitialState(pThread,
+                                      pStartFunction,
+                                      firstArg,
+                                      secondArg,
+                                      Process->PagingData->Data.KernelSpace);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_ThreadSetupInitialState", status);
+        return status;
+    }
+
+    if (NULL == pCpu->ThreadData.IdleThread)
+    {
+        pThread->State = ThreadStateReady;
+
+        // this is the IDLE thread creation
+        pCpu->ThreadData.IdleThread = pThread;
+    }
+    else
+    {
+        ThreadUnblock(pThread);
+    }
+
+    *Thread = pThread;
+
+    return status;
+}
+
+void
+ThreadTick(
+    void
+    )
+{
+    PPCPU pCpu = GetCurrentPcpu();
+    PTHREAD pThread = GetCurrentThread();
+
+    ASSERT( INTR_OFF == CpuIntrGetState());
+    ASSERT( NULL != pCpu);
+
+    LOG_TRACE_THREAD("Thread tick\n");
+    if (pCpu->ThreadData.IdleThread == pThread)
+    {
+        pCpu->ThreadData.IdleTicks++;
+    }
+    else
+    {
+        pCpu->ThreadData.KernelTicks++;
+    }
+    pThread->TickCountCompleted++;
+
+    if (++pCpu->ThreadData.RunningThreadTicks >= THREAD_TIME_SLICE)
+    {
+        LOG_TRACE_THREAD("Will yield on return\n");
+        pCpu->ThreadData.YieldOnInterruptReturn = TRUE;
+    }
+}
+
+void
+ThreadYield(
+    void
+    )
+{
+    INTR_STATE dummyState;
+    INTR_STATE oldState;
+    PTHREAD pThread = GetCurrentThread();
+    PPCPU pCpu;
+    BOOLEAN bForcedYield;
+
+    ASSERT( NULL != pThread);
+
+    oldState = CpuIntrDisable();
+
+    pCpu = GetCurrentPcpu();
+
+    ASSERT( NULL != pCpu );
+
+    bForcedYield = pCpu->ThreadData.YieldOnInterruptReturn;
+    pCpu->ThreadData.YieldOnInterruptReturn = FALSE;
+
+    if (THREAD_FLAG_FORCE_TERMINATE_PENDING == _InterlockedAnd(&pThread->Flags, MAX_DWORD))
+    {
+        _ThreadForcedExit();
+        NOT_REACHED;
+    }
+
+    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
+    if (pThread != pCpu->ThreadData.IdleThread)
+    {
+        InsertTailList(&m_threadSystemData.ReadyThreadsList, &pThread->ReadyList);
+    }
+    if (!bForcedYield)
+    {
+        pThread->TickCountEarly++;
+    }
+    pThread->State = ThreadStateReady;
+    _ThreadSchedule();
+    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+    LOG_TRACE_THREAD("Returned from _ThreadSchedule\n");
+
+    CpuIntrSetState(oldState);
+}
+
+void
+ThreadBlock(
+    void
+    )
+{
+    INTR_STATE oldState;
+    PTHREAD pCurrentThread;
+
+    pCurrentThread = GetCurrentThread();
+
+    ASSERT( INTR_OFF == CpuIntrGetState());
+    ASSERT(LockIsOwner(&pCurrentThread->BlockLock));
+
+    if (THREAD_FLAG_FORCE_TERMINATE_PENDING == _InterlockedAnd(&pCurrentThread->Flags, MAX_DWORD))
+    {
+        _ThreadForcedExit();
+        NOT_REACHED;
+    }
+
+    pCurrentThread->TickCountEarly++;
+    pCurrentThread->State = ThreadStateBlocked;
+    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
+    _ThreadSchedule();
+    ASSERT( !LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+}
+
+void
+ThreadUnblock(
+    IN      PTHREAD              Thread
+    )
+{
+    INTR_STATE oldState;
+    INTR_STATE dummyState;
+
+    ASSERT(NULL != Thread);
+
+    LockAcquire(&Thread->BlockLock, &oldState);
+
+    ASSERT(ThreadStateBlocked == Thread->State);
+
+    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &dummyState);
+    InsertTailList(&m_threadSystemData.ReadyThreadsList, &Thread->ReadyList);
+    Thread->State = ThreadStateReady;
+    LockRelease(&m_threadSystemData.ReadyThreadsLock, dummyState );
+    LockRelease(&Thread->BlockLock, oldState);
+}
+
+void
+ThreadExit(
+    IN      STATUS              ExitStatus
+    )
+{
+    PTHREAD pThread;
+    INTR_STATE oldState;
+
+    LOG_FUNC_START_THREAD;
+
+    pThread = GetCurrentThread();
+
+    CpuIntrDisable();
+
+    if (LockIsOwner(&pThread->BlockLock))
+    {
+        LockRelease(&pThread->BlockLock, INTR_OFF);
+    }
+
+    pThread->State = ThreadStateDying;
+    pThread->ExitStatus = ExitStatus;
+    ExEventSignal(&pThread->TerminationEvt);
+
+    ProcessNotifyThreadTermination(pThread);
+
+    LockAcquire(&m_threadSystemData.ReadyThreadsLock, &oldState);
+    _ThreadSchedule();
+    NOT_REACHED;
+}
+
+BOOLEAN
+ThreadYieldOnInterrupt(
+    void
+    )
+{
+    return GetCurrentPcpu()->ThreadData.YieldOnInterruptReturn;
+}
+
+void
+ThreadTakeBlockLock(
+    void
+    )
+{
+    INTR_STATE dummyState;
+
+    LockAcquire(&GetCurrentThread()->BlockLock, &dummyState);
+}
+
+void
+ThreadWaitForTermination(
+    IN      PTHREAD             Thread,
+    OUT     STATUS*             ExitStatus
+    )
+{
+    ASSERT( NULL != Thread );
+    ASSERT( NULL != ExitStatus);
+
+    ExEventWaitForSignal(&Thread->TerminationEvt);
+
+    *ExitStatus = Thread->ExitStatus;
+}
+
+void
+ThreadCloseHandle(
+    INOUT   PTHREAD             Thread
+    )
+{
+    ASSERT( NULL != Thread);
+
+    _ThreadDereference(Thread);
+}
+
+void
+ThreadTerminate(
+    INOUT   PTHREAD             Thread
+    )
+{
+    ASSERT( NULL != Thread );
+
+    // it's not a problem if the thread already finished
+    _InterlockedOr(&Thread->Flags, THREAD_FLAG_FORCE_TERMINATE_PENDING );
+}
+
+const
+char*
+ThreadGetName(
+    IN_OPT  PTHREAD             Thread
+    )
+{
+    PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
+
+    return (NULL != pThread) ? pThread->Name : "";
+}
+
+TID
+ThreadGetId(
+    IN_OPT  PTHREAD             Thread
+    )
+{
+    PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
+
+    return (NULL != pThread) ? pThread->Id : 0;
+}
+
+THREAD_PRIORITY
+ThreadGetPriority(
+    IN_OPT  PTHREAD             Thread
+    )
+{
+    PTHREAD pThread = (NULL != Thread) ? Thread : GetCurrentThread();
+
+    return (NULL != pThread) ? pThread->Priority : 0;
+}
+
+void
+ThreadSetPriority(
+    IN      THREAD_PRIORITY     NewPriority
+    )
+{
+    ASSERT(ThreadPriorityLowest <= NewPriority && NewPriority <= ThreadPriorityMaximum);
+
+    GetCurrentThread()->Priority = NewPriority;
+}
+
+STATUS
+ThreadExecuteForEachThreadEntry(
+    IN      PFUNC_ListFunction  Function,
+    IN_OPT  PVOID               Context
+    )
+{
+    STATUS status;
+    INTR_STATE oldState;
+
+    if (NULL == Function)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+
+    LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
+    status = ForEachElementExecute(&m_threadSystemData.AllThreadsList,
+                                   Function,
+                                   Context,
+                                   FALSE
+                                   );
+    LockRelease(&m_threadSystemData.AllThreadsLock, oldState );
+
+    return status;
+}
+
+void
+SetCurrentThread(
+    IN      PTHREAD     Thread
+    )
+{
+    PPCPU pCpu;
+
+    __writemsr(IA32_FS_BASE_MSR, Thread);
+
+    pCpu = GetCurrentPcpu();
+    ASSERT(pCpu != NULL);
+
+    pCpu->ThreadData.CurrentThread = Thread->Self;
+    if (NULL != Thread->Self)
+    {
+        pCpu->StackTop = Thread->InitialStackBase;
+        pCpu->StackSize = Thread->StackSize;
+        pCpu->Tss.Rsp[0] = (QWORD) Thread->InitialStackBase;
+    }
+}
+
+static
+STATUS
+_ThreadInit(
+    IN_Z        char*               Name,
+    IN          THREAD_PRIORITY     Priority,
+    OUT_PTR     PTHREAD*            Thread,
+    IN          BOOLEAN             AllocateKernelStack
+    )
+{
+    STATUS status;
+    PTHREAD pThread;
+    DWORD nameLen;
+    PVOID pStack;
+    INTR_STATE oldIntrState;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != Name);
+    ASSERT(NULL != Thread);
+    ASSERT_INFO(ThreadPriorityLowest <= Priority && Priority <= ThreadPriorityMaximum,
+                "Priority is 0x%x\n", Priority);
+
+    status = STATUS_SUCCESS;
+    pThread = NULL;
+    nameLen = strlen(Name);
+    pStack = NULL;
+
+    __try
+    {
+        pThread = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(THREAD), HEAP_THREAD_TAG, 0);
+        if (NULL == pThread)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(THREAD));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        RfcPreInit(&pThread->RefCnt);
+
+        status = RfcInit(&pThread->RefCnt, _ThreadDestroy, NULL);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("RfcInit", status);
+            __leave;
+        }
+
+        pThread->Self = pThread;
+
+        status = ExEventInit(&pThread->TerminationEvt, ExEventTypeNotification, FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("ExEventInit", status);
+            __leave;
+        }
+
+        if (AllocateKernelStack)
+        {
+            pStack = MmuAllocStack(STACK_DEFAULT_SIZE, TRUE, FALSE, NULL);
+            if (NULL == pStack)
+            {
+                LOG_FUNC_ERROR_ALLOC("MmuAllocStack", STACK_DEFAULT_SIZE);
+                status = STATUS_MEMORY_CANNOT_BE_COMMITED;
+                __leave;
+            }
+            pThread->Stack = pStack;
+            pThread->InitialStackBase = pStack;
+            pThread->StackSize = STACK_DEFAULT_SIZE;
+        }
+
+        pThread->Name = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(char)*(nameLen + 1), HEAP_THREAD_TAG, 0);
+        if (NULL == pThread->Name)
+        {
+            LOG_FUNC_ERROR_ALLOC("HeapAllocatePoolWithTag", sizeof(char)*(nameLen + 1));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        strcpy(pThread->Name, Name);
+
+        pThread->Id = _ThreadSystemGetNextTid();
+        pThread->State = ThreadStateBlocked;
+        pThread->Priority = Priority;
+
+        LockInit(&pThread->BlockLock);
+
+        LockAcquire(&m_threadSystemData.AllThreadsLock, &oldIntrState);
+        InsertTailList(&m_threadSystemData.AllThreadsList, &pThread->AllList);
+        LockRelease(&m_threadSystemData.AllThreadsLock, oldIntrState);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pThread)
+            {
+                _ThreadDereference(pThread);
+                pThread = NULL;
+            }
+        }
+
+        *Thread = pThread;
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+//  STACK TOP
+//  -----------------------------------------------------------------
+//  |                                                               |
+//  |       Shadow Space                                            |
+//  |                                                               |
+//  |                                                               |
+//  -----------------------------------------------------------------
+//  |     Dummy Function RA                                         |
+//  ---------------------------------------------------------------------------------
+//  |     SS     = DS64Supervisor        | DS64Usermode             |               |
+//  -----------------------------------------------------------------               |
+//  |     RSP    = &(Dummy Function RA)  | Thread->UserStack        |               |
+//  -----------------------------------------------------------------               |
+//  |     RFLAGS = RFLAGS_IF | RFLAGS_RESERVED                      |   Interrupt   |
+//  -----------------------------------------------------------------     Stack     |
+//  |     CS     = CS64Supervisor        | CS64Usermode             |               |
+//  -----------------------------------------------------------------               |
+//  |     RIP    = _ThreadKernelFunction | AddressOfEntryPoint      |               |
+//  ---------------------------------------------------------------------------------
+//  |     Thread Start Function                                     |
+//  -----------------------------------------------------------------
+//  |                                                               |
+//  |       PROCESSOR_STATE                                         |
+//  |                                                               |
+//  |                                                               |
+//  -----------------------------------------------------------------
+//  STACK BASE <- RSP at ThreadSwitch
+static
+STATUS
+_ThreadSetupInitialState(
+    IN      PTHREAD             Thread,
+    IN      PVOID               StartFunction,
+    IN      QWORD               FirstArgument,
+    IN      QWORD               SecondArgument,
+    IN      BOOLEAN             KernelStack
+    )
+{
+    STATUS status;
+    PVOID* pStack;
+    PCOMPLETE_PROCESSOR_STATE pState;
+    PINTERRUPT_STACK pIst;
+
+    ASSERT( NULL != Thread );
+    ASSERT( NULL != StartFunction);
+
+    status = STATUS_SUCCESS;
+
+    pStack = (PVOID*) Thread->Stack;
+
+    // The kernel function has to have a shadow space and a dummy RA
+    pStack = pStack - ( 4 + 1 );
+
+    pStack = (PVOID*) PtrDiff(pStack, sizeof(INTERRUPT_STACK));
+
+    // setup pseudo-interrupt stack
+    pIst = (PINTERRUPT_STACK) pStack;
+
+    pIst->Rip = (QWORD) StartFunction;
+    if (KernelStack)
+    {
+        pIst->CS = GdtMuGetCS64Supervisor();
+        pIst->Rsp = (QWORD)(pIst + 1);
+        pIst->SS = GdtMuGetDS64Supervisor();
+    }
+    else
+    {
+        ASSERT(Thread->UserStack != NULL);
+
+        pIst->CS = GdtMuGetCS64Usermode() | RING_THREE_PL;
+        pIst->Rsp = (QWORD) Thread->UserStack;
+        pIst->SS = GdtMuGetDS64Usermode() | RING_THREE_PL;
+    }
+
+    pIst->RFLAGS = RFLAGS_INTERRUPT_FLAG_BIT | RFLAGS_RESERVED_BIT;
+
+    pStack = pStack - 1;
+
+    // warning C4054: 'type cast': from function pointer 'void (__cdecl *)(const PFUNC_ThreadStart,const PVOID)' to data pointer 'PVOID'
+#pragma warning(suppress:4054)
+    *pStack = (PVOID) ThreadStart;
+
+    pStack = (PVOID*) PtrDiff(pStack, sizeof(COMPLETE_PROCESSOR_STATE));
+    pState = (PCOMPLETE_PROCESSOR_STATE) pStack;
+
+    memzero(pState, sizeof(COMPLETE_PROCESSOR_STATE));
+    pState->RegisterArea.RegisterValues[RegisterRcx] = FirstArgument;
+    pState->RegisterArea.RegisterValues[RegisterRdx] = SecondArgument;
+
+    Thread->Stack = pStack;
+
+    return STATUS_SUCCESS;
+}
+
+
+//  USER STACK TOP
+//  -----------------------------------------------------------------
+//  |                       Argument N-1                            |
+//  -----------------------------------------------------------------
+//  |                          ...                                  |
+//  -----------------------------------------------------------------
+//  |                       Argument 0                              |
+//  -----------------------------------------------------------------
+//  |                 argv[N-1] = &(Argument N-1)                   |
+//  -----------------------------------------------------------------
+//  |                          ...                                  |
+//  -----------------------------------------------------------------
+//  |                 argv[0] = &(Argument 0)                       |
+//  -----------------------------------------------------------------
+//  |                 Dummy 4th Arg = 0xDEADBEEF                    |
+//  -----------------------------------------------------------------
+//  |                 Dummy 3rd Arg = 0xDEADBEEF                    |
+//  -----------------------------------------------------------------
+//  |                 argv = &argv[0]                               |
+//  -----------------------------------------------------------------
+//  |                 argc = N (Process->NumberOfArguments)         |
+//  -----------------------------------------------------------------
+//  |                 Dummy RA = 0xDEADC0DE                         |
+//  -----------------------------------------------------------------
+//  USER STACK BASE
+static
+STATUS
+_ThreadSetupMainThreadUserStack(
+    IN      PVOID               InitialStack,
+    OUT     PVOID*              ResultingStack,
+    IN      PPROCESS            Process
+    )
+{
+    ASSERT(InitialStack != NULL);
+    ASSERT(ResultingStack != NULL);
+    ASSERT(Process != NULL);
+
+    *ResultingStack = InitialStack;
+
+    return STATUS_SUCCESS;
+}
+
+REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
+static
+void
+_ThreadSchedule(
+    void
+    )
+{
+    PTHREAD pCurrentThread;
+    PTHREAD pNextThread;
+    PCPU* pCpu;
+
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+
+    pCurrentThread = GetCurrentThread();
+    ASSERT( NULL != pCurrentThread );
+
+    pCpu = GetCurrentPcpu();
+
+    // save previous thread
+    pCpu->ThreadData.PreviousThread = pCurrentThread;
+
+    // get next thread
+    pNextThread = _ThreadGetReadyThread();
+    ASSERT( NULL != pNextThread );
+
+    // if current differs from next
+    // => schedule next
+    if (pNextThread != pCurrentThread)
+    {
+        LOG_TRACE_THREAD("Before ThreadSwitch\n");
+        LOG_TRACE_THREAD("Current thread: %s\n", pCurrentThread->Name);
+        LOG_TRACE_THREAD("Next thread: %s\n", pNextThread->Name);
+
+        if (pCurrentThread->Process != pNextThread->Process)
+        {
+            MmuChangeProcessSpace(pNextThread->Process);
+        }
+
+        // Before any thread is scheduled it executes this function, thus if we set the current
+        // thread to be the next one it will be fine - there is no possibility of interrupts
+        // appearing to cause inconsistencies
+        pCurrentThread->UninterruptedTicks = 0;
+
+        SetCurrentThread(pNextThread);
+        ThreadSwitch( &pCurrentThread->Stack, pNextThread->Stack);
+
+        ASSERT(INTR_OFF == CpuIntrGetState());
+        ASSERT(LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+
+        LOG_TRACE_THREAD("After ThreadSwitch\n");
+        LOG_TRACE_THREAD("Current: %s\n", pCurrentThread->Name);
+
+        // We cannot log the name of the 'next thread', i.e. the thread which formerly preempted
+        // this one because a long time may have passed since then and it may have been destroyed
+
+        // The previous thread may also have been destroyed after it was de-scheduled, we have
+        // to be careful before logging its name
+        if (pCpu->ThreadData.PreviousThread != NULL)
+        {
+            LOG_TRACE_THREAD("Prev thread: %s\n", pCpu->ThreadData.PreviousThread->Name);
+        }
+    }
+    else
+    {
+        pCurrentThread->UninterruptedTicks++;
+    }
+
+    ThreadCleanupPostSchedule();
+}
+
+REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
+RELEASES_EXCL_AND_NON_REENTRANT_LOCK(m_threadSystemData.ReadyThreadsLock)
+void
+ThreadCleanupPostSchedule(
+    void
+    )
+{
+    PTHREAD prevThread;
+
+    ASSERT(INTR_OFF == CpuIntrGetState());
+
+    GetCurrentPcpu()->ThreadData.RunningThreadTicks = 0;
+    prevThread = GetCurrentPcpu()->ThreadData.PreviousThread;
+
+    LockRelease(&m_threadSystemData.ReadyThreadsLock, INTR_OFF);
+
+    if (NULL != prevThread)
+    {
+        if (LockIsOwner(&prevThread->BlockLock))
+        {
+            // Unfortunately, we cannot use the inverse condition because it is not always
+            // true, i.e. if the previous thread is the idle thread it's not 100% sure that
+            // it was previously holding the block hold, it may have been preempted before
+            // acquiring it.
+            ASSERT(prevThread->State == ThreadStateBlocked
+                   || prevThread == GetCurrentPcpu()->ThreadData.IdleThread);
+
+            LOG_TRACE_THREAD("Will release block lock for thread [%s]\n", prevThread->Name);
+
+            _Analysis_assume_lock_held_(prevThread->BlockLock);
+            LockRelease(&prevThread->BlockLock, INTR_OFF);
+        }
+        else if (prevThread->State == ThreadStateDying)
+        {
+            LOG_TRACE_THREAD("Will dereference thread: [%s]\n", prevThread->Name);
+
+            // dereference thread
+            _ThreadDereference(prevThread);
+            GetCurrentPcpu()->ThreadData.PreviousThread = NULL;
+        }
+    }
+}
+
+static
+STATUS
+(__cdecl _IdleThread)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PEX_EVENT pEvent;
+
+    LOG_FUNC_START_THREAD;
+
+    ASSERT( NULL != Context);
+
+    pEvent = (PEX_EVENT) Context;
+    ExEventSignal(pEvent);
+
+    // warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        CpuIntrDisable();
+        ThreadTakeBlockLock();
+        ThreadBlock();
+
+        __sti_and_hlt();
+    }
+
+    NOT_REACHED;
+}
+
+REQUIRES_EXCL_LOCK(m_threadSystemData.ReadyThreadsLock)
+static
+_Ret_notnull_
+PTHREAD
+_ThreadGetReadyThread(
+    void
+    )
+{
+    PTHREAD pNextThread;
+    PLIST_ENTRY pEntry;
+    BOOLEAN bIdleScheduled;
+
+    ASSERT( INTR_OFF == CpuIntrGetState());
+    ASSERT( LockIsOwner(&m_threadSystemData.ReadyThreadsLock));
+
+    pNextThread = NULL;
+
+    pEntry = RemoveHeadList(&m_threadSystemData.ReadyThreadsList);
+    if (pEntry == &m_threadSystemData.ReadyThreadsList)
+    {
+        pNextThread = GetCurrentPcpu()->ThreadData.IdleThread;
+        bIdleScheduled = TRUE;
+    }
+    else
+    {
+        pNextThread = CONTAINING_RECORD( pEntry, THREAD, ReadyList );
+
+        ASSERT( pNextThread->State == ThreadStateReady );
+        bIdleScheduled = FALSE;
+    }
+
+    // maybe we shouldn't update idle time each time a thread is scheduled
+    // maybe it is enough only every x times
+    // or maybe we can update time only on RTC updates
+    CoreUpdateIdleTime(bIdleScheduled);
+
+    return pNextThread;
+}
+
+static
+void
+_ThreadForcedExit(
+    void
+    )
+{
+    PTHREAD pCurrentThread = GetCurrentThread();
+
+    _InterlockedOr( &pCurrentThread->Flags, THREAD_FLAG_FORCE_TERMINATED );
+
+    ThreadExit(STATUS_JOB_INTERRUPTED);
+    NOT_REACHED;
+}
+
+static
+void
+_ThreadReference(
+    INOUT   PTHREAD                 Thread
+    )
+{
+    ASSERT( NULL != Thread );
+
+    RfcReference(&Thread->RefCnt);
+}
+
+static
+void
+_ThreadDereference(
+    INOUT   PTHREAD                 Thread
+    )
+{
+    ASSERT( NULL != Thread );
+
+    RfcDereference(&Thread->RefCnt);
+}
+
+static
+void
+_ThreadDestroy(
+    IN      PVOID                   Object,
+    IN_OPT  PVOID                   Context
+    )
+{
+    INTR_STATE oldState;
+    PTHREAD pThread = (PTHREAD) CONTAINING_RECORD(Object, THREAD, RefCnt);
+
+    ASSERT(NULL != pThread);
+    ASSERT(NULL == Context);
+
+    LockAcquire(&m_threadSystemData.AllThreadsLock, &oldState);
+    RemoveEntryList(&pThread->AllList);
+    LockRelease(&m_threadSystemData.AllThreadsLock, oldState);
+
+    // This must be done before removing the thread from the process list, else
+    // this may be the last thread and the process VAS will be freed by the time
+    // ProcessRemoveThreadFromList - this function also dereferences the process
+    if (NULL != pThread->UserStack)
+    {
+        // Free UM stack
+        MmuFreeStack(pThread->UserStack, pThread->Process);
+        pThread->UserStack = NULL;
+    }
+
+    ProcessRemoveThreadFromList(pThread);
+
+    if (NULL != pThread->Name)
+    {
+        ExFreePoolWithTag(pThread->Name, HEAP_THREAD_TAG);
+        pThread->Name = NULL;
+    }
+
+    if (NULL != pThread->Stack)
+    {
+        // This is the kernel mode stack
+        // It does not 'belong' to any process => pass NULL
+        MmuFreeStack(pThread->Stack, NULL);
+        pThread->Stack = NULL;
+    }
+
+    ExFreePoolWithTag(pThread, HEAP_THREAD_TAG);
+}
+
+static
+void
+_ThreadKernelFunction(
+    IN      PFUNC_ThreadStart       Function,
+    IN_OPT  PVOID                   Context
+    )
+{
+    STATUS exitStatus;
+
+    ASSERT(NULL != Function);
+
+    CHECK_STACK_ALIGNMENT;
+
+    ASSERT(CpuIntrGetState() == INTR_ON);
+    exitStatus = Function(Context);
+
+    ThreadExit(exitStatus);
+    NOT_REACHED;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/um_application.c b/src_proiect/HAL9000/src/um_application.c
new file mode 100644
index 0000000..886eb13
--- /dev/null
+++ b/src_proiect/HAL9000/src/um_application.c
@@ -0,0 +1,266 @@
+#include "HAL9000.h"
+#include "um_application.h"
+#include "io.h"
+#include "pe_parser.h"
+#include "vmm.h"
+#include "thread_internal.h"
+#include "process_internal.h"
+
+static
+STATUS
+_UmApplicationReadExecutableContents(
+    IN_Z        char*       FullPath,
+    _Outptr_result_buffer_(*BufferSize)
+                PVOID*      Buffer,
+    OUT         QWORD*      BufferSize
+    );
+
+static
+void
+_UmApplicationDiscardKernelExecutableMapping(
+    IN          PVOID       ApplicationBuffer
+    );
+
+STATUS
+UmApplicationRetrieveHeader(
+    IN_Z        char*                   Path,
+    OUT         PPE_NT_HEADER_INFO      NtHeaderInfo
+    )
+{
+    STATUS status;
+    QWORD peSize;
+    PVOID pBuffer;
+
+    if (Path == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NtHeaderInfo == NULL)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    LOG_FUNC_START;
+
+    pBuffer = NULL;
+    status = STATUS_SUCCESS;
+    peSize = 0;
+    memzero(NtHeaderInfo, sizeof(PE_NT_HEADER_INFO));
+
+    __try
+    {
+        LOG_TRACE_USERMODE("Will open executable found at [%s]\n", Path);
+
+        status = _UmApplicationReadExecutableContents(Path,
+                                                      &pBuffer,
+                                                      &peSize);
+        if (!SUCCEEDED(status))
+        {
+            LOG_TRACE_USERMODE("[ERROR]_UmApplicationReadExecutableContents failed with status 0x%x", status);
+            __leave;
+        }
+
+        LOG_TRACE_USERMODE("Will parse NT header!\n");
+
+        ASSERT(peSize <= MAX_DWORD);
+        status = PeRetrieveNtHeader(pBuffer,
+                                    (DWORD)peSize,
+                                    NtHeaderInfo);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("PeRetrieveNtHeader", status);
+            __leave;
+        }
+
+        LOG_TRACE_USERMODE("Successfully parsed NT header!\n");
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (pBuffer != NULL)
+            {
+                _UmApplicationDiscardKernelExecutableMapping(pBuffer);
+                pBuffer = NULL;
+            }
+        }
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+STATUS
+UmApplicationRun(
+    IN          PPROCESS                Process,
+    IN          BOOLEAN                 WaitForExecution,
+    OUT_OPT     STATUS*                 CompletionStatus
+    )
+{
+    STATUS status;
+    PTHREAD pThread;
+
+    UNREFERENCED_PARAMETER(WaitForExecution);
+    UNREFERENCED_PARAMETER(CompletionStatus);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pThread = NULL;
+
+    __try
+    {
+        // Loads the kernel image at the preferred image dictated by the NT header
+        status = MmuLoadPe(Process->HeaderInfo,
+                           Process->PagingData);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("MmuLoadPe", status);
+            __leave;
+        }
+
+        LOG_TRACE_USERMODE("Successfully loaded PE file!\n");
+
+        // After we loaded the PE into the appropriate process there is no need to keep the kernel mapping
+        _UmApplicationDiscardKernelExecutableMapping(Process->HeaderInfo->ImageBase);
+
+        LOG_TRACE_USERMODE("Will create thread with entry point at 0x%X\n", Process->HeaderInfo->Preferred.AddressOfEntryPoint);
+
+        status = ThreadCreateEx("Test",
+                                ThreadPriorityDefault,
+                                //  warning C4055: 'type cast': from data pointer 'PVOID' to function pointer 'PFUNC_ThreadStart'
+#pragma warning(suppress:4055)
+                                (PFUNC_ThreadStart)Process->HeaderInfo->Preferred.AddressOfEntryPoint,
+                                NULL,
+                                &pThread,
+                                Process);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("ThreadCreate", status);
+            __leave;
+        }
+
+        LOG_TRACE_USERMODE("Successfully created thread!\n");
+    }
+    __finally
+    {
+        if (pThread != NULL)
+        {
+            // This MUST be done on both success and failure
+            // We are not returning the thread pointer anywhere => we need to close
+            // it here so the reference count will be zero when it will terminate
+            ThreadCloseHandle(pThread);
+            pThread = NULL;
+        }
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_UmApplicationReadExecutableContents(
+    IN_Z        char*       FullPath,
+    _Outptr_result_buffer_(*BufferSize)
+                PVOID*      Buffer,
+    OUT         QWORD*      BufferSize
+    )
+{
+    PFILE_OBJECT pExecutableFile;
+    STATUS status;
+    FILE_INFORMATION fileInfo;
+    PVOID pBuffer;
+    QWORD bytesRead;
+
+    LOG_FUNC_START;
+
+    pExecutableFile = NULL;
+    status = STATUS_SUCCESS;
+    pBuffer = NULL;
+    memzero(&fileInfo, sizeof(FILE_INFORMATION));
+    bytesRead = 0;
+
+    __try
+    {
+        LOG_TRACE_USERMODE("Will open executable found at [%s]\n", FullPath);
+
+        status = IoCreateFile(&pExecutableFile,
+                              FullPath,
+                              FALSE,
+                              FALSE,
+                              FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_TRACE_USERMODE("[ERROR] IoCreateFile with status 0x%x\n", status);
+            __leave;
+        }
+
+        status = IoQueryInformationFile(pExecutableFile,
+                                        &fileInfo);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoQueryInformationFile", status);
+            __leave;
+        }
+
+        LOG_TRACE_USERMODE("Executable has %U bytes length, file object at 0x%X!\n", fileInfo.FileSize, pExecutableFile);
+        ASSERT(fileInfo.FileSize <= MAX_DWORD);
+
+        // Allocate a memory region backed up by a file and bring it eagerly into memory
+        pBuffer = VmmAllocRegionEx(NULL,
+                                   fileInfo.FileSize,
+                                   VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_NOT_LAZY,
+                                   PAGE_RIGHTS_READWRITE,
+                                   FALSE,
+                                   pExecutableFile,
+                                   NULL,
+                                   NULL,
+                                   NULL);
+        if (pBuffer == NULL)
+        {
+            LOG_FUNC_ERROR_ALLOC("VmmAllocRegionEx", fileInfo.FileSize);
+            __leave;
+        }
+
+        LOG_TRACE_USERMODE("Buffer allocated at 0x%X\n", pBuffer);
+    }
+    __finally
+    {
+        if (SUCCEEDED(status))
+        {
+            *BufferSize = fileInfo.FileSize;
+            *Buffer = pBuffer;
+        }
+        else
+        {
+            if (pExecutableFile != NULL)
+            {
+                IoCloseFile(pExecutableFile);
+                pExecutableFile = NULL;
+            }
+        }
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+void
+_UmApplicationDiscardKernelExecutableMapping(
+    IN          PVOID       ApplicationBuffer
+    )
+{
+    ASSERT(ApplicationBuffer != NULL);
+
+    LOG_TRACE_USERMODE("Will free memory region at 0x%X\n", ApplicationBuffer);
+
+    // We don't want to release the physical frames because they will still be used by
+    // the user-mode application
+    VmmFreeRegionEx(ApplicationBuffer, 0, VMM_FREE_TYPE_RELEASE, FALSE, NULL, NULL);
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000/src/vm_reservation_space.c b/src_proiect/HAL9000/src/vm_reservation_space.c
new file mode 100644
index 0000000..0ba08be
--- /dev/null
+++ b/src_proiect/HAL9000/src/vm_reservation_space.c
@@ -0,0 +1,1018 @@
+#include "HAL9000.h"
+#include "vm_reservation_space.h"
+#include "cpumu.h"
+#include "bitmap.h"
+#include "lock_common.h"
+#include "io.h"
+
+typedef enum _VMM_RESERVATION_STATE
+{
+    VmmReservationStateFree     = 0x0,
+    VmmReservationStateUsed     = 0x1,
+    VmmReservationStateLast     = 0x2,
+} VMM_RESERVATION_STATE;
+
+// A reservation is allocated each time a process reserves an area of
+// virtual memory. The commit bitmap is used to distinguish between the
+// reserved memory and the committed memory.
+typedef struct _VMM_RESERVATION
+{
+    // Starting addresses of the virtual memory allocation
+    PVOID                   StartVa;
+
+    // Size of the allocation
+    QWORD                   Size;
+
+    // The rights with which the memory was allocated
+    PAGE_RIGHTS             PageRights;
+
+    // The state of the this structure, this is used for finding the
+    // next free slot
+    VMM_RESERVATION_STATE   State;
+
+    // If TRUE memory will be set as strong uncacheable (UC)
+    // If FALSE the memory will be set as write back (WB)
+    BOOLEAN                 Uncacheable;
+
+    // Used for memory backed up by files
+    // Indicates the file which holds the data
+    PFILE_OBJECT            BackingFile;
+
+    // Describes which pages of the virtual memory reserved are actually
+    // committed, i.e. which are valid when a #PF occurs
+    BITMAP                  CommitBitmap;
+} VMM_RESERVATION, *PVMM_RESERVATION;
+
+// 20% Will go for the list of reservations
+// 80% Will go for the bitmaps describing the memory committed by those reservations
+#define RESERVATION_LIST_PERCENTAGE_IN_HUNDREDS     (20 * 100)
+
+//******************************************************************************
+// Function:     _VmFindFirstFreeReservation
+// Description:  Returns the first free reservation entry or NULL if the whole
+//               region was exhausted.
+// Returns:      PVMM_RESERVATION
+// Parameter:    void
+//******************************************************************************
+REQUIRES_SHARED_LOCK(ReservationSpace->ReservationLock)
+static
+PTR_SUCCESS
+PVMM_RESERVATION
+_VmFindFirstFreeReservation(
+    INOUT    PVMM_RESERVATION_SPACE  ReservationSpace
+    );
+
+//******************************************************************************
+// Function:     VmFindReservation
+// Description:  Checks if there is a reservation made for the address range
+//               received as input. If Reservation is non-NULL the pointer which
+//               describes the reservation is returned.
+// Returns:      STATUS - STATUS_SUCCESS or STATUS_ELEMENT_NOT_FOUND in case of
+//               failure
+// Parameter:    IN PVOID Address
+// Parameter:    IN QWORD Size
+// Parameter:    OUT_OPT_PTR PVMM_RESERVATION* Reservation
+//******************************************************************************
+REQUIRES_SHARED_LOCK(ReservationSpace->ReservationLock)
+static
+STATUS
+_VmFindReservation(
+    INOUT           PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN              PVOID                   Address,
+    IN              QWORD                   Size,
+    OUT_OPT_PTR     PVMM_RESERVATION*       Reservation
+    );
+
+//******************************************************************************
+// Function:     VmInitializeReservation
+// Description:  Initializes a reservation entry to describe the range of
+//               virtual addresses received as input.
+// Returns:      STATUS
+// Parameter:    IN PVOID Address
+// Parameter:    IN QWORD Size
+// Parameter:    IN PAGE_RIGHTS PageRights
+// Parameter:    OUT PVMM_RESERVATION VmmReservation
+//******************************************************************************
+REQUIRES_EXCL_LOCK(ReservationSpace->ReservationLock)
+static
+void
+_VmInitializeReservation(
+    INOUT   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject,
+    OUT     PVMM_RESERVATION        VmmReservation
+    );
+
+//******************************************************************************
+// Function:     VmChangeVaReservationState
+// Description:  Reserves and/or commits the virtual address range received as
+//               input. These addresses must be PAGE_SIZE aligned.
+// Returns:      STATUS
+// Parameter:    IN PVOID Address
+// Parameter:    IN QWORD Size
+// Parameter:    IN VMM_ALLOC_TYPE AllocationType
+// Parameter:    IN PAGE_RIGHTS PageRights
+//******************************************************************************
+REQUIRES_EXCL_LOCK(ReservationSpace->ReservationLock)
+static
+STATUS
+_VmChangeVaReservationState(
+    INOUT   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    IN      VMM_ALLOC_TYPE          AllocationType,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject
+    );
+
+// This function should be called only on a copy of the reservation to be uninitialized
+// i.e. the reservation will not be itself uninitialized, but only the fields described
+// and that's why it's ok to use a copy
+// NOTE: this method is applied so that we won't have to hold the reservation lock when
+// there is no good reason to do so
+static
+void
+_VmUninitializeReservation(
+    IN      PVMM_RESERVATION        VmmReservation
+    );
+
+//******************************************************************************
+// Function:     _VmCommitReservation
+// Description:  Commits a region of an already initialized reservation entry.
+// Returns:      void
+// Parameter:    IN PVOID Address
+// Parameter:    IN QWORD Size
+// Parameter:    INOUT PVMM_RESERVATION VmmReservation
+//******************************************************************************
+/// REQUIRES_EXCL_LOCK(m_vmmData.ReservationLock)
+static
+void
+_VmCommitReservation(
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    INOUT   PVMM_RESERVATION        VmmReservation
+    );
+
+/// REQUIRES_EXCL_LOCK(m_vmmData.ReservationLock)
+static
+void
+_VmDecommitReservation(
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    INOUT   PVMM_RESERVATION        VmmReservation
+    );
+
+//******************************************************************************
+// Function:     _VmIsVaCommited
+// Description:  Checks if a virtual address from within a reservation is
+//               commited or not.
+// Returns:      BOOLEAN
+// Parameter:    IN PVMM_RESERVATION VmmReservation
+// Parameter:    IN PVOID Address
+//******************************************************************************
+/// REQUIRES_SHARED_LOCK(m_vmmData.ReservationLock)
+static
+BOOLEAN
+_VmIsVaCommited(
+    IN      PVMM_RESERVATION        VmmReservation,
+    IN      PVOID                   Address
+    );
+
+
+// We have the following virtual memory layout
+// --------------------------------------------------------------------------------------------------------------
+// |          ReservationMetadataBaseAddress  | + ReservationMetadataSize or at ReservationBaseAddress          |
+// --------------------------------------------------------------------------------------------------------------
+// | ReservationList | Commit Bitmap Buffers  | VmmAllocRegionEx allocates Virtual Addresses starting from here |
+// --------------------------------------------------------------------------------------------------------------
+// |       20%       |          80%           |                                                                 |
+// --------------------------------------------------------------------------------------------------------------
+_No_competing_thread_
+void
+VmReservationSpaceInit(
+    IN          PVOID                   ReservationMetadataBaseAddress,
+    IN_OPT      PVOID                   ReservationBaseAddress,
+    IN          QWORD                   ReservationMetadataSize,
+    OUT         PVMM_RESERVATION_SPACE  ReservationSpace
+    )
+{
+    QWORD sizeForReservationList;
+
+    ASSERT(NULL != ReservationMetadataBaseAddress );
+    ASSERT(IsAddressAligned(ReservationMetadataBaseAddress, PAGE_SIZE));
+    ASSERT(ReservationMetadataSize != 0);
+    ASSERT(NULL != ReservationSpace);
+
+    LOG_TRACE_VMM("VMM reservation space base address at 0x%X\n", ReservationMetadataBaseAddress);
+
+    sizeForReservationList = CalculatePercentage(ReservationMetadataSize, RESERVATION_LIST_PERCENTAGE_IN_HUNDREDS);
+
+    ReservationSpace->ReservationList = (PVMM_RESERVATION) ReservationMetadataBaseAddress;
+    ReservationSpace->BitmapAddressStart = PtrOffset(ReservationMetadataBaseAddress, sizeForReservationList);
+    ReservationSpace->FreeBitmapAddress = ReservationSpace->BitmapAddressStart;
+
+    LOG_TRACE_VMM("Start of bitmap address: 0x%X\n", ReservationSpace->BitmapAddressStart);
+
+    ReservationSpace->FreeVirtualAddressPointer = (ReservationBaseAddress == NULL) ?
+                    (PVOID)PtrOffset(ReservationMetadataBaseAddress, ReservationMetadataSize) :
+                    ReservationBaseAddress;
+    ReservationSpace->StartOfVirtualAddressSpace = ReservationSpace->FreeVirtualAddressPointer;
+    ReservationSpace->ReservedAreaSize = ReservationMetadataSize;
+
+    LOG_TRACE_VMM("First virtual address is 0x%X\n", ReservationSpace->FreeVirtualAddressPointer);
+    LOG_TRACE_VMM("Start of reserved VA: 0x%X\n", ReservationMetadataBaseAddress );
+    LOG_TRACE_VMM("End of reserved VA: 0x%X\n", PtrOffset(ReservationMetadataBaseAddress, ReservationSpace->ReservedAreaSize));
+
+    LOG_TRACE_VMM("Reserved area size: %U KB\n", ReservationMetadataSize / KB_SIZE );
+
+    RwSpinlockInit(&ReservationSpace->ReservationLock);
+}
+
+_No_competing_thread_
+void
+VmReservationSpaceFinishInit(
+    INOUT       PVMM_RESERVATION_SPACE  ReservationSpace
+    )
+{
+    ASSERT(ReservationSpace != NULL);
+
+    ReservationSpace->ReservationList[0].State = VmmReservationStateLast;
+}
+
+REQUIRES_SHARED_LOCK(ReservationSpace->ReservationLock)
+static
+STATUS
+_VmFindReservation(
+    INOUT           PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN              PVOID                   Address,
+    IN              QWORD                   Size,
+    OUT_OPT_PTR     PVMM_RESERVATION*       Reservation
+    )
+{
+    STATUS status;
+    PVMM_RESERVATION pCurrentReservation;
+    BOOLEAN bFound;
+
+    ASSERT(ReservationSpace != NULL);
+    ASSERT(NULL != Address );
+    ASSERT(0 != Size );
+    ASSERT(Reservation != NULL);
+
+    status = STATUS_SUCCESS;
+    bFound = FALSE;
+
+    for(pCurrentReservation = ReservationSpace->ReservationList;
+            VmmReservationStateLast != pCurrentReservation->State &&
+            (PVOID) pCurrentReservation < ReservationSpace->BitmapAddressStart;
+        pCurrentReservation = pCurrentReservation + 1
+        )
+    {
+        if (VmmReservationStateFree == pCurrentReservation->State)
+        {
+            // skip free entries
+            continue;
+        }
+
+        if (CHECK_BOUNDS(Address, Size, pCurrentReservation->StartVa, pCurrentReservation->Size))
+        {
+            bFound = TRUE;
+            break;
+        }
+    }
+
+    if (!bFound)
+    {
+        LOG_TRACE_VMM("Could not find reservation for VA 0x%X of size 0x%X\n", Address, Size );
+        status = STATUS_ELEMENT_NOT_FOUND;
+    }
+    else
+    {
+        if (NULL != Reservation)
+        {
+            *Reservation = pCurrentReservation;
+        }
+    }
+
+    return status;
+}
+
+REQUIRES_EXCL_LOCK(ReservationSpace->ReservationLock)
+static
+void
+_VmInitializeReservation(
+    INOUT   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject,
+    OUT     PVMM_RESERVATION        VmmReservation
+    )
+{
+    QWORD bitmapSize;
+    QWORD noOfPages;
+
+    ASSERT(NULL != ReservationSpace);
+    ASSERT( NULL != Address );
+    ASSERT( 0 != Size );
+    ASSERT(IsAddressAligned(Address, PAGE_SIZE));
+    ASSERT(IsAddressAligned(Size, PAGE_SIZE));
+    ASSERT( NULL != VmmReservation );
+
+    noOfPages = Size / PAGE_SIZE;
+    bitmapSize = 0;
+
+    VmmReservation->State = VmmReservationStateUsed;
+    VmmReservation->StartVa = Address;
+    VmmReservation->Size = Size;
+    VmmReservation->PageRights = PageRights;
+    VmmReservation->Uncacheable = Uncacheable;
+    VmmReservation->BackingFile = FileObject;
+
+    LOG_TRACE_VMM("StartVa: 0x%X\n", Address );
+    LOG_TRACE_VMM("Size: 0x%X\n", Size );
+
+    ASSERT( noOfPages <= MAX_DWORD);
+
+    bitmapSize = BitmapPreinit( &VmmReservation->CommitBitmap, (DWORD) noOfPages );
+    ASSERT( 0 != bitmapSize );
+
+    LOG_TRACE_VMM("BitmapSize: 0x%X\n", bitmapSize );
+    LOG_TRACE_VMM("NoOfPages: 0x%X\n", noOfPages );
+    LOG_TRACE_VMM("Bitmap->BitCount: 0x%x\n", BitmapGetMaxElementCount(&VmmReservation->CommitBitmap) );
+
+    /// TODO: Check if there's a reason in which we advance the bitmap buffers from page to page - it seems rather
+    /// wasteful (most reservations will probably be under 8 pages - this could be described by a BYTE, not a PAGE)
+    /// One reason may be because at uninit the whole physical frame of memory will be released => there can't be two
+    /// bitmap buffers in the same PAGE - we need to analyze what is more wasteful (never being able to free some physical
+    /// frames or allocating a physical frame to described the buffer for each reservation)
+    /// Another suggestion would be for each VMM_RESERVATION structure to also have a QWORD which can be used as the
+    /// bitmap if the pages described fit in the buffer (i.e. 64 pages or 256KB which will cover 99,99% cases)
+    ASSERT( IsAddressAligned(ReservationSpace->FreeBitmapAddress, PAGE_SIZE ));
+    BitmapInit(&VmmReservation->CommitBitmap, ReservationSpace->FreeBitmapAddress );
+
+    // Make sure we're not exceeding our bitmap buffers VA space
+    ASSERT(CHECK_BOUNDS(ReservationSpace->FreeBitmapAddress,
+                        AlignAddressUpper(bitmapSize, PAGE_SIZE),
+                        ReservationSpace->ReservationList,
+                        ReservationSpace->ReservedAreaSize));
+
+    ReservationSpace->FreeBitmapAddress = ReservationSpace->FreeBitmapAddress + AlignAddressUpper( bitmapSize, PAGE_SIZE );
+}
+
+REQUIRES_EXCL_LOCK(ReservationSpace->ReservationLock)
+static
+STATUS
+_VmChangeVaReservationState(
+    INOUT   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    IN      VMM_ALLOC_TYPE          AllocationType,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject
+    )
+{
+    PVMM_RESERVATION pReservation;
+    STATUS status;
+
+    ASSERT(ReservationSpace != NULL);
+    ASSERT(NULL != Address);
+    ASSERT(0 != Size);
+
+    // We want only one of these 2 flags to be set
+    ASSERT((AllocationType == VMM_ALLOC_TYPE_RESERVE) ^ (AllocationType == VMM_ALLOC_TYPE_COMMIT));
+
+    ASSERT(IsAddressAligned(Address, PAGE_SIZE));
+    ASSERT(IsAddressAligned(Size, PAGE_SIZE));
+
+    status = STATUS_SUCCESS;
+    pReservation = NULL;
+
+    status = _VmFindReservation(ReservationSpace,
+                                Address,
+                                Size,
+                                &pReservation
+                                );
+    if (STATUS_ELEMENT_NOT_FOUND == status)
+    {
+        if (VMM_ALLOC_TYPE_RESERVE != AllocationType)
+        {
+            LOG_ERROR("There is no reservation found for address 0x%X\n", Address);
+            return STATUS_MEMORY_IS_NOT_RESERVED;
+        }
+        status = STATUS_SUCCESS;
+    }
+    else if (SUCCEEDED(status))
+    {
+        if (VMM_ALLOC_TYPE_RESERVE == AllocationType)
+        {
+            LOG_ERROR("Cannot reserve an already reserved virtual address 0x%X\n", Address);
+            return STATUS_MEMORY_ALREADY_RESERVED;
+        }
+    }
+
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_VmFindReservation", status );
+        return status;
+    }
+
+    switch (AllocationType)
+    {
+    case VMM_ALLOC_TYPE_RESERVE:
+        pReservation = _VmFindFirstFreeReservation(ReservationSpace);
+        ASSERT( NULL != pReservation );
+
+        // _VmChangeVaReservationState is called with the lock taken exclusively and no function to release
+        // the lock is called
+        // warning C26110: Caller failing to hold lock 'm_vmmData.ReservationLock' before calling function
+        // '_VmInitializeReservation'
+#pragma warning(suppress: 26110)
+        _VmInitializeReservation(ReservationSpace,
+                                Address,
+                                Size,
+                                PageRights,
+                                Uncacheable,
+                                FileObject,
+                                pReservation
+                                );
+        break;
+    case VMM_ALLOC_TYPE_COMMIT:
+        ASSERT( NULL != pReservation );
+
+        if (pReservation->PageRights != PageRights)
+        {
+            LOG_ERROR("Reservation rights 0x%x differ from the ones currently requested: 0x%x\n", pReservation->PageRights, PageRights );
+            return STATUS_MEMORY_CONFLICTING_ACCESS_RIGHTS;
+        }
+
+        if (pReservation->Uncacheable != Uncacheable)
+        {
+            LOG_ERROR("Caching 0x%x differs from the one currently requested: 0x%x\n", pReservation->Uncacheable, Uncacheable );
+            return STATUS_MEMORY_CONFLICTING_CACHEABILITY;
+        }
+
+        // _VmChangeVaReservationState is called with the lock taken exclusively and no function to release
+        // the lock is called
+        // warning C26110: Caller failing to hold lock 'm_vmmData.ReservationLock' before calling function
+        // '_VmCommitReservation'
+#pragma warning(suppress: 26110)
+        _VmCommitReservation(Address,
+                             Size,
+                             pReservation
+                             );
+        break;
+    default:
+        status = STATUS_UNSUPPORTED;
+    }
+
+    return status;
+}
+
+REQUIRES_SHARED_LOCK(ReservationSpace->ReservationLock)
+static
+PTR_SUCCESS
+PVMM_RESERVATION
+_VmFindFirstFreeReservation(
+    INOUT       PVMM_RESERVATION_SPACE  ReservationSpace
+    )
+{
+    PVMM_RESERVATION pResult;
+
+    ASSERT(ReservationSpace != NULL);
+
+    pResult = NULL;
+
+    for (PVMM_RESERVATION pCurrentReservation = ReservationSpace->ReservationList;
+        (PVOID)pCurrentReservation < ReservationSpace->BitmapAddressStart;
+         pCurrentReservation = pCurrentReservation + 1
+         )
+    {
+        if (VmmReservationStateFree == pCurrentReservation->State)
+        {
+            pResult = pCurrentReservation;
+
+            break;
+        }
+
+        if (VmmReservationStateLast == pCurrentReservation->State)
+        {
+            pCurrentReservation->State = VmmReservationStateFree;
+
+            // set the next reservation as the last one
+            (pCurrentReservation + 1)->State = VmmReservationStateLast;
+
+            pResult = pCurrentReservation;
+
+            break;
+        }
+    }
+
+    return pResult;
+}
+
+static
+void
+_VmUninitializeReservation(
+    IN      PVMM_RESERVATION        VmmReservation
+    )
+{
+    PVOID pBitmapBuffer;
+    DWORD bitmapSize;
+
+    ASSERT( NULL != VmmReservation );
+
+    pBitmapBuffer = VmmReservation->CommitBitmap.BitmapBuffer;
+    ASSERT(IsAddressAligned( pBitmapBuffer, PAGE_SIZE ));
+
+    bitmapSize = VmmReservation->CommitBitmap.BufferSize;
+
+    BitmapUninit(&VmmReservation->CommitBitmap);
+
+    MmuUnmapMemoryEx(pBitmapBuffer, bitmapSize, TRUE, NULL );
+
+    if (VmmReservation->BackingFile != NULL)
+    {
+        STATUS status;
+
+        // this is a memory mapped file
+        status = IoCloseFile(VmmReservation->BackingFile);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCloseFile", status);
+        }
+
+        VmmReservation->BackingFile = NULL;
+    }
+}
+
+/// REQUIRES_EXCL_LOCK(m_vmmData.ReservationLock)
+static
+void
+_VmCommitReservation(
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    INOUT   PVMM_RESERVATION        VmmReservation
+    )
+{
+    QWORD startIndex;
+    QWORD noOfPages;
+
+    ASSERT(NULL != Address);
+    ASSERT(0 != Size);
+    ASSERT(IsAddressAligned(Address, PAGE_SIZE));
+    ASSERT(IsAddressAligned(Size, PAGE_SIZE));
+
+    noOfPages = Size / PAGE_SIZE;
+    startIndex = PtrDiff(Address, VmmReservation->StartVa) / PAGE_SIZE;
+
+    ASSERT(noOfPages <= MAX_DWORD);
+    ASSERT(startIndex <= MAX_DWORD);
+
+    BitmapSetBits(&VmmReservation->CommitBitmap, (DWORD) startIndex, (DWORD) noOfPages );
+}
+
+/// REQUIRES_EXCL_LOCK(m_vmmData.ReservationLock)
+static
+void
+_VmDecommitReservation(
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    INOUT   PVMM_RESERVATION        VmmReservation
+    )
+{
+    QWORD startIndex;
+    QWORD noOfPages;
+
+    ASSERT(NULL != Address);
+    ASSERT(0 != Size);
+    ASSERT(IsAddressAligned(Address, PAGE_SIZE));
+    ASSERT(IsAddressAligned(Size, PAGE_SIZE));
+
+    noOfPages = Size / PAGE_SIZE;
+    startIndex = PtrDiff(Address, VmmReservation->StartVa) / PAGE_SIZE;
+
+    ASSERT(noOfPages <= MAX_DWORD);
+    ASSERT(startIndex <= MAX_DWORD);
+
+    BitmapClearBits(&VmmReservation->CommitBitmap, (DWORD)startIndex, (DWORD)noOfPages);
+}
+
+/// REQUIRES_SHARED_LOCK(m_vmmData.ReservationLock)
+static
+BOOLEAN
+_VmIsVaCommited(
+    IN      PVMM_RESERVATION        VmmReservation,
+    IN      PVOID                   Address
+    )
+{
+    QWORD pageNo;
+
+    ASSERT(NULL != VmmReservation);
+    ASSERT(NULL != Address);
+
+    pageNo = PtrDiff(Address, VmmReservation->StartVa) / PAGE_SIZE;
+
+    ASSERT(pageNo <= MAX_DWORD);
+
+    return BitmapGetBitValue(&VmmReservation->CommitBitmap, (DWORD) pageNo );
+}
+
+BOOLEAN
+VmReservationCanAddressBeAccessed(
+    INOUT                   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN                      PVOID                   FaultingAddress,
+    IN                      PAGE_RIGHTS             RightsRequested,
+    OUT                     PAGE_RIGHTS*            MemoryRights,
+    OUT                     BOOLEAN*                Uncacheable,
+    OUT_PTR_MAYBE_NULL      PFILE_OBJECT*           BackingFile,
+    OUT                     QWORD*                  FileOffset
+    )
+{
+    BOOLEAN bSolvedPageFault;
+    BOOLEAN reservationLockHeld;
+    INTR_STATE dummyState;
+    PAGE_RIGHTS pageRights;
+    BOOLEAN uncacheable;
+    PFILE_OBJECT pBackingFile;
+    QWORD fileOffset;
+    PCPU* pCpu;
+    STATUS status;
+
+    ASSERT(ReservationSpace != NULL);
+    ASSERT(MemoryRights != NULL);
+    ASSERT(Uncacheable != NULL);
+    ASSERT(BackingFile != NULL);
+    ASSERT(FileOffset != NULL);
+    ASSERT(INTR_OFF == CpuIntrGetState());
+
+    if (NULL == FaultingAddress)
+    {
+        return FALSE;
+    }
+
+    bSolvedPageFault = FALSE;
+    reservationLockHeld = FALSE;
+    pageRights = 0;
+    uncacheable = FALSE;
+    pBackingFile = NULL;
+    fileOffset = 0;
+    pCpu = GetCurrentPcpu();
+    status = STATUS_SUCCESS;
+
+    __try
+    {
+        // m_vmmData.ReservationList needs to be accessed with the lock taken only when actually
+        // accessing the elements of the array
+        // warning C26130: Missing annotation _Requires_lock_held_(m_vmmData.ReservationLock) or _No_competing_thread_
+        // at function 'VmmSolvePageFault'.Otherwise it could be a race condition.Variable 'm_vmmData.ReservationList'
+        // should be protected by lock 'm_vmmData.ReservationLock'
+#pragma warning(suppress: 26130)
+        if (CHECK_BOUNDS(FaultingAddress, 1, ReservationSpace->ReservationList, ReservationSpace->ReservedAreaSize))
+        {
+            LOG_TRACE_VMM("Faulting address 0x%X is in reservation area!\n", FaultingAddress);
+
+            // Check that the CPU is knowing what it's doing when accessing the reservation metadata
+            // We wouldn't want to receive a #PF in this area due to a corruption or due to a bad system architecture
+            if (NULL == pCpu || pCpu->VmmMemoryAccess)
+            {
+                // Also, definitely we don't want to execute code from here, so just drop it
+                bSolvedPageFault = !IsBooleanFlagOn(RightsRequested, PAGE_RIGHTS_EXECUTE);
+
+                // the pageRights variable is not actually used in case we can't solve the page fault, but still, for
+                // future compatibility it will be set to 0 in case we can't solve the #PF
+                pageRights = bSolvedPageFault ? PAGE_RIGHTS_READWRITE : 0;
+                __leave;
+            }
+        }
+        else
+        {
+            PVMM_RESERVATION pReservation;
+            BOOLEAN bIsVaCommited;
+
+            // another memory access
+            RwSpinlockAcquireShared(&ReservationSpace->ReservationLock, &dummyState);
+            reservationLockHeld = TRUE;
+
+            status = _VmFindReservation(ReservationSpace, FaultingAddress, 1, &pReservation);
+            if (!SUCCEEDED(status))
+            {
+                LOG_TRACE_VMM("_VmFindReservation", status);
+                __leave;
+            }
+
+            LOG_TRACE_VMM("Reservation VA: 0x%X\n", pReservation->StartVa);
+            LOG_TRACE_VMM("Reservation size: 0x%X\n", pReservation->Size);
+
+            bIsVaCommited = _VmIsVaCommited(pReservation, FaultingAddress);
+
+            pageRights = pReservation->PageRights;
+            uncacheable = pReservation->Uncacheable;
+
+            pBackingFile = pReservation->BackingFile;
+            if (pBackingFile != NULL)
+            {
+                fileOffset = AlignAddressLower(PtrDiff(FaultingAddress, pReservation->StartVa), PAGE_SIZE);
+            }
+
+            // to solve the page fault we must have the VA already committed
+            // and the page rights which were requested must be included in the
+            // reservation rights
+            bSolvedPageFault = bIsVaCommited && (IsBooleanFlagOn(pageRights, RightsRequested));
+
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (reservationLockHeld)
+        {
+            // This function checks at the beginning that it was called with the interrupts disabled,
+            // when we release the lock they will remain that way
+            RwSpinlockReleaseShared(&ReservationSpace->ReservationLock, INTR_OFF);
+            reservationLockHeld = FALSE;
+        }
+
+        if (bSolvedPageFault)
+        {
+            *MemoryRights = pageRights;
+            *Uncacheable = uncacheable;
+
+            *BackingFile = pBackingFile;
+            *FileOffset = fileOffset;
+        }
+    }
+
+    return bSolvedPageFault;
+}
+
+STATUS
+VmReservationSpaceAllocRegion(
+    IN      PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN_OPT  PVOID                   BaseAddress,
+    IN      QWORD                   Size,
+    IN      VMM_ALLOC_TYPE          AllocType,
+    IN      PAGE_RIGHTS             Rights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject,
+    OUT     PVOID*                  MappedAddress,
+    OUT     QWORD*                  MappedSize
+    )
+{
+    PVOID pBaseAddress;
+    INTR_STATE oldState;
+    STATUS status;
+    QWORD alignedSize;
+    PPCPU pCpu;
+
+    ASSERT(ReservationSpace != NULL);
+    ASSERT(Size != 0);
+    ASSERT(MappedAddress != NULL);
+    ASSERT(MappedSize != NULL);
+    ASSERT(IsFlagOn(AllocType, VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_RESERVE));
+
+    status = STATUS_SUCCESS;
+
+    if (NULL != BaseAddress)
+    {
+        // if we received BaseAddress as input we need
+        // to align the address
+        pBaseAddress = (PVOID)AlignAddressLower(BaseAddress, PAGE_SIZE);
+        alignedSize = AlignAddressUpper(Size + PtrDiff(BaseAddress, pBaseAddress), PAGE_SIZE);
+
+        if (pBaseAddress < ReservationSpace->StartOfVirtualAddressSpace)
+        {
+            LOG_ERROR("Cannot alloc virtual memory at 0x%X. Allocations start from 0x%X\n",
+                      pBaseAddress, ReservationSpace->StartOfVirtualAddressSpace);
+            return STATUS_MEMORY_CANNOT_BE_RESERVED;
+        }
+    }
+    else
+    {
+        // if we're generating the virtual address =>
+        // we can make sure it is aligned and we only
+        // need to align the size
+        alignedSize = AlignAddressUpper(Size, PAGE_SIZE);
+        pBaseAddress = VmReservationSpaceDetermineNextFreeVirtualAddress(ReservationSpace, alignedSize);
+    }
+
+    RwSpinlockAcquireExclusive(&ReservationSpace->ReservationLock, &oldState);
+    pCpu = GetCurrentPcpu();
+
+    if (NULL != pCpu)
+    {
+        pCpu->VmmMemoryAccess = TRUE;
+    }
+
+    __try
+    {
+        if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_RESERVE))
+        {
+            // reserve area
+            status = _VmChangeVaReservationState(ReservationSpace,
+                                                pBaseAddress,
+                                                alignedSize,
+                                                VMM_ALLOC_TYPE_RESERVE,
+                                                Rights,
+                                                Uncacheable,
+                                                FileObject
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_VmChangeVaReservationState", status);
+                __leave;
+            }
+        }
+        // these 2 are independent of each other and can be both active
+        // so no if else
+
+        if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_COMMIT))
+        {
+            // commit area
+            status = _VmChangeVaReservationState(ReservationSpace,
+                                                 pBaseAddress,
+                                                 alignedSize,
+                                                 VMM_ALLOC_TYPE_COMMIT,
+                                                 Rights,
+                                                 Uncacheable,
+                                                 FileObject
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_VmChangeVaReservationState", status);
+                __leave;
+            }
+        }
+    }
+    __finally
+    {
+        if (NULL != pCpu)
+        {
+            pCpu->VmmMemoryAccess = FALSE;
+        }
+        RwSpinlockReleaseExclusive(&ReservationSpace->ReservationLock, oldState);
+
+        if (SUCCEEDED(status))
+        {
+            *MappedAddress = pBaseAddress;
+            *MappedSize = alignedSize;
+        }
+    }
+
+    return status;
+}
+
+void
+VmReservationSpaceFreeRegion(
+    INOUT   PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN      PVOID                   Address,
+    _When_(VMM_FREE_TYPE_RELEASE == FreeType, IN_OPT)
+    _When_(VMM_FREE_TYPE_RELEASE != FreeType, IN)
+            QWORD                   Size,
+    IN      VMM_FREE_TYPE           FreeType,
+    OUT     PVOID*                  AlignedAddress,
+    OUT     QWORD*                  AlignedSize
+    )
+{
+    INTR_STATE oldState;
+    PPCPU pCpu;
+    STATUS status;
+    PVMM_RESERVATION pReservation;
+    BOOLEAN lockHeld;
+    PVOID alignedAddress;
+    QWORD alignedSize;
+
+    ASSERT(Address != NULL);
+    ASSERT(   (IsBooleanFlagOn(FreeType,VMM_FREE_TYPE_RELEASE) && (Size == 0))
+           || (IsBooleanFlagOn(FreeType,VMM_FREE_TYPE_DECOMMIT) && (Size != 0))
+            );
+    ASSERT(AlignedAddress != NULL);
+    ASSERT(AlignedSize != NULL);
+
+    status = STATUS_SUCCESS;
+    lockHeld = FALSE;
+    pReservation = NULL;
+    alignedAddress = NULL;
+    alignedSize = 0;
+
+    // they cannot both be used at the same time
+    ASSERT( IsBooleanFlagOn( FreeType, VMM_FREE_TYPE_RELEASE ) ^ IsBooleanFlagOn(FreeType, VMM_FREE_TYPE_DECOMMIT ));
+
+    RwSpinlockAcquireExclusive(&ReservationSpace->ReservationLock, &oldState);
+    pCpu = GetCurrentPcpu();
+    lockHeld = TRUE;
+
+    if (NULL != pCpu)
+    {
+        pCpu->VmmMemoryAccess = TRUE;
+    }
+
+    status = _VmFindReservation(ReservationSpace, Address, 1, &pReservation);
+    ASSERT_INFO(SUCCEEDED(status), "Cannot free reservation at address 0x%X\n", Address);
+
+    if (IsBooleanFlagOn(FreeType, VMM_FREE_TYPE_RELEASE))
+    {
+        VMM_RESERVATION reservationCopy;
+
+        // remove reservation
+        memcpy( &reservationCopy, pReservation, sizeof(VMM_RESERVATION));
+        memzero( pReservation, sizeof(VMM_RESERVATION));
+        pReservation->State = VmmReservationStateFree;
+
+        _Analysis_assume_lock_held_(ReservationSpace->ReservationLock);
+        RwSpinlockReleaseExclusive(&ReservationSpace->ReservationLock, oldState);
+        lockHeld = FALSE;
+
+        // we will want to ummap this memory
+        alignedAddress = reservationCopy.StartVa;
+        alignedSize = reservationCopy.Size;
+
+        // _VmUninitializeReservation actually acts on a copy
+        // of the reservation, this is so that we can call the function
+        // without holding the reservation lock
+        _VmUninitializeReservation(&reservationCopy);
+    }
+    else if (IsBooleanFlagOn(FreeType, VMM_FREE_TYPE_DECOMMIT))
+    {
+        // de-commit memory
+        alignedAddress = (PVOID)AlignAddressLower(Address, PAGE_SIZE);
+        alignedSize = AlignAddressUpper(Size + ((PBYTE)Address - (PBYTE)alignedAddress), PAGE_SIZE);
+
+        _VmDecommitReservation(alignedAddress, alignedSize, pReservation );
+    }
+
+    if (NULL != pCpu)
+    {
+        pCpu->VmmMemoryAccess = FALSE;
+    }
+    if (lockHeld)
+    {
+        RwSpinlockReleaseExclusive(&ReservationSpace->ReservationLock, oldState);
+    }
+
+    *AlignedAddress = alignedAddress;
+    *AlignedSize = alignedSize;
+}
+
+STATUS
+VmReservationReturnRightsForAddress(
+    IN      PVMM_RESERVATION_SPACE  ReservationSpace,
+    IN      PVOID                   Address,
+    IN      QWORD                   Size,
+    OUT     PAGE_RIGHTS*            Rights
+    )
+{
+    PVMM_RESERVATION pReservation;
+    INTR_STATE oldState;
+    STATUS status;
+    BOOLEAN bFullyCommited;
+
+    ASSERT(ReservationSpace != NULL);
+    ASSERT(Address != NULL);
+    ASSERT(Size != 0);
+    ASSERT(Rights != NULL);
+
+    status = STATUS_SUCCESS;
+    pReservation = NULL;
+    bFullyCommited = FALSE;
+
+    RwSpinlockAcquireShared(&ReservationSpace->ReservationLock, &oldState);
+
+    __try
+    {
+        status = _VmFindReservation(ReservationSpace, Address, Size, &pReservation);
+        if (!SUCCEEDED(status))
+        {
+            LOG_TRACE_VMM("_VmFindReservation", status);
+            __leave;
+        }
+
+        *Rights = pReservation->PageRights;
+
+        // Start with the assumption that the reservation is fully committed
+        bFullyCommited = TRUE;
+
+        /// TODO: This could be greatly optimized by both improving the bitmap implementation
+        /// or by checking the offset directly from here without calling the function
+        /// the function call implies an avoidable pointer subtraction and integer division
+        for (QWORD i = 0; i < Size; i += PAGE_SIZE)
+        {
+            if (!_VmIsVaCommited(pReservation, PtrOffset(Address,i)))
+            {
+                bFullyCommited = FALSE;
+                __leave;
+            }
+        }
+    }
+    __finally
+    {
+        RwSpinlockReleaseShared(&ReservationSpace->ReservationLock, oldState);
+    }
+
+    return bFullyCommited ? STATUS_SUCCESS : STATUS_MEMORY_IS_NOT_COMMITED;
+}
diff --git a/src_proiect/HAL9000/src/vmm.c b/src_proiect/HAL9000/src/vmm.c
new file mode 100644
index 0000000..db29675
--- /dev/null
+++ b/src_proiect/HAL9000/src/vmm.c
@@ -0,0 +1,1373 @@
+#include "HAL9000.h"
+#include "vmm.h"
+#include "synch.h"
+#include "pmm.h"
+#include "bitmap.h"
+#include "cpumu.h"
+#include "mtrr.h"
+#include "io.h"
+#include "vm_reservation_space.h"
+#include "thread_internal.h"
+#include "process_internal.h"
+#include "mdl.h"
+
+#define VMM_SIZE_FOR_RESERVATION_METADATA            (5*TB_SIZE)
+
+typedef struct _VMM_DATA
+{
+    VMM_RESERVATION_SPACE   VmmReservationSpace;
+
+
+    // Global paging related defines
+    // No matter what CR3 we're using the same WB and UC indexes will be used
+    BYTE                    WriteBackIndex;
+    BYTE                    UncacheableIndex;
+} VMM_DATA, *PVMM_DATA;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_PageWalkCallback)(
+    IN      PML4                    Cr3,
+    IN      PVOID                   PageTable,
+    IN      PVOID                   VirtualAddress,
+    IN      BYTE                    PageLevel,
+    IN_OPT  PVOID                   Context
+    );
+
+typedef FUNC_PageWalkCallback *PFUNC_PageWalkCallback;
+
+typedef struct _VMM_MAP_UNMAP_PAGE_WALK_CONTEXT
+{
+    // These fields are valid only when mapping memory in _VmMapPage
+    PPAGING_DATA                    PagingData;
+    PHYSICAL_ADDRESS                PhysicalAddressBase;
+    PVOID                           VirtualAddressBase;
+
+    PAGE_RIGHTS                     PageRights;
+    BOOLEAN                         Invalidate;
+    BOOLEAN                         Uncacheable;
+
+    // Valid only when unmapping memory in _VmUnmapPage;
+    BOOLEAN                         ReleaseMemory;
+} VMM_MAP_UNMAP_PAGE_WALK_CONTEXT, *PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT;
+
+// Used when determining the physical address, a/d bits and when resetting them
+typedef struct _VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT
+{
+    PHYSICAL_ADDRESS                PhysicalAddress;
+
+    // Returns the values of the A/D bits
+    BOOLEAN                         Accessed;
+    BOOLEAN                         Dirty;
+
+    // When set clears the A/D bits
+    BOOLEAN                         ClearAccessed;
+    BOOLEAN                         ClearDirty;
+} VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT, *PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT;
+
+static VMM_DATA m_vmmData;
+
+static
+void
+_VmSetupPagingStructure(
+    IN      PPAGING_DATA            PagingData,
+    IN      PVOID                   PagingStructure
+    );
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_VmDeterminePatIndices(
+    IN      QWORD                   PatValues,
+    OUT     PBYTE                   WbIndex,
+    OUT     PBYTE                   UcIndex
+    );
+
+static
+void
+_VmWalkPagingTables(
+    IN      PML4                        Cr3,
+    IN      PVOID                       BaseAddress,
+    IN      QWORD                       Size,
+    IN      PFUNC_PageWalkCallback      WalkCallback,
+    IN_OPT  PVOID                       Context
+    );
+
+static FUNC_PageWalkCallback            _VmMapPage;
+static FUNC_PageWalkCallback            _VmUnmapPage;
+static FUNC_PageWalkCallback            _VmRetrievePhyAccess;
+
+__forceinline
+static
+PHYSICAL_ADDRESS
+_VmRetrieveNextPhysicalAddressForPagingStructure(
+    IN      PPAGING_DATA            PagingData
+    )
+{
+    QWORD nextAddress;
+    DWORD currentIndex;
+
+    ASSERT( NULL != PagingData );
+
+    currentIndex = PagingData->CurrentIndex;
+
+    ASSERT( currentIndex < PagingData->NumberOfFrames );
+
+    nextAddress = (QWORD) PagingData->BasePhysicalAddress + currentIndex * PAGE_SIZE;
+    PagingData->CurrentIndex++;
+
+    return (PHYSICAL_ADDRESS) nextAddress;
+}
+
+__forceinline
+static
+BOOLEAN
+_VmIsKernelAddress(
+    IN      PVOID                   Address
+    )
+{
+    return IsBooleanFlagOn((QWORD)Address, (QWORD)1 << VA_HIGHEST_VALID_BIT);
+}
+
+__forceinline
+static
+BOOLEAN
+_VmIsKernelRange(
+    IN      PVOID                   Address,
+    IN      QWORD                   RangeSize
+    )
+{
+    ASSERT(RangeSize != 0);
+
+    // Check both ends, if one of the addresses is a KM address => game over :)
+    return _VmIsKernelAddress(Address) || _VmIsKernelAddress(PtrOffset(Address, RangeSize - 1));
+}
+
+__forceinline
+static
+PTR_SUCCESS
+PVMM_RESERVATION_SPACE
+_VmmRetrieveReservationSpaceForAddress(
+    IN      PVOID           VirtualAddress
+    )
+{
+    if (_VmIsKernelAddress(VirtualAddress))
+    {
+        return &m_vmmData.VmmReservationSpace;
+    }
+    else
+    {
+        PTHREAD pThread;
+
+        // by the time we have UM processes it's clear that we'll have a populated THREAD structure
+        // with a process to which it belongs
+
+        pThread = GetCurrentThread();
+
+        ASSERT(pThread != NULL);
+        ASSERT(pThread->Process != NULL);
+
+        return pThread->Process->VaSpace;
+    }
+}
+
+_No_competing_thread_
+void
+VmmPreinit(
+    void
+    )
+{
+    memzero(&m_vmmData, sizeof(VMM_DATA));
+}
+
+_No_competing_thread_
+STATUS
+VmmInit(
+    IN      PVOID                   BaseAddress
+    )
+{
+    if (BaseAddress == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    VmReservationSpaceInit(BaseAddress,
+                           NULL,
+                           VMM_SIZE_FOR_RESERVATION_METADATA,
+                           &m_vmmData.VmmReservationSpace);
+
+    return STATUS_SUCCESS;
+}
+
+PTR_SUCCESS
+PVOID
+VmmMapMemoryEx(
+    IN      PPAGING_DATA            PagingData,
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable
+    )
+{
+    PVOID pVirtualAddress;
+
+    if (PagingData == NULL)
+    {
+        return NULL;
+    }
+
+    if (!IsAddressAligned(PhysicalAddress, PAGE_SIZE))
+    {
+        return NULL;
+    }
+
+    if ((0 == Size) || (!IsAddressAligned(Size, PAGE_SIZE)))
+    {
+        return NULL;
+    }
+
+    pVirtualAddress = VmReservationSpaceDetermineNextFreeVirtualAddress(&m_vmmData.VmmReservationSpace, Size);
+    LOG_TRACE_VMM("Virtual address: 0x%X\n", pVirtualAddress);
+    ASSERT(IsAddressAligned(pVirtualAddress, PAGE_SIZE));
+
+    VmmMapMemoryInternal(PagingData,
+                         PhysicalAddress,
+                         Size,
+                         pVirtualAddress,
+                         PageRights,
+                         Invalidate,
+                         Uncacheable
+                         );
+
+    return pVirtualAddress;
+}
+
+void
+VmmMapMemoryInternal(
+    IN      PPAGING_DATA            PagingData,
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      QWORD                   Size,
+    IN      PVOID                   BaseAddress,
+    IN      PAGE_RIGHTS             PageRights,
+    IN      BOOLEAN                 Invalidate,
+    IN      BOOLEAN                 Uncacheable
+    )
+{
+    VMM_MAP_UNMAP_PAGE_WALK_CONTEXT ctx = { 0 };
+    PML4 cr3;
+
+    ASSERT(PagingData != NULL);
+    ASSERT(IsAddressAligned(PhysicalAddress, PAGE_SIZE));
+    ASSERT(0 != Size && IsAddressAligned(Size, PAGE_SIZE));
+
+    ctx.PagingData = PagingData;
+    ctx.PhysicalAddressBase = PhysicalAddress;
+    ctx.VirtualAddressBase = BaseAddress;
+    ctx.PageRights = PageRights;
+    ctx.Invalidate = Invalidate;
+    ctx.Uncacheable = Uncacheable;
+
+    cr3.Raw = (QWORD) PagingData->BasePhysicalAddress;
+
+    _VmWalkPagingTables(cr3,
+                        BaseAddress,
+                        Size,
+                        _VmMapPage,
+                        &ctx);
+}
+
+void
+VmmUnmapMemoryEx(
+    IN      PML4                    Cr3,
+    IN      PVOID                   VirtualAddress,
+    IN      QWORD                   Size,
+    IN      BOOLEAN                 ReleaseMemory
+    )
+{
+    VMM_MAP_UNMAP_PAGE_WALK_CONTEXT ctx = { 0 };
+
+    if ((NULL == VirtualAddress) || (!IsAddressAligned(VirtualAddress, PAGE_SIZE)))
+    {
+        return;
+    }
+
+    if ((0 == Size) || (!IsAddressAligned(Size, PAGE_SIZE)))
+    {
+        return;
+    }
+
+    ctx.ReleaseMemory = ReleaseMemory;
+
+    _VmWalkPagingTables(Cr3,
+                        VirtualAddress,
+                        Size,
+                        _VmUnmapPage,
+                        &ctx);
+}
+
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+VmmGetPhysicalAddressEx(
+    IN      PML4                    Cr3,
+    IN      PVOID                   VirtualAddress,
+    OUT_OPT BOOLEAN*                Accessed,
+    OUT_OPT BOOLEAN*                Dirty
+    )
+{
+    VMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT ctx = { 0 };
+
+    ASSERT(NULL != VirtualAddress);
+    ASSERT(IsAddressAligned(VirtualAddress, PAGE_SIZE));
+
+    ctx.ClearAccessed = Accessed != NULL;
+    ctx.ClearDirty = Dirty != NULL;
+
+    _VmWalkPagingTables(Cr3,
+                        VirtualAddress,
+                        PAGE_SIZE,
+                        _VmRetrievePhyAccess,
+                        &ctx
+                        );
+
+    if (Accessed != NULL)
+    {
+        *Accessed = ctx.Accessed;
+    }
+
+    if (Dirty != NULL)
+    {
+        *Dirty = ctx.Dirty;
+    }
+
+    return ctx.PhysicalAddress;
+}
+
+_No_competing_thread_
+STATUS
+VmmPreparePagingData(
+    void
+    )
+{
+    QWORD ia32PatValues;
+    BOOLEAN bResult;
+
+    ia32PatValues = 0;
+    bResult = FALSE;
+
+    ia32PatValues = __readmsr(IA32_PAT);
+    bResult = _VmDeterminePatIndices(ia32PatValues,
+                                     &m_vmmData.WriteBackIndex,
+                                     &m_vmmData.UncacheableIndex
+    );
+    if (!bResult)
+    {
+        LOG_ERROR("_VmDeterminePatIndices failed!\n");
+        return STATUS_PAT_LAYOUT_NOT_COMPATIBLE;
+    }
+
+    LOG("IA32_PAT: 0x%X\n", ia32PatValues);
+    LOG("WbIndex: %u\n", m_vmmData.WriteBackIndex);
+    LOG("UcIndex: %u\n", m_vmmData.UncacheableIndex);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+VmmSetupPageTables(
+    INOUT   PPAGING_DATA            PagingDataWhereToMap,
+    OUT     PPAGING_DATA            PagingData,
+    IN      PHYSICAL_ADDRESS        BasePhysicalAddress,
+    IN      DWORD                   FramesReserved,
+    IN      BOOLEAN                 KernelStructures
+    )
+{
+    DWORD sizeReservedForPagingStructures;
+    PVOID pBaseVirtualAddress;
+
+    ASSERT(PagingDataWhereToMap != NULL);
+    ASSERT(PagingData != NULL);
+    ASSERT(BasePhysicalAddress != NULL);
+    ASSERT(FramesReserved != 0);
+
+    pBaseVirtualAddress = (PVOID) PA2VA(BasePhysicalAddress);
+
+    ASSERT(FramesReserved <= MAX_DWORD / PAGE_SIZE);
+    sizeReservedForPagingStructures = FramesReserved * PAGE_SIZE;
+
+    // Current index should start at 1 because at 0 we have the CR3 (PML4 table address)
+    PagingData->CurrentIndex = 1;
+    PagingData->NumberOfFrames = FramesReserved;
+    PagingData->BasePhysicalAddress = BasePhysicalAddress;
+    PagingData->KernelSpace = KernelStructures;
+
+    LOG_TRACE_VMM("Will setup paging tables at physical address: 0x%X\n", PagingData->BasePhysicalAddress);
+    LOG_TRACE_VMM("BaseAddress: 0x%X\n", pBaseVirtualAddress);
+    LOG_TRACE_VMM("Size of paging tables: 0x%x\n", sizeReservedForPagingStructures);
+
+    // 1. We cannot zero the memory before mapping it (because it's not mapped)
+    // 2. We cannot zero it after it was mapped because we already have some entries
+    // populated to describe the mapped memory.
+
+    // This is not a problem anyway because when we setup a new paging structure we
+    // zero it anyway.
+
+    VmmMapMemoryInternal(PagingDataWhereToMap,
+                         PagingData->BasePhysicalAddress,
+                         sizeReservedForPagingStructures,
+                         pBaseVirtualAddress,
+                         PAGE_RIGHTS_READWRITE,
+                         TRUE,
+                         FALSE
+                         );
+    LOG_TRACE_VMM("VmmMapMemoryInternal finished\n");
+
+    if (PagingDataWhereToMap != PagingData)
+    {
+        // Zero the newly mapped PML4 if we didn't map it in it's own
+        // paging structures - else it would already be populated
+        memzero(pBaseVirtualAddress, PAGE_SIZE);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+void
+VmmChangeCr3(
+    IN      PHYSICAL_ADDRESS        Pml4Base,
+    IN_RANGE(PCID_FIRST_VALID_VALUE, PCID_TOTAL_NO_OF_VALUES - 1)
+            PCID                    Pcid,
+    IN      BOOLEAN                 Invalidate
+    )
+{
+    ASSERT(IsAddressAligned(Pml4Base,PAGE_SIZE));
+    ASSERT(PCID_IS_VALID(Pcid));
+
+    // Intel System Programming Manual Vol 3C
+    // Section 4.10.4.1 Operations that Invalidate TLBs and Paging-Structure Caches
+
+    // If CR4.PCIDE = 1 and bit 63 of the instructions source operand is 0, the instruction invalidates all TLB
+    // entries associated with the PCID specified in bits 11:0 of the instructions source operand except those for
+    // global pages.It also invalidates all entries in all paging - structure caches associated with that PCID.It is not
+    // required to invalidate entries in the TLBs and paging - structure caches that are associated with other PCIDs.
+
+    // If CR4.PCIDE = 1 and bit 63 of the instructions source operand is 1, the instruction is not required to
+    // invalidate any TLB entries or entries in paging - structure caches.
+    __writecr3((Invalidate ? 0 : MOV_TO_CR3_DO_NOT_INVALIDATE_PCID_MAPPINGS) | (QWORD)Pml4Base | Pcid);
+
+    /// TODO: This should be broadcast on all CPUs to invalidate their mappings for PCID Pcid
+}
+
+_No_competing_thread_
+void
+VmmInitReservationSystem(
+    void
+    )
+{
+    VmReservationSpaceFinishInit(&m_vmmData.VmmReservationSpace);
+}
+
+static
+void
+_VmmMapDescribedRegion(
+    IN      PVOID                   BaseAddress,
+    IN      PMDL                    Mdl,
+    IN      PAGE_RIGHTS             Rights,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    )
+{
+    QWORD currentOffset = 0;
+
+    ASSERT(BaseAddress != NULL);
+    ASSERT(IsAddressAligned(BaseAddress, PAGE_SIZE));
+    ASSERT(Mdl != NULL);
+
+    for (DWORD i = 0;
+         i < MdlGetNumberOfPairs(Mdl);
+         ++i)
+    {
+        PHYSICAL_ADDRESS alignedPa;
+        QWORD alignedPaSize;
+        PMDL_TRANSLATION_PAIR pMdlPair;
+
+        pMdlPair = MdlGetTranslationPair(Mdl, i);
+
+        alignedPa = (PHYSICAL_ADDRESS)AlignAddressLower(pMdlPair->Address, PAGE_SIZE);
+        alignedPaSize = AlignAddressUpper(pMdlPair->NumberOfBytes + AddressOffset(pMdlPair->Address, PAGE_SIZE), PAGE_SIZE);
+
+        MmuMapMemoryInternal(alignedPa,
+                             alignedPaSize,
+                             Rights,
+                             PtrOffset(BaseAddress, currentOffset),
+                             FALSE,
+                             FALSE,
+                             PagingData);
+
+        // advance to the next VA->PA physical mapping
+        currentOffset += alignedPaSize;
+    }
+}
+
+PTR_SUCCESS
+PVOID
+VmmAllocRegionEx(
+    IN_OPT  PVOID                   BaseAddress,
+    IN      QWORD                   Size,
+    IN      VMM_ALLOC_TYPE          AllocType,
+    IN      PAGE_RIGHTS             Rights,
+    IN      BOOLEAN                 Uncacheable,
+    IN_OPT  PFILE_OBJECT            FileObject,
+    IN_OPT  PVMM_RESERVATION_SPACE  VaSpace,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData,
+    IN_OPT  PMDL                    Mdl
+    )
+{
+    PVOID pBaseAddress;
+    QWORD alignedSize;
+    STATUS status;
+    PVMM_RESERVATION_SPACE pVaSpace;
+    PHYSICAL_ADDRESS pa;
+
+    ASSERT(Size != 0);
+
+    // We need at least one of these flags set, else we have nothing to do
+    ASSERT(IsFlagOn(AllocType, VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_RESERVE));
+
+    // If the MDL is non-NULL we must have the VMM_ALLOC_TYPE_NOT_LAZY set,
+    // we don't have an implementation for allocating a VA lazily for memory ranges described by a MDL
+    ASSERT(Mdl == NULL || IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY));
+
+    // We currently do not support mapping zero pages
+    ASSERT(!IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_ZERO));
+
+    // We cannot have both the Mdl and the FileObject non-NULL, the region either is already backed up by some physical
+    // frames or it is backed up by a file, or it is not backed up by anything
+    ASSERT((Mdl == NULL) || (FileObject == NULL));
+
+    status = STATUS_SUCCESS;
+    pBaseAddress = NULL;
+    pa = NULL;
+    alignedSize = 0;
+
+    pVaSpace = (VaSpace == NULL) ? &m_vmmData.VmmReservationSpace : VaSpace;
+    ASSERT(pVaSpace != NULL);
+
+    __try
+    {
+        status = VmReservationSpaceAllocRegion(pVaSpace,
+                                               BaseAddress,
+                                               Size,
+                                               AllocType,
+                                               Rights,
+                                               Uncacheable,
+                                               FileObject,
+                                               &pBaseAddress,
+                                               &alignedSize);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("VmReservationSpaceAllocRegion", status);
+            __leave;
+        }
+        ASSERT(NULL != pBaseAddress);
+
+        if (IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_NOT_LAZY))
+        {
+            ASSERT(IsBooleanFlagOn(AllocType, VMM_ALLOC_TYPE_COMMIT));
+
+            if (Mdl != NULL)
+            {
+                // If we received a MDL as a parameter => we already have some initialized physical frames
+                // which we want to map to pBaseAddress
+                ASSERT(Mdl->ByteCount <= alignedSize);
+
+                _VmmMapDescribedRegion(pBaseAddress, Mdl, Rights, PagingData);
+            }
+            else
+            {
+                // This area is not described by an MDL, we need to reserve it now
+                // We will ask for a continuous number of frames, we have no way of
+                // asking for discontinuous frames - even if we call the function multiple
+                // times with 1 frame we probably will receive a continuous mapping because
+                // there is noone else requesting physical frames in the meantime
+
+                ASSERT(alignedSize / PAGE_SIZE <= MAX_DWORD);
+                DWORD noOfFrames = (DWORD)(alignedSize / PAGE_SIZE);
+
+                pa = PmmReserveMemory(noOfFrames);
+                if (NULL == pa)
+                {
+                    LOG_ERROR("PmmReserverMemory failed!\n");
+                    __leave;
+                }
+
+                MmuMapMemoryInternal(pa,
+                                     alignedSize,
+                                     Rights,
+                                     pBaseAddress,
+                                     TRUE,
+                                     Uncacheable,
+                                     PagingData
+                );
+
+                // Check if the mapping is backed up by a file
+                if (FileObject != NULL)
+                {
+                    QWORD fileOffset;
+                    QWORD bytesRead;
+
+                    // make sure we read from the start of the file
+                    fileOffset = 0;
+
+                    status = IoReadFile(FileObject,
+                                        alignedSize,
+                                        &fileOffset,
+                                        pBaseAddress,
+                                        &bytesRead);
+                    if (!SUCCEEDED(status))
+                    {
+                        LOG_FUNC_ERROR("IoReadFile", status);
+                        __leave;
+                    }
+
+                    LOG_TRACE_VMM("File size is 0x%X, bytes read are 0x%X\n", alignedSize, bytesRead);
+
+                    // zero the rest of the file
+                    ASSERT(alignedSize - bytesRead <= MAX_DWORD);
+
+                    // memzero the rest of the allocation (in case the size of the allocation is greater than the
+                    // size of the file)
+                    memzero(PtrOffset(pBaseAddress, bytesRead), (DWORD)(alignedSize - bytesRead));
+                }
+            }
+        }
+
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            LOG_ERROR("We failed with status 0x%x\n", status);
+
+            if (pBaseAddress != NULL)
+            {
+                PVOID pAlignedAddress;
+
+                VmReservationSpaceFreeRegion(pVaSpace,
+                                             pBaseAddress,
+                                             0,
+                                             VMM_FREE_TYPE_RELEASE,
+                                             &pAlignedAddress,
+                                             &alignedSize
+                                             );
+                ASSERT(pAlignedAddress == pBaseAddress);
+                pBaseAddress = NULL;
+
+                if (pa != NULL)
+                {
+                    MmuUnmapMemoryEx(pAlignedAddress, (DWORD) alignedSize, TRUE, PagingData);
+                    pa = NULL;
+                }
+            }
+            ASSERT(pa == NULL);
+        }
+        else
+        {
+            if (IsBooleanFlagOn(Rights, PAGE_RIGHTS_EXECUTE | PAGE_RIGHTS_WRITE))
+            {
+                LOG_WARNING("Successfully mapped W+X memory at 0x%X of size 0x%X\n",
+                            pBaseAddress, alignedSize);
+            }
+        }
+    }
+
+    return pBaseAddress;
+}
+
+void
+VmmFreeRegionEx(
+    IN      PVOID                   Address,
+    _When_(VMM_FREE_TYPE_RELEASE == FreeType, _Reserved_)
+    _When_(VMM_FREE_TYPE_RELEASE != FreeType, IN)
+            QWORD                   Size,
+    IN      VMM_FREE_TYPE           FreeType,
+    IN      BOOLEAN                 Release,
+    IN_OPT  PVMM_RESERVATION_SPACE  VaSpace,
+    IN_OPT  PPAGING_LOCK_DATA       PagingData
+    )
+{
+    PVOID alignedAddress;
+    QWORD alignedSize;
+
+    ASSERT(Address != NULL);
+    ASSERT(IsBooleanFlagOn( FreeType, VMM_FREE_TYPE_RELEASE ) ^ IsBooleanFlagOn(FreeType, VMM_FREE_TYPE_DECOMMIT ));
+    ASSERT((IsBooleanFlagOn(FreeType, VMM_FREE_TYPE_RELEASE) && (Size == 0))
+           || (IsBooleanFlagOn(FreeType, VMM_FREE_TYPE_DECOMMIT) && (Size != 0)));
+
+    alignedAddress = NULL;
+    alignedSize = 0;
+
+    VmReservationSpaceFreeRegion((VaSpace == NULL) ? &m_vmmData.VmmReservationSpace : VaSpace,
+                                 Address,
+                                 Size,
+                                 FreeType,
+                                 &alignedAddress,
+                                 &alignedSize);
+
+    if (IsFlagOn(FreeType, VMM_FREE_TYPE_DECOMMIT | VMM_FREE_TYPE_RELEASE ))
+    {
+        ASSERT( NULL != alignedAddress);
+        ASSERT( 0 != alignedSize);
+
+        LOG_TRACE_VMM("Will free %U bytes of memory starting from VA: 0x%X\n", alignedSize, alignedAddress );
+
+        // un-map memory
+        // this must be called without the reservation lock taken
+        MmuUnmapMemoryEx(alignedAddress,
+                         alignedSize,
+                         Release,
+                         PagingData);
+    }
+}
+
+BOOLEAN
+VmmSolvePageFault(
+    IN      PVOID                   FaultingAddress,
+    IN      PAGE_RIGHTS             RightsRequested,
+    IN      PPAGING_LOCK_DATA       PagingData
+    )
+{
+    BOOLEAN bSolvedPageFault;
+    BOOLEAN bAccessValid;
+    STATUS status;
+    PPCPU pCpu;
+    PAGE_RIGHTS pageRights;
+    BOOLEAN uncacheable;
+    PFILE_OBJECT pBackingFile;
+    QWORD fileOffset;
+    BOOLEAN bKernelAddress;
+    QWORD bytesReadFromFile;
+
+    ASSERT(INTR_OFF == CpuIntrGetState());
+    ASSERT(PagingData != NULL);
+
+    // we will certainly not use the first virtual page of memory
+    if (NULL == (PVOID) AlignAddressLower(FaultingAddress, PAGE_SIZE))
+    {
+        return FALSE;
+    }
+
+    bKernelAddress = _VmIsKernelAddress(FaultingAddress);
+
+    if (bKernelAddress && !PagingData->Data.KernelSpace)
+    {
+        LOG_TRACE_VMM("User code should not access KM pages!\n");
+        return FALSE;
+    }
+    else if (!bKernelAddress && PagingData->Data.KernelSpace)
+    {
+        LOG_ERROR("Kernel code should not access UM pages!\n");
+        return FALSE;
+    }
+
+    bSolvedPageFault = FALSE;
+    bAccessValid = FALSE;
+    status = STATUS_SUCCESS;
+    pCpu = GetCurrentPcpu();
+    pageRights = 0;
+    uncacheable = FALSE;
+    pBackingFile = NULL;
+    fileOffset = 0;
+    bytesReadFromFile = 0;
+
+    // See if the VA is already committed and retrieve its description (the page rights with which it was mapped,
+    // cacheability and for memory backed by files the FILE_OBJECT and corresponding offset in file)
+    bAccessValid = VmReservationCanAddressBeAccessed(_VmmRetrieveReservationSpaceForAddress(FaultingAddress),
+                                                     FaultingAddress,
+                                                     RightsRequested,
+                                                     &pageRights,
+                                                     &uncacheable,
+                                                     &pBackingFile,
+                                                     &fileOffset);
+
+    __try
+    {
+        if (bAccessValid)
+        {
+            PHYSICAL_ADDRESS pa;
+            PVOID alignedAddress;
+
+            // solve #PF
+
+            // 1. Reserve one frame of physical memory
+            pa = PmmReserveMemory(1);
+            ASSERT(NULL != pa);
+
+            alignedAddress = (PVOID)AlignAddressLower(FaultingAddress, PAGE_SIZE);
+
+            // 2. Map the aligned faulting address to the newly acquired physical frame
+            MmuMapMemoryInternal(pa,
+                                 PAGE_SIZE,
+                                 pageRights,
+                                 alignedAddress,
+                                 TRUE,
+                                 uncacheable,
+                                 PagingData
+                                 );
+
+            // 3. If the virtual address is backed by a file read its contents
+            if (pBackingFile != NULL)
+            {
+                LOGL("Will read data from file 0x%X and offset 0x%X\n", pBackingFile, fileOffset);
+
+                status = IoReadFile(pBackingFile,
+                                    PAGE_SIZE,
+                                    &fileOffset,
+                                    alignedAddress,
+                                    &bytesReadFromFile);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("IoReadFile", status);
+                    __leave;
+                }
+
+                LOGL("Bytes read 0x%X\n", bytesReadFromFile);
+                ASSERT(bytesReadFromFile <= PAGE_SIZE);
+            }
+
+            // 4. Zero the rest of the memory (in case the remaining file size was smaller than a page
+            /// TODO: check if this is really necessary (we have a ZERO worker thread already!)
+            if (bytesReadFromFile != PAGE_SIZE)
+            {
+                /// TODO: Check if we really need to remove the WP (I'd rather not do this)
+                /// According to the Intel manual the WP flag has nothing to do with accessing UM pages
+                /// It is more generic, if WP is set => supervisor accesses can write to any virtual address
+                /// even if it is read-only
+                __writecr0(__readcr0() & ~CR0_WP);
+                memzero(PtrOffset(alignedAddress, bytesReadFromFile), PAGE_SIZE - (DWORD)bytesReadFromFile);
+                __writecr0(__readcr0() | CR0_WP);
+            }
+
+            if (NULL != pCpu)
+            {
+                // solved another page fault :)
+                pCpu->PageFaults = pCpu->PageFaults + 1;
+            }
+            bSolvedPageFault = TRUE;
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return bSolvedPageFault;
+}
+
+PVMM_RESERVATION_SPACE
+VmmRetrieveReservationSpaceForSystemProcess(
+    void
+    )
+{
+    return &m_vmmData.VmmReservationSpace;
+}
+
+STATUS
+VmmCreateVirtualAddressSpace(
+    OUT_PTR struct _VMM_RESERVATION_SPACE** ReservationSpace,
+    IN      QWORD                           ReservationMetadataSize,
+    IN      PVOID                           StartOfVirtualAddressSpace
+    )
+{
+    STATUS status;
+    PVMM_RESERVATION_SPACE pProcessVaHeader;
+    PVOID pReservationMetadataStart;
+
+    if (ReservationSpace == NULL)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (ReservationSpace == 0)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (StartOfVirtualAddressSpace == NULL)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    status = STATUS_SUCCESS;
+    pProcessVaHeader = NULL;
+    pReservationMetadataStart = NULL;
+
+    __try
+    {
+        pProcessVaHeader = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(VMM_RESERVATION_SPACE), HEAP_PROCESS_TAG, 0);
+        if (pProcessVaHeader == NULL)
+        {
+            status = STATUS_INSUFFICIENT_MEMORY;
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(VMM_RESERVATION_SPACE));
+            __leave;
+        }
+
+        pReservationMetadataStart = VmmAllocRegionEx(NULL,
+                                                     ReservationMetadataSize,
+                                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                                     PAGE_RIGHTS_READWRITE,
+                                                     FALSE,
+                                                     NULL,
+                                                     NULL,
+                                                     NULL,
+                                                     NULL);
+        if (pReservationMetadataStart == NULL)
+        {
+            status = STATUS_INSUFFICIENT_MEMORY;
+            LOG_FUNC_ERROR_ALLOC("VmmAllocRegionEx", ReservationMetadataSize);
+            __leave;
+        }
+
+        VmReservationSpaceInit(pReservationMetadataStart,
+                               StartOfVirtualAddressSpace,
+                               ReservationMetadataSize,
+                               pProcessVaHeader);
+        VmReservationSpaceFinishInit(pProcessVaHeader);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (pReservationMetadataStart != NULL)
+            {
+                VmmFreeRegion(pReservationMetadataStart, 0, VMM_FREE_TYPE_RELEASE);
+                pReservationMetadataStart = NULL;
+            }
+
+            if (pProcessVaHeader != NULL)
+            {
+                ExFreePoolWithTag(pProcessVaHeader, HEAP_PROCESS_TAG);
+                pProcessVaHeader = NULL;
+            }
+        }
+        else
+        {
+            *ReservationSpace = pProcessVaHeader;
+        }
+    }
+
+    return status;
+}
+
+void
+VmmDestroyVirtualAddressSpace(
+    _Pre_valid_ _Post_ptr_invalid_
+        struct _VMM_RESERVATION_SPACE*      ReservationSpace
+    )
+{
+    ASSERT(ReservationSpace != NULL);
+
+    if (ReservationSpace->ReservationList != NULL)
+    {
+        /// TODO: go through each reservation belonging to the process and
+        /// release all the physical frames used (else we have physical memory leaks :) - not fun)
+
+        VmmFreeRegion(ReservationSpace->ReservationList, 0, VMM_FREE_TYPE_RELEASE);
+        ReservationSpace->ReservationList = NULL;
+    }
+
+    ExFreePoolWithTag(ReservationSpace, HEAP_PROCESS_TAG);
+}
+
+STATUS
+VmmIsBufferValid(
+    IN          PVOID                               Buffer,
+    IN          QWORD                               BufferSize,
+    IN          PAGE_RIGHTS                         RightsRequested,
+    IN          PVMM_RESERVATION_SPACE              ReservationSpace,
+    IN          BOOLEAN                             KernelAccess
+    )
+{
+    STATUS status;
+    PAGE_RIGHTS rightsGranted;
+
+    ASSERT(Buffer != NULL);
+    ASSERT(BufferSize != 0);
+    ASSERT(ReservationSpace != NULL);
+
+    if (!KernelAccess && _VmIsKernelRange(Buffer, BufferSize))
+    {
+        // We shouldn't be accessing from UM kernel buffers :)
+        LOG_TRACE_VMM("Usermode code should not be accessing kernel memory between 0x%X -> 0x%X\n",
+                  BufferSize, PtrOffset(BufferSize, BufferSize - 1));
+        return STATUS_MEMORY_PREVENTS_USERMODE_ACCESS;
+    }
+
+    status = VmReservationReturnRightsForAddress(ReservationSpace,
+                                                 Buffer,
+                                                 BufferSize,
+                                                 &rightsGranted);
+    if (!SUCCEEDED(status))
+    {
+        LOG_TRACE_VMM("VmReservationReturnRightsForAddress", status);
+        return status;
+    }
+
+    if (!IsBooleanFlagOn(rightsGranted, RightsRequested))
+    {
+        LOG_ERROR("The VA space has paging rights of 0x%x, but we requested 0x%x. Will certainly not allow!\n",
+                  rightsGranted, RightsRequested);
+        return STATUS_MEMORY_INSUFFICIENT_ACCESS_RIGHTS;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+void
+_VmSetupPagingStructure(
+    IN      PPAGING_DATA            PagingData,
+    IN      PVOID                   PagingStructure
+    )
+{
+    PHYSICAL_ADDRESS physicalAddr;
+    PTE_MAP_FLAGS flags = { 0 };
+
+    ASSERT(NULL != PagingData);
+    ASSERT(NULL != PagingStructure);
+
+    // request 1 frame of physical memory
+    physicalAddr = _VmRetrieveNextPhysicalAddressForPagingStructure(PagingData);
+    flags.Writable = TRUE;
+    flags.Executable = TRUE;
+    flags.PagingStructure = TRUE;
+    flags.UserAccess = !PagingData->KernelSpace;
+
+    // for paging structure PA2VA can always be used :)
+    PteMap(PagingStructure, physicalAddr, flags);
+
+    PageInvalidateTlb((PVOID)PA2VA(physicalAddr));
+
+    // Zero the current paging structure entry => we cannot get stray memory accesses
+    memzero((PVOID)PA2VA(physicalAddr), PAGE_SIZE);
+}
+
+static
+BOOL_SUCCESS
+BOOLEAN
+_VmDeterminePatIndices(
+    IN      QWORD                   PatValues,
+    OUT     PBYTE                   WbIndex,
+    OUT     PBYTE                   UcIndex
+    )
+{
+    BOOLEAN bFoundWb;
+    BOOLEAN bFoundUc;
+    PBYTE patArrayValue;
+
+    ASSERT( NULL != WbIndex );
+    ASSERT( NULL != UcIndex );
+
+    bFoundWb = bFoundUc = FALSE;
+    patArrayValue = (PBYTE) &PatValues;
+
+    for (BYTE i = 0; i < sizeof(QWORD); ++i)
+    {
+        if (MemoryCachingStrongUncacheable == patArrayValue[i] )
+        {
+            if (!bFoundUc)
+            {
+                bFoundUc = TRUE;
+                *UcIndex = i;
+            }
+        }
+        else if (MemoryCachingWriteBack == patArrayValue[i])
+        {
+            if( !bFoundWb)
+            {
+                bFoundWb = TRUE;
+                *WbIndex = i;
+            }
+        }
+    }
+
+    return bFoundWb && bFoundUc;
+}
+
+static
+void
+_VmWalkPagingTables(
+    IN      PML4                        Cr3,
+    IN      PVOID                       BaseAddress,
+    IN      QWORD                       Size,
+    IN      PFUNC_PageWalkCallback      WalkCallback,
+    IN_OPT  PVOID                       Context
+    )
+{
+    // we may need to map multiple pages => we iterate until we map all the
+    // addresses
+    for(QWORD offset = 0;
+        offset < Size;
+        offset = offset + PAGE_SIZE)
+    {
+        WORD offsets[4];
+        BOOLEAN bContinue;
+        PVOID currentVa;
+        PHYSICAL_ADDRESS curStructPa;
+
+        // address to map
+        currentVa = PtrOffset(BaseAddress, offset);
+
+        offsets[0] = MASK_PML4_OFFSET(currentVa);
+        offsets[1] = MASK_PDPTE_OFFSET(currentVa);
+        offsets[2] = MASK_PDE_OFFSET(currentVa);
+        offsets[3] = MASK_PTE_OFFSET(currentVa);
+
+        bContinue = FALSE;
+
+        curStructPa = (PHYSICAL_ADDRESS)(Cr3.Pcide.PhysicalAddress << SHIFT_FOR_PHYSICAL_ADDR);
+
+        for (BYTE i = PAGING_TABLES_FIRST_LEVEL;
+             i <= PAGING_TABLES_LAST_LEVEL;
+             ++i)
+        {
+            PT_ENTRY* pCurrentEntry;
+
+            pCurrentEntry = (PT_ENTRY*)PA2VA(curStructPa);
+
+            pCurrentEntry = &(pCurrentEntry[offsets[i-1]]);
+
+            if (!WalkCallback(Cr3,
+                              pCurrentEntry,
+                              currentVa,
+                              i,
+                              Context))
+            {
+                bContinue = TRUE;
+                break;
+            }
+
+            if (i != PAGING_TABLES_LAST_LEVEL)
+            {
+                ASSERT(((PD_ENTRY_PT*)pCurrentEntry)->PageSize == 0);
+            }
+
+            curStructPa = PteGetPhysicalAddress(pCurrentEntry);
+        }
+
+        if (bContinue)
+        {
+            continue;
+        }
+    }
+}
+
+static
+BOOLEAN
+(__cdecl _VmMapPage)(
+    IN      PML4                    Cr3,
+    IN      PVOID                   PageTable,
+    IN      PVOID                   VirtualAddress,
+    IN      BYTE                    PageLevel,
+    IN_OPT  PVOID                   Context
+    )
+{
+    PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT pPageContext;
+
+    UNREFERENCED_PARAMETER(Cr3);
+
+    ASSERT(PageTable != NULL);
+    ASSERT(VirtualAddress != NULL);
+    ASSERT(PAGING_TABLES_FIRST_LEVEL <= PageLevel && PageLevel <= PAGING_TABLES_LAST_LEVEL);
+
+    pPageContext = (PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT) Context;
+    ASSERT(pPageContext != NULL);
+
+    if (PteIsPresent(PageTable) &&
+        !((PageLevel == PAGING_TABLES_LAST_LEVEL) && pPageContext->Invalidate))
+    {
+        return TRUE;
+    }
+
+    if (PageLevel == PAGING_TABLES_LAST_LEVEL)
+    {
+        PHYSICAL_ADDRESS physAddr = (PHYSICAL_ADDRESS)(PtrOffset(pPageContext->PhysicalAddressBase,
+                                                       PtrDiff(VirtualAddress, pPageContext->VirtualAddressBase)));
+        PTE_MAP_FLAGS flags = { 0 };
+
+        flags.Executable = IsBooleanFlagOn(pPageContext->PageRights, PAGE_RIGHTS_EXECUTE);
+        flags.Writable = IsBooleanFlagOn(pPageContext->PageRights, PAGE_RIGHTS_WRITE);
+        flags.PatIndex = pPageContext->Uncacheable ? m_vmmData.UncacheableIndex : m_vmmData.WriteBackIndex;
+        flags.GlobalPage = pPageContext->PagingData->KernelSpace;
+        flags.UserAccess = !pPageContext->PagingData->KernelSpace;
+
+        PteMap(PageTable, physAddr, flags);
+
+        PageInvalidateTlb(VirtualAddress);
+
+        /// TODO: signal other processors to invalidate the mapping
+    }
+    else
+    {
+        // paging structure
+        _VmSetupPagingStructure(pPageContext->PagingData, PageTable);
+    }
+
+    // continue iteration
+    return TRUE;
+}
+
+static
+BOOLEAN
+(__cdecl _VmUnmapPage)(
+    IN      PML4                    Cr3,
+    IN      PVOID                   PageTable,
+    IN      PVOID                   VirtualAddress,
+    IN      BYTE                    PageLevel,
+    IN_OPT  PVOID                   Context
+    )
+{
+    PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT pPageContext;
+
+    UNREFERENCED_PARAMETER(Cr3);
+
+    ASSERT(PageTable != NULL);
+    ASSERT(VirtualAddress != NULL);
+    ASSERT(PAGING_TABLES_FIRST_LEVEL <= PageLevel && PageLevel <= PAGING_TABLES_LAST_LEVEL);
+
+    pPageContext = (PVMM_MAP_UNMAP_PAGE_WALK_CONTEXT) Context;
+    ASSERT(pPageContext != NULL);
+
+    if (!PteIsPresent(PageTable))
+    {
+        return FALSE;
+    }
+
+    if (PageLevel == PAGING_TABLES_LAST_LEVEL)
+    {
+        PHYSICAL_ADDRESS pa = PteGetPhysicalAddress(PageTable);
+
+        PteUnmap(PageTable);
+
+        PageInvalidateTlb(VirtualAddress);
+
+        if (pPageContext->ReleaseMemory)
+        {
+            MmuReleaseMemory(pa, 1);
+        }
+
+        /// TODO: signal other processors to invalidate the mapping
+    }
+
+    // continue iteration
+    return TRUE;
+}
+
+static
+BOOLEAN
+(__cdecl _VmRetrievePhyAccess)(
+    IN      PML4                    Cr3,
+    IN      PVOID                   PageTable,
+    IN      PVOID                   VirtualAddress,
+    IN      BYTE                    PageLevel,
+    IN_OPT  PVOID                   Context
+    )
+{
+    PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT pPageContext;
+    BOOLEAN bContinue;
+
+    UNREFERENCED_PARAMETER(Cr3);
+
+    ASSERT(PageTable != NULL);
+    ASSERT(VirtualAddress != NULL);
+    ASSERT(PAGING_TABLES_FIRST_LEVEL <= PageLevel && PageLevel <= PAGING_TABLES_LAST_LEVEL);
+
+    pPageContext = (PVMM_RETRIEVE_PHYS_ACCESS_PAGE_WALK_CONTEXT) Context;
+    ASSERT(pPageContext != NULL);
+
+    bContinue = TRUE;
+
+    if (!PteIsPresent(PageTable))
+    {
+        pPageContext->PhysicalAddress = NULL;
+        return FALSE;
+    }
+
+    if (PageLevel < PAGING_TABLES_LAST_LEVEL - 1)
+    {
+        return TRUE;
+    }
+
+    __try
+    {
+        if (PageLevel == PAGING_TABLES_LAST_LEVEL - 1)
+        {
+            PD_ENTRY_2MB* pPdEntry = (PD_ENTRY_2MB*) PageTable;
+
+            if (pPdEntry->PageSize == 1)
+            {
+                pPageContext->PhysicalAddress = PtrOffset(PteLargePageGetPhysicalAddress(PageTable),
+                                                          AddressOffset(VirtualAddress, PAGE_2MB_OFFSET + 1));
+
+                bContinue = FALSE;
+                __leave;
+            }
+        }
+        else
+        {
+            ASSERT(PageLevel == PAGING_TABLES_LAST_LEVEL);
+
+            pPageContext->PhysicalAddress = PteGetPhysicalAddress(PageTable);
+            bContinue = FALSE;
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (!bContinue)
+        {
+            BOOLEAN bInvalidatePage = FALSE;
+            PT_ENTRY* pPtEntry = (PT_ENTRY*)PageTable;
+
+            pPageContext->Accessed = (BOOLEAN) pPtEntry->Accessed;
+            pPageContext->Dirty = (BOOLEAN) pPtEntry->Dirty;
+
+            if (pPageContext->ClearAccessed)
+            {
+                pPtEntry->Accessed = FALSE;
+                bInvalidatePage = TRUE;
+            }
+
+            if (pPageContext->ClearDirty)
+            {
+                pPtEntry->Dirty = FALSE;
+                bInvalidatePage = TRUE;
+            }
+
+            if (bInvalidatePage)
+            {
+                // 4.10.4.2 Recommended Invalidation
+                // If software modifies a paging - structure entry that maps a page(rather than referencing
+                // another paging structure), it should execute INVLPG for any linear address with a page
+                // number whose translation uses that paging - structure entry.
+
+                // 4.10.4.3 Optional Invalidation
+                // If a paging - structure entry is modified to change the accessed flag from 1 to 0, failure
+                // to perform an invalidation may result in the processor not setting that bit in response to
+                // a subsequent access to a linear address whose translation uses the entry.Software cannot
+                // interpret the bit being clear as an indication that such an access has not occurred.
+
+                // If software modifies a paging - structure entry that identifies the final physical address
+                // for a linear address (either a PTE or a paging - structure entry in which the PS flag is 1)
+                // to change the dirty flag from 1 to 0, failure to perform an invalidation may result in the
+                // processor not setting that bit in response to a subsequent write to a linear address whose
+                // translation uses the entry.Software cannot interpret the bit being clear as an indication
+                // that such a write has not occurred.
+                PageInvalidateTlb(VirtualAddress);
+
+                /// TODO: signal other processors to invalidate the mapping
+            }
+        }
+    }
+
+    return bContinue;
+}
\ No newline at end of file
diff --git a/src_proiect/HAL9000_WithoutApplications.sln b/src_proiect/HAL9000_WithoutApplications.sln
new file mode 100644
index 0000000..1d918fd
--- /dev/null
+++ b/src_proiect/HAL9000_WithoutApplications.sln
@@ -0,0 +1,162 @@
+﻿
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 16
+VisualStudioVersion = 16.0.30517.126
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL9000", "HAL9000\HAL9000.vcxproj", "{79A21DCA-19AF-4F8E-9B83-62D7CF504104}"
+	ProjectSection(ProjectDependencies) = postProject
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8} = {642F9F32-68EC-40AD-BAAF-3436DA0B66A8}
+		{9412F640-A271-4661-B437-5932E9B95C26} = {9412F640-A271-4661-B437-5932E9B95C26}
+		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D} = {4DA7677D-D0E7-44EC-B350-F7170E0ED84D}
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A} = {E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E} = {0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1} = {02EC2CAD-C1E9-45FB-96AC-27976A9300F1}
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608} = {0C5EB2D2-DA05-44F7-89CA-A15CB692D608}
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1} = {F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "HAL", "HAL\HAL.vcxproj", "{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Filesystems", "Filesystems", "{2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FAT32", "FAT32\FAT32.vcxproj", "{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Misc", "Misc", "{0B471868-BE09-4F73-996F-2EAFFDF591CE}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PE_Parser", "PE_Parser\PE_Parser.vcxproj", "{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Networking", "Networking", "{C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Eth_82574L", "Eth_82574L\Eth_82574L.vcxproj", "{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}"
+	ProjectSection(ProjectDependencies) = postProject
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F} = {B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NetworkStack", "NetworkStack\NetworkStack.vcxproj", "{9412F640-A271-4661-B437-5932E9B95C26}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "NetworkPort", "NetworkPort\NetworkPort.vcxproj", "{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Storage", "Storage", "{9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Disk", "Disk\Disk.vcxproj", "{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Volume", "Volume\Volume.vcxproj", "{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ata", "Ata\Ata.vcxproj", "{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Utils", "Utils", "{2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RunTests", "Utils\RunTests\RunTests.vcxproj", "{291C9D17-6BA7-404F-8664-C60F38E061C7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104} = {79A21DCA-19AF-4F8E-9B83-62D7CF504104}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "RemoveAllTests", "Utils\RemoveAllTests\RemoveAllTests.vcxproj", "{6CAFB378-993C-4078-B545-9D8636F383DC}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLib", "CommonLib\CommonLib.vcxproj", "{CA44C37A-1730-447F-8975-3DF40D559310}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SwapFS", "SwapFS\SwapFS.vcxproj", "{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CommonLibUnitTests", "CommonLibUnitTests\CommonLibUnitTests.vcxproj", "{098EB03E-8151-46DB-9052-5136D9BC14EA}"
+	ProjectSection(ProjectDependencies) = postProject
+		{CA44C37A-1730-447F-8975-3DF40D559310} = {CA44C37A-1730-447F-8975-3DF40D559310}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		CommonLibTests|x64 = CommonLibTests|x64
+		Threads|x64 = Threads|x64
+		Userprog|x64 = Userprog|x64
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Threads|x64.Build.0 = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.ActiveCfg = Debug|x64
+		{79A21DCA-19AF-4F8E-9B83-62D7CF504104}.Userprog|x64.Build.0 = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Threads|x64.Build.0 = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.ActiveCfg = Debug|x64
+		{0AAEEAA7-E70D-41BE-ABE4-34FD9449870E}.Userprog|x64.Build.0 = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Threads|x64.Build.0 = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.ActiveCfg = Debug|x64
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D}.Userprog|x64.Build.0 = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Threads|x64.Build.0 = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.ActiveCfg = Debug|x64
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}.Userprog|x64.Build.0 = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Threads|x64.Build.0 = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.ActiveCfg = Debug|x64
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608}.Userprog|x64.Build.0 = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Threads|x64.Build.0 = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.ActiveCfg = Debug|x64
+		{9412F640-A271-4661-B437-5932E9B95C26}.Userprog|x64.Build.0 = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Threads|x64.Build.0 = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.ActiveCfg = Debug|x64
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}.Userprog|x64.Build.0 = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Threads|x64.Build.0 = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.ActiveCfg = Debug|x64
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1}.Userprog|x64.Build.0 = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Threads|x64.Build.0 = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.ActiveCfg = Debug|x64
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}.Userprog|x64.Build.0 = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Threads|x64.Build.0 = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.ActiveCfg = Debug|x64
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1}.Userprog|x64.Build.0 = Debug|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.CommonLibTests|x64.ActiveCfg = Userprog|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Threads|x64.ActiveCfg = Threads|x64
+		{291C9D17-6BA7-404F-8664-C60F38E061C7}.Userprog|x64.ActiveCfg = Userprog|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.Threads|x64.ActiveCfg = Debug|x64
+		{6CAFB378-993C-4078-B545-9D8636F383DC}.Userprog|x64.ActiveCfg = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.ActiveCfg = DebugNonNative|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.CommonLibTests|x64.Build.0 = DebugNonNative|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.ActiveCfg = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Threads|x64.Build.0 = Debug|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.ActiveCfg = DebugNoLocks|x64
+		{CA44C37A-1730-447F-8975-3DF40D559310}.Userprog|x64.Build.0 = DebugNoLocks|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Threads|x64.Build.0 = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.ActiveCfg = Debug|x64
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}.Userprog|x64.Build.0 = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.ActiveCfg = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.CommonLibTests|x64.Build.0 = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Threads|x64.ActiveCfg = Debug|x64
+		{098EB03E-8151-46DB-9052-5136D9BC14EA}.Userprog|x64.ActiveCfg = Debug|x64
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{4DA7677D-D0E7-44EC-B350-F7170E0ED84D} = {2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}
+		{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A} = {0B471868-BE09-4F73-996F-2EAFFDF591CE}
+		{0C5EB2D2-DA05-44F7-89CA-A15CB692D608} = {C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}
+		{9412F640-A271-4661-B437-5932E9B95C26} = {C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}
+		{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F} = {C19D9CBB-A6EF-4497-941B-3A8D1E7928E9}
+		{02EC2CAD-C1E9-45FB-96AC-27976A9300F1} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
+		{642F9F32-68EC-40AD-BAAF-3436DA0B66A8} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
+		{F2FB6AEB-E2B7-40D2-9D78-A9913001D8D1} = {9FE0F885-5675-4B1E-B3FB-FEE6C164E1C5}
+		{291C9D17-6BA7-404F-8664-C60F38E061C7} = {2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}
+		{6CAFB378-993C-4078-B545-9D8636F383DC} = {2FF6ADE0-C136-4D36-B9D2-D279A8E79BCC}
+		{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7} = {2EA5AF3B-4CA5-4D96-ADE5-BB8A37081300}
+	EndGlobalSection
+EndGlobal
diff --git a/src_proiect/NetworkPort/NetworkPort.vcxproj b/src_proiect/NetworkPort/NetworkPort.vcxproj
new file mode 100644
index 0000000..ea7b1f9
--- /dev/null
+++ b/src_proiect/NetworkPort/NetworkPort.vcxproj
@@ -0,0 +1,134 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{B4E5D0A0-4316-4FE3-A66B-B2C5E296567F}</ProjectGuid>
+    <RootNamespace>NetworkPort</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\network_dispatch.c" />
+    <ClCompile Include="src\network_miniport.c" />
+    <ClCompile Include="src\network_port.c" />
+    <ClCompile Include="src\network_structures.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\network_dispatch.h" />
+    <ClInclude Include="headers\network_port_base.h" />
+    <ClInclude Include="headers\network_structures.h" />
+    <ClInclude Include="inc\network_port.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/NetworkPort.vcxproj.filters b/src_proiect/NetworkPort/NetworkPort.vcxproj.filters
new file mode 100644
index 0000000..769ac25
--- /dev/null
+++ b/src_proiect/NetworkPort/NetworkPort.vcxproj.filters
@@ -0,0 +1,48 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{2d021ba9-eb69-41e8-bdd6-7313604d94cd}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\network_port.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_dispatch.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_miniport.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_structures.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\network_port.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\network_port_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\network_dispatch.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\network_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/headers/network_dispatch.h b/src_proiect/NetworkPort/headers/network_dispatch.h
new file mode 100644
index 0000000..f8e95c3
--- /dev/null
+++ b/src_proiect/NetworkPort/headers/network_dispatch.h
@@ -0,0 +1,5 @@
+#pragma once
+
+FUNC_DriverDispatch             NetPortDeviceControl;
+
+FUNC_ThreadStart                NetPortTransmitFunction;
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/headers/network_port_base.h b/src_proiect/NetworkPort/headers/network_port_base.h
new file mode 100644
index 0000000..54205c7
--- /dev/null
+++ b/src_proiect/NetworkPort/headers/network_port_base.h
@@ -0,0 +1,10 @@
+#pragma once
+
+#include "common_lib.h"
+#include "log.h"
+#include "io.h"
+#include "thread.h"
+#include "network.h"
+#include "network_utils.h"
+#include "network_port.h"
+#include "network_structures.h"
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/headers/network_structures.h b/src_proiect/NetworkPort/headers/network_structures.h
new file mode 100644
index 0000000..5007831
--- /dev/null
+++ b/src_proiect/NetworkPort/headers/network_structures.h
@@ -0,0 +1,102 @@
+#pragma once
+
+#include "lock_common.h"
+#include "ex_event.h"
+
+#pragma warning(push)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable: 4200)
+typedef struct _NETWORK_PORT_DRIVER_DATA
+{
+    MINIPORT_FUNCTIONS              MiniportFunctions;
+} NETWORK_PORT_DRIVER_DATA, *PNETWORK_PORT_DRIVER_DATA;
+
+typedef struct _PORT_BUFFERS
+{
+    DWORD                       NumberOfBuffers;
+    WORD                        BufferSize;
+
+    PVOID*                      Buffers;
+
+    LOCK                        FramesLock;
+    LIST_ENTRY                  FramesList;
+    EX_EVENT                    FramesListNotEmptyEvent;
+
+    volatile QWORD              NumberOfFramesTransferred;
+} PORT_BUFFERS, *PPORT_BUFFERS;
+
+typedef struct _RX_DATA
+{
+    PORT_BUFFERS                Buffers;
+} RX_DATA, *PRX_DATA;
+
+typedef struct _TX_DATA
+{
+    PORT_BUFFERS                Buffers;
+
+    EX_EVENT                    DescriptorsAvailable;
+
+    struct _THREAD*             TransmitWorkerThread;
+    WORD                        CurrentTxIndex;
+} TX_DATA, *PTX_DATA;
+
+typedef struct _NETWORK_PORT_DEVICE
+{
+    PMINIPORT_DEVICE            Miniport;
+
+    RX_DATA                     RxData;
+    TX_DATA                     TxData;
+} NETWORK_PORT_DEVICE, *PNETWORK_PORT_DEVICE;
+
+typedef struct _FRAME_DESCRIPTOR
+{
+    DWORD               BufferSize;
+    BYTE                Buffer[0];
+} FRAME_DESCRIPTOR, *PFRAME_DESCRIPTOR;
+STATIC_ASSERT_INFO(sizeof(FRAME_DESCRIPTOR) == FIELD_OFFSET(FRAME_DESCRIPTOR, Buffer),
+                   "Buffer must always be the last element in the structure");
+
+typedef struct _FRAME_DESCRIPTOR_ENTRY
+{
+    LIST_ENTRY          ListEntry;
+    BYTE                __Padding[4];
+    FRAME_DESCRIPTOR    Frame;
+} FRAME_DESCRIPTOR_ENTRY, *PFRAME_DESCRIPTOR_ENTRY;
+STATIC_ASSERT_INFO(sizeof(FRAME_DESCRIPTOR_ENTRY) - sizeof(FRAME_DESCRIPTOR) == FIELD_OFFSET(FRAME_DESCRIPTOR_ENTRY, Frame),
+                   "Frame must always be the last element in the structure");
+
+#pragma warning(pop)
+
+void
+NetworkPortDevicePreinit(
+    OUT         PNETWORK_PORT_DEVICE    PortDevice
+    );
+
+STATUS
+NetworkPortDeviceInit(
+    INOUT       PNETWORK_PORT_DEVICE    PortDevice,
+    IN          PMINIPORT_DEVICE        MiniportDevice,
+    IN          DWORD                   NumberOfReceiveBuffers,
+    IN          PVOID*                  ReceiveBuffers,
+    IN          WORD                    ReceiveBufferSize,
+    IN          DWORD                   NumberOfTransmitBuffers,
+    IN          PVOID*                  TransmitBuffers,
+    IN          WORD                    TransmitBufferSize
+    );
+
+void
+NetworkPortDeviceUninit(
+    INOUT       PNETWORK_PORT_DEVICE    PortDevice
+    );
+
+PTR_SUCCESS
+PFRAME_DESCRIPTOR_ENTRY
+NetworkPortAllocateFrameDescriptor(
+    IN          DWORD                   BufferSize
+    );
+
+void
+NetworkPortFreeFrameDescriptor(
+    IN          PFRAME_DESCRIPTOR_ENTRY Descriptor
+    );
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/inc/network_port.h b/src_proiect/NetworkPort/inc/network_port.h
new file mode 100644
index 0000000..90fca50
--- /dev/null
+++ b/src_proiect/NetworkPort/inc/network_port.h
@@ -0,0 +1,142 @@
+#pragma once
+
+typedef struct _MINIPORT_DEVICE
+{
+    // IN - completed by NetworkPortRegisterMiniportDriver
+    PDEVICE_OBJECT                  DeviceObject;
+    PVOID                           DeviceExtension;
+
+    // OUT - completed by the FUNC_NetworkMiniportInitializeDevice
+    // function
+    MAC_ADDRESS                     PhysicalAddress;
+
+    NETWORK_DEVICE_STATUS           DeviceStatus;
+    volatile BOOLEAN                LinkUp;
+} MINIPORT_DEVICE, *PMINIPORT_DEVICE;
+
+typedef struct _MINIPORT_BUFFER_INITIALIZATION
+{
+    DWORD                           NumberOfBuffers;
+    PHYSICAL_ADDRESS*               Buffers;
+    PVOID                           RingBuffer;
+    WORD                            BufferSize;
+} MINIPORT_BUFFER_INITIALIZATION, *PMINIPORT_BUFFER_INITIALIZATION;
+
+typedef struct _MINIPORT_DEVICE_INITIALIZATION
+{
+    PPCI_BAR                        PciBar;
+
+    MINIPORT_BUFFER_INITIALIZATION  RxBuffers;
+    MINIPORT_BUFFER_INITIALIZATION  TxBuffers;
+} MINIPORT_DEVICE_INITIALIZATION, *PMINIPORT_DEVICE_INITIALIZATION;
+
+typedef
+STATUS
+(__cdecl FUNC_NetworkMiniportInitializeDevice)(
+    INOUT                           PMINIPORT_DEVICE                    MiniportDevice,
+    IN                              PMINIPORT_DEVICE_INITIALIZATION     MiniportInitialization
+    );
+
+typedef FUNC_NetworkMiniportInitializeDevice*   PFUNC_NetworkMiniportInitializeDevice;
+
+typedef
+STATUS
+(__cdecl FUNC_NetworkMiniportUninitializeDevice)(
+    INOUT                           PMINIPORT_DEVICE            MiniportDevice
+    );
+
+typedef FUNC_NetworkMiniportUninitializeDevice* PFUNC_NetworkMiniportUninitializeDevice;
+
+typedef
+STATUS
+(__cdecl FUNC_NetworkMiniportSendBuffer)(
+    IN  PMINIPORT_DEVICE            MiniportDevice,
+    IN  WORD                        DesccriptorIndex,
+    IN  WORD                        Length
+    );
+
+typedef FUNC_NetworkMiniportSendBuffer*         PFUNC_NetworkMiniportSendBuffer;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_NetworkMiniportInterruptHandler)(
+    IN  PMINIPORT_DEVICE            MiniportDevice
+    );
+
+typedef FUNC_NetworkMiniportInterruptHandler*   PFUNC_NetworkMiniportInterruptHandler;
+
+typedef
+void
+(__cdecl FUNC_NetworkMiniportChangeDeviceStatus)(
+    IN  PMINIPORT_DEVICE            MiniportDevice,
+    IN  PNETWORK_DEVICE_STATUS      DeviceStatus
+    );
+
+typedef FUNC_NetworkMiniportChangeDeviceStatus* PFUNC_NetworkMiniportChangeDeviceStatus;
+
+typedef struct _MINIPORT_FUNCTIONS
+{
+    PFUNC_NetworkMiniportInitializeDevice       MiniportInitializeDevice;
+
+    PFUNC_NetworkMiniportUninitializeDevice     MiniportUninitializeDevice;
+
+    PFUNC_NetworkMiniportSendBuffer             MiniportSendBuffer;
+
+    PFUNC_NetworkMiniportInterruptHandler       MiniportInterruptHandler;
+
+    PFUNC_NetworkMiniportChangeDeviceStatus     MiniportChangeDeviceStatus;
+} MINIPORT_FUNCTIONS, *PMINIPORT_FUNCTIONS;
+
+typedef struct _MINIPORT_BUFFER_DESCRIPTION
+{
+    DWORD                                       NumberOfBuffers;
+    DWORD                                       DescriptorSize;
+    WORD                                        BufferSize;
+} MINIPORT_BUFFER_DESCRIPTION, *PMINIPORT_BUFFER_DESCRIPTION;
+
+typedef struct _MINIPORT_REGISTRATION
+{
+    PCI_SPEC                                    Specification;
+
+    DWORD                                       DeviceContextSize;
+
+    MINIPORT_BUFFER_DESCRIPTION                 RxBuffers;
+    MINIPORT_BUFFER_DESCRIPTION                 TxBuffers;
+
+    MINIPORT_FUNCTIONS                          MiniportFunctions;
+} MINIPORT_REGISTRATION, *PMINIPORT_REGISTRATION;
+
+STATUS
+NetworkPortRegisterMiniportDriver(
+    IN      PDRIVER_OBJECT          DriverObject,
+    IN      PMINIPORT_REGISTRATION  MiniportRegistration
+    );
+
+PTR_SUCCESS
+PVOID
+NetworkPortGetMiniportExtension(
+    IN      PMINIPORT_DEVICE        Device
+    );
+
+STATUS
+NetworkPortNotifyReceiveBuffer(
+    IN                          PMINIPORT_DEVICE        Device,
+    IN                          DWORD                   DesciptorIndex,
+    IN                          DWORD                   BufferSize
+    );
+
+void
+NetworkPortNotifyTxDescriptorAvailable(
+    IN                          PMINIPORT_DEVICE        Device
+    );
+
+void
+NetworkPortNotifyTxQueueFull(
+    IN                          PMINIPORT_DEVICE        Device
+    );
+
+void
+NetworkPortNotifyLinkStatusChange(
+    IN                          PMINIPORT_DEVICE        Device,
+    IN                          BOOLEAN                 LinkUp
+    );
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/src/network_dispatch.c b/src_proiect/NetworkPort/src/network_dispatch.c
new file mode 100644
index 0000000..4268206
--- /dev/null
+++ b/src_proiect/NetworkPort/src/network_dispatch.c
@@ -0,0 +1,418 @@
+#include "network_port_base.h"
+#include "network_dispatch.h"
+#include "ex.h"
+
+static
+STATUS
+_NetDispatchReceiveFrame(
+    INOUT                                   PNETWORK_PORT_DEVICE        Device,
+    IN                                      DWORD                       OutputBufferSize,
+    OUT_WRITES_BYTES(OutputBufferSize)      PNET_RECEIVE_FRAME_OUTPUT   ReceiveOutput,
+    OUT                                     QWORD*                      Information
+    );
+
+static
+STATUS
+_NetDispatchSendFrame(
+    INOUT                                   PNETWORK_PORT_DEVICE        Device,
+    IN                                      DWORD                       InputBufferSize,
+    IN_READS_BYTES(InputBufferSize)         PNET_RECEIVE_FRAME_OUTPUT   SendBuffer
+    );
+
+static
+STATUS
+_NetDispatchChangeDeviceStatus(
+    INOUT                                   PNETWORK_PORT_DEVICE        Device,
+    IN                                      PNET_GET_SET_DEVICE_STATUS  DeviceStatus
+    );
+
+STATUS
+NetPortDeviceControl(
+    INOUT       PDEVICE_OBJECT          DeviceObject,
+    INOUT       PIRP                    Irp
+)
+{
+    STATUS status;
+    PNETWORK_PORT_DEVICE pPortDevice;
+    PIO_STACK_LOCATION pStackLocation;
+    QWORD information;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pPortDevice = NULL;
+    information = 0;
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+
+    pPortDevice = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pPortDevice);
+
+    switch (pStackLocation->Parameters.DeviceControl.IoControlCode)
+    {
+    case IOCTL_NET_RECEIVE_FRAME:
+        information = sizeof(NET_RECEIVE_FRAME_OUTPUT);
+
+        if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+            break;
+        }
+
+        status = _NetDispatchReceiveFrame(pPortDevice, pStackLocation->Parameters.DeviceControl.OutputBufferLength, pStackLocation->Parameters.DeviceControl.OutputBuffer, &information );
+
+        break;
+    case IOCTL_NET_GET_PHYSICAL_ADDRESS:
+        information = sizeof(NET_GET_SET_PHYSICAL_ADDRESS);
+
+        if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+            break;
+        }
+
+        memcpy(pStackLocation->Parameters.DeviceControl.OutputBuffer, &pPortDevice->Miniport->PhysicalAddress, sizeof(MAC_ADDRESS));
+        break;
+    case IOCTL_NET_SEND_FRAME:
+        status = _NetDispatchSendFrame(pPortDevice, pStackLocation->Parameters.DeviceControl.InputBufferLength, Irp->Buffer );
+        break;
+    case IOCTL_NET_GET_DEVICE_STATUS:
+        {
+            PNET_GET_SET_DEVICE_STATUS pDeviceStatus = (PNET_GET_SET_DEVICE_STATUS) pStackLocation->Parameters.DeviceControl.OutputBuffer;
+
+            information = sizeof(NET_GET_SET_DEVICE_STATUS);
+
+            if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+            {
+                status = STATUS_BUFFER_TOO_SMALL;
+                break;
+            }
+
+            memcpy(&pDeviceStatus->DeviceStatus, &pPortDevice->Miniport->DeviceStatus, sizeof(NETWORK_DEVICE_STATUS));
+        }
+        break;
+    case IOCTL_NET_SET_DEVICE_STATUS:
+        information = sizeof(NET_GET_SET_DEVICE_STATUS);
+
+        if (pStackLocation->Parameters.DeviceControl.InputBufferLength < information)
+        {
+            status = STATUS_BUFFER_TOO_SMALL;
+            break;
+        }
+
+        status = _NetDispatchChangeDeviceStatus(pPortDevice, Irp->Buffer);
+        break;
+    case IOCTL_NET_GET_LINK_STATUS:
+        {
+            PNET_GET_LINK_STATUS pLinkStatus = (PNET_GET_LINK_STATUS) pStackLocation->Parameters.DeviceControl.OutputBuffer;
+
+            information = sizeof(NET_GET_LINK_STATUS);
+
+            if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+            {
+                status = STATUS_BUFFER_TOO_SMALL;
+                break;
+            }
+
+            pLinkStatus->LinkUp = pPortDevice->Miniport->LinkUp;
+        }
+        break;
+    default:
+        status = STATUS_UNSUPPORTED;
+    }
+
+    Irp->IoStatus.Status = status;
+    Irp->IoStatus.Information = information;
+    IoCompleteIrp(Irp);
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl NetPortTransmitFunction)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PNETWORK_PORT_DEVICE pPortDevice;
+    PNETWORK_PORT_DRIVER_DATA pDriverExtension;
+    INTR_STATE intrState;
+    PLIST_ENTRY pEntry;
+    BOOLEAN bListEmpty;
+    PFRAME_DESCRIPTOR_ENTRY pDescriptorEntry;
+    STATUS status;
+    WORD curTxIndex;
+
+    ASSERT( NULL != Context );
+
+    pPortDevice = Context;
+    pEntry = NULL;
+    bListEmpty = FALSE;
+    status = STATUS_SUCCESS;
+    pDriverExtension = NULL;
+
+    LOG_FUNC_START;
+
+    pDriverExtension = IoGetDriverExtension(pPortDevice->Miniport->DeviceObject);
+    ASSERT(NULL != pDriverExtension);
+
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        pDescriptorEntry = NULL;
+
+        // wait to have actual data to send
+        ExEventWaitForSignal(&pPortDevice->TxData.Buffers.FramesListNotEmptyEvent);
+
+        LockAcquire(&pPortDevice->TxData.Buffers.FramesLock, &intrState);
+        pEntry = RemoveHeadList(&pPortDevice->TxData.Buffers.FramesList);
+        bListEmpty = ( pEntry == &pPortDevice->TxData.Buffers.FramesList );
+
+        if (bListEmpty)
+        {
+            ExEventClearSignal(&pPortDevice->TxData.Buffers.FramesListNotEmptyEvent);
+        }
+
+        LockRelease(&pPortDevice->TxData.Buffers.FramesLock, intrState );
+
+        if (bListEmpty)
+        {
+            // list is empty :(
+            continue;
+        }
+
+        pDescriptorEntry = CONTAINING_RECORD(pEntry, FRAME_DESCRIPTOR_ENTRY, ListEntry );
+        curTxIndex = pPortDevice->TxData.CurrentTxIndex;
+
+        ExEventWaitForSignal(&pPortDevice->TxData.DescriptorsAvailable);
+
+        ASSERT( pDescriptorEntry->Frame.BufferSize <= MAX_WORD );
+        memcpy( pPortDevice->TxData.Buffers.Buffers[curTxIndex], pDescriptorEntry->Frame.Buffer, pDescriptorEntry->Frame.BufferSize );
+
+        status = pDriverExtension->MiniportFunctions.MiniportSendBuffer( pPortDevice->Miniport, curTxIndex, (WORD) pDescriptorEntry->Frame.BufferSize );
+        ASSERT(SUCCEEDED(status));
+
+        curTxIndex = ( curTxIndex + 1 ) % pPortDevice->TxData.Buffers.NumberOfBuffers;
+        _InterlockedIncrement64(&pPortDevice->TxData.Buffers.NumberOfFramesTransferred);
+        pPortDevice->TxData.CurrentTxIndex = curTxIndex;
+
+        NetworkPortFreeFrameDescriptor(pDescriptorEntry);
+        pDescriptorEntry = NULL;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
+
+static
+STATUS
+_NetDispatchReceiveFrame(
+    INOUT                                   PNETWORK_PORT_DEVICE        Device,
+    IN                                      DWORD                       OutputBufferSize,
+    OUT_WRITES_BYTES(OutputBufferSize)      PNET_RECEIVE_FRAME_OUTPUT   ReceiveOutput,
+    OUT                                     QWORD*                      Information
+    )
+{
+    STATUS status;
+    INTR_STATE oldState;
+    PLIST_ENTRY pListEntry;
+    BOOLEAN bListEmpty;
+    PFRAME_DESCRIPTOR_ENTRY pFrame;
+    DWORD bufferSize;
+
+    ASSERT( NULL != Device );
+    ASSERT( OutputBufferSize >= sizeof(NET_RECEIVE_FRAME_OUTPUT) );
+    ASSERT( NULL != ReceiveOutput );
+    ASSERT( NULL != Information );
+
+    status = STATUS_SUCCESS;
+    pListEntry = NULL;
+    bListEmpty = FALSE;
+    pFrame = NULL;
+    bufferSize = 0;
+
+// warning C4127: conditional expression is constant
+#pragma warning(suppress:4127)
+    while (TRUE)
+    {
+        LockAcquire(&Device->RxData.Buffers.FramesLock, &oldState);
+
+        pListEntry = Device->RxData.Buffers.FramesList.Flink;
+        bListEmpty = (pListEntry == &Device->RxData.Buffers.FramesList);
+
+        if (!bListEmpty)
+        {
+            pFrame = CONTAINING_RECORD(pListEntry, FRAME_DESCRIPTOR_ENTRY, ListEntry);
+            bufferSize = pFrame->Frame.BufferSize;
+
+            if (bufferSize > OutputBufferSize)
+            {
+                LOGL("Buffer received of size %u is too small. Required: %u\n", OutputBufferSize, bufferSize );
+                status = STATUS_BUFFER_TOO_SMALL;
+            }
+            else
+            {
+                // actually remove element from list
+                RemoveEntryList(pListEntry);
+            }
+        }
+        else
+        {
+            // list empty clear event
+            ExEventClearSignal(&Device->RxData.Buffers.FramesListNotEmptyEvent);
+        }
+
+        LockRelease(&Device->RxData.Buffers.FramesLock, oldState);
+
+
+        if (STATUS_BUFFER_TOO_SMALL == status)
+        {
+            break;
+        }
+
+        ASSERT(SUCCEEDED(status));
+
+        if (bListEmpty)
+        {
+            // if list is empty we need to check if the link is down or if the device RX
+            // functionality is disabled
+            if (!Device->Miniport->LinkUp)
+            {
+                LOG_WARNING("Device is not linked\n");
+                status = STATUS_DEVICE_NOT_CONNECTED;
+                break;
+            }
+
+            if (!Device->Miniport->DeviceStatus.RxEnabled)
+            {
+                LOG_WARNING("Can no longer receive packets because device RX is disabled! :(\n");
+                status = STATUS_DEVICE_DISABLED;
+                break;
+            }
+
+            ExEventWaitForSignal(&Device->RxData.Buffers.FramesListNotEmptyEvent);
+        }
+        else
+        {
+            break;
+        }
+    }
+
+    // set output buffer size written/required
+    *Information = bufferSize;
+
+    if (SUCCEEDED(status))
+    {
+        ASSERT(NULL != pFrame);
+        ASSERT(!bListEmpty);
+
+        memcpy( &ReceiveOutput->Buffer,pFrame->Frame.Buffer, pFrame->Frame.BufferSize);
+
+        NetworkPortFreeFrameDescriptor(pFrame);
+        pFrame = NULL;
+    }
+
+
+    return status;
+}
+
+static
+STATUS
+_NetDispatchSendFrame(
+    INOUT                                   PNETWORK_PORT_DEVICE        Device,
+    IN                                      DWORD                       InputBufferSize,
+    IN_READS_BYTES(InputBufferSize)         PNET_RECEIVE_FRAME_OUTPUT   SendBuffer
+    )
+{
+    STATUS status;
+    PFRAME_DESCRIPTOR_ENTRY pFrameDescriptor;
+    INTR_STATE intrState;
+    BOOLEAN bListWasEmpty;
+
+    ASSERT(NULL != Device);
+    ASSERT(0 != InputBufferSize);
+    ASSERT(NULL != SendBuffer);
+
+    if (!Device->Miniport->LinkUp)
+    {
+        LOG_WARNING("Device is not linked\n");
+        return STATUS_DEVICE_NOT_CONNECTED;
+    }
+
+    if (!Device->Miniport->DeviceStatus.TxEnabled)
+    {
+        LOG_WARNING("Device TX is disabled, cannot send packets\n");
+        return STATUS_DEVICE_DISABLED;
+    }
+
+    if (InputBufferSize > Device->TxData.Buffers.BufferSize)
+    {
+        LOG_ERROR("Transmit buffer size %u bytes too large for device buffer size of %u bytes\n",
+             InputBufferSize, Device->TxData.Buffers.BufferSize );
+        return STATUS_BUFFER_TOO_LARGE;
+    }
+
+    status = STATUS_SUCCESS;
+    pFrameDescriptor = NULL;
+    bListWasEmpty = FALSE;
+
+    pFrameDescriptor = NetworkPortAllocateFrameDescriptor(InputBufferSize);
+    if (NULL == pFrameDescriptor)
+    {
+        LOG_FUNC_ERROR_ALLOC("NetworkPortAllocateFrameDescriptor", InputBufferSize);
+        return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+    }
+
+    pFrameDescriptor->Frame.BufferSize = InputBufferSize;
+    memcpy( pFrameDescriptor->Frame.Buffer, SendBuffer, InputBufferSize);
+
+    LockAcquire(&Device->TxData.Buffers.FramesLock, &intrState);
+    bListWasEmpty = IsListEmpty(&Device->TxData.Buffers.FramesList);
+    InsertTailList(&Device->TxData.Buffers.FramesList, &pFrameDescriptor->ListEntry);
+    LockRelease(&Device->TxData.Buffers.FramesLock, intrState);
+    pFrameDescriptor = NULL;
+
+    if (bListWasEmpty)
+    {
+        ExEventSignal(&Device->TxData.Buffers.FramesListNotEmptyEvent);
+    }
+
+    return status;
+}
+
+static
+STATUS
+_NetDispatchChangeDeviceStatus(
+    INOUT                                   PNETWORK_PORT_DEVICE        Device,
+    IN                                      PNET_GET_SET_DEVICE_STATUS  DeviceStatus
+    )
+{
+    STATUS status;
+    PNETWORK_PORT_DRIVER_DATA pDriverExtension;
+
+    ASSERT(NULL != Device);
+    ASSERT(NULL != DeviceStatus);
+
+    status = STATUS_SUCCESS;
+    pDriverExtension = NULL;
+
+    LOG_FUNC_START;
+
+    pDriverExtension = IoGetDriverExtension(Device->Miniport->DeviceObject);
+    ASSERT(NULL != pDriverExtension);
+
+    pDriverExtension->MiniportFunctions.MiniportChangeDeviceStatus(Device->Miniport,
+                                                                   &DeviceStatus->DeviceStatus
+                                                                   );
+    LOGL("Miniport device successfully changed status\n");
+
+    memcpy(&Device->Miniport->DeviceStatus, &DeviceStatus->DeviceStatus, sizeof(NETWORK_DEVICE_STATUS));
+
+    LOG_FUNC_END;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/src/network_miniport.c b/src_proiect/NetworkPort/src/network_miniport.c
new file mode 100644
index 0000000..5a4756d
--- /dev/null
+++ b/src_proiect/NetworkPort/src/network_miniport.c
@@ -0,0 +1,137 @@
+#include "network_port_base.h"
+#include "ex.h"
+
+STATUS
+NetworkPortNotifyReceiveBuffer(
+    IN                          PMINIPORT_DEVICE        Device,
+    IN                          DWORD                   DesciptorIndex,
+    IN                          DWORD                   BufferSize
+    )
+{
+    STATUS status;
+    PDEVICE_OBJECT pDevObject;
+    PNETWORK_PORT_DEVICE pPortDevice;
+    INTR_STATE oldState;
+    PLIST_ENTRY pListEntry;
+    PFRAME_DESCRIPTOR_ENTRY pFrameDescriptor;
+    BOOLEAN bListWasEmpty;
+    PVOID pReceiveBuffer;
+
+    ASSERT( NULL != Device );
+    ASSERT( 0 != BufferSize );
+
+    status = STATUS_SUCCESS;
+    pListEntry = NULL;
+    pDevObject = NULL;
+    pPortDevice = NULL;
+    pFrameDescriptor = NULL;
+    bListWasEmpty = FALSE;
+    pReceiveBuffer = NULL;
+
+    pDevObject = Device->DeviceObject;
+    ASSERT( NULL != pDevObject );
+
+    pPortDevice = IoGetDeviceExtension(pDevObject);
+    ASSERT( NULL != pPortDevice );
+
+    if (DesciptorIndex >= pPortDevice->RxData.Buffers.NumberOfBuffers)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (BufferSize > pPortDevice->RxData.Buffers.BufferSize)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    pFrameDescriptor = NetworkPortAllocateFrameDescriptor(BufferSize);
+    if (NULL == pFrameDescriptor)
+    {
+        LOG_FUNC_ERROR_ALLOC("NetworkPortAllocateFrameDescriptor", BufferSize);
+        return STATUS_HEAP_INSUFFICIENT_RESOURCES;
+    }
+
+    pFrameDescriptor->Frame.BufferSize = BufferSize;
+    pReceiveBuffer = pPortDevice->RxData.Buffers.Buffers[DesciptorIndex];
+    ASSERT( NULL != pReceiveBuffer );
+
+    memcpy( pFrameDescriptor->Frame.Buffer, pReceiveBuffer, BufferSize );
+
+    LockAcquire(&pPortDevice->RxData.Buffers.FramesLock, &oldState);
+
+    bListWasEmpty = IsListEmpty(&pPortDevice->RxData.Buffers.FramesList);
+    InsertTailList(&pPortDevice->RxData.Buffers.FramesList, &pFrameDescriptor->ListEntry);
+
+    LockRelease(&pPortDevice->RxData.Buffers.FramesLock, oldState);
+
+    if (bListWasEmpty)
+    {
+        // signal event
+        ExEventSignal(&pPortDevice->RxData.Buffers.FramesListNotEmptyEvent);
+    }
+
+    _InterlockedIncrement64(&pPortDevice->RxData.Buffers.NumberOfFramesTransferred);
+
+    return status;
+}
+
+void
+NetworkPortNotifyTxDescriptorAvailable(
+    IN                          PMINIPORT_DEVICE        Device
+    )
+{
+    PNETWORK_PORT_DEVICE pPortDevice;
+    PDEVICE_OBJECT pDevObject;
+
+    ASSERT(NULL != Device);
+
+    LOG_FUNC_START;
+
+    pDevObject = Device->DeviceObject;
+    ASSERT(NULL != pDevObject);
+
+    pPortDevice = IoGetDeviceExtension(pDevObject);
+    ASSERT(NULL != pPortDevice);
+
+    ExEventSignal(&pPortDevice->TxData.DescriptorsAvailable);
+
+    LOG_FUNC_END;
+}
+
+void
+NetworkPortNotifyTxQueueFull(
+    IN                          PMINIPORT_DEVICE        Device
+    )
+{
+    PNETWORK_PORT_DEVICE pPortDevice;
+    PDEVICE_OBJECT pDevObject;
+
+    ASSERT(NULL != Device);
+
+    LOG_FUNC_START;
+
+    pDevObject = Device->DeviceObject;
+    ASSERT(NULL != pDevObject);
+
+    pPortDevice = IoGetDeviceExtension(pDevObject);
+    ASSERT(NULL != pPortDevice);
+
+    ExEventClearSignal(&pPortDevice->TxData.DescriptorsAvailable);
+
+    LOG_FUNC_END;
+}
+
+void
+NetworkPortNotifyLinkStatusChange(
+    IN                          PMINIPORT_DEVICE        Device,
+    IN                          BOOLEAN                 LinkUp
+    )
+{
+    ASSERT(NULL != Device);
+
+    LOG_FUNC_START;
+
+    _InterlockedExchange8(&Device->LinkUp, LinkUp);
+
+    LOG_FUNC_END;
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/src/network_port.c b/src_proiect/NetworkPort/src/network_port.c
new file mode 100644
index 0000000..f0090b8
--- /dev/null
+++ b/src_proiect/NetworkPort/src/network_port.c
@@ -0,0 +1,597 @@
+#include "network_port_base.h"
+#include "network_port.h"
+#include "network_dispatch.h"
+#include "ex.h"
+
+static FUNC_InterruptFunction   _NetworkPortGenericInterrupt;
+
+__forceinline
+BOOLEAN
+_NetworkPortValidateMiniportFunctions(
+    IN      PMINIPORT_FUNCTIONS     MiniportFunctions
+    )
+{
+    ASSERT( NULL != MiniportFunctions );
+
+    if ((NULL == MiniportFunctions->MiniportInitializeDevice)   ||
+        (NULL == MiniportFunctions->MiniportSendBuffer)         ||
+        (NULL == MiniportFunctions->MiniportInterruptHandler)   ||
+        (NULL == MiniportFunctions->MiniportChangeDeviceStatus)
+        )
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+__forceinline
+BOOLEAN
+_NetworkPortValidateBufferDescription(
+    IN      PMINIPORT_BUFFER_DESCRIPTION    BufferDescription
+    )
+{
+    ASSERT( NULL != BufferDescription );
+
+    if ((0 == BufferDescription->NumberOfBuffers) ||
+        (0 == BufferDescription->DescriptorSize) ||
+        (0 == BufferDescription->BufferSize)
+        )
+    {
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static
+STATUS
+_NetworkPortConfigureDevice(
+    IN                          PDRIVER_OBJECT          DriverObject,
+    IN                          PMINIPORT_REGISTRATION  MiniportRegistration,
+    IN                          PPCI_DEVICE_DESCRIPTION PciDevice,
+    OUT_WRITES_ALL(MiniportRegistration->RxBuffers.NumberOfBuffers)
+                                PHYSICAL_ADDRESS*       RxPhysicalAddresses,
+    OUT_WRITES_ALL(MiniportRegistration->TxBuffers.NumberOfBuffers)
+                                PHYSICAL_ADDRESS*       TxPhysicalAddresses
+    );
+
+static
+STATUS
+_NetworkPortInitializeMiniportBuffers(
+    IN      PMINIPORT_BUFFER_DESCRIPTION                    BufferDescription,
+    OUT_WRITES_ALL(BufferDescription->NumberOfBuffers)
+            PHYSICAL_ADDRESS*                               PhysicalAddresses,
+    OUT_PTR PVOID**                                         BufferArray,
+    OUT_PTR PVOID*                                          DescriptorArray
+    );
+
+STATUS
+NetworkPortRegisterMiniportDriver(
+    IN      PDRIVER_OBJECT          DriverObject,
+    IN      PMINIPORT_REGISTRATION  MiniportRegistration
+    )
+{
+    STATUS status;
+    PPCI_DEVICE_DESCRIPTION* pPciDevices;
+    DWORD noOfDevices;
+    DWORD i, j;
+    PHYSICAL_ADDRESS* pRxPhysicalAddresses;
+    PHYSICAL_ADDRESS* pTxPhysicalAddresses;
+    DWORD noOfDevicesInitialized;
+    DWORD noOfRxBuffers;
+    DWORD noOfTxBuffers;
+
+    if (NULL == DriverObject)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == MiniportRegistration)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (!_NetworkPortValidateBufferDescription(&MiniportRegistration->RxBuffers))
+    {
+        return STATUS_INVALID_BUFFER;
+    }
+
+    if (!_NetworkPortValidateBufferDescription(&MiniportRegistration->TxBuffers))
+    {
+        return STATUS_INVALID_BUFFER;
+    }
+
+    if (!_NetworkPortValidateMiniportFunctions(&MiniportRegistration->MiniportFunctions))
+    {
+        return STATUS_INVALID_FUNCTION;
+    }
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pPciDevices = NULL;
+    noOfDevices = 0;
+    pRxPhysicalAddresses = NULL;
+    noOfDevicesInitialized = 0;
+    noOfRxBuffers = MiniportRegistration->RxBuffers.NumberOfBuffers;
+    noOfTxBuffers = MiniportRegistration->TxBuffers.NumberOfBuffers;
+    pRxPhysicalAddresses = NULL;
+    pTxPhysicalAddresses = NULL;
+
+    DriverObject->DispatchFunctions[IRP_MJ_DEVICE_CONTROL] = NetPortDeviceControl;
+
+    __try
+    {
+        status = IoGetPciDevicesMatchingSpecification(MiniportRegistration->Specification,
+                                                      &pPciDevices,
+                                                      &noOfDevices
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoGetPciDevicesMatchingSpecification", status);
+            __leave;
+        }
+
+        ASSERT(NULL == DriverObject->DriverExtension);
+        DriverObject->DriverExtension = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                                              sizeof(NETWORK_PORT_DRIVER_DATA),
+                                                              HEAP_PORT_TAG,
+                                                              0
+        );
+        if (NULL == DriverObject->DriverExtension)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExALlocatePoolWithTag", sizeof(NETWORK_PORT_DRIVER_DATA));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+        memcpy(&((PNETWORK_PORT_DRIVER_DATA)DriverObject->DriverExtension)->MiniportFunctions, &MiniportRegistration->MiniportFunctions, sizeof(MINIPORT_FUNCTIONS));
+
+        pRxPhysicalAddresses = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                                     sizeof(PHYSICAL_ADDRESS) * noOfRxBuffers,
+                                                     HEAP_TEMP_TAG,
+                                                     0
+        );
+        if (NULL == pRxPhysicalAddresses)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PHYSICAL_ADDRESS) * noOfRxBuffers);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        pTxPhysicalAddresses = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                                     sizeof(PHYSICAL_ADDRESS) * noOfTxBuffers,
+                                                     HEAP_TEMP_TAG,
+                                                     0
+        );
+        if (NULL == pTxPhysicalAddresses)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PHYSICAL_ADDRESS) * noOfTxBuffers);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        for (i = 0; i < noOfDevices; ++i)
+        {
+            // configure current PCI device
+            status = _NetworkPortConfigureDevice(DriverObject,
+                                                 MiniportRegistration,
+                                                 pPciDevices[i],
+                                                 pRxPhysicalAddresses,
+                                                 pTxPhysicalAddresses
+            );
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("_NetworkPortConfigureDevice", status);
+                continue;
+            }
+
+            LOGL("Successfully configured network device found on PCI location (%u.%u.%u)\n",
+                 pPciDevices[i]->DeviceLocation.Bus,
+                 pPciDevices[i]->DeviceLocation.Device,
+                 pPciDevices[i]->DeviceLocation.Function
+            );
+
+            // if we're here => we successfully initialized the device
+            noOfDevicesInitialized = noOfDevicesInitialized + 1;
+
+            for (j = 0; j < noOfRxBuffers; ++j)
+            {
+                pRxPhysicalAddresses[j] = NULL;
+            }
+            for (j = 0; j < noOfTxBuffers; ++j)
+            {
+                pTxPhysicalAddresses[j] = NULL;
+            }
+        }
+    }
+    __finally
+    {
+        if (NULL != pRxPhysicalAddresses)
+        {
+            for (j = 0; j < noOfRxBuffers; ++j)
+            {
+                if (NULL != pRxPhysicalAddresses[j])
+                {
+                    pRxPhysicalAddresses[j] = NULL;
+                }
+            }
+
+            ExFreePoolWithTag(pRxPhysicalAddresses, HEAP_TEMP_TAG);
+            pRxPhysicalAddresses = NULL;
+        }
+
+        if (NULL != pTxPhysicalAddresses)
+        {
+            for (j = 0; j < noOfTxBuffers; ++j)
+            {
+                if (NULL != pTxPhysicalAddresses[j])
+                {
+                    pTxPhysicalAddresses[j] = NULL;
+                }
+            }
+
+            ExFreePoolWithTag(pTxPhysicalAddresses, HEAP_TEMP_TAG);
+            pTxPhysicalAddresses = NULL;
+        }
+
+        if (NULL != pPciDevices)
+        {
+            IoFreeTemporaryData(pPciDevices);
+            pPciDevices = NULL;
+        }
+
+        // if we initialized at least a device we can say we did our job :)
+        status = noOfDevicesInitialized > 1 ? STATUS_SUCCESS : STATUS_DEVICE_DOES_NOT_EXIST;
+
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != DriverObject->DriverExtension)
+            {
+                ExFreePoolWithTag(DriverObject->DriverExtension, HEAP_PORT_TAG);
+                DriverObject->DriverExtension = NULL;
+            }
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+PTR_SUCCESS
+PVOID
+NetworkPortGetMiniportExtension(
+    IN      PMINIPORT_DEVICE        Device
+    )
+{
+    ASSERT( NULL != Device );
+
+    return Device->DeviceExtension;
+}
+
+static
+STATUS
+_NetworkPortConfigureDevice(
+    IN                          PDRIVER_OBJECT          DriverObject,
+    IN                          PMINIPORT_REGISTRATION  MiniportRegistration,
+    IN                          PPCI_DEVICE_DESCRIPTION PciDevice,
+    OUT_WRITES_ALL(MiniportRegistration->RxBuffers.NumberOfBuffers)
+                                PHYSICAL_ADDRESS*       RxPhysicalAddresses,
+    OUT_WRITES_ALL(MiniportRegistration->TxBuffers.NumberOfBuffers)
+                                PHYSICAL_ADDRESS*       TxPhysicalAddresses
+    )
+{
+    MINIPORT_DEVICE_INITIALIZATION initialization;
+    STATUS status;
+    PDEVICE_OBJECT pDevObj;
+    PNETWORK_PORT_DEVICE pPortDevice;
+    PMINIPORT_DEVICE pMiniportDevice;
+    PVOID* pRxBuffers;
+    PVOID* pTxBuffers;
+    DWORD i;
+    IO_INTERRUPT ioInterrupt;
+
+    ASSERT( NULL != DriverObject );
+    ASSERT( NULL != MiniportRegistration );
+    ASSERT( NULL != PciDevice );
+
+    status = STATUS_SUCCESS;
+    memzero(&initialization, sizeof(MINIPORT_DEVICE_INITIALIZATION));
+    pDevObj = NULL;
+    pPortDevice = NULL;
+    pMiniportDevice= NULL;
+    pRxBuffers = NULL;
+    pTxBuffers = NULL;
+    memzero(&ioInterrupt, sizeof(IO_INTERRUPT));
+
+    __try
+    {
+        pDevObj = IoCreateDevice(DriverObject, sizeof(NETWORK_PORT_DEVICE), DeviceTypePhysicalNetcard);
+        if (NULL == pDevObj)
+        {
+            LOG_FUNC_ERROR_ALLOC("IoCreateDevice", sizeof(NETWORK_PORT_DEVICE));
+            status = STATUS_DEVICE_COULD_NOT_BE_CREATED;
+            __leave;
+        }
+
+        pPortDevice = IoGetDeviceExtension(pDevObj);
+        ASSERT(NULL != pPortDevice);
+
+        NetworkPortDevicePreinit(pPortDevice);
+
+        pMiniportDevice = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(MINIPORT_DEVICE), HEAP_PORT_TAG, 0);
+        if (NULL == pMiniportDevice)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(MINIPORT_DEVICE));
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+        pMiniportDevice->DeviceObject = pDevObj;
+
+        if (0 != MiniportRegistration->DeviceContextSize)
+        {
+            pMiniportDevice->DeviceExtension = ExAllocatePoolWithTag(PoolAllocateZeroMemory,
+                                                                     MiniportRegistration->DeviceContextSize,
+                                                                     HEAP_PORT_TAG,
+                                                                     0
+            );
+            if (NULL == pMiniportDevice->DeviceExtension)
+            {
+                LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", MiniportRegistration->DeviceContextSize);
+                status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                __leave;
+            }
+        }
+
+        status = _NetworkPortInitializeMiniportBuffers(&MiniportRegistration->RxBuffers,
+                                                       RxPhysicalAddresses,
+                                                       &pRxBuffers,
+                                                       &initialization.RxBuffers.RingBuffer
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_NetworkPortInitializeMiniportBuffers", status);
+            __leave;
+        }
+
+        status = _NetworkPortInitializeMiniportBuffers(&MiniportRegistration->TxBuffers,
+                                                       TxPhysicalAddresses,
+                                                       &pTxBuffers,
+                                                       &initialization.TxBuffers.RingBuffer
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("_NetworkPortInitializeMiniportBuffers", status);
+            __leave;
+        }
+
+        initialization.PciBar = PciDevice->DeviceData->Header.Device.Bar;
+
+        initialization.RxBuffers.NumberOfBuffers = MiniportRegistration->RxBuffers.NumberOfBuffers;
+        initialization.RxBuffers.Buffers = RxPhysicalAddresses;
+        initialization.RxBuffers.BufferSize = MiniportRegistration->RxBuffers.BufferSize;
+
+        initialization.TxBuffers.NumberOfBuffers = MiniportRegistration->TxBuffers.NumberOfBuffers;
+        initialization.TxBuffers.Buffers = TxPhysicalAddresses;
+        initialization.TxBuffers.BufferSize = MiniportRegistration->TxBuffers.BufferSize;
+
+        // initialize miniport device
+        status = MiniportRegistration->MiniportFunctions.MiniportInitializeDevice(pMiniportDevice,
+                                                                                  &initialization
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("MiniportInitializeDevice", status);
+            __leave;
+        }
+
+        LOG_TRACE_NETWORK("Miniport device successfully initialized\n");
+
+        // initialize port device
+        status = NetworkPortDeviceInit(pPortDevice,
+                                       pMiniportDevice,
+                                       MiniportRegistration->RxBuffers.NumberOfBuffers,
+                                       pRxBuffers,
+                                       MiniportRegistration->RxBuffers.BufferSize,
+                                       MiniportRegistration->TxBuffers.NumberOfBuffers,
+                                       pTxBuffers,
+                                       MiniportRegistration->TxBuffers.BufferSize
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NetworkPortDeviceInit", status);
+            __leave;
+        }
+
+        // register interrupt
+        ioInterrupt.Type = IoInterruptTypePci;
+        ioInterrupt.Irql = IrqlNetworkLevel;
+        ioInterrupt.ServiceRoutine = _NetworkPortGenericInterrupt;
+        ioInterrupt.Exclusive = FALSE;
+        ioInterrupt.Pci.PciDevice = PciDevice;
+
+        status = IoRegisterInterrupt(&ioInterrupt, pDevObj);
+        ASSERT(SUCCEEDED(status));
+
+        LOG_TRACE_NETWORK("Successfully registered interrupt for network device\n");
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pPortDevice)
+            {
+                NetworkPortDeviceUninit(pPortDevice);
+                pPortDevice = NULL;
+            }
+
+            if (NULL != pDevObj)
+            {
+                IoDeleteDevice(pDevObj);
+                pDevObj = NULL;
+            }
+
+            if (NULL != pMiniportDevice)
+            {
+                if (NULL != pMiniportDevice->DeviceExtension)
+                {
+                    ExFreePoolWithTag(pMiniportDevice->DeviceExtension, HEAP_PORT_TAG);
+                    pMiniportDevice->DeviceExtension = NULL;
+                }
+
+                ExFreePoolWithTag(pMiniportDevice, HEAP_PORT_TAG);
+                pMiniportDevice = NULL;
+            }
+
+            if (NULL != pRxBuffers)
+            {
+                for (i = 0; i < MiniportRegistration->RxBuffers.NumberOfBuffers; ++i)
+                {
+                    if (NULL != pRxBuffers[i])
+                    {
+                        IoFreeContinuousMemory(pRxBuffers[i]);
+                        pRxBuffers[i] = NULL;
+                    }
+                }
+
+                ExFreePoolWithTag(pRxBuffers, HEAP_PORT_TAG);
+                pRxBuffers = NULL;
+            }
+
+            if (NULL != pTxBuffers)
+            {
+                for (i = 0; i < MiniportRegistration->TxBuffers.NumberOfBuffers; ++i)
+                {
+                    if (NULL != pTxBuffers[i])
+                    {
+                        IoFreeContinuousMemory(pTxBuffers[i]);
+                        pTxBuffers[i] = NULL;
+                    }
+                }
+
+                ExFreePoolWithTag(pTxBuffers, HEAP_PORT_TAG);
+                pTxBuffers = NULL;
+            }
+        }
+    }
+
+    return status;
+}
+
+static
+STATUS
+_NetworkPortInitializeMiniportBuffers(
+    IN      PMINIPORT_BUFFER_DESCRIPTION                    BufferDescription,
+    OUT_WRITES_ALL(BufferDescription->NumberOfBuffers)
+            PHYSICAL_ADDRESS*                               PhysicalAddresses,
+    OUT_PTR PVOID**                                         BufferArray,
+    OUT_PTR PVOID*                                          DescriptorArray
+    )
+{
+    STATUS status;
+    PVOID* bufferArray;
+    PVOID descriptorArray;
+    DWORD i;
+
+    ASSERT( NULL != BufferDescription );
+    ASSERT( NULL != BufferArray );
+    ASSERT( NULL != DescriptorArray );
+
+    status = STATUS_SUCCESS;
+    bufferArray = NULL;
+    descriptorArray = NULL;
+    i = 0;
+
+    __try
+    {
+        bufferArray = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(PVOID) * BufferDescription->NumberOfBuffers, HEAP_PORT_TAG, 0);
+        if (NULL == bufferArray)
+        {
+            LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(PVOID) * BufferDescription->NumberOfBuffers);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+
+        for (i = 0; i < BufferDescription->NumberOfBuffers; ++i)
+        {
+            bufferArray[i] = IoAllocateContinuousMemory(BufferDescription->BufferSize);
+            if (NULL == bufferArray[i])
+            {
+                LOG_FUNC_ERROR_ALLOC("IoAllocateContinuousMemory", BufferDescription->BufferSize);
+                status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                __leave;
+            }
+
+            PhysicalAddresses[i] = IoGetPhysicalAddress(bufferArray[i]);
+            ASSERT(NULL != PhysicalAddresses[i]);
+        }
+
+        descriptorArray = IoAllocateContinuousMemory(BufferDescription->NumberOfBuffers * BufferDescription->DescriptorSize);
+        if (NULL == descriptorArray)
+        {
+            LOG_FUNC_ERROR_ALLOC("IoAllocateContinuousMemory", BufferDescription->NumberOfBuffers * BufferDescription->DescriptorSize);
+            status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != descriptorArray)
+            {
+                IoFreeContinuousMemory(descriptorArray);
+                descriptorArray = NULL;
+            }
+
+            if (NULL != bufferArray)
+            {
+                for (i = 0; i < BufferDescription->NumberOfBuffers; ++i)
+                {
+                    if (NULL != bufferArray[i])
+                    {
+                        IoFreeContinuousMemory(bufferArray[i]);
+                        bufferArray[i] = NULL;
+                    }
+                }
+
+                ExFreePoolWithTag(bufferArray, HEAP_PORT_TAG);
+                bufferArray = NULL;
+            }
+        }
+        else
+        {
+            *BufferArray = bufferArray;
+            *DescriptorArray = descriptorArray;
+        }
+    }
+
+    return status;
+}
+
+static
+BOOLEAN
+(__cdecl _NetworkPortGenericInterrupt)(
+    IN      PDEVICE_OBJECT  Device
+    )
+{
+    PNETWORK_PORT_DEVICE pPortDevice;
+    PMINIPORT_DEVICE pMiniportDevice;
+    PNETWORK_PORT_DRIVER_DATA pDriverExtension;
+
+    ASSERT(NULL != Device);
+
+    pPortDevice = IoGetDeviceExtension(Device);
+    ASSERT(NULL != pPortDevice);
+
+    pMiniportDevice = pPortDevice->Miniport;
+    ASSERT(NULL != pMiniportDevice);
+
+    pDriverExtension = IoGetDriverExtension( Device );
+    ASSERT( NULL != pDriverExtension );
+
+    ASSERT( NULL != pDriverExtension->MiniportFunctions.MiniportInterruptHandler);
+
+    return pDriverExtension->MiniportFunctions.MiniportInterruptHandler( pMiniportDevice );
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkPort/src/network_structures.c b/src_proiect/NetworkPort/src/network_structures.c
new file mode 100644
index 0000000..980e590
--- /dev/null
+++ b/src_proiect/NetworkPort/src/network_structures.c
@@ -0,0 +1,304 @@
+#include "network_port_base.h"
+#include "network_dispatch.h"
+#include "ex.h"
+
+__forceinline
+void
+_NetworkPortPreinitBuffers(
+    OUT         PPORT_BUFFERS           Buffers
+    )
+{
+    memzero(Buffers, sizeof(PORT_BUFFERS));
+
+    LockInit(&Buffers->FramesLock);
+    InitializeListHead(&Buffers->FramesList);
+}
+
+__forceinline
+void
+_NetworkPortDeviceInitBuffers(
+    OUT         PPORT_BUFFERS           PortBuffers,
+    IN          DWORD                   NumberOfBuffers,
+    IN          PVOID*                  Buffers,
+    IN          WORD                    BufferSize
+    )
+{
+    ASSERT( NULL != PortBuffers );
+    ASSERT( 0 != NumberOfBuffers );
+    ASSERT( NULL != Buffers );
+    ASSERT( 0 != BufferSize );
+
+    PortBuffers->NumberOfBuffers = NumberOfBuffers;
+    PortBuffers->Buffers = (PVOID*)Buffers;
+    PortBuffers->BufferSize = BufferSize;
+}
+
+static
+STATUS
+_NetworkPortDeviceInitRx(
+    INOUT       PRX_DATA                RxData,
+    IN          DWORD                   NumberOfReceiveBuffers,
+    IN          PVOID*                  ReceiveBuffers,
+    IN          WORD                    ReceiveBufferSize
+    );
+
+static
+STATUS
+_NetworkPortDeviceInitTx(
+    INOUT       PTX_DATA                TxData,
+    IN          PNETWORK_PORT_DEVICE    PortDevice,
+    IN          DWORD                   NumberOfTransmitBuffers,
+    IN          PVOID*                  TransmitBuffers,
+    IN          WORD                    TransmitBufferSize
+    );
+
+void
+NetworkPortDevicePreinit(
+    OUT         PNETWORK_PORT_DEVICE    PortDevice
+    )
+{
+    ASSERT( NULL != PortDevice );
+
+    memzero(PortDevice, sizeof(NETWORK_PORT_DEVICE));
+
+    _NetworkPortPreinitBuffers(&PortDevice->RxData.Buffers);
+    _NetworkPortPreinitBuffers(&PortDevice->TxData.Buffers);
+}
+
+STATUS
+NetworkPortDeviceInit(
+    INOUT       PNETWORK_PORT_DEVICE    PortDevice,
+    IN          PMINIPORT_DEVICE        MiniportDevice,
+    IN          DWORD                   NumberOfReceiveBuffers,
+    IN          PVOID*                  ReceiveBuffers,
+    IN          WORD                    ReceiveBufferSize,
+    IN          DWORD                   NumberOfTransmitBuffers,
+    IN          PVOID*                  TransmitBuffers,
+    IN          WORD                    TransmitBufferSize
+    )
+{
+    STATUS status;
+
+    if (NULL == PortDevice)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (NULL == MiniportDevice)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == NumberOfReceiveBuffers)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (NULL == ReceiveBuffers)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    if (0 == ReceiveBufferSize)
+    {
+        return STATUS_INVALID_PARAMETER5;
+    }
+
+    if (0 == NumberOfTransmitBuffers)
+    {
+        return STATUS_INVALID_PARAMETER6;
+    }
+
+    if (NULL == TransmitBuffers)
+    {
+        return STATUS_INVALID_PARAMETER7;
+    }
+
+    if (0 == TransmitBufferSize)
+    {
+        return STATUS_INVALID_PARAMETER8;
+    }
+
+    status = STATUS_SUCCESS;
+
+    PortDevice->Miniport = MiniportDevice;
+
+    status = _NetworkPortDeviceInitRx(&PortDevice->RxData,
+                                      NumberOfReceiveBuffers,
+                                      ReceiveBuffers,
+                                      ReceiveBufferSize
+                                      );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_NetworkPortDeviceInitRx", status );
+        return status;
+    }
+
+    status = _NetworkPortDeviceInitTx(&PortDevice->TxData,
+                                      PortDevice,
+                                      NumberOfTransmitBuffers,
+                                      TransmitBuffers,
+                                      TransmitBufferSize
+                                      );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("_NetworkPortDeviceInitTx", status);
+        return status;
+    }
+
+
+    return status;
+}
+
+void
+NetworkPortDeviceUninit(
+    INOUT       PNETWORK_PORT_DEVICE    PortDevice
+    )
+{
+    PMINIPORT_DEVICE pMiniportDevice;
+
+    ASSERT( NULL != PortDevice );
+
+    pMiniportDevice = PortDevice->Miniport;
+
+    if (NULL != pMiniportDevice)
+    {
+        if (NULL != pMiniportDevice->DeviceObject)
+        {
+            PNETWORK_PORT_DRIVER_DATA pDriverData = IoGetDriverExtension(pMiniportDevice->DeviceObject);
+            if (NULL != pDriverData)
+            {
+                if (NULL != pDriverData->MiniportFunctions.MiniportUninitializeDevice)
+                {
+                    pDriverData->MiniportFunctions.MiniportUninitializeDevice(pMiniportDevice);
+                }
+            }
+        }
+
+        if (NULL != pMiniportDevice->DeviceExtension)
+        {
+            ExFreePoolWithTag(pMiniportDevice->DeviceExtension, HEAP_PORT_TAG);
+            pMiniportDevice->DeviceExtension = NULL;
+        }
+
+        ExFreePoolWithTag(pMiniportDevice, HEAP_PORT_TAG);
+        pMiniportDevice = NULL;
+    }
+
+    if (NULL != PortDevice->RxData.Buffers.Buffers)
+    {
+        ExFreePoolWithTag(PortDevice->RxData.Buffers.Buffers, HEAP_PORT_TAG);
+        PortDevice->RxData.Buffers.Buffers = NULL;
+    }
+
+    if (NULL != PortDevice->TxData.Buffers.Buffers)
+    {
+        ExFreePoolWithTag(PortDevice->TxData.Buffers.Buffers, HEAP_PORT_TAG);
+        PortDevice->TxData.Buffers.Buffers = NULL;
+    }
+
+    memzero(PortDevice, sizeof(NETWORK_PORT_DEVICE));
+}
+
+PTR_SUCCESS
+PFRAME_DESCRIPTOR_ENTRY
+NetworkPortAllocateFrameDescriptor(
+    IN          DWORD                   BufferSize
+    )
+{
+    ASSERT(0 != BufferSize);
+
+    return ExAllocatePoolWithTag(0, sizeof(FRAME_DESCRIPTOR_ENTRY) + BufferSize, HEAP_PORT_TAG, 0);
+}
+
+void
+NetworkPortFreeFrameDescriptor(
+    IN          PFRAME_DESCRIPTOR_ENTRY Descriptor
+    )
+{
+    ASSERT( NULL != Descriptor );
+
+    ExFreePoolWithTag(Descriptor, HEAP_PORT_TAG);
+}
+
+static
+STATUS
+_NetworkPortDeviceInitRx(
+    INOUT       PRX_DATA                RxData,
+    IN          DWORD                   NumberOfReceiveBuffers,
+    IN          PVOID*                  ReceiveBuffers,
+    IN          WORD                    ReceiveBufferSize
+    )
+{
+    STATUS status;
+
+    ASSERT( NULL != RxData );
+
+    status = STATUS_SUCCESS;
+
+    _NetworkPortDeviceInitBuffers(&RxData->Buffers,
+                                  NumberOfReceiveBuffers,
+                                  ReceiveBuffers,
+                                  ReceiveBufferSize
+                                  );
+
+    status = ExEventInit(&RxData->Buffers.FramesListNotEmptyEvent, ExEventTypeNotification, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ExEventInit", status);
+        return status;
+    }
+
+    return status;
+}
+
+static
+STATUS
+_NetworkPortDeviceInitTx(
+    INOUT       PTX_DATA                TxData,
+    IN          PNETWORK_PORT_DEVICE    PortDevice,
+    IN          DWORD                   NumberOfTransmitBuffers,
+    IN          PVOID*                  TransmitBuffers,
+    IN          WORD                    TransmitBufferSize
+    )
+{
+    STATUS status;
+
+    ASSERT(NULL != TxData);
+
+    status = STATUS_SUCCESS;
+
+    _NetworkPortDeviceInitBuffers(&TxData->Buffers,
+                                  NumberOfTransmitBuffers,
+                                  TransmitBuffers,
+                                  TransmitBufferSize
+                                  );
+
+    status = ExEventInit(&TxData->Buffers.FramesListNotEmptyEvent, ExEventTypeNotification, FALSE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ExEventInit", status);
+        return status;
+    }
+
+    status = ExEventInit(&TxData->DescriptorsAvailable, ExEventTypeNotification, TRUE);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ExEventInit", status);
+        return status;
+    }
+
+    status = ThreadCreate("TX worker thread",
+                          ThreadPriorityDefault,
+                          NetPortTransmitFunction,
+                          PortDevice,
+                          &PortDevice->TxData.TransmitWorkerThread
+                          );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("ThreadCreate", status);
+        return status;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/NetworkStack.vcxproj b/src_proiect/NetworkStack/NetworkStack.vcxproj
new file mode 100644
index 0000000..d8519ba
--- /dev/null
+++ b/src_proiect/NetworkStack/NetworkStack.vcxproj
@@ -0,0 +1,134 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{9412F640-A271-4661-B437-5932E9B95C26}</ProjectGuid>
+    <RootNamespace>NetworkStack</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\network_device.c" />
+    <ClCompile Include="src\network_interface.c" />
+    <ClCompile Include="src\network_operations.c" />
+    <ClCompile Include="src\network_stack.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\network_internal.h" />
+    <ClInclude Include="headers\network_operations.h" />
+    <ClInclude Include="headers\network_stack_base.h" />
+    <ClInclude Include="inc\network_stack.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/NetworkStack.vcxproj.filters b/src_proiect/NetworkStack/NetworkStack.vcxproj.filters
new file mode 100644
index 0000000..ee465d3
--- /dev/null
+++ b/src_proiect/NetworkStack/NetworkStack.vcxproj.filters
@@ -0,0 +1,48 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{1f3e4f69-6cc7-4e92-a3a4-eab205a128b6}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\network_stack.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\network_stack_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\network_operations.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\network_internal.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\network_stack.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_interface.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_device.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\network_operations.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/headers/network_internal.h b/src_proiect/NetworkStack/headers/network_internal.h
new file mode 100644
index 0000000..3fcc230
--- /dev/null
+++ b/src_proiect/NetworkStack/headers/network_internal.h
@@ -0,0 +1,42 @@
+#pragma once
+
+#include "lock_common.h"
+#include "network_device.h"
+
+typedef struct _NETWORK_DEVICE
+{
+    PDEVICE_OBJECT              PhysicalDevice;
+    LIST_ENTRY                  NextDevice;
+
+    NETWORK_DEVICE_INFO         Info;
+} NETWORK_DEVICE, *PNETWORK_DEVICE;
+
+typedef struct _NETWORK_STACK_DATA
+{
+    BOOLEAN                     NetworkingEnabled;
+
+    /// should be executive synch mechanism
+    RW_SPINLOCK                 DeviceLock;
+
+    _Guarded_by_(DeviceLock)
+    DWORD                       NumberOfDevices;
+
+    _Guarded_by_(DeviceLock)
+    LIST_ENTRY                  NetworkDeviceList;             
+} NETWORK_STACK_DATA, *PNETWORK_STACK_DATA;
+
+_No_competing_thread_
+void
+NetworkDevicePreinit(
+    OUT     PNETWORK_DEVICE     Device,
+    IN      PDEVICE_OBJECT      DeviceObject,
+    IN      DEVICE_ID           DeviceId
+    );
+
+_No_competing_thread_
+STATUS
+NetworkDeviceInitialize(
+    INOUT    PNETWORK_DEVICE    Device
+    );
+
+extern NETWORK_STACK_DATA m_netStackData;
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/headers/network_operations.h b/src_proiect/NetworkStack/headers/network_operations.h
new file mode 100644
index 0000000..430ee38
--- /dev/null
+++ b/src_proiect/NetworkStack/headers/network_operations.h
@@ -0,0 +1,31 @@
+#pragma once
+
+STATUS
+NetOpGetPhysicalAddress(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    OUT         PMAC_ADDRESS            Address
+    );
+
+PTR_SUCCESS
+PNETWORK_DEVICE
+NetOpGetDeviceById(
+    IN          DEVICE_ID               Device
+    );
+
+STATUS
+NetOpGetDeviceStatus(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    OUT         PNETWORK_DEVICE_STATUS  DeviceStatus
+    );
+
+STATUS
+NetOpSetDeviceStatus(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    IN          PNETWORK_DEVICE_STATUS  DeviceStatus
+    );
+
+STATUS
+NetOpGetLinkStatus(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    OUT         BOOLEAN*                LinkStatus
+    );
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/headers/network_stack_base.h b/src_proiect/NetworkStack/headers/network_stack_base.h
new file mode 100644
index 0000000..725a582
--- /dev/null
+++ b/src_proiect/NetworkStack/headers/network_stack_base.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#include "common_lib.h"
+#include "log.h"
+#include "io.h"
+#include "ex.h"
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/inc/network_stack.h b/src_proiect/NetworkStack/inc/network_stack.h
new file mode 100644
index 0000000..6a1251d
--- /dev/null
+++ b/src_proiect/NetworkStack/inc/network_stack.h
@@ -0,0 +1,19 @@
+#pragma once
+
+_No_competing_thread_
+void
+NetworkStackPreinit(
+    void
+    );
+
+_No_competing_thread_
+STATUS
+NetworkStackInit(
+    IN  BOOLEAN     EnableNetworking
+    );
+
+_No_competing_thread_
+STATUS
+NetworkStackSetState(
+    IN  BOOLEAN     EnableNetworking
+    );
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/src/network_device.c b/src_proiect/NetworkStack/src/network_device.c
new file mode 100644
index 0000000..3172c94
--- /dev/null
+++ b/src_proiect/NetworkStack/src/network_device.c
@@ -0,0 +1,55 @@
+#include "network_stack_base.h"
+#include "network_internal.h"
+#include "network_operations.h"
+
+_No_competing_thread_
+void
+NetworkDevicePreinit(
+    OUT     PNETWORK_DEVICE     Device,
+    IN      PDEVICE_OBJECT      DeviceObject,
+    IN      DEVICE_ID           DeviceId
+    )
+{
+    ASSERT(NULL != Device);
+    ASSERT(NULL != DeviceObject);
+
+    Device->PhysicalDevice = DeviceObject;
+    Device->Info.DeviceId = DeviceId;
+}
+
+_No_competing_thread_
+STATUS
+NetworkDeviceInitialize(
+    INOUT    PNETWORK_DEVICE    Device
+    )
+{
+    STATUS status;
+
+    ASSERT(NULL != Device);
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+
+    status = NetOpGetPhysicalAddress(Device->PhysicalDevice,
+                                     &Device->Info.PhysicalAddress
+                                     );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NetOpGetPhysicalAddress", status);
+        return status;
+    }
+
+    status = NetOpGetDeviceStatus(Device->PhysicalDevice,
+                                  &Device->Info.DeviceStatus
+                                  );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NetOpGetDeviceStatus", status);
+        return status;
+    }
+
+    LOG_FUNC_END;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/src/network_interface.c b/src_proiect/NetworkStack/src/network_interface.c
new file mode 100644
index 0000000..996d11e
--- /dev/null
+++ b/src_proiect/NetworkStack/src/network_interface.c
@@ -0,0 +1,280 @@
+#include "network_stack_base.h"
+#include "network.h"
+#include "network_internal.h"
+#include "network_operations.h"
+
+STATUS
+NetSendFrame(
+    IN                      BOOLEAN         SendOnAllInterfaces,
+    _When_(SendOnAllInterfaces, _Reserved_)
+    _When_(!SendOnAllInterfaces, IN)
+                            DEVICE_ID       DeviceId,
+    IN_READS_BYTES(Size)    PVOID           Buffer,
+    IN                      DWORD           Size,
+    IN                      MAC_ADDRESS     DestinationAddress
+    )
+{
+    STATUS status;
+    PNETWORK_DEVICE pNetDevice;
+    PIRP pIrp;
+    PETHERNET_FRAME pFrame;
+
+    if (NULL == Buffer)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (0 == Size)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    if (SendOnAllInterfaces)
+    {
+        LOG_ERROR("SendOnAllInterfaces not implemented!\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    status = STATUS_NOT_IMPLEMENTED;
+    pIrp = NULL;
+    pNetDevice = NULL;
+    pFrame = Buffer;
+
+    pNetDevice = NetOpGetDeviceById(DeviceId);
+    if (NULL == pNetDevice)
+    {
+        return STATUS_DEVICE_DOES_NOT_EXIST;
+    }
+
+    memcpy(&pFrame->Source, &pNetDevice->Info.PhysicalAddress, sizeof(MAC_ADDRESS));
+    memcpy(&pFrame->Destination, (PMAC_ADDRESS) &DestinationAddress, sizeof(MAC_ADDRESS) );
+
+    __try
+    {
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_NET_SEND_FRAME,
+                                             pNetDevice->PhysicalDevice,
+                                             Buffer,
+                                             Size,
+                                             NULL,
+                                             0
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(pNetDevice->PhysicalDevice,
+                              pIrp
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+NetReceiveFrame(
+    IN                      DEVICE_ID       DeviceId,
+    OUT_WRITES_BYTES(Size)  PVOID           Buffer,
+    IN                      DWORD           Size,
+    OUT                     DWORD*          BytesWritten
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    PETHERNET_FRAME pFrame;
+    PNETWORK_DEVICE pNetDevice;
+
+    if (NULL == Buffer)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (0 == Size)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (NULL == BytesWritten)
+    {
+        return STATUS_INVALID_PARAMETER4;
+    }
+
+    status = STATUS_NOT_IMPLEMENTED;
+    pIrp = NULL;
+    pFrame = NULL;
+
+    pNetDevice = NetOpGetDeviceById(DeviceId);
+    if (NULL == pNetDevice)
+    {
+        return STATUS_DEVICE_DOES_NOT_EXIST;
+    }
+
+    __try
+    {
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_NET_RECEIVE_FRAME,
+                                             pNetDevice->PhysicalDevice,
+                                             NULL,
+                                             0,
+                                             Buffer,
+                                             Size
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(pNetDevice->PhysicalDevice,
+                              pIrp
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        ASSERT(pIrp->IoStatus.Information <= MAX_DWORD);
+        *BytesWritten = (DWORD)pIrp->IoStatus.Information;
+        if (!SUCCEEDED(status))
+        {
+            if (STATUS_BUFFER_TOO_SMALL != status)
+            {
+                LOG_FUNC_ERROR("IoCallDriver", status);
+                __leave;
+            }
+            LOG_WARNING("IoCallDriver failed before buffer of size %u was too small, %u bytes are required\n", Size, *BytesWritten);
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+    }
+
+    return status;
+}
+
+STATUS
+NetGetNetworkDevices(
+    OUT_WRITES_OPT(*NumberOfDevices)
+            PNETWORK_DEVICE_INFO            DeviceObjects,
+    _When_(NULL == DeviceObjects, OUT)
+    _When_(NULL != DeviceObjects, INOUT)
+            DWORD*                          NumberOfDevices
+    )
+{
+    STATUS status;
+    INTR_STATE intrState;
+    DWORD i;
+
+    if (NULL == NumberOfDevices)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    status = STATUS_SUCCESS;
+    i = 0;
+
+    RwSpinlockAcquireShared(&m_netStackData.DeviceLock, &intrState);
+    
+    __try
+    {
+        if (NULL != DeviceObjects)
+        {
+            if (*NumberOfDevices < m_netStackData.NumberOfDevices)
+            {
+                status = STATUS_BUFFER_TOO_SMALL;
+            }
+            else
+            {
+                PLIST_ENTRY pEntry;
+
+                for (pEntry = m_netStackData.NetworkDeviceList.Flink;
+                     pEntry != &m_netStackData.NetworkDeviceList;
+                     pEntry = pEntry->Flink)
+                {
+                    PNETWORK_DEVICE pNetDevice;
+
+                    pNetDevice = CONTAINING_RECORD(pEntry, NETWORK_DEVICE, NextDevice);
+
+                    status = NetOpGetDeviceStatus(pNetDevice->PhysicalDevice,
+                                                  &pNetDevice->Info.DeviceStatus
+                    );
+                    if (!SUCCEEDED(status))
+                    {
+                        LOG_FUNC_ERROR("NetOpGetDeviceStatus", status);
+                        __leave;
+                    }
+
+                    status = NetOpGetLinkStatus(pNetDevice->PhysicalDevice,
+                                                &pNetDevice->Info.LinkStatus
+                    );
+                    if (!SUCCEEDED(status))
+                    {
+                        LOG_FUNC_ERROR("NetOpGetDeviceStatus", status);
+                        __leave;
+                    }
+
+                    memcpy(&DeviceObjects[i], &pNetDevice->Info, sizeof(NETWORK_DEVICE_INFO));
+                    ++i;
+                }
+            }
+        }
+        *NumberOfDevices = m_netStackData.NumberOfDevices;
+    }
+    __finally
+    {
+        RwSpinlockReleaseShared(&m_netStackData.DeviceLock, intrState);
+    }
+
+    return status;
+}
+
+STATUS
+NetChangeDeviceStatus(
+    IN              DEVICE_ID                       DeviceId,
+    IN              PNETWORK_DEVICE_STATUS          DeviceStatus
+    )
+{
+    STATUS status;
+    PNETWORK_DEVICE pNetDevice;
+
+    if (NULL == DeviceStatus)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    pNetDevice = NetOpGetDeviceById(DeviceId);
+    if (NULL == pNetDevice)
+    {
+        return STATUS_DEVICE_DOES_NOT_EXIST;
+    }
+
+    status = NetOpSetDeviceStatus(pNetDevice->PhysicalDevice,
+                                  DeviceStatus
+                                  );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("NetOpSetDeviceStatus", status );
+        return status;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/src/network_operations.c b/src_proiect/NetworkStack/src/network_operations.c
new file mode 100644
index 0000000..ff0e28a
--- /dev/null
+++ b/src_proiect/NetworkStack/src/network_operations.c
@@ -0,0 +1,283 @@
+#include "network_stack_base.h"
+#include "network_internal.h"
+#include "network_operations.h"
+
+STATUS
+NetOpGetPhysicalAddress(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    OUT         PMAC_ADDRESS            Address
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    NET_GET_SET_PHYSICAL_ADDRESS physAddr;
+
+    LOG_FUNC_START;
+
+    ASSERT( NULL != DeviceObject );
+    ASSERT( NULL != Address );
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    memzero(&physAddr, sizeof(NET_GET_SET_PHYSICAL_ADDRESS));
+
+    __try
+    {
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_NET_GET_PHYSICAL_ADDRESS,
+                                             DeviceObject,
+                                             NULL,
+                                             0,
+                                             &physAddr,
+                                             sizeof(NET_GET_SET_PHYSICAL_ADDRESS)
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(DeviceObject,
+                              pIrp
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        memcpy(Address, &physAddr.Address, sizeof(MAC_ADDRESS));
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+PTR_SUCCESS
+PNETWORK_DEVICE
+NetOpGetDeviceById(
+    IN          DEVICE_ID               Device
+    )
+{
+    INTR_STATE intrState;
+    PLIST_ENTRY pEntry;
+    PNETWORK_DEVICE pResult;
+
+    pEntry = NULL;
+    pResult = NULL;
+
+    RwSpinlockAcquireShared(&m_netStackData.DeviceLock, &intrState);
+
+    for (pEntry = m_netStackData.NetworkDeviceList.Flink;
+        pEntry != &m_netStackData.NetworkDeviceList;
+        pEntry = pEntry->Flink)
+    {
+        PNETWORK_DEVICE pNetDevice = CONTAINING_RECORD(pEntry, NETWORK_DEVICE, NextDevice );
+
+        if (pNetDevice->Info.DeviceId == Device)
+        {
+            pResult = pNetDevice;
+            break;
+        }
+    }
+
+    RwSpinlockReleaseShared(&m_netStackData.DeviceLock, intrState );
+
+    return pResult;
+}
+
+STATUS
+NetOpGetDeviceStatus(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    OUT         PNETWORK_DEVICE_STATUS  DeviceStatus
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    NET_GET_SET_DEVICE_STATUS devStatus;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != DeviceStatus);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    memzero(&devStatus, sizeof(NET_GET_SET_DEVICE_STATUS));
+
+    __try
+    {
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_NET_GET_DEVICE_STATUS,
+                                             DeviceObject,
+                                             NULL,
+                                             0,
+                                             &devStatus,
+                                             sizeof(NET_GET_SET_DEVICE_STATUS)
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(DeviceObject,
+                              pIrp
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        memcpy(DeviceStatus, &devStatus.DeviceStatus, sizeof(NET_GET_SET_DEVICE_STATUS));
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+STATUS
+NetOpSetDeviceStatus(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    IN          PNETWORK_DEVICE_STATUS  DeviceStatus
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    NET_GET_SET_DEVICE_STATUS devStatus;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != DeviceStatus);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    memzero(&devStatus, sizeof(NET_GET_SET_DEVICE_STATUS));
+    memcpy(&devStatus.DeviceStatus, DeviceStatus, sizeof(NETWORK_DEVICE_STATUS));
+
+    __try
+    {
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_NET_SET_DEVICE_STATUS,
+                                             DeviceObject,
+                                             &devStatus,
+                                             sizeof(NET_GET_SET_DEVICE_STATUS),
+                                             NULL,
+                                             0
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(DeviceObject,
+                              pIrp
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+STATUS
+NetOpGetLinkStatus(
+    IN          PDEVICE_OBJECT          DeviceObject,
+    OUT         BOOLEAN*                LinkStatus
+    )
+{
+    STATUS status;
+    PIRP pIrp;
+    NET_GET_LINK_STATUS linkStatus;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != LinkStatus);
+
+    status = STATUS_SUCCESS;
+    pIrp = NULL;
+    memzero(&linkStatus, sizeof(NET_GET_LINK_STATUS));
+
+    __try
+    {
+        pIrp = IoBuildDeviceIoControlRequest(IOCTL_NET_GET_LINK_STATUS,
+                                             DeviceObject,
+                                             NULL,
+                                             0,
+                                             &linkStatus,
+                                             sizeof(NET_GET_LINK_STATUS)
+        );
+        ASSERT(NULL != pIrp);
+
+        status = IoCallDriver(DeviceObject,
+                              pIrp
+        );
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        status = pIrp->IoStatus.Status;
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCallDriver", status);
+            __leave;
+        }
+
+        *LinkStatus = linkStatus.LinkUp;
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/NetworkStack/src/network_stack.c b/src_proiect/NetworkStack/src/network_stack.c
new file mode 100644
index 0000000..9c3c0f4
--- /dev/null
+++ b/src_proiect/NetworkStack/src/network_stack.c
@@ -0,0 +1,167 @@
+#include "network_stack_base.h"
+#include "network_stack.h"
+#include "network_internal.h"
+#include "network_operations.h"
+
+NETWORK_STACK_DATA m_netStackData;
+
+const MAC_ADDRESS MAC_BROADCAST = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+_No_competing_thread_
+__forceinline
+static
+DEVICE_ID
+_NetworkStackGetNextDeviceId(
+    void
+    )
+{
+    static DEVICE_ID __nextDeviceId = 0;
+
+    return __nextDeviceId++;
+}
+
+_No_competing_thread_
+void
+NetworkStackPreinit(
+    void
+    )
+{
+    memzero(&m_netStackData, sizeof(NETWORK_STACK_DATA));
+
+    InitializeListHead(&m_netStackData.NetworkDeviceList);
+    RwSpinlockInit(&m_netStackData.DeviceLock);
+
+    m_netStackData.NetworkingEnabled = TRUE;
+}
+
+_No_competing_thread_
+STATUS
+NetworkStackInit(
+    IN  BOOLEAN     EnableNetworking
+    )
+{
+    STATUS status;
+    PDEVICE_OBJECT* pNetworkDevices;
+    DWORD numberOfDevices;
+    DWORD i;
+    PNETWORK_DEVICE pNetDevice;
+
+    LOG_FUNC_START;
+
+    status = STATUS_SUCCESS;
+    pNetDevice = NULL;
+    pNetworkDevices = NULL;
+    numberOfDevices = 0;
+
+    status = IoGetDevicesByType(DeviceTypePhysicalNetcard, 
+                                &pNetworkDevices, 
+                                &numberOfDevices
+                                );
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetDeviceByType", status);
+        return status;
+    }
+
+    __try
+    {
+        for (i = 0; i < numberOfDevices; ++i)
+        {
+            if (NULL == pNetDevice)
+            {
+                pNetDevice = ExAllocatePoolWithTag(PoolAllocateZeroMemory, sizeof(NETWORK_DEVICE), HEAP_NET_TAG, 0);
+                if (NULL == pNetDevice)
+                {
+                    status = STATUS_HEAP_INSUFFICIENT_RESOURCES;
+                    LOG_FUNC_ERROR_ALLOC("ExAllocatePoolWithTag", sizeof(NETWORK_DEVICE));
+                    __leave;
+                }
+            }
+
+            ASSERT(NULL != pNetDevice);
+            NetworkDevicePreinit(pNetDevice, pNetworkDevices[i], _NetworkStackGetNextDeviceId());
+
+            status = NetworkDeviceInitialize(pNetDevice);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("NetworkDeviceInitialize", status);
+                __leave;
+            }
+
+            InsertTailList(&m_netStackData.NetworkDeviceList, &pNetDevice->NextDevice);
+            m_netStackData.NumberOfDevices++;
+            pNetDevice = NULL;
+        }
+
+        status = NetworkStackSetState(EnableNetworking);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NetworkStackSetState", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (NULL != pNetworkDevices)
+        {
+            IoFreeTemporaryData(pNetworkDevices);
+            pNetworkDevices = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+_No_competing_thread_
+STATUS
+NetworkStackSetState(
+    IN  BOOLEAN     EnableNetworking
+    )
+{
+    STATUS status;
+    PLIST_ENTRY pCurEntry;
+    NETWORK_DEVICE_STATUS devStatus;
+
+    if (!(EnableNetworking ^ m_netStackData.NetworkingEnabled))
+    {
+        // no change in state
+        return STATUS_ALREADY_INITIALIZED_HINT;
+    }
+
+    status = STATUS_SUCCESS;
+    pCurEntry = NULL;
+    memzero(&devStatus, sizeof(NETWORK_DEVICE_STATUS));
+
+    devStatus.RxEnabled = EnableNetworking;
+    devStatus.TxEnabled = EnableNetworking;
+
+    LOG_FUNC_START;
+
+    LOG("Will change networking state %u -> %u\n", 
+        m_netStackData.NetworkingEnabled, EnableNetworking );
+
+    for (pCurEntry = m_netStackData.NetworkDeviceList.Flink;
+    pCurEntry != &m_netStackData.NetworkDeviceList;
+        pCurEntry = pCurEntry->Flink
+        )
+    {
+        PNETWORK_DEVICE pNetDevice = CONTAINING_RECORD(pCurEntry, NETWORK_DEVICE, NextDevice );
+
+        status = NetOpSetDeviceStatus(pNetDevice->PhysicalDevice,
+                                      &devStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("NetOpSetDeviceStatus", status );
+            break;
+        }
+    }
+
+
+    m_netStackData.NetworkingEnabled = EnableNetworking;
+
+    LOG_FUNC_END;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/PE_Parser.vcxproj b/src_proiect/PE_Parser/PE_Parser.vcxproj
new file mode 100644
index 0000000..d102455
--- /dev/null
+++ b/src_proiect/PE_Parser/PE_Parser.vcxproj
@@ -0,0 +1,131 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{E990BC83-862E-4E94-ACD2-DED7CD3E8E4A}</ProjectGuid>
+    <RootNamespace>PE_Parser</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <TargetExt>.lib</TargetExt>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <TargetExt>.lib</TargetExt>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\pe_parser.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\pe_base.h" />
+    <ClInclude Include="headers\pe_structures.h" />
+    <ClInclude Include="inc\pe_exports.h" />
+    <ClInclude Include="inc\pe_parser.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/PE_Parser.vcxproj.filters b/src_proiect/PE_Parser/PE_Parser.vcxproj.filters
new file mode 100644
index 0000000..3a8d5e0
--- /dev/null
+++ b/src_proiect/PE_Parser/PE_Parser.vcxproj.filters
@@ -0,0 +1,39 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{0d1d933a-92d8-4d3c-b54d-c10e106454d8}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\pe_parser.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\pe_parser.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\pe_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\pe_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\pe_exports.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/headers/pe_base.h b/src_proiect/PE_Parser/headers/pe_base.h
new file mode 100644
index 0000000..de72c00
--- /dev/null
+++ b/src_proiect/PE_Parser/headers/pe_base.h
@@ -0,0 +1,3 @@
+#pragma once
+
+#include "common_lib.h"
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/headers/pe_structures.h b/src_proiect/PE_Parser/headers/pe_structures.h
new file mode 100644
index 0000000..9936755
--- /dev/null
+++ b/src_proiect/PE_Parser/headers/pe_structures.h
@@ -0,0 +1,156 @@
+#pragma once
+
+#define MZ_SIGNATURE                            'ZM'
+#define NT_SIGNATURE                             0x00004550  // PE00
+
+typedef unsigned __int64 ULONGLONG;
+typedef __int32 LONG;
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
+
+#pragma pack(push,1)
+typedef struct _IMAGE_DATA_DIRECTORY {
+    DWORD   VirtualAddress;
+    DWORD   Size;
+} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
+
+#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
+
+typedef struct _IMAGE_FILE_HEADER {
+    WORD    Machine;
+    WORD    NumberOfSections;
+    DWORD   TimeDateStamp;
+    DWORD   PointerToSymbolTable;
+    DWORD   NumberOfSymbols;
+    WORD    SizeOfOptionalHeader;
+    WORD    Characteristics;
+} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
+
+typedef struct _IMAGE_OPTIONAL_HEADER64 {
+    WORD        Magic;
+    BYTE        MajorLinkerVersion;
+    BYTE        MinorLinkerVersion;
+    DWORD       SizeOfCode;
+    DWORD       SizeOfInitializedData;
+    DWORD       SizeOfUninitializedData;
+    DWORD       AddressOfEntryPoint;
+    DWORD       BaseOfCode;
+    ULONGLONG   ImageBase;
+    DWORD       SectionAlignment;
+    DWORD       FileAlignment;
+    WORD        MajorOperatingSystemVersion;
+    WORD        MinorOperatingSystemVersion;
+    WORD        MajorImageVersion;
+    WORD        MinorImageVersion;
+    WORD        MajorSubsystemVersion;
+    WORD        MinorSubsystemVersion;
+    DWORD       Win32VersionValue;
+    DWORD       SizeOfImage;
+    DWORD       SizeOfHeaders;
+    DWORD       CheckSum;
+    WORD        Subsystem;
+    WORD        DllCharacteristics;
+    ULONGLONG   SizeOfStackReserve;
+    ULONGLONG   SizeOfStackCommit;
+    ULONGLONG   SizeOfHeapReserve;
+    ULONGLONG   SizeOfHeapCommit;
+    DWORD       LoaderFlags;
+    DWORD       NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
+
+typedef struct _IMAGE_OPTIONAL_HEADER {
+    //
+    // Standard fields.
+    //
+
+    WORD    Magic;
+    BYTE    MajorLinkerVersion;
+    BYTE    MinorLinkerVersion;
+    DWORD   SizeOfCode;
+    DWORD   SizeOfInitializedData;
+    DWORD   SizeOfUninitializedData;
+    DWORD   AddressOfEntryPoint;
+    DWORD   BaseOfCode;
+    DWORD   BaseOfData;
+
+    //
+    // NT additional fields.
+    //
+
+    DWORD   ImageBase;
+    DWORD   SectionAlignment;
+    DWORD   FileAlignment;
+    WORD    MajorOperatingSystemVersion;
+    WORD    MinorOperatingSystemVersion;
+    WORD    MajorImageVersion;
+    WORD    MinorImageVersion;
+    WORD    MajorSubsystemVersion;
+    WORD    MinorSubsystemVersion;
+    DWORD   Win32VersionValue;
+    DWORD   SizeOfImage;
+    DWORD   SizeOfHeaders;
+    DWORD   CheckSum;
+    WORD    Subsystem;
+    WORD    DllCharacteristics;
+    DWORD   SizeOfStackReserve;
+    DWORD   SizeOfStackCommit;
+    DWORD   SizeOfHeapReserve;
+    DWORD   SizeOfHeapCommit;
+    DWORD   LoaderFlags;
+    DWORD   NumberOfRvaAndSizes;
+    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
+} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
+
+typedef struct _IMAGE_NT_HEADERS64 {
+    DWORD Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
+} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;
+
+typedef struct _IMAGE_NT_HEADERS {
+    DWORD Signature;
+    IMAGE_FILE_HEADER FileHeader;
+    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
+} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
+
+typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
+    WORD   e_magic;                     // Magic number
+    WORD   e_cblp;                      // Bytes on last page of file
+    WORD   e_cp;                        // Pages in file
+    WORD   e_crlc;                      // Relocations
+    WORD   e_cparhdr;                   // Size of header in paragraphs
+    WORD   e_minalloc;                  // Minimum extra paragraphs needed
+    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
+    WORD   e_ss;                        // Initial (relative) SS value
+    WORD   e_sp;                        // Initial SP value
+    WORD   e_csum;                      // Checksum
+    WORD   e_ip;                        // Initial IP value
+    WORD   e_cs;                        // Initial (relative) CS value
+    WORD   e_lfarlc;                    // File address of relocation table
+    WORD   e_ovno;                      // Overlay number
+    WORD   e_res[4];                    // Reserved words
+    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
+    WORD   e_oeminfo;                   // OEM information; e_oemid specific
+    WORD   e_res2[10];                  // Reserved words
+    LONG   e_lfanew;                    // File address of new exe header
+} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
+
+#define IMAGE_SIZEOF_SHORT_NAME              8
+
+typedef struct _IMAGE_SECTION_HEADER {
+    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
+    union {
+        DWORD   PhysicalAddress;
+        DWORD   VirtualSize;
+    } Misc;
+    DWORD   VirtualAddress;
+    DWORD   SizeOfRawData;
+    DWORD   PointerToRawData;
+    DWORD   PointerToRelocations;
+    DWORD   PointerToLinenumbers;
+    WORD    NumberOfRelocations;
+    WORD    NumberOfLinenumbers;
+    DWORD   Characteristics;
+} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
+#pragma pack(pop)
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/inc/pe_exports.h b/src_proiect/PE_Parser/inc/pe_exports.h
new file mode 100644
index 0000000..36ea1b1
--- /dev/null
+++ b/src_proiect/PE_Parser/inc/pe_exports.h
@@ -0,0 +1,118 @@
+#pragma once
+
+#define IMAGE_FILE_MACHINE_I386             0x014c
+#define IMAGE_FILE_MACHINE_AMD64            0x8664
+
+#define IMAGE_SUBSYSTEM_UNKNOWN              0   // Unknown subsystem.
+#define IMAGE_SUBSYSTEM_NATIVE               1   // Image doesn't require a subsystem.
+
+typedef struct _PE_NT_HEADER_INFO
+{
+    // Refers to the addresses where the PE is currently loaded
+    PVOID               ImageBase;
+    PVOID               NtBase;
+    PVOID               AddressOfEntryPoint;
+
+    DWORD               ImageAlignment;
+    DWORD               FileAlignment;
+
+    // Refers to the addresses where the PE should ideally be loaded
+    struct 
+    {
+        PVOID           ImageBase;
+        PVOID           AddressOfEntryPoint;
+    } Preferred;
+
+    DWORD               Size;
+
+    WORD                Machine;
+    WORD                Subsystem;
+
+    DWORD               SizeOfHeaders;
+    DWORD               NumberOfSections;
+} PE_NT_HEADER_INFO, *PPE_NT_HEADER_INFO;
+
+//
+// Section characteristics.
+//
+//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
+//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
+//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
+//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
+#define IMAGE_SCN_TYPE_NO_PAD                0x00000008  // Reserved.
+//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.
+
+#define IMAGE_SCN_CNT_CODE                   0x00000020  // Section contains code.
+#define IMAGE_SCN_CNT_INITIALIZED_DATA       0x00000040  // Section contains initialized data.
+#define IMAGE_SCN_CNT_UNINITIALIZED_DATA     0x00000080  // Section contains uninitialized data.
+
+#define IMAGE_SCN_LNK_OTHER                  0x00000100  // Reserved.
+#define IMAGE_SCN_LNK_INFO                   0x00000200  // Section contains comments or some other type of information.
+//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
+#define IMAGE_SCN_LNK_REMOVE                 0x00000800  // Section contents will not become part of image.
+#define IMAGE_SCN_LNK_COMDAT                 0x00001000  // Section contents comdat.
+//                                           0x00002000  // Reserved.
+//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
+#define IMAGE_SCN_NO_DEFER_SPEC_EXC          0x00004000  // Reset speculative exceptions handling bits in the TLB entries for this section.
+#define IMAGE_SCN_GPREL                      0x00008000  // Section content can be accessed relative to GP
+#define IMAGE_SCN_MEM_FARDATA                0x00008000
+//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
+#define IMAGE_SCN_MEM_PURGEABLE              0x00020000
+#define IMAGE_SCN_MEM_16BIT                  0x00020000
+#define IMAGE_SCN_MEM_LOCKED                 0x00040000
+#define IMAGE_SCN_MEM_PRELOAD                0x00080000
+
+#define IMAGE_SCN_ALIGN_1BYTES               0x00100000  //
+#define IMAGE_SCN_ALIGN_2BYTES               0x00200000  //
+#define IMAGE_SCN_ALIGN_4BYTES               0x00300000  //
+#define IMAGE_SCN_ALIGN_8BYTES               0x00400000  //
+#define IMAGE_SCN_ALIGN_16BYTES              0x00500000  // Default alignment if no others are specified.
+#define IMAGE_SCN_ALIGN_32BYTES              0x00600000  //
+#define IMAGE_SCN_ALIGN_64BYTES              0x00700000  //
+#define IMAGE_SCN_ALIGN_128BYTES             0x00800000  //
+#define IMAGE_SCN_ALIGN_256BYTES             0x00900000  //
+#define IMAGE_SCN_ALIGN_512BYTES             0x00A00000  //
+#define IMAGE_SCN_ALIGN_1024BYTES            0x00B00000  //
+#define IMAGE_SCN_ALIGN_2048BYTES            0x00C00000  //
+#define IMAGE_SCN_ALIGN_4096BYTES            0x00D00000  //
+#define IMAGE_SCN_ALIGN_8192BYTES            0x00E00000  //
+// Unused                                    0x00F00000
+#define IMAGE_SCN_ALIGN_MASK                 0x00F00000
+
+#define IMAGE_SCN_LNK_NRELOC_OVFL            0x01000000  // Section contains extended relocations.
+#define IMAGE_SCN_MEM_DISCARDABLE            0x02000000  // Section can be discarded.
+#define IMAGE_SCN_MEM_NOT_CACHED             0x04000000  // Section is not cachable.
+#define IMAGE_SCN_MEM_NOT_PAGED              0x08000000  // Section is not pageable.
+#define IMAGE_SCN_MEM_SHARED                 0x10000000  // Section is shareable.
+#define IMAGE_SCN_MEM_EXECUTE                0x20000000  // Section is executable.
+#define IMAGE_SCN_MEM_READ                   0x40000000  // Section is readable.
+#define IMAGE_SCN_MEM_WRITE                  0x80000000  // Section is writeable.
+
+typedef struct _PE_SECTION_INFO
+{
+    PVOID               BaseAddress;
+    DWORD               Size;
+    DWORD               Characteristics;
+} PE_SECTION_INFO, *PPE_SECTION_INFO;
+
+#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
+#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
+#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
+#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
+#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
+#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
+#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
+#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
+#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
+#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
+#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
+#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
+#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
+#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
+#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor
+
+typedef struct _PE_DATA_DIRECTORY
+{
+    PVOID               BaseAddress;
+    DWORD               Size;
+} PE_DATA_DIRECTORY, *PPE_DATA_DIRECTORY;
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/inc/pe_parser.h b/src_proiect/PE_Parser/inc/pe_parser.h
new file mode 100644
index 0000000..a8e62ac
--- /dev/null
+++ b/src_proiect/PE_Parser/inc/pe_parser.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "pe_exports.h"
+
+STATUS
+PeRetrieveNtHeader(
+    IN_READS_BYTES(ImageSize)   PVOID                   ImageBase,
+    IN                          DWORD                   ImageSize,
+    OUT                         PPE_NT_HEADER_INFO      NtInfo
+    );
+
+STATUS
+PeRetrieveSection(
+    IN                          PPE_NT_HEADER_INFO      NtInfo,
+    IN                          DWORD                   SectionIndex,
+    OUT                         PPE_SECTION_INFO        SectionInfo
+    );
+
+STATUS
+PeRetrieveDataDirectory(
+    IN                          PPE_NT_HEADER_INFO      NtInfo,
+    IN                          BYTE                    DataDirectory,
+    OUT                         PPE_DATA_DIRECTORY      DataDirectoryInfo
+    );
\ No newline at end of file
diff --git a/src_proiect/PE_Parser/src/pe_parser.c b/src_proiect/PE_Parser/src/pe_parser.c
new file mode 100644
index 0000000..bb9b1d5
--- /dev/null
+++ b/src_proiect/PE_Parser/src/pe_parser.c
@@ -0,0 +1,173 @@
+#include "pe_base.h"
+#include "pe_parser.h"
+#include "pe_structures.h"
+
+STATUS
+PeRetrieveNtHeader(
+    IN_READS_BYTES(ImageSize)           PVOID                   ImageBase,
+    IN                                  DWORD                   ImageSize,
+    OUT                                 PPE_NT_HEADER_INFO      NtInfo
+    )
+{
+    STATUS status;
+    IMAGE_DOS_HEADER* pDos;
+    IMAGE_NT_HEADERS64* nt;
+
+    if (NULL == ImageBase)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (0 == ImageSize)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == NtInfo)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    status = STATUS_SUCCESS;
+
+    pDos = (IMAGE_DOS_HEADER*)ImageBase;
+
+    if (MZ_SIGNATURE != pDos->e_magic)  // MZ
+    {
+        return STATUS_INVALID_MZ_IMAGE;
+    }
+
+    nt = (IMAGE_NT_HEADERS64*)((BYTE*)pDos + pDos->e_lfanew);
+    if (!CHECK_BOUNDS(nt, sizeof(IMAGE_NT_HEADERS64), ImageBase, ImageSize))
+    {
+        return STATUS_INVALID_IMAGE_SIZE;
+    }
+
+    if (NT_SIGNATURE != nt->Signature)  // PE
+    {
+        return STATUS_INVALID_PE_IMAGE;
+    } 
+    
+    NtInfo->ImageBase = ImageBase;
+    NtInfo->NtBase = nt;
+    NtInfo->Size = nt->OptionalHeader.SizeOfImage;
+    NtInfo->Machine = nt->FileHeader.Machine;
+    NtInfo->Subsystem = nt->OptionalHeader.Subsystem;
+    NtInfo->AddressOfEntryPoint = PtrOffset(NtInfo->ImageBase, nt->OptionalHeader.AddressOfEntryPoint);
+    NtInfo->SizeOfHeaders = nt->OptionalHeader.SizeOfHeaders;
+    NtInfo->NumberOfSections = nt->FileHeader.NumberOfSections;
+    NtInfo->ImageAlignment = nt->OptionalHeader.SectionAlignment;
+    NtInfo->FileAlignment = nt->OptionalHeader.FileAlignment;
+
+    NtInfo->Preferred.ImageBase = (PVOID) nt->OptionalHeader.ImageBase;
+    NtInfo->Preferred.AddressOfEntryPoint = PtrOffset(NtInfo->Preferred.ImageBase, nt->OptionalHeader.AddressOfEntryPoint);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+PeRetrieveSection(
+    IN                          PPE_NT_HEADER_INFO      NtInfo,
+    IN                          DWORD                   SectionIndex,
+    OUT                         PPE_SECTION_INFO        SectionInfo
+    )
+{
+    IMAGE_SECTION_HEADER* pSections;
+    IMAGE_NT_HEADERS64* pNt;
+
+    if (NULL == NtInfo)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if (SectionIndex >= NtInfo->NumberOfSections)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == SectionInfo)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (IMAGE_FILE_MACHINE_AMD64 != NtInfo->Machine)
+    {
+        // we currently only support 64-bit PEs
+        return STATUS_UNSUPPORTED;
+    }
+
+    pSections = NULL;
+    pNt = (IMAGE_NT_HEADERS64*)NtInfo->NtBase;
+
+    pSections = (IMAGE_SECTION_HEADER*)((PBYTE)pNt + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + pNt->FileHeader.SizeOfOptionalHeader);
+    if (!CHECK_BOUNDS(pSections, sizeof(IMAGE_SECTION_HEADER) * NtInfo->NumberOfSections, NtInfo->ImageBase, NtInfo->Size) )
+    {
+        return STATUS_INVALID_IMAGE_SIZE;
+    }
+
+    SectionInfo->BaseAddress = (PBYTE)NtInfo->ImageBase + pSections[SectionIndex].VirtualAddress;
+    SectionInfo->Size = pSections[SectionIndex].Misc.VirtualSize;
+    SectionInfo->Characteristics = pSections[SectionIndex].Characteristics;
+
+    if (!CHECK_BOUNDS(SectionInfo->BaseAddress, SectionInfo->Size, NtInfo->ImageBase, NtInfo->Size))
+    {
+        return STATUS_INVALID_IMAGE_SIZE;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+PeRetrieveDataDirectory(
+    IN                          PPE_NT_HEADER_INFO      NtInfo,
+    IN                          BYTE                    DataDirectory,
+    OUT                         PPE_DATA_DIRECTORY      DataDirectoryInfo
+    )
+{
+    IMAGE_NT_HEADERS64* pNt;
+    PIMAGE_DATA_DIRECTORY pDataDirectory;
+
+    if (NULL == NtInfo)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    if ( IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR < DataDirectory )
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    if (NULL == DataDirectoryInfo)
+    {
+        return STATUS_INVALID_PARAMETER3;
+    }
+
+    if (IMAGE_FILE_MACHINE_AMD64 != NtInfo->Machine)
+    {
+        // we currently only support 64-bit PEs
+        return STATUS_UNSUPPORTED;
+    }
+
+    pNt = (IMAGE_NT_HEADERS64*)NtInfo->NtBase;
+
+    if (DataDirectory >= pNt->OptionalHeader.NumberOfRvaAndSizes)
+    {
+        return STATUS_INVALID_PARAMETER2;
+    }
+
+    pDataDirectory = &pNt->OptionalHeader.DataDirectory[DataDirectory];
+    if (!CHECK_BOUNDS(pDataDirectory, sizeof(IMAGE_DATA_DIRECTORY), NtInfo->ImageBase, NtInfo->Size))
+    {
+        return STATUS_INVALID_IMAGE_SIZE;
+    }
+
+    DataDirectoryInfo->BaseAddress = (PBYTE)NtInfo->ImageBase + pDataDirectory->VirtualAddress;
+    DataDirectoryInfo->Size = pDataDirectory->Size;
+
+    if (!CHECK_BOUNDS(DataDirectoryInfo->BaseAddress, DataDirectoryInfo->Size, NtInfo->ImageBase, NtInfo->Size))
+    {
+        return STATUS_INVALID_IMAGE_SIZE;
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/SwapFS/SwapFS.vcxproj b/src_proiect/SwapFS/SwapFS.vcxproj
new file mode 100644
index 0000000..834658a
--- /dev/null
+++ b/src_proiect/SwapFS/SwapFS.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{7E91BC80-DF0A-4DCE-9E99-FAA3ACF429B7}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>SwapFS</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+    </Link>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\swapfs.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\swapfs_base.h" />
+    <ClInclude Include="inc\swapfs.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/SwapFS/SwapFS.vcxproj.filters b/src_proiect/SwapFS/SwapFS.vcxproj.filters
new file mode 100644
index 0000000..33dba39
--- /dev/null
+++ b/src_proiect/SwapFS/SwapFS.vcxproj.filters
@@ -0,0 +1,33 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{f489e2d1-9d8e-477f-b65d-7cfa4840cc0d}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\swapfs.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\swapfs.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\swapfs_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/SwapFS/headers/swapfs_base.h b/src_proiect/SwapFS/headers/swapfs_base.h
new file mode 100644
index 0000000..424305e
--- /dev/null
+++ b/src_proiect/SwapFS/headers/swapfs_base.h
@@ -0,0 +1,5 @@
+#pragma once
+
+#include "common_lib.h"
+#include "io.h"
+#include "log.h"
\ No newline at end of file
diff --git a/src_proiect/SwapFS/inc/swapfs.h b/src_proiect/SwapFS/inc/swapfs.h
new file mode 100644
index 0000000..38c7e35
--- /dev/null
+++ b/src_proiect/SwapFS/inc/swapfs.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry        SwapFsDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/SwapFS/src/swapfs.c b/src_proiect/SwapFS/src/swapfs.c
new file mode 100644
index 0000000..1734966
--- /dev/null
+++ b/src_proiect/SwapFS/src/swapfs.c
@@ -0,0 +1,357 @@
+#include "swapfs_base.h"
+#include "swapfs.h"
+
+static FUNC_DriverDispatch     _SwapFsCreate;
+static FUNC_DriverDispatch     _SwapFsClose;
+static FUNC_DriverDispatch     _SwapFsRead;
+static FUNC_DriverDispatch     _SwapFsWrite;
+
+typedef struct _SWAPFS_DATA
+{
+    PDEVICE_OBJECT              VolumeDevice;
+
+    QWORD                       FileSystemSize;
+} SWAPFS_DATA, *PSWAPFS_DATA;
+
+STATUS
+(__cdecl SwapFsDriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    )
+{
+    STATUS status;
+    PDEVICE_OBJECT* pVolumeDevices;
+    PDEVICE_OBJECT pCurVolume;
+    PARTITION_INFORMATION partitionInformation;
+    DWORD i;
+    DWORD numberOfDevices;
+    PIRP pIrp;
+    PDEVICE_OBJECT pFileSystemDevice;
+    PSWAPFS_DATA pSwapFsData;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DriverObject);
+
+    status = STATUS_SUCCESS;
+    pVolumeDevices = NULL;
+    pCurVolume = NULL;
+    numberOfDevices = 0;
+    pIrp = NULL;
+    pFileSystemDevice = NULL;
+    pSwapFsData = NULL;
+
+    DriverObject->DispatchFunctions[IRP_MJ_CREATE] = _SwapFsCreate;
+    DriverObject->DispatchFunctions[IRP_MJ_CLOSE] = _SwapFsClose;
+    DriverObject->DispatchFunctions[IRP_MJ_READ] = _SwapFsRead;
+    DriverObject->DispatchFunctions[IRP_MJ_WRITE] = _SwapFsWrite;
+
+    status = IoGetDevicesByType(DeviceTypeVolume, &pVolumeDevices, &numberOfDevices);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetDeviceByType", status);
+        return status;
+    }
+
+    __try
+    {
+        for (i = 0; i < numberOfDevices; ++i)
+        {
+            pCurVolume = pVolumeDevices[i];
+
+            if (NULL != pFileSystemDevice)
+            {
+                IoDeleteDevice(pFileSystemDevice);
+                pFileSystemDevice = NULL;
+            }
+
+            memzero(&partitionInformation, sizeof(PARTITION_INFORMATION));
+
+            if (NULL != pIrp)
+            {
+                IoFreeIrp(pIrp);
+                pIrp = NULL;
+            }
+
+            // send an IOCTL to see device description
+            pIrp = IoBuildDeviceIoControlRequest(IOCTL_VOLUME_PARTITION_INFO,
+                                                 pCurVolume,
+                                                 NULL,
+                                                 0,
+                                                 &partitionInformation,
+                                                 sizeof(PARTITION_INFORMATION)
+            );
+            if (NULL == pIrp)
+            {
+                LOG_ERROR("IoBuildDeviceIoControlRequest failed\n");
+                continue;
+            }
+
+            status = IoCallDriver(pCurVolume, pIrp);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoCallDriver", status);
+                continue;
+            }
+
+            if (!SUCCEEDED(pIrp->IoStatus.Status))
+            {
+                LOG_FUNC_ERROR("IoCallDriver", pIrp->IoStatus.Status);
+                continue;
+            }
+
+            LOG_TRACE_FILESYSTEM("Succesfully called device with IOCTL IOCTL_VOLUME_PARTITION_INFO\n");
+
+            if (PARTITION_TYPE_LINUX_SWAP != partitionInformation.PartitionType)
+            {
+                LOG_WARNING("Partition type 0x%x not supported\n", partitionInformation.PartitionType);
+                continue;
+            }
+
+            LOG_TRACE_FILESYSTEM("Found supported partition type: 0x%x\n", partitionInformation.PartitionType);
+
+            pFileSystemDevice = IoCreateDevice(DriverObject, sizeof(SWAPFS_DATA), DeviceTypeFilesystem);
+            if (NULL == pFileSystemDevice)
+            {
+                LOG_FUNC_ERROR_ALLOC("IoCreateDevice", sizeof(SWAPFS_DATA));
+                status = STATUS_DEVICE_COULD_NOT_BE_CREATED;
+                __leave;
+            }
+
+            pFileSystemDevice->DeviceAlignment = PAGE_SIZE;
+
+            pSwapFsData = IoGetDeviceExtension(pFileSystemDevice);
+            ASSERT(NULL != pSwapFsData);
+
+            pSwapFsData->VolumeDevice = pCurVolume;
+            pSwapFsData->FileSystemSize = partitionInformation.PartitionSize * SECTOR_SIZE;
+
+            LOG_TRACE_FILESYSTEM("Mounted SWAP FS on partition of size 0x%X\n", pSwapFsData->FileSystemSize);
+
+            // attach to volume
+            IoAttachDevice(pFileSystemDevice, pCurVolume);
+
+            pCurVolume->Vpb->FilesystemDevice = pFileSystemDevice;
+            pCurVolume->Vpb->Flags.Mounted = TRUE;
+            pCurVolume->Vpb->Flags.SwapSpace = TRUE;
+
+            pFileSystemDevice->Vpb = pCurVolume->Vpb;
+
+            pFileSystemDevice = NULL;
+            pSwapFsData = NULL;
+        }
+    }
+    __finally
+    {
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        if (NULL != pVolumeDevices)
+        {
+            IoFreeTemporaryData(pVolumeDevices);
+            pVolumeDevices = NULL;
+        }
+    }
+
+    return status;
+}
+
+static
+STATUS
+(__cdecl _SwapFsCreate)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PSWAPFS_DATA pSwapFsData;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+    pSwapFsData = NULL;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_CREATE == pStackLocation->MajorFunction);
+
+    pSwapFsData = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pSwapFsData);
+
+    ASSERT(NULL == pStackLocation->FileObject->RelatedFileObject);
+
+    __try
+    {
+        // in the case of swap FS we only have the root file which we'll use for all our read/write operations
+        if (strcmp(pStackLocation->FileObject->FileName, "\\") != 0)
+        {
+            status = STATUS_FILE_NOT_FOUND;
+            __leave;
+        }
+
+        pStackLocation->FileObject->FileSize = pSwapFsData->FileSystemSize;
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = 0;
+
+        IoCompleteIrp(Irp);
+
+        LOG_FUNC_END;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+(__cdecl _SwapFsClose)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    Irp->IoStatus.Status = STATUS_SUCCESS;
+    IoCompleteIrp(Irp);
+
+    LOG_FUNC_END;
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+(__cdecl _SwapFsRead)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PSWAPFS_DATA pSwapFsData;
+    QWORD bytesRead;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+    pSwapFsData = NULL;
+    bytesRead = 0;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_READ == pStackLocation->MajorFunction);
+
+    pSwapFsData = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pSwapFsData);
+
+    __try
+    {
+        bytesRead = pStackLocation->Parameters.ReadWrite.Length;
+
+        if (bytesRead != PAGE_SIZE)
+        {
+            LOG_ERROR("We cannot read more than a page at time!Bytes requested: %U\n", bytesRead);
+            status = STATUS_DEVICE_NOT_SUPPORTED;
+            __leave;
+        }
+
+        status = IoReadDeviceEx(pSwapFsData->VolumeDevice,
+                                Irp->Buffer,
+                                &bytesRead,
+                                pStackLocation->Parameters.ReadWrite.Offset,
+                                FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoReadDeviceEx", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = bytesRead;
+
+        IoCompleteIrp(Irp);
+
+        LOG_FUNC_END;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+(__cdecl _SwapFsWrite)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PIO_STACK_LOCATION pStackLocation;
+    PSWAPFS_DATA pSwapFsData;
+    QWORD bytesWritten;
+
+    LOG_FUNC_START;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pStackLocation = NULL;
+    pSwapFsData = NULL;
+    bytesWritten = 0;
+
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_WRITE == pStackLocation->MajorFunction);
+
+    pSwapFsData = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pSwapFsData);
+
+    __try
+    {
+        bytesWritten = pStackLocation->Parameters.ReadWrite.Length;
+
+        if (bytesWritten != PAGE_SIZE)
+        {
+            LOG_ERROR("We cannot write more than a page at time!Bytes requested: %U\n", bytesWritten);
+            status = STATUS_DEVICE_NOT_SUPPORTED;
+            __leave;
+        }
+
+        status = IoWriteDeviceEx(pSwapFsData->VolumeDevice,
+                                 Irp->Buffer,
+                                 &bytesWritten,
+                                 pStackLocation->Parameters.ReadWrite.Offset,
+                                 FALSE);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoWriteDeviceEx", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        Irp->IoStatus.Status = status;
+        Irp->IoStatus.Information = bytesWritten;
+
+        IoCompleteIrp(Irp);
+
+        LOG_FUNC_END;
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/AppHelloWorld/AppHelloWorld.vcxproj b/src_proiect/Usermode/AppHelloWorld/AppHelloWorld.vcxproj
new file mode 100644
index 0000000..1cf5147
--- /dev/null
+++ b/src_proiect/Usermode/AppHelloWorld/AppHelloWorld.vcxproj
@@ -0,0 +1,151 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{E5ABDC11-649C-430A-B4E0-4603247A38C5}</ProjectGuid>
+    <RootNamespace>AppHelloWorld</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/AppHelloWorld/AppHelloWorld.vcxproj.filters b/src_proiect/Usermode/AppHelloWorld/AppHelloWorld.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/AppHelloWorld/AppHelloWorld.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/AppHelloWorld/main.c b/src_proiect/Usermode/AppHelloWorld/main.c
new file mode 100644
index 0000000..0eba343
--- /dev/null
+++ b/src_proiect/Usermode/AppHelloWorld/main.c
@@ -0,0 +1,80 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+FUNC_ThreadStart _HelloWorldFromThread;
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+    )
+{
+    STATUS status;
+    TID tid;
+    PID pid;
+    UM_HANDLE umHandle;
+
+    LOG("Hello from your usermode application!\n");
+
+    LOG("Number of arguments 0x%x\n", argc);
+    LOG("Arguments at 0x%X\n", argv);
+    for (DWORD i = 0; i < argc; ++i)
+    {
+        LOG("Argument[%u] is at 0x%X\n", i, argv[i]);
+        LOG("Argument[%u] is %s\n", i, argv[i]);
+    }
+
+    status = SyscallProcessGetPid(UM_INVALID_HANDLE_VALUE, &pid);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallProcessGetPid", status);
+        return status;
+    }
+
+    LOG("Hello from process with ID 0x%X\n", pid);
+
+
+    status = SyscallThreadGetTid(UM_INVALID_HANDLE_VALUE, &tid);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+        return status;
+    }
+
+    LOG("Hello from thread with ID 0x%X\n", tid);
+
+    status = UmThreadCreate(_HelloWorldFromThread, (PVOID)(QWORD) argc, &umHandle);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallThreadCreate", status);
+        return status;
+    }
+
+    //SyscallThreadCloseHandle()
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl _HelloWorldFromThread)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    TID tid;
+
+    ASSERT(Context != NULL);
+
+    status = SyscallThreadGetTid(UM_INVALID_HANDLE_VALUE, &tid);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+        return status;
+    }
+
+    LOG("Hello from thread with ID 0x%X\n", tid);
+    LOG("Context is 0x%X\n", Context);
+
+    return status;
+}
diff --git a/src_proiect/Usermode/Args/Args.vcxproj b/src_proiect/Usermode/Args/Args.vcxproj
new file mode 100644
index 0000000..311bd5b
--- /dev/null
+++ b/src_proiect/Usermode/Args/Args.vcxproj
@@ -0,0 +1,138 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{a7fc9721-01ea-4cd7-8d9e-c1dfe90d0099}</ProjectGuid>
+    <RootNamespace>Args</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/Args/Args.vcxproj.filters b/src_proiect/Usermode/Args/Args.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/Args/Args.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/Args/main.c b/src_proiect/Usermode/Args/main.c
new file mode 100644
index 0000000..f1edf1a
--- /dev/null
+++ b/src_proiect/Usermode/Args/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    LOG("Number of arguments 0x%x", argc);
+    for (DWORD i = 0; i < argc; ++i)
+    {
+        LOG("Argument[%u] is [%s]", i, argv[i]);
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpKernel/BadJumpKernel.vcxproj b/src_proiect/Usermode/BadJumpKernel/BadJumpKernel.vcxproj
new file mode 100644
index 0000000..8de5298
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpKernel/BadJumpKernel.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{638ad489-3390-414f-8931-abbb7ceed92d}</ProjectGuid>
+    <RootNamespace>BadJumpKernel</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpKernel/BadJumpKernel.vcxproj.filters b/src_proiect/Usermode/BadJumpKernel/BadJumpKernel.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpKernel/BadJumpKernel.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpKernel/main.c b/src_proiect/Usermode/BadJumpKernel/main.c
new file mode 100644
index 0000000..7a6a33e
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpKernel/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully called kernel code: %d",
+        ((int(*)(void))0xFFFF800000000000ULL)());
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpNoncanonical/BadJumpNoncanonical.vcxproj b/src_proiect/Usermode/BadJumpNoncanonical/BadJumpNoncanonical.vcxproj
new file mode 100644
index 0000000..1d93f22
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpNoncanonical/BadJumpNoncanonical.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{8853a519-4e05-429d-a2a1-911bace363c6}</ProjectGuid>
+    <RootNamespace>BadJumpNoncanonical</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpNoncanonical/BadJumpNoncanonical.vcxproj.filters b/src_proiect/Usermode/BadJumpNoncanonical/BadJumpNoncanonical.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpNoncanonical/BadJumpNoncanonical.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpNoncanonical/main.c b/src_proiect/Usermode/BadJumpNoncanonical/main.c
new file mode 100644
index 0000000..197b11c
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpNoncanonical/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully called a non-canonical address: %d",
+        ((int(*)(void))0xFFFF000000000000ULL)());
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpNull/BadJumpNull.vcxproj b/src_proiect/Usermode/BadJumpNull/BadJumpNull.vcxproj
new file mode 100644
index 0000000..c0a3525
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpNull/BadJumpNull.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{f092d608-d31b-4e30-9650-11058bd45093}</ProjectGuid>
+    <RootNamespace>BadJumpNull</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpNull/BadJumpNull.vcxproj.filters b/src_proiect/Usermode/BadJumpNull/BadJumpNull.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpNull/BadJumpNull.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadJumpNull/main.c b/src_proiect/Usermode/BadJumpNull/main.c
new file mode 100644
index 0000000..4cac9c8
--- /dev/null
+++ b/src_proiect/Usermode/BadJumpNull/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully called NULL: %d",
+        ((int(*)(void))NULL)());
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadIoPort/BadReadIoPort.vcxproj b/src_proiect/Usermode/BadReadIoPort/BadReadIoPort.vcxproj
new file mode 100644
index 0000000..d27c83f
--- /dev/null
+++ b/src_proiect/Usermode/BadReadIoPort/BadReadIoPort.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{f5b97493-5840-4d09-88d7-44cb0c4e0677}</ProjectGuid>
+    <RootNamespace>BadReadIoPort</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadIoPort/BadReadIoPort.vcxproj.filters b/src_proiect/Usermode/BadReadIoPort/BadReadIoPort.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadReadIoPort/BadReadIoPort.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadIoPort/main.c b/src_proiect/Usermode/BadReadIoPort/main.c
new file mode 100644
index 0000000..f698396
--- /dev/null
+++ b/src_proiect/Usermode/BadReadIoPort/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully read an IO port: 0x%x",
+        __indword(0x60));
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadKernel/BadReadKernel.vcxproj b/src_proiect/Usermode/BadReadKernel/BadReadKernel.vcxproj
new file mode 100644
index 0000000..da42fb7
--- /dev/null
+++ b/src_proiect/Usermode/BadReadKernel/BadReadKernel.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d127b5b4-f60e-4436-b663-45404e95bb97}</ProjectGuid>
+    <RootNamespace>BadReadKernel</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadKernel/BadReadKernel.vcxproj.filters b/src_proiect/Usermode/BadReadKernel/BadReadKernel.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadReadKernel/BadReadKernel.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadKernel/main.c b/src_proiect/Usermode/BadReadKernel/main.c
new file mode 100644
index 0000000..110b7fc
--- /dev/null
+++ b/src_proiect/Usermode/BadReadKernel/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully read kernel memory: 0x%X",
+        *((QWORD*)0xFFFF800000000000ULL));
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadMsr/BadReadMsr.vcxproj b/src_proiect/Usermode/BadReadMsr/BadReadMsr.vcxproj
new file mode 100644
index 0000000..d7084ec
--- /dev/null
+++ b/src_proiect/Usermode/BadReadMsr/BadReadMsr.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{752c9059-8c84-4ffd-938a-055e76e6bd2d}</ProjectGuid>
+    <RootNamespace>BadReadMsr</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadMsr/BadReadMsr.vcxproj.filters b/src_proiect/Usermode/BadReadMsr/BadReadMsr.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadReadMsr/BadReadMsr.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadMsr/main.c b/src_proiect/Usermode/BadReadMsr/main.c
new file mode 100644
index 0000000..34b2732
--- /dev/null
+++ b/src_proiect/Usermode/BadReadMsr/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully read a MSR: 0x%X",
+        __readmsr(0xC000'0100));
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadNonCanonical/BadReadNonCanonical.vcxproj b/src_proiect/Usermode/BadReadNonCanonical/BadReadNonCanonical.vcxproj
new file mode 100644
index 0000000..d495563
--- /dev/null
+++ b/src_proiect/Usermode/BadReadNonCanonical/BadReadNonCanonical.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d157b165-f35b-4d6a-b23d-90596b0328fd}</ProjectGuid>
+    <RootNamespace>BadReadNonCanonical</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadNonCanonical/BadReadNonCanonical.vcxproj.filters b/src_proiect/Usermode/BadReadNonCanonical/BadReadNonCanonical.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadReadNonCanonical/BadReadNonCanonical.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadNonCanonical/main.c b/src_proiect/Usermode/BadReadNonCanonical/main.c
new file mode 100644
index 0000000..1d65986
--- /dev/null
+++ b/src_proiect/Usermode/BadReadNonCanonical/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully read from a non-canonical address: 0x%X",
+        *((QWORD*)0xFFFF000000000000ULL));
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadNull/BadReadNull.vcxproj b/src_proiect/Usermode/BadReadNull/BadReadNull.vcxproj
new file mode 100644
index 0000000..6aa6988
--- /dev/null
+++ b/src_proiect/Usermode/BadReadNull/BadReadNull.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{4f0011cd-9ddb-43c2-8555-5928f3be8196}</ProjectGuid>
+    <RootNamespace>BadReadNull</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadNull/BadReadNull.vcxproj.filters b/src_proiect/Usermode/BadReadNull/BadReadNull.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadReadNull/BadReadNull.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadReadNull/main.c b/src_proiect/Usermode/BadReadNull/main.c
new file mode 100644
index 0000000..fa9fbb6
--- /dev/null
+++ b/src_proiect/Usermode/BadReadNull/main.c
@@ -0,0 +1,19 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    LOG("Congratulations - you have successfully read NULL: 0x%X",
+        *((QWORD*)NULL));
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteIoPort/BadWriteIoPort.vcxproj b/src_proiect/Usermode/BadWriteIoPort/BadWriteIoPort.vcxproj
new file mode 100644
index 0000000..2b1c7fb
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteIoPort/BadWriteIoPort.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{837d6aba-2c74-4163-9d85-4e78d52883e4}</ProjectGuid>
+    <RootNamespace>BadWriteIoPort</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteIoPort/BadWriteIoPort.vcxproj.filters b/src_proiect/Usermode/BadWriteIoPort/BadWriteIoPort.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteIoPort/BadWriteIoPort.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteIoPort/main.c b/src_proiect/Usermode/BadWriteIoPort/main.c
new file mode 100644
index 0000000..77d9666
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteIoPort/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    __outbyte(0x60, 0x5);
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteKernel/BadWriteKernel.vcxproj b/src_proiect/Usermode/BadWriteKernel/BadWriteKernel.vcxproj
new file mode 100644
index 0000000..909ec6b
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteKernel/BadWriteKernel.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{6505aa65-a3c0-4792-bdee-0e7be0425639}</ProjectGuid>
+    <RootNamespace>BadWriteKernel</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteKernel/BadWriteKernel.vcxproj.filters b/src_proiect/Usermode/BadWriteKernel/BadWriteKernel.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteKernel/BadWriteKernel.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteKernel/main.c b/src_proiect/Usermode/BadWriteKernel/main.c
new file mode 100644
index 0000000..03cf203
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteKernel/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    *((QWORD*)0xFFFF800000000000ULL) = 0x77;
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteMsr/BadWriteMsr.vcxproj b/src_proiect/Usermode/BadWriteMsr/BadWriteMsr.vcxproj
new file mode 100644
index 0000000..aaf917c
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteMsr/BadWriteMsr.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{ca491a14-a976-4c84-8530-c72974026fce}</ProjectGuid>
+    <RootNamespace>BadWriteMsr</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteMsr/BadWriteMsr.vcxproj.filters b/src_proiect/Usermode/BadWriteMsr/BadWriteMsr.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteMsr/BadWriteMsr.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteMsr/main.c b/src_proiect/Usermode/BadWriteMsr/main.c
new file mode 100644
index 0000000..591cf8f
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteMsr/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    __writemsr(0xC000'0100, 0x5);
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteNonCanonical/BadWriteNonCanonical.vcxproj b/src_proiect/Usermode/BadWriteNonCanonical/BadWriteNonCanonical.vcxproj
new file mode 100644
index 0000000..ca20352
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteNonCanonical/BadWriteNonCanonical.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{e757415d-952b-41eb-91d2-678ed2a21241}</ProjectGuid>
+    <RootNamespace>BadWriteNonCanonical</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteNonCanonical/BadWriteNonCanonical.vcxproj.filters b/src_proiect/Usermode/BadWriteNonCanonical/BadWriteNonCanonical.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteNonCanonical/BadWriteNonCanonical.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteNonCanonical/main.c b/src_proiect/Usermode/BadWriteNonCanonical/main.c
new file mode 100644
index 0000000..b99a234
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteNonCanonical/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    *((QWORD*)0xFFFF000000000000ULL) = 0x77;
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteNull/BadWriteNull.vcxproj b/src_proiect/Usermode/BadWriteNull/BadWriteNull.vcxproj
new file mode 100644
index 0000000..216496c
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteNull/BadWriteNull.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{f6b76094-cb73-463f-8faa-794214ec3621}</ProjectGuid>
+    <RootNamespace>BadWriteNull</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteNull/BadWriteNull.vcxproj.filters b/src_proiect/Usermode/BadWriteNull/BadWriteNull.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteNull/BadWriteNull.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/BadWriteNull/main.c b/src_proiect/Usermode/BadWriteNull/main.c
new file mode 100644
index 0000000..ead240e
--- /dev/null
+++ b/src_proiect/Usermode/BadWriteNull/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    *((QWORD*)NULL) = 0x77;
+    LOG_ERROR("Should have terminated the process!");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj b/src_proiect/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj
new file mode 100644
index 0000000..a2add7d
--- /dev/null
+++ b/src_proiect/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj
@@ -0,0 +1,76 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{42D8C78E-FCAD-4452-8098-BC8C2DFD562E}</ProjectGuid>
+    <RootNamespace>CopyUmAppsToVm</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\..\postbuild\copy_um_apps_to_vm.cmd $(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\ Applications</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\..\postbuild\copy_um_apps_to_vm.cmd $(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\ Applications</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj.filters b/src_proiect/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj.filters
new file mode 100644
index 0000000..9cd8510
--- /dev/null
+++ b/src_proiect/Usermode/CopyUmAppsToVm/CopyUmAppsToVm.vcxproj.filters
@@ -0,0 +1,2 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
\ No newline at end of file
diff --git a/src_proiect/Usermode/Dummy/Dummy.vcxproj b/src_proiect/Usermode/Dummy/Dummy.vcxproj
new file mode 100644
index 0000000..ec65315
--- /dev/null
+++ b/src_proiect/Usermode/Dummy/Dummy.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{5040b126-0e99-434a-9f35-e1b5cdce0729}</ProjectGuid>
+    <RootNamespace>Dummy</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/Dummy/Dummy.vcxproj.filters b/src_proiect/Usermode/Dummy/Dummy.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/Dummy/Dummy.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/Dummy/main.c b/src_proiect/Usermode/Dummy/main.c
new file mode 100644
index 0000000..9ecad9e
--- /dev/null
+++ b/src_proiect/Usermode/Dummy/main.c
@@ -0,0 +1,15 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/DummyFail/DummyFail.vcxproj b/src_proiect/Usermode/DummyFail/DummyFail.vcxproj
new file mode 100644
index 0000000..ac42b72
--- /dev/null
+++ b/src_proiect/Usermode/DummyFail/DummyFail.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{1dd3d1fa-62bb-47ad-b04c-853f278b8722}</ProjectGuid>
+    <RootNamespace>DummyFail</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/DummyFail/DummyFail.vcxproj.filters b/src_proiect/Usermode/DummyFail/DummyFail.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/DummyFail/DummyFail.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/DummyFail/main.c b/src_proiect/Usermode/DummyFail/main.c
new file mode 100644
index 0000000..772552b
--- /dev/null
+++ b/src_proiect/Usermode/DummyFail/main.c
@@ -0,0 +1,15 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    return STATUS_UNSUCCESSFUL;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseBad/FileCloseBad.vcxproj b/src_proiect/Usermode/FileCloseBad/FileCloseBad.vcxproj
new file mode 100644
index 0000000..a755b98
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseBad/FileCloseBad.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{a3fbf603-47c5-40bb-92d1-57b0dbe2d4e4}</ProjectGuid>
+    <RootNamespace>FileCloseBad</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseBad/FileCloseBad.vcxproj.filters b/src_proiect/Usermode/FileCloseBad/FileCloseBad.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseBad/FileCloseBad.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseBad/main.c b/src_proiect/Usermode/FileCloseBad/main.c
new file mode 100644
index 0000000..bac727f
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseBad/main.c
@@ -0,0 +1,23 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileClose(0x73213213);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallFileClose should have failed!!!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseNormal/FileCloseNormal.vcxproj b/src_proiect/Usermode/FileCloseNormal/FileCloseNormal.vcxproj
new file mode 100644
index 0000000..8d7cf29
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseNormal/FileCloseNormal.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{88595ecd-557e-4b04-a510-76d670899876}</ProjectGuid>
+    <RootNamespace>FileCloseNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseNormal/FileCloseNormal.vcxproj.filters b/src_proiect/Usermode/FileCloseNormal/FileCloseNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseNormal/FileCloseNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseNormal/main.c b/src_proiect/Usermode/FileCloseNormal/main.c
new file mode 100644
index 0000000..5534fc8
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseNormal/main.c
@@ -0,0 +1,43 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE handle;
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    __try
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            __leave;
+        }
+
+        status = SyscallFileClose(handle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseStdout/FileCloseStdout.vcxproj b/src_proiect/Usermode/FileCloseStdout/FileCloseStdout.vcxproj
new file mode 100644
index 0000000..5f01fd0
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseStdout/FileCloseStdout.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{59fde7c8-88bd-4850-9d64-a4fef7500a3f}</ProjectGuid>
+    <RootNamespace>FileCloseStdout</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseStdout/FileCloseStdout.vcxproj.filters b/src_proiect/Usermode/FileCloseStdout/FileCloseStdout.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseStdout/FileCloseStdout.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseStdout/main.c b/src_proiect/Usermode/FileCloseStdout/main.c
new file mode 100644
index 0000000..1c20275
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseStdout/main.c
@@ -0,0 +1,23 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileClose(UM_FILE_HANDLE_STDOUT);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallFileClose", status);
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseTwice/FileCloseTwice.vcxproj b/src_proiect/Usermode/FileCloseTwice/FileCloseTwice.vcxproj
new file mode 100644
index 0000000..dd1c5df
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseTwice/FileCloseTwice.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d28e7f99-b199-4953-bb56-4f6574763a52}</ProjectGuid>
+    <RootNamespace>FileCloseTwice</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseTwice/FileCloseTwice.vcxproj.filters b/src_proiect/Usermode/FileCloseTwice/FileCloseTwice.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseTwice/FileCloseTwice.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCloseTwice/main.c b/src_proiect/Usermode/FileCloseTwice/main.c
new file mode 100644
index 0000000..f0e4f45
--- /dev/null
+++ b/src_proiect/Usermode/FileCloseTwice/main.c
@@ -0,0 +1,60 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    __try
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            __leave;
+        }
+
+        status = SyscallFileClose(handle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+        }
+
+        status = SyscallFileClose(handle);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallFileClose should have failed!!!\n");
+        }
+
+        status = SyscallFileClose(UM_FILE_HANDLE_STDOUT);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+        }
+
+        status = SyscallFileClose(UM_FILE_HANDLE_STDOUT);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallFileClose should have failed!!!\n");
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateBadPointer/FileCreateBadPointer.vcxproj b/src_proiect/Usermode/FileCreateBadPointer/FileCreateBadPointer.vcxproj
new file mode 100644
index 0000000..ce8f686
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateBadPointer/FileCreateBadPointer.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{818797e2-6cdc-41d4-8bcf-03a670ba33f9}</ProjectGuid>
+    <RootNamespace>FileCreateBadPointer</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateBadPointer/FileCreateBadPointer.vcxproj.filters b/src_proiect/Usermode/FileCreateBadPointer/FileCreateBadPointer.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateBadPointer/FileCreateBadPointer.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateBadPointer/main.c b/src_proiect/Usermode/FileCreateBadPointer/main.c
new file mode 100644
index 0000000..d9df194
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateBadPointer/main.c
@@ -0,0 +1,29 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE handle;
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate((char*)0x73213213,
+                               0x100,
+                               FALSE,
+                               FALSE,
+                               &handle
+                               );
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallFileCreate should have failed!!!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateEmptyPath/FileCreateEmptyPath.vcxproj b/src_proiect/Usermode/FileCreateEmptyPath/FileCreateEmptyPath.vcxproj
new file mode 100644
index 0000000..33efdab
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateEmptyPath/FileCreateEmptyPath.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{5e6e5e67-1760-4744-8483-478b41f5d3e2}</ProjectGuid>
+    <RootNamespace>FileCreateEmptyPath</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateEmptyPath/FileCreateEmptyPath.vcxproj.filters b/src_proiect/Usermode/FileCreateEmptyPath/FileCreateEmptyPath.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateEmptyPath/FileCreateEmptyPath.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateEmptyPath/main.c b/src_proiect/Usermode/FileCreateEmptyPath/main.c
new file mode 100644
index 0000000..d8d7b57
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateEmptyPath/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("",
+                               sizeof(""),
+                               FALSE,
+                               FALSE,
+                               &handle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallFileCreate with empty path should have failed\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateExistent/FileCreateExistent.vcxproj b/src_proiect/Usermode/FileCreateExistent/FileCreateExistent.vcxproj
new file mode 100644
index 0000000..ca0b6f3
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateExistent/FileCreateExistent.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{9a40e264-fe2a-4f5d-a2a1-fa2539f93d0b}</ProjectGuid>
+    <RootNamespace>FileCreateExistent</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateExistent/FileCreateExistent.vcxproj.filters b/src_proiect/Usermode/FileCreateExistent/FileCreateExistent.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateExistent/FileCreateExistent.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateExistent/main.c b/src_proiect/Usermode/FileCreateExistent/main.c
new file mode 100644
index 0000000..5cb3654
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateExistent/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("HAL9000.ini",
+                               sizeof("HAL9000.ini"),
+                               FALSE,
+                               TRUE,
+                               &handle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("Function should have failed because file already exists!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateLongPath/FileCreateLongPath.vcxproj b/src_proiect/Usermode/FileCreateLongPath/FileCreateLongPath.vcxproj
new file mode 100644
index 0000000..8ac6f40
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateLongPath/FileCreateLongPath.vcxproj
@@ -0,0 +1,133 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{c02ded68-80a3-42e1-b5c4-13677a5d602f}</ProjectGuid>
+    <RootNamespace>FileCreateLongPath</RootNamespace>
+    <WindowsTargetPlatformVersion>$(WindowsDefaultSDK)</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateLongPath/FileCreateLongPath.vcxproj.filters b/src_proiect/Usermode/FileCreateLongPath/FileCreateLongPath.vcxproj.filters
new file mode 100644
index 0000000..6a1782f
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateLongPath/FileCreateLongPath.vcxproj.filters
@@ -0,0 +1,17 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateMissing/FileCreateMissing.vcxproj b/src_proiect/Usermode/FileCreateMissing/FileCreateMissing.vcxproj
new file mode 100644
index 0000000..7fb980e
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateMissing/FileCreateMissing.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{758fceb9-b595-4827-8b74-44b96e668b5e}</ProjectGuid>
+    <RootNamespace>FileCreateMissing</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateMissing/FileCreateMissing.vcxproj.filters b/src_proiect/Usermode/FileCreateMissing/FileCreateMissing.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateMissing/FileCreateMissing.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateMissing/main.c b/src_proiect/Usermode/FileCreateMissing/main.c
new file mode 100644
index 0000000..411eb41
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateMissing/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("inexistent.ini",
+                               sizeof("inexistent.ini"),
+                               FALSE,
+                               FALSE,
+                               &handle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("Function should have failed because file doesn't exist!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateNormal/FileCreateNormal.vcxproj b/src_proiect/Usermode/FileCreateNormal/FileCreateNormal.vcxproj
new file mode 100644
index 0000000..dd25b52
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateNormal/FileCreateNormal.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{5bfaee74-425b-49c9-bc09-bd0b9081e696}</ProjectGuid>
+    <RootNamespace>FileCreateNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateNormal/FileCreateNormal.vcxproj.filters b/src_proiect/Usermode/FileCreateNormal/FileCreateNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateNormal/FileCreateNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateNormal/main.c b/src_proiect/Usermode/FileCreateNormal/main.c
new file mode 100644
index 0000000..f154322
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateNormal/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("HAL9000.ini",
+                               sizeof("HAL9000.ini"),
+                               FALSE,
+                               FALSE,
+                               &handle);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallFileCreate", status);
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateNull/FileCreateNull.vcxproj b/src_proiect/Usermode/FileCreateNull/FileCreateNull.vcxproj
new file mode 100644
index 0000000..20e5273
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateNull/FileCreateNull.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d6247145-847f-4337-877e-e5f2adaf3d37}</ProjectGuid>
+    <RootNamespace>FileCreateNull</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateNull/FileCreateNull.vcxproj.filters b/src_proiect/Usermode/FileCreateNull/FileCreateNull.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateNull/FileCreateNull.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateNull/main.c b/src_proiect/Usermode/FileCreateNull/main.c
new file mode 100644
index 0000000..acaa5a7
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateNull/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate(NULL,
+                               MAX_PATH,
+                               FALSE,
+                               TRUE,
+                               &handle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("Function should have failed because path was NULL!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateTwice/FileCreateTwice.vcxproj b/src_proiect/Usermode/FileCreateTwice/FileCreateTwice.vcxproj
new file mode 100644
index 0000000..f4d53de
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateTwice/FileCreateTwice.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{e16f11cf-443b-4a4e-adc4-7b224867ba99}</ProjectGuid>
+    <RootNamespace>FileCreateTwice</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateTwice/FileCreateTwice.vcxproj.filters b/src_proiect/Usermode/FileCreateTwice/FileCreateTwice.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateTwice/FileCreateTwice.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileCreateTwice/main.c b/src_proiect/Usermode/FileCreateTwice/main.c
new file mode 100644
index 0000000..27a9d39
--- /dev/null
+++ b/src_proiect/Usermode/FileCreateTwice/main.c
@@ -0,0 +1,66 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hFile1, hFile2;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hFile1 = UM_INVALID_HANDLE_VALUE;
+    hFile2 = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &hFile1);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            __leave;
+        }
+
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &hFile2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            __leave;
+        }
+
+        if (hFile1 == hFile2)
+        {
+            LOG_ERROR("File handles should have different values: hFile1 is 0x%X, hFile2 is 0x%X!\n",
+                      hFile1, hFile2);
+        }
+    }
+    __finally
+    {
+        if (hFile1 != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallFileClose(hFile1);
+            hFile1 = UM_INVALID_HANDLE_VALUE;
+        }
+
+        if (hFile2!= UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallFileClose(hFile2);
+            hFile2 = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadBadHandle/FileReadBadHandle.vcxproj b/src_proiect/Usermode/FileReadBadHandle/FileReadBadHandle.vcxproj
new file mode 100644
index 0000000..222615c
--- /dev/null
+++ b/src_proiect/Usermode/FileReadBadHandle/FileReadBadHandle.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{dd1ffe8a-c00d-496f-8b49-f67984dbe9f2}</ProjectGuid>
+    <RootNamespace>FileReadBadHandle</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadBadHandle/FileReadBadHandle.vcxproj.filters b/src_proiect/Usermode/FileReadBadHandle/FileReadBadHandle.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileReadBadHandle/FileReadBadHandle.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadBadHandle/main.c b/src_proiect/Usermode/FileReadBadHandle/main.c
new file mode 100644
index 0000000..7f53b5a
--- /dev/null
+++ b/src_proiect/Usermode/FileReadBadHandle/main.c
@@ -0,0 +1,33 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    const UM_HANDLE BAD_HANDLES[] = { UM_INVALID_HANDLE_VALUE, 5, 1000, MAX_QWORD };
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    for (DWORD i = 0; i < ARRAYSIZE(BAD_HANDLES); ++i)
+    {
+        STATUS status;
+        char buf;
+        QWORD bytesRead;
+
+        status = SyscallFileRead(BAD_HANDLES[i],
+                                 &buf,
+                                 1,
+                                 &bytesRead);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallFileRead should have failed because of invalid handle 0x%X\n", BAD_HANDLES[i]);
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadBadPointer/FileReadBadPointer.vcxproj b/src_proiect/Usermode/FileReadBadPointer/FileReadBadPointer.vcxproj
new file mode 100644
index 0000000..f801463
--- /dev/null
+++ b/src_proiect/Usermode/FileReadBadPointer/FileReadBadPointer.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{30db9549-4343-4ebc-ac4f-72f98ebd0632}</ProjectGuid>
+    <RootNamespace>FileReadBadPointer</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadBadPointer/FileReadBadPointer.vcxproj.filters b/src_proiect/Usermode/FileReadBadPointer/FileReadBadPointer.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileReadBadPointer/FileReadBadPointer.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadBadPointer/main.c b/src_proiect/Usermode/FileReadBadPointer/main.c
new file mode 100644
index 0000000..1b6f2d6
--- /dev/null
+++ b/src_proiect/Usermode/FileReadBadPointer/main.c
@@ -0,0 +1,35 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+    QWORD bytesRead;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("HAL9000.ini",
+                               sizeof("HAL9000.ini"),
+                               FALSE,
+                               FALSE,
+                               &handle);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallFileCreate", status);
+    }
+
+     status = SyscallFileRead(handle, (PVOID) 0x14'0000'0000ULL, PAGE_SIZE, &bytesRead);
+     if (SUCCEEDED(status))
+     {
+         LOG_ERROR("SyscallFileRead should have failed!\n");
+     }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadKernel/FileReadKernel.vcxproj b/src_proiect/Usermode/FileReadKernel/FileReadKernel.vcxproj
new file mode 100644
index 0000000..36f9221
--- /dev/null
+++ b/src_proiect/Usermode/FileReadKernel/FileReadKernel.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{9bd7f8a3-f558-4d72-aa8d-b54a89f04ab2}</ProjectGuid>
+    <RootNamespace>FileReadKernel</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadKernel/FileReadKernel.vcxproj.filters b/src_proiect/Usermode/FileReadKernel/FileReadKernel.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileReadKernel/FileReadKernel.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadKernel/main.c b/src_proiect/Usermode/FileReadKernel/main.c
new file mode 100644
index 0000000..616c884
--- /dev/null
+++ b/src_proiect/Usermode/FileReadKernel/main.c
@@ -0,0 +1,35 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+    QWORD bytesRead;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("HAL9000.ini",
+                               sizeof("HAL9000.ini"),
+                               FALSE,
+                               FALSE,
+                               &handle);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallFileCreate", status);
+    }
+
+    status = SyscallFileRead(handle, (PVOID) 0xFFFF800000000000ULL, PAGE_SIZE, &bytesRead);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallFileRead should have failed!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadNormal/FileReadNormal.vcxproj b/src_proiect/Usermode/FileReadNormal/FileReadNormal.vcxproj
new file mode 100644
index 0000000..75b27d6
--- /dev/null
+++ b/src_proiect/Usermode/FileReadNormal/FileReadNormal.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{7a6d1e11-2d94-4154-8147-153427da2e98}</ProjectGuid>
+    <RootNamespace>FileReadNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadNormal/FileReadNormal.vcxproj.filters b/src_proiect/Usermode/FileReadNormal/FileReadNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileReadNormal/FileReadNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadNormal/main.c b/src_proiect/Usermode/FileReadNormal/main.c
new file mode 100644
index 0000000..d84cd7a
--- /dev/null
+++ b/src_proiect/Usermode/FileReadNormal/main.c
@@ -0,0 +1,73 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define EXPECTED_BUFFER "UserModeApplications:Applications"
+
+#define MIN_BUFFER_SIZE     0x200
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+    QWORD bytesRead;
+    BYTE bufferRead[MIN_BUFFER_SIZE];
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    handle = UM_INVALID_HANDLE_VALUE;
+    bufferRead[MIN_BUFFER_SIZE - 1] = '\0';
+
+    __try
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            __leave;
+        }
+
+        status = SyscallFileRead(handle,
+                                 bufferRead,
+                                 MIN_BUFFER_SIZE,
+                                 &bytesRead);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileRead", status);
+            __leave;
+        }
+
+        if (bytesRead != MIN_BUFFER_SIZE)
+        {
+            LOG_ERROR("We expected to read %U bytes, while we actually read %U!\n",
+                      MIN_BUFFER_SIZE, bytesRead);
+            __leave;
+        }
+
+        if (memcmp(bufferRead, EXPECTED_BUFFER, (DWORD) sizeof(EXPECTED_BUFFER) - 1) != 0)
+        {
+            LOG_ERROR("Expected buffer is [%s], buffer read is [%s]\n",
+                      EXPECTED_BUFFER, bufferRead);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (handle != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallFileClose(handle);
+            handle = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadStdout/FileReadStdout.vcxproj b/src_proiect/Usermode/FileReadStdout/FileReadStdout.vcxproj
new file mode 100644
index 0000000..0312f3c
--- /dev/null
+++ b/src_proiect/Usermode/FileReadStdout/FileReadStdout.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{79dda691-0eea-4658-8372-e6b1c2e77fe8}</ProjectGuid>
+    <RootNamespace>FileReadStdout</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadStdout/FileReadStdout.vcxproj.filters b/src_proiect/Usermode/FileReadStdout/FileReadStdout.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileReadStdout/FileReadStdout.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadStdout/main.c b/src_proiect/Usermode/FileReadStdout/main.c
new file mode 100644
index 0000000..97833d3
--- /dev/null
+++ b/src_proiect/Usermode/FileReadStdout/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    QWORD bytesRead;
+    char buff;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileRead(UM_FILE_HANDLE_STDOUT,
+                             &buff,
+                             1,
+                             &bytesRead);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("We should not be able to read from STDOUT!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadZero/FileReadZero.vcxproj b/src_proiect/Usermode/FileReadZero/FileReadZero.vcxproj
new file mode 100644
index 0000000..910a5d6
--- /dev/null
+++ b/src_proiect/Usermode/FileReadZero/FileReadZero.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{357100b6-0650-44f2-9bb6-f3337249d714}</ProjectGuid>
+    <RootNamespace>FileReadZero</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadZero/FileReadZero.vcxproj.filters b/src_proiect/Usermode/FileReadZero/FileReadZero.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/FileReadZero/FileReadZero.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/FileReadZero/main.c b/src_proiect/Usermode/FileReadZero/main.c
new file mode 100644
index 0000000..4dff2d4
--- /dev/null
+++ b/src_proiect/Usermode/FileReadZero/main.c
@@ -0,0 +1,61 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+    QWORD bytesRead;
+    char buf;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    handle = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            __leave;
+        }
+
+        status = SyscallFileRead(handle,
+                                 &buf,
+                                 0,
+                                 &bytesRead);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileRead", status);
+            __leave;
+        }
+
+        if (bytesRead != 0)
+        {
+            LOG_ERROR("We expected to read zero bytes, while we actually read %U!\n", bytesRead);
+            __leave;
+        }
+
+    }
+    __finally
+    {
+        if (handle != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallFileClose(handle);
+            handle = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/HAL9000_UserApplication.zip b/src_proiect/Usermode/HAL9000_UserApplication.zip
new file mode 100644
index 0000000..780c0ed
Binary files /dev/null and b/src_proiect/Usermode/HAL9000_UserApplication.zip differ
diff --git a/src_proiect/Usermode/HAL9000_UserMain.zip b/src_proiect/Usermode/HAL9000_UserMain.zip
new file mode 100644
index 0000000..ad1b3f1
Binary files /dev/null and b/src_proiect/Usermode/HAL9000_UserMain.zip differ
diff --git a/src_proiect/Usermode/ProcessCloseFile/ProcessCloseFile.vcxproj b/src_proiect/Usermode/ProcessCloseFile/ProcessCloseFile.vcxproj
new file mode 100644
index 0000000..d7855b2
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseFile/ProcessCloseFile.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0d8d80a1-e274-401d-bded-928a315700d7}</ProjectGuid>
+    <RootNamespace>ProcessCloseFile</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseFile/ProcessCloseFile.vcxproj.filters b/src_proiect/Usermode/ProcessCloseFile/ProcessCloseFile.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseFile/ProcessCloseFile.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseFile/main.c b/src_proiect/Usermode/ProcessCloseFile/main.c
new file mode 100644
index 0000000..4452333
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseFile/main.c
@@ -0,0 +1,34 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallFileCreate("HAL9000.ini",
+                               sizeof("HAL9000.ini"),
+                               FALSE,
+                               FALSE,
+                               &handle);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallFileCreate", status);
+    }
+
+    status = SyscallProcessCloseHandle(handle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallProcessCloseHandle should have failed with file handle!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseNormal/ProcessCloseNormal.vcxproj b/src_proiect/Usermode/ProcessCloseNormal/ProcessCloseNormal.vcxproj
new file mode 100644
index 0000000..3cc61aa
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseNormal/ProcessCloseNormal.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{61e34105-4020-4582-9f7c-e86db0bdd7bd}</ProjectGuid>
+    <RootNamespace>ProcessCloseNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseNormal/ProcessCloseNormal.vcxproj.filters b/src_proiect/Usermode/ProcessCloseNormal/ProcessCloseNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseNormal/ProcessCloseNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseNormal/main.c b/src_proiect/Usermode/ProcessCloseNormal/main.c
new file mode 100644
index 0000000..414df29
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseNormal/main.c
@@ -0,0 +1,44 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcess;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallProcessCreate("dummy.exe",
+                                  sizeof("dummy.exe"),
+                                  NULL,
+                                  0,
+                                  &hProcess);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallProcessCreate", status);
+    }
+    else
+    {
+        STATUS termStatus;
+
+        status = SyscallProcessWaitForTermination(hProcess, &termStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+        }
+
+        status = SyscallProcessCloseHandle(hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseParentHandle/ProcessCloseParentHandle.vcxproj b/src_proiect/Usermode/ProcessCloseParentHandle/ProcessCloseParentHandle.vcxproj
new file mode 100644
index 0000000..8b83b8a
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseParentHandle/ProcessCloseParentHandle.vcxproj
@@ -0,0 +1,140 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{54ae077d-560d-4fcc-97ba-d357ccf9a482}</ProjectGuid>
+    <RootNamespace>ProcessCloseParentHandle</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <DisableSpecificWarnings>4474;4778;</DisableSpecificWarnings>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseParentHandle/ProcessCloseParentHandle.vcxproj.filters b/src_proiect/Usermode/ProcessCloseParentHandle/ProcessCloseParentHandle.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseParentHandle/ProcessCloseParentHandle.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseParentHandle/main.c b/src_proiect/Usermode/ProcessCloseParentHandle/main.c
new file mode 100644
index 0000000..955c40c
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseParentHandle/main.c
@@ -0,0 +1,94 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+#include "strutils.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    if (argc == 1)
+    {
+        // Initial process, will spawn this process again with an additional argument specifying the handle to close
+        STATUS status;
+        STATUS terminationStatus;
+        UM_HANDLE hFile;
+        UM_HANDLE hProcess;
+        char argBuffer[MAX_PATH];
+
+        __try
+        {
+            status = SyscallFileCreate("HAL9000.ini",
+                                       sizeof("HAL9000.ini"),
+                                       FALSE,
+                                       FALSE,
+                                       &hFile);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallFileCreate", status);
+                __leave;
+            }
+
+            status = snprintf(argBuffer, MAX_PATH, "%U", hFile);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("snprintf", status);
+                __leave;
+            }
+
+            status = SyscallProcessCreate("Proces~3.exe",
+                                          sizeof("Proces~3.exe"),
+                                          argBuffer,
+                                          MAX_PATH,
+                                          &hProcess);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCreate", status);
+                __leave;
+            }
+
+            status = SyscallProcessWaitForTermination(hProcess,
+                                                      &terminationStatus);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+                __leave;
+            }
+
+            status = SyscallProcessCloseHandle(hProcess);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+                __leave;
+            }
+
+            status = SyscallFileClose(hFile);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallFileClose", status);
+                __leave;
+            }
+        }
+        __finally
+        {
+
+        }
+    }
+    else
+    {
+        STATUS status;
+        UM_HANDLE hFileHandle;
+
+        atoi64(&hFileHandle, argv[1],BASE_TEN);
+
+        status = SyscallFileClose(hFileHandle);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallFileClose should have failed for parent file handle!\n");
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseTwice/ProcessCloseTwice.vcxproj b/src_proiect/Usermode/ProcessCloseTwice/ProcessCloseTwice.vcxproj
new file mode 100644
index 0000000..b53367a
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseTwice/ProcessCloseTwice.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{cef377b2-de01-4858-b831-4b698952b5c8}</ProjectGuid>
+    <RootNamespace>ProcessCloseTwice</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseTwice/ProcessCloseTwice.vcxproj.filters b/src_proiect/Usermode/ProcessCloseTwice/ProcessCloseTwice.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseTwice/ProcessCloseTwice.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCloseTwice/main.c b/src_proiect/Usermode/ProcessCloseTwice/main.c
new file mode 100644
index 0000000..d88ac16
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCloseTwice/main.c
@@ -0,0 +1,58 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcess;
+    STATUS termStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    __try
+    {
+        status = SyscallProcessCreate("dummy.exe",
+                                      sizeof("dummy.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        status = SyscallProcessWaitForTermination(hProcess, &termStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            __leave;
+        }
+
+        status = SyscallProcessCloseHandle(hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            __leave;
+        }
+
+        status = SyscallProcessCloseHandle(hProcess);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallProcessCloseHandle should have failed on the second close attempt!\n");
+            __leave;
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateBadPointer/ProcessCreateBadPointer.vcxproj b/src_proiect/Usermode/ProcessCreateBadPointer/ProcessCreateBadPointer.vcxproj
new file mode 100644
index 0000000..ff4609a
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateBadPointer/ProcessCreateBadPointer.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{858f4efc-1c02-402a-adee-4e40dee20b61}</ProjectGuid>
+    <RootNamespace>ProcessCreateBadPointer</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateBadPointer/ProcessCreateBadPointer.vcxproj.filters b/src_proiect/Usermode/ProcessCreateBadPointer/ProcessCreateBadPointer.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateBadPointer/ProcessCreateBadPointer.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateBadPointer/main.c b/src_proiect/Usermode/ProcessCreateBadPointer/main.c
new file mode 100644
index 0000000..3000907
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateBadPointer/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcessHandle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallProcessCreate(NULL,
+                                  0,
+                                  NULL,
+                                  0,
+                                  &hProcessHandle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("Process creation with invalid pointer should have failed!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateMissingFile/ProcessCreateMissingFile.vcxproj b/src_proiect/Usermode/ProcessCreateMissingFile/ProcessCreateMissingFile.vcxproj
new file mode 100644
index 0000000..38bb635
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateMissingFile/ProcessCreateMissingFile.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{34d1efde-5f45-462f-a610-f925822f10be}</ProjectGuid>
+    <RootNamespace>ProcessCreateMissingFile</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateMissingFile/ProcessCreateMissingFile.vcxproj.filters b/src_proiect/Usermode/ProcessCreateMissingFile/ProcessCreateMissingFile.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateMissingFile/ProcessCreateMissingFile.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateMissingFile/main.c b/src_proiect/Usermode/ProcessCreateMissingFile/main.c
new file mode 100644
index 0000000..ca9e80d
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateMissingFile/main.c
@@ -0,0 +1,28 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcessHandle;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallProcessCreate("invalid.exe",
+                                  sizeof("invalid.exe"),
+                                  NULL,
+                                  0,
+                                  &hProcessHandle);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("Process creation with invalid path should have failed!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateMultiple/ProcessCreateMultiple.vcxproj b/src_proiect/Usermode/ProcessCreateMultiple/ProcessCreateMultiple.vcxproj
new file mode 100644
index 0000000..4663f98
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateMultiple/ProcessCreateMultiple.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{60070351-33a9-4935-9ba4-8ec021cb47b7}</ProjectGuid>
+    <RootNamespace>ProcessCreateMultiple</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateMultiple/ProcessCreateMultiple.vcxproj.filters b/src_proiect/Usermode/ProcessCreateMultiple/ProcessCreateMultiple.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateMultiple/ProcessCreateMultiple.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateMultiple/main.c b/src_proiect/Usermode/ProcessCreateMultiple/main.c
new file mode 100644
index 0000000..c560bfd
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateMultiple/main.c
@@ -0,0 +1,72 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define PROCESSES_TO_CREATE         10
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcess[PROCESSES_TO_CREATE];
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    for (DWORD i = 0; i < PROCESSES_TO_CREATE; ++i)
+    {
+        hProcess[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    __try
+    {
+        for (DWORD i = 0; i < PROCESSES_TO_CREATE; ++i)
+        {
+            STATUS termStatus;
+
+            status = SyscallProcessCreate("dummy.exe",
+                                          sizeof("dummy.exe"),
+                                          NULL,
+                                          0,
+                                          &hProcess[i]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCreate", status);
+                __leave;
+            }
+
+            if (hProcess[i] == UM_INVALID_HANDLE_VALUE)
+            {
+                LOG_ERROR("0x%X is not a valid handle value for a process!\n", UM_INVALID_HANDLE_VALUE);
+                __leave;
+            }
+
+            status = SyscallProcessWaitForTermination(hProcess[i], &termStatus);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+                __leave;
+            }
+        }
+    }
+    __finally
+    {
+        for (DWORD i = 0; i < PROCESSES_TO_CREATE; ++i)
+        {
+            if (hProcess[i] != UM_INVALID_HANDLE_VALUE)
+            {
+                status = SyscallProcessCloseHandle(hProcess[i]);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+                }
+                hProcess[i] = UM_INVALID_HANDLE_VALUE;
+            }
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateOnce/ProcessCreateOnce.vcxproj b/src_proiect/Usermode/ProcessCreateOnce/ProcessCreateOnce.vcxproj
new file mode 100644
index 0000000..def8b71
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateOnce/ProcessCreateOnce.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{a6f6a4a3-a04b-4aad-8ac8-31bd2d515d9e}</ProjectGuid>
+    <RootNamespace>ProcessCreateOnce</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateOnce/ProcessCreateOnce.vcxproj.filters b/src_proiect/Usermode/ProcessCreateOnce/ProcessCreateOnce.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateOnce/ProcessCreateOnce.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateOnce/main.c b/src_proiect/Usermode/ProcessCreateOnce/main.c
new file mode 100644
index 0000000..f7dec5c
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateOnce/main.c
@@ -0,0 +1,58 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcess;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hProcess = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallProcessCreate("dummy.exe",
+                                      sizeof("dummy.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        if (hProcess == UM_INVALID_HANDLE_VALUE)
+        {
+            LOG_ERROR("0x%X is not a valid handle value for a process!\n", UM_INVALID_HANDLE_VALUE);
+        }
+
+        status = SyscallProcessWaitForTermination(hProcess, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+        }
+    }
+    __finally
+    {
+        if (hProcess != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallProcessCloseHandle(hProcess);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            }
+            hProcess = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateWithArguments/ProcessCreateWithArguments.vcxproj b/src_proiect/Usermode/ProcessCreateWithArguments/ProcessCreateWithArguments.vcxproj
new file mode 100644
index 0000000..37324cf
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateWithArguments/ProcessCreateWithArguments.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{46b6d3d5-1320-42e8-97eb-e91cf0c47b97}</ProjectGuid>
+    <RootNamespace>ProcessCreateWithArguments</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateWithArguments/ProcessCreateWithArguments.vcxproj.filters b/src_proiect/Usermode/ProcessCreateWithArguments/ProcessCreateWithArguments.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateWithArguments/ProcessCreateWithArguments.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessCreateWithArguments/main.c b/src_proiect/Usermode/ProcessCreateWithArguments/main.c
new file mode 100644
index 0000000..fa9cc61
--- /dev/null
+++ b/src_proiect/Usermode/ProcessCreateWithArguments/main.c
@@ -0,0 +1,53 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE hProcessHandle;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hProcessHandle = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallProcessCreate("args.exe",
+                                      sizeof("args.exe"),
+                                      "Let's get some arguments printed!",
+                                      sizeof("Let's get some arguments printed!"),
+                                      &hProcessHandle);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+        }
+
+        status = SyscallProcessWaitForTermination(hProcessHandle, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+        }
+    }
+    __finally
+    {
+        if (hProcessHandle != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallProcessCloseHandle(hProcessHandle);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            }
+
+            hProcessHandle = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessExit/ProcessExit.vcxproj b/src_proiect/Usermode/ProcessExit/ProcessExit.vcxproj
new file mode 100644
index 0000000..ec66db2
--- /dev/null
+++ b/src_proiect/Usermode/ProcessExit/ProcessExit.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{a995d9fc-dbb6-4178-a067-21fba8364cd3}</ProjectGuid>
+    <RootNamespace>ProcessExit</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessExit/ProcessExit.vcxproj.filters b/src_proiect/Usermode/ProcessExit/ProcessExit.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessExit/ProcessExit.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessExit/main.c b/src_proiect/Usermode/ProcessExit/main.c
new file mode 100644
index 0000000..3f2a864
--- /dev/null
+++ b/src_proiect/Usermode/ProcessExit/main.c
@@ -0,0 +1,20 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallProcessExit(STATUS_SUCCESS);
+    LOG_ERROR("The exit function should not return!\n");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessGetPid/ProcessGetPid.vcxproj b/src_proiect/Usermode/ProcessGetPid/ProcessGetPid.vcxproj
new file mode 100644
index 0000000..1fe3255
--- /dev/null
+++ b/src_proiect/Usermode/ProcessGetPid/ProcessGetPid.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{45e73486-6f22-4d46-bf4d-a4efa4a5be83}</ProjectGuid>
+    <RootNamespace>ProcessGetPid</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessGetPid/ProcessGetPid.vcxproj.filters b/src_proiect/Usermode/ProcessGetPid/ProcessGetPid.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessGetPid/ProcessGetPid.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessGetPid/main.c b/src_proiect/Usermode/ProcessGetPid/main.c
new file mode 100644
index 0000000..9431e5f
--- /dev/null
+++ b/src_proiect/Usermode/ProcessGetPid/main.c
@@ -0,0 +1,103 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    PID pid1, pid2;
+    UM_HANDLE hProcess;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hProcess = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallProcessGetPid(UM_INVALID_HANDLE_VALUE, &pid1);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessGetPid", status);
+            __leave;
+        }
+
+        status = SyscallProcessGetPid(UM_INVALID_HANDLE_VALUE, &pid2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessGetPid", status);
+            __leave;
+        }
+
+        if (pid1 != pid2)
+        {
+            LOG_ERROR("The process should not randomly change its PID, pid1: 0x%X, pid2: 0x%X!\n",
+                      pid1, pid2);
+            __leave;
+        }
+
+        status = SyscallProcessCreate("dummy.exe",
+                                      sizeof("dummy.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        status = SyscallProcessGetPid(UM_INVALID_HANDLE_VALUE, &pid2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessGetPid", status);
+            __leave;
+        }
+
+        if (pid1 != pid2)
+        {
+            LOG_ERROR("The process should not change its PID after it created a child, pid1: 0x%X, pid2: 0x%X!\n",
+                      pid1, pid2);
+        }
+
+        status = SyscallProcessGetPid(hProcess, &pid2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessGetPid", status);
+            __leave;
+        }
+
+        if (pid1 == pid2)
+        {
+            LOG_ERROR("Two processes should not have the same PID, pid1: 0x%X, pid2: 0x%X!\n",
+                      pid1, pid2);
+        }
+    }
+    __finally
+    {
+        if (hProcess != UM_INVALID_HANDLE_VALUE)
+        {
+            STATUS termStatus;
+
+            status = SyscallProcessWaitForTermination(hProcess, &termStatus);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+            }
+
+            status = SyscallProcessCloseHandle(hProcess);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            }
+
+            hProcess = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj b/src_proiect/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj
new file mode 100644
index 0000000..55812c6
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{2c3203ca-606a-4748-9859-06d6545dd166}</ProjectGuid>
+    <RootNamespace>ProcessQuotaGood</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj.filters b/src_proiect/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaGood/ProcessQuotaGood.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaGood/main.c b/src_proiect/Usermode/ProcessQuotaGood/main.c
new file mode 100644
index 0000000..6c149f9
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaGood/main.c
@@ -0,0 +1,103 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define HANDLES_TO_OPEN         16
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handles[HANDLES_TO_OPEN];
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            return status;
+        }
+    }
+
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileClose(handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+            return status;
+        }
+
+        handles[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    // After we closed the handles, we can open other ones
+
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            return status;
+        }
+    }
+
+    // close half of them
+    for (DWORD i = 0; i < HANDLES_TO_OPEN / 2; ++i)
+    {
+        status = SyscallFileClose(handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+            return status;
+        }
+
+        handles[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    // open another 8 handles
+    for (DWORD i = 0; i < HANDLES_TO_OPEN / 2; ++i)
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            return status;
+        }
+    }
+
+    // everything went just fine
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileClose(handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+            return status;
+        }
+
+        handles[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj b/src_proiect/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj
new file mode 100644
index 0000000..694fe08
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{73243670-829f-4e0c-b332-ec673749fad4}</ProjectGuid>
+    <RootNamespace>ProcessQuotaJustRight</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj.filters b/src_proiect/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaJustRight/ProcessQuotaJustRight.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaJustRight/main.c b/src_proiect/Usermode/ProcessQuotaJustRight/main.c
new file mode 100644
index 0000000..5879337
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaJustRight/main.c
@@ -0,0 +1,46 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define HANDLES_TO_OPEN         16
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handles[HANDLES_TO_OPEN];
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            return status;
+        }
+    }
+
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileClose(handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+            return status;
+        }
+
+        handles[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj b/src_proiect/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj
new file mode 100644
index 0000000..6ea417f
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{30a04ce4-0907-4357-a8cb-baf5d7fb463a}</ProjectGuid>
+    <RootNamespace>ProcessQuotaMore</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj.filters b/src_proiect/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaMore/ProcessQuotaMore.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessQuotaMore/main.c b/src_proiect/Usermode/ProcessQuotaMore/main.c
new file mode 100644
index 0000000..c99e705
--- /dev/null
+++ b/src_proiect/Usermode/ProcessQuotaMore/main.c
@@ -0,0 +1,54 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define HANDLES_TO_OPEN         32
+#define NO_OF_VALID_HANDLES     16
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    UM_HANDLE handles[HANDLES_TO_OPEN];
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    for (DWORD i = 0; i < HANDLES_TO_OPEN; ++i)
+    {
+        status = SyscallFileCreate("HAL9000.ini",
+                                   sizeof("HAL9000.ini"),
+                                   FALSE,
+                                   FALSE,
+                                   &handles[i]);
+        if ((i < NO_OF_VALID_HANDLES) && !SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileCreate", status);
+            return status;
+        }
+
+        if ((i >= NO_OF_VALID_HANDLES) && SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallFileCreate succeeded even if we exceeded or %u open files quota!\n",
+                      NO_OF_VALID_HANDLES);
+            return status;
+        }
+    }
+
+    for (DWORD i = 0; i < NO_OF_VALID_HANDLES; ++i)
+    {
+        status = SyscallFileClose(handles[i]);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallFileClose", status);
+            return status;
+        }
+
+        handles[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitBadHandle/ProcessWaitBadHandle.vcxproj b/src_proiect/Usermode/ProcessWaitBadHandle/ProcessWaitBadHandle.vcxproj
new file mode 100644
index 0000000..636a8ef
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitBadHandle/ProcessWaitBadHandle.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{fba79b89-f2f7-40a7-aa87-87a1d8a367d9}</ProjectGuid>
+    <RootNamespace>ProcessWaitBadHandle</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitBadHandle/ProcessWaitBadHandle.vcxproj.filters b/src_proiect/Usermode/ProcessWaitBadHandle/ProcessWaitBadHandle.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitBadHandle/ProcessWaitBadHandle.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitBadHandle/main.c b/src_proiect/Usermode/ProcessWaitBadHandle/main.c
new file mode 100644
index 0000000..b8af000
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitBadHandle/main.c
@@ -0,0 +1,24 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallProcessWaitForTermination(0x700, &terminationStatus);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallProcessWaitForTermination should have failed for invalid handle!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitClosedHandle/ProcessWaitClosedHandle.vcxproj b/src_proiect/Usermode/ProcessWaitClosedHandle/ProcessWaitClosedHandle.vcxproj
new file mode 100644
index 0000000..25cbe01
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitClosedHandle/ProcessWaitClosedHandle.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{809928ad-2acc-4f25-80d0-3abcd962607b}</ProjectGuid>
+    <RootNamespace>ProcessWaitClosedHandle</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitClosedHandle/ProcessWaitClosedHandle.vcxproj.filters b/src_proiect/Usermode/ProcessWaitClosedHandle/ProcessWaitClosedHandle.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitClosedHandle/ProcessWaitClosedHandle.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitClosedHandle/main.c b/src_proiect/Usermode/ProcessWaitClosedHandle/main.c
new file mode 100644
index 0000000..fd4fe14
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitClosedHandle/main.c
@@ -0,0 +1,55 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    STATUS terminationStatus;
+    UM_HANDLE hProcess;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hProcess = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallProcessCreate("dummy.exe",
+                                      sizeof("dummy.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        status = SyscallProcessCloseHandle(hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            __leave;
+        }
+
+        status = SyscallProcessWaitForTermination(hProcess, &terminationStatus);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallProcessWaitForTermination should have failed for closed handle 0x%X", hProcess);
+            __leave;
+        }
+
+        LOG_TEST_PASS;
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitNormal/ProcessWaitNormal.vcxproj b/src_proiect/Usermode/ProcessWaitNormal/ProcessWaitNormal.vcxproj
new file mode 100644
index 0000000..927a386
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitNormal/ProcessWaitNormal.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{4088c233-7226-4098-9711-23d48000c2b8}</ProjectGuid>
+    <RootNamespace>ProcessWaitNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitNormal/ProcessWaitNormal.vcxproj.filters b/src_proiect/Usermode/ProcessWaitNormal/ProcessWaitNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitNormal/ProcessWaitNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitNormal/main.c b/src_proiect/Usermode/ProcessWaitNormal/main.c
new file mode 100644
index 0000000..9a708e5
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitNormal/main.c
@@ -0,0 +1,98 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    STATUS terminationStatus;
+    UM_HANDLE hProcess1;
+    UM_HANDLE hProcess2;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hProcess1 = UM_INVALID_HANDLE_VALUE;
+    hProcess2 = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallProcessCreate("dummy.exe",
+                                      sizeof("dummy.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess1);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        status = SyscallProcessWaitForTermination(hProcess1, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+            __leave;
+        }
+
+        if (terminationStatus != STATUS_SUCCESS)
+        {
+            LOG_ERROR("Process should have terminated with status 0x%x, but terminated with 0x%x\n",
+                      STATUS_SUCCESS, terminationStatus);
+            __leave;
+        }
+
+        status = SyscallProcessCreate("dummyf~1.exe",
+                                      sizeof("dummyf~1.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        status = SyscallProcessWaitForTermination(hProcess2, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+            __leave;
+        }
+
+        if (terminationStatus != STATUS_UNSUCCESSFUL)
+        {
+            LOG_ERROR("Process should have terminated with status 0x%x, but terminated with 0x%x\n",
+                      STATUS_UNSUCCESSFUL, terminationStatus);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hProcess1 != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallProcessCloseHandle(hProcess1);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            }
+            hProcess1 = UM_INVALID_HANDLE_VALUE;
+        }
+
+        if (hProcess2 != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallProcessCloseHandle(hProcess2);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            }
+            hProcess2 = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitTerminated/ProcessWaitTerminated.vcxproj b/src_proiect/Usermode/ProcessWaitTerminated/ProcessWaitTerminated.vcxproj
new file mode 100644
index 0000000..7cff097
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitTerminated/ProcessWaitTerminated.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{f434c3b0-1c9a-4a00-94ef-b8124021d370}</ProjectGuid>
+    <RootNamespace>ProcessWaitTerminated</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitTerminated/ProcessWaitTerminated.vcxproj.filters b/src_proiect/Usermode/ProcessWaitTerminated/ProcessWaitTerminated.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitTerminated/ProcessWaitTerminated.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ProcessWaitTerminated/main.c b/src_proiect/Usermode/ProcessWaitTerminated/main.c
new file mode 100644
index 0000000..06a1541
--- /dev/null
+++ b/src_proiect/Usermode/ProcessWaitTerminated/main.c
@@ -0,0 +1,68 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    STATUS terminationStatus;
+    UM_HANDLE hProcess;
+    volatile QWORD test = 0;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hProcess = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallProcessCreate("dummy.exe",
+                                      sizeof("dummy.exe"),
+                                      NULL,
+                                      0,
+                                      &hProcess);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessCreate", status);
+            __leave;
+        }
+
+        // wait for a period of time to make sure the newly spawned process has terminated
+        for (DWORD i = 0; i < 0x10000; ++i)
+        {
+            test += i * i;
+        }
+
+        status = SyscallProcessWaitForTermination(hProcess, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+            __leave;
+        }
+
+        if (terminationStatus != STATUS_SUCCESS)
+        {
+            LOG_ERROR("Process should have terminated with status 0x%x, but terminated with 0x%x\n",
+                      STATUS_SUCCESS, terminationStatus);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hProcess != UM_INVALID_HANDLE_VALUE)
+        {
+            status = SyscallProcessCloseHandle(hProcess);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+            }
+            hProcess = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj b/src_proiect/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj
new file mode 100644
index 0000000..06de4a8
--- /dev/null
+++ b/src_proiect/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{7a3f18f0-b375-4a08-b944-ac7148793ae7}</ProjectGuid>
+    <RootNamespace>StackGrowthRecursiveFunction</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj.filters b/src_proiect/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/StackGrowthRecursiveFunction/StackGrowthRecursiveFunction.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/StackGrowthRecursiveFunction/main.c b/src_proiect/Usermode/StackGrowthRecursiveFunction/main.c
new file mode 100644
index 0000000..705d7a9
--- /dev/null
+++ b/src_proiect/Usermode/StackGrowthRecursiveFunction/main.c
@@ -0,0 +1,29 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define NO_OF_TIMES_TO_CALL_RECURSIVE_FUNCTIONS     10000
+
+// we turn all compiler optimizations off so we don't have any surprises
+#pragma optimize("", off)
+static void _RecursiveFunction(DWORD TimesToCall)
+{
+    if (TimesToCall == 0) return;
+
+    _RecursiveFunction(TimesToCall - 1);
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    _RecursiveFunction(NO_OF_TIMES_TO_CALL_RECURSIVE_FUNCTIONS);
+
+    return STATUS_SUCCESS;
+}
+#pragma optimize("", on)
diff --git a/src_proiect/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj b/src_proiect/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj
new file mode 100644
index 0000000..d4505e2
--- /dev/null
+++ b/src_proiect/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d4ef4101-8e74-45c4-93b0-1ac3f29399b9}</ProjectGuid>
+    <RootNamespace>StackGrowthVariables</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj.filters b/src_proiect/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/StackGrowthVariables/StackGrowthVariables.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/StackGrowthVariables/main.c b/src_proiect/Usermode/StackGrowthVariables/main.c
new file mode 100644
index 0000000..64a5ef2
--- /dev/null
+++ b/src_proiect/Usermode/StackGrowthVariables/main.c
@@ -0,0 +1,72 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+// we turn all compiler optimizations off so we don't have any surprises
+#pragma optimize("", off)
+
+#define NO_OF_TIMES_TO_ALLOCATE_ALMOST_A_PAGE_OF_LOCAL_VARIABLES     10
+
+#define VALUE_TO_PLACE_ON_LOCAL_VARIABLE                             0xAA
+
+// explanation can be found in figure (I have no idea why Visual C compiler generates 0x30 bytes
+// of 0xCC's for RTC at the start of the variable, but only 0x10 bytes at the end of it
+// 0x70 (0x20 shadow stack + 0x8 RA + 0x8 RDI + 0x40 CC's)
+#define MAX_LOCAL_VAR_ALLOC_LENGTH      (PAGE_SIZE - 0x70)
+
+// the reason why we call multiple functions to allocate more than 1 page of variables is because
+// if we want to allocate a PAGE_SIZE or more of local variables the Visual C compiler wants to call
+// __chkstk which HAL currently doesn't support (__chkstk would actually do what we do in these functions,
+// i.e. touch the local variables page by page)
+
+//  STACK TOP
+//  -----------------------------------------------------------------
+//  |                                                               |
+//  |       Shadow Space                                            |
+//  |                                                               |
+//  |                                                               |
+//  -----------------------------------------------------------------   -0x20
+//  |     Return Address                                            |
+//  -----------------------------------------------------------------   -0x28
+//  |     RDI                                                       |
+//  -----------------------------------------------------------------   -0x30
+//  |     RTC variable = 0xCC..CC                                   |
+//  -----------------------------------------------------------------   -0x40
+//  |     dummyVariable                                             |
+//  -----------------------------------------------------------------   -0xFD0
+//  |     RTC variable = 0xCC..CC                                   |
+//  -----------------------------------------------------------------   -0x1000
+static void _AllocateAlmostAPageOfLocalVariables(DWORD TimesToCall)
+{
+    BYTE dummyVariable[MAX_LOCAL_VAR_ALLOC_LENGTH];
+
+    if (TimesToCall == 0) return;
+
+    // on debug this isn't even needed because Visual C initializes the region
+    // with CC's
+    dummyVariable[0] = VALUE_TO_PLACE_ON_LOCAL_VARIABLE;
+
+    _AllocateAlmostAPageOfLocalVariables(TimesToCall - 1);
+
+    if (dummyVariable[0] != VALUE_TO_PLACE_ON_LOCAL_VARIABLE)
+    {
+        LOG_ERROR("Value placed on stack 0x%02x differs from value read 0x%02x\n",
+            VALUE_TO_PLACE_ON_LOCAL_VARIABLE, dummyVariable[0]);
+    }
+}
+
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    _AllocateAlmostAPageOfLocalVariables(NO_OF_TIMES_TO_ALLOCATE_ALMOST_A_PAGE_OF_LOCAL_VARIABLES);
+
+    return STATUS_SUCCESS;
+}
+#pragma optimize("", on)
diff --git a/src_proiect/Usermode/SwapLinear/SwapLinear.vcxproj b/src_proiect/Usermode/SwapLinear/SwapLinear.vcxproj
new file mode 100644
index 0000000..f62688d
--- /dev/null
+++ b/src_proiect/Usermode/SwapLinear/SwapLinear.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d61d8289-38bd-4cc1-b943-a53c2dcd800b}</ProjectGuid>
+    <RootNamespace>SwapLinear</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapLinear/SwapLinear.vcxproj.filters b/src_proiect/Usermode/SwapLinear/SwapLinear.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/SwapLinear/SwapLinear.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapLinear/main.c b/src_proiect/Usermode/SwapLinear/main.c
new file mode 100644
index 0000000..d97d41c
--- /dev/null
+++ b/src_proiect/Usermode/SwapLinear/main.c
@@ -0,0 +1,90 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+#define SIZE_TO_ALLOCATE            (16 * MB_SIZE)
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile QWORD* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     SIZE_TO_ALLOCATE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*)&pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+        memzero((PVOID)pAllocatedAddress, SIZE_TO_ALLOCATE);
+
+        for (DWORD i = 0; i < SIZE_TO_ALLOCATE / sizeof(*pAllocatedAddress); i += PAGE_SIZE)
+        {
+            pAllocatedAddress[i] = i + VALUE_TO_WRITE;
+        }
+
+        for (DWORD i = 0; i < SIZE_TO_ALLOCATE / sizeof(*pAllocatedAddress); i += PAGE_SIZE)
+        {
+            if (pAllocatedAddress[i] != i + VALUE_TO_WRITE)
+            {
+                LOG_ERROR("We have preivously written 0x%X at offset 0x%X, but now we have 0x%X\n",
+                          i + VALUE_TO_WRITE, PtrDiff(pAllocatedAddress + i, pAllocatedAddress), pAllocatedAddress[i]);
+                __leave;
+            }
+
+            pAllocatedAddress[i] = 0;
+        }
+
+        for (DWORD i = 0; i < SIZE_TO_ALLOCATE / sizeof(*pAllocatedAddress); i += PAGE_SIZE)
+        {
+            if (pAllocatedAddress[i] != 0)
+            {
+                LOG_ERROR("We have preivously zeroed at offset 0x%X, but now we have 0x%X\n",
+                          PtrDiff(pAllocatedAddress + i, pAllocatedAddress), pAllocatedAddress[i]);
+                __leave;
+            }
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj b/src_proiect/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj
new file mode 100644
index 0000000..fc7aabe
--- /dev/null
+++ b/src_proiect/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{fc4360d9-b78c-4cd3-82ee-67877e091ec7}</ProjectGuid>
+    <RootNamespace>SwapMultipleShared</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj.filters b/src_proiect/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/SwapMultipleShared/SwapMultipleShared.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapMultipleShared/main.c b/src_proiect/Usermode/SwapMultipleShared/main.c
new file mode 100644
index 0000000..80d8d7b
--- /dev/null
+++ b/src_proiect/Usermode/SwapMultipleShared/main.c
@@ -0,0 +1,148 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+#include "strutils.h"
+
+#define VALUE_TO_WRITE              0x37U
+#define SHARED_KEY_VALUE            0xC391'3921'0231'3922ULL
+
+#define SIZE_TO_ALLOCATE            (16 * MB_SIZE)
+
+#define PROCESSES_TO_SPAWN          4
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile QWORD* pAllocatedAddress;
+    BOOLEAN bPassed;
+    DWORD processIdx;
+    BOOLEAN bFirstProcess;
+
+    if (argc != 2)
+    {
+        LOG_ERROR("Program usage is %s $PROCESS_IDX\n", argv[0]);
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+    atoi32(&processIdx, argv[1], BASE_TEN);
+    bFirstProcess = (processIdx == 0);
+
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     SIZE_TO_ALLOCATE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     SHARED_KEY_VALUE,
+                                     (PVOID*)&pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        if (bFirstProcess)
+        {
+            UM_HANDLE hProcesses[PROCESSES_TO_SPAWN];
+            char nxtProcessIdx[3];
+
+            for (DWORD i = 0; i < PROCESSES_TO_SPAWN; ++i)
+            {
+                hProcesses[i] = UM_INVALID_HANDLE_VALUE;
+            }
+
+            for (DWORD i = 0; i < PROCESSES_TO_SPAWN; ++i)
+            {
+                snprintf(nxtProcessIdx, sizeof(nxtProcessIdx), "%u", i + 1);
+
+                // create a new reincarcanation of itself
+                status = SyscallProcessCreate(argv[0],
+                                              strlen(argv[0]) + 1,
+                                              nxtProcessIdx,
+                                              strlen(nxtProcessIdx) + 1,
+                                              &hProcesses[i]);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("SyscallProcessCreate", status);
+                    __leave;
+                }
+            }
+
+            for (DWORD i = 0; i < PROCESSES_TO_SPAWN; ++i)
+            {
+                STATUS termStatus;
+
+                status = SyscallProcessWaitForTermination(hProcesses[i], &termStatus);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+                    __leave;
+                }
+
+                if (!SUCCEEDED(termStatus))
+                {
+                    LOG_ERROR("Process terminated with status 0x%x\n", termStatus);
+                }
+
+                status = SyscallProcessCloseHandle(hProcesses[i]);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("SyscallProcessCloseHandle", status);
+                    __leave;
+                }
+
+                hProcesses[i] = UM_INVALID_HANDLE_VALUE;
+            }
+
+            for (DWORD i = 0; i < SIZE_TO_ALLOCATE / sizeof(*pAllocatedAddress); ++i)
+            {
+                if (pAllocatedAddress[i] != i + VALUE_TO_WRITE)
+                {
+                    LOG_ERROR("We have preivously written 0x%X at offset 0x%X, but now we have 0x%X\n",
+                              i + VALUE_TO_WRITE, PtrDiff(pAllocatedAddress + i, pAllocatedAddress), pAllocatedAddress[i]);
+                    __leave;
+                }
+            }
+
+            bPassed = TRUE;
+        }
+        else
+        {
+            DWORD idxInBuffer = processIdx - 1;
+
+            for (DWORD i = idxInBuffer; i < SIZE_TO_ALLOCATE; i += PROCESSES_TO_SPAWN)
+            {
+                pAllocatedAddress[i] = i + VALUE_TO_WRITE;
+            }
+        }
+
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapZeros/SwapZeros.vcxproj b/src_proiect/Usermode/SwapZeros/SwapZeros.vcxproj
new file mode 100644
index 0000000..0f2f3ff
--- /dev/null
+++ b/src_proiect/Usermode/SwapZeros/SwapZeros.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{2bf11960-6b4a-46ce-92c0-21c30ff1ab39}</ProjectGuid>
+    <RootNamespace>SwapZeros</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapZeros/SwapZeros.vcxproj.filters b/src_proiect/Usermode/SwapZeros/SwapZeros.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/SwapZeros/SwapZeros.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapZeros/main.c b/src_proiect/Usermode/SwapZeros/main.c
new file mode 100644
index 0000000..29a54b3
--- /dev/null
+++ b/src_proiect/Usermode/SwapZeros/main.c
@@ -0,0 +1,71 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+#define ZERO_ALLOC_SIZE             (256 * MB_SIZE)
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     ZERO_ALLOC_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_ZERO,
+                                     PAGE_RIGHTS_READ,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*)&pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        for (DWORD i = 0; i < ZERO_ALLOC_SIZE; i += PAGE_SIZE)
+        {
+            if (pAllocatedAddress[i] != 0)
+            {
+                LOG_ERROR("Allocated zero memory, but it isn't zero!\n");
+                __leave;
+            }
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj b/src_proiect/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj
new file mode 100644
index 0000000..59e983c
--- /dev/null
+++ b/src_proiect/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{f50ba1cb-dfb3-4c75-9c21-aafbf009ca42}</ProjectGuid>
+    <RootNamespace>SwapZerosWritten</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj.filters b/src_proiect/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/SwapZerosWritten/SwapZerosWritten.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/SwapZerosWritten/main.c b/src_proiect/Usermode/SwapZerosWritten/main.c
new file mode 100644
index 0000000..eab1b3d
--- /dev/null
+++ b/src_proiect/Usermode/SwapZerosWritten/main.c
@@ -0,0 +1,83 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+#define MEMORY_SIZE_TO_WRITE        (16 * MB_SIZE)
+#define ZERO_ALLOC_SIZE             (256 * MB_SIZE)
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     ZERO_ALLOC_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_ZERO,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*)&pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        for (DWORD i = 0; i < MEMORY_SIZE_TO_WRITE; i += PAGE_SIZE)
+        {
+            if (pAllocatedAddress[i] != 0)
+            {
+                LOG_ERROR("Allocated zero memory, but it isn't zero!\n");
+                __leave;
+            }
+
+            pAllocatedAddress[i] = VALUE_TO_WRITE;
+        }
+
+        for (DWORD i = 0; i < MEMORY_SIZE_TO_WRITE; i += PAGE_SIZE)
+        {
+            if (pAllocatedAddress[i] != VALUE_TO_WRITE)
+            {
+                LOG_ERROR("Changes to zero memory not brought back in memory!\n");
+                __leave;
+            }
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCloseTwice/ThreadCloseTwice.vcxproj b/src_proiect/Usermode/ThreadCloseTwice/ThreadCloseTwice.vcxproj
new file mode 100644
index 0000000..ee76d99
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCloseTwice/ThreadCloseTwice.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{89f0cc41-f7a4-46b8-b680-776ea30b3626}</ProjectGuid>
+    <RootNamespace>ThreadCloseTwice</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCloseTwice/ThreadCloseTwice.vcxproj.filters b/src_proiect/Usermode/ThreadCloseTwice/ThreadCloseTwice.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCloseTwice/ThreadCloseTwice.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCloseTwice/main.c b/src_proiect/Usermode/ThreadCloseTwice/main.c
new file mode 100644
index 0000000..5c405c6
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCloseTwice/main.c
@@ -0,0 +1,59 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = UmThreadCreate(_ThreadFunc, NULL, &hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        status = SyscallThreadCloseHandle(hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadCloseHandle", status);
+            __leave;
+        }
+
+        status = SyscallThreadCloseHandle(hThread);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallThreadCloseHandle succeeded even if the 0x%X handle was already closed!\n", hThread);
+            __leave;
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateBadPointer/ThreadCreateBadPointer.vcxproj b/src_proiect/Usermode/ThreadCreateBadPointer/ThreadCreateBadPointer.vcxproj
new file mode 100644
index 0000000..c641cea
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateBadPointer/ThreadCreateBadPointer.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{fe1ad7b0-8779-46a9-9404-5e9f70b5f251}</ProjectGuid>
+    <RootNamespace>ThreadCreateBadPointer</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateBadPointer/ThreadCreateBadPointer.vcxproj.filters b/src_proiect/Usermode/ThreadCreateBadPointer/ThreadCreateBadPointer.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateBadPointer/ThreadCreateBadPointer.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateBadPointer/main.c b/src_proiect/Usermode/ThreadCreateBadPointer/main.c
new file mode 100644
index 0000000..1ec6a06
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateBadPointer/main.c
@@ -0,0 +1,37 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    volatile QWORD test = 0;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        UmThreadCreate((PFUNC_ThreadStart) 0x7000'3203ULL, NULL, &hThread);
+
+        // wait for the process to crash
+        while(&hThread)
+        {
+            test += 1;
+            _mm_pause();
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateMultiple/ThreadCreateMultiple.vcxproj b/src_proiect/Usermode/ThreadCreateMultiple/ThreadCreateMultiple.vcxproj
new file mode 100644
index 0000000..9022956
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateMultiple/ThreadCreateMultiple.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{3e621da0-ad72-46dc-813a-78541acbe00a}</ProjectGuid>
+    <RootNamespace>ThreadCreateMultiple</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateMultiple/ThreadCreateMultiple.vcxproj.filters b/src_proiect/Usermode/ThreadCreateMultiple/ThreadCreateMultiple.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateMultiple/ThreadCreateMultiple.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateMultiple/main.c b/src_proiect/Usermode/ThreadCreateMultiple/main.c
new file mode 100644
index 0000000..91bcf67
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateMultiple/main.c
@@ -0,0 +1,73 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define THREADS_TO_CREATE           10
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThreads[THREADS_TO_CREATE];
+    STATUS thStatuses[THREADS_TO_CREATE];
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    for (DWORD i = 0; i < THREADS_TO_CREATE; ++i)
+    {
+        hThreads[i] = UM_INVALID_HANDLE_VALUE;
+    }
+
+    __try
+    {
+        for (DWORD i = 0; i < THREADS_TO_CREATE; ++i)
+        {
+            status = UmThreadCreate(_ThreadFunc, NULL, &hThreads[i]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("UmThreadCreate", status);
+                __leave;
+            }
+
+            if (hThreads[i] == UM_INVALID_HANDLE_VALUE)
+            {
+                LOG_ERROR("UmThreadCreate succeeded but the returned thread handle is 0x%X\n", hThreads[i]);
+                __leave;
+            }
+        }
+    }
+    __finally
+    {
+        for (DWORD i = 0; i < THREADS_TO_CREATE; ++i)
+        {
+            status = SyscallThreadWaitForTermination(hThreads[i], &thStatuses[i]);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            }
+        }
+
+        for (DWORD i = 0; i < THREADS_TO_CREATE; ++i)
+        {
+            SyscallThreadCloseHandle(hThreads[i]);
+            hThreads[i] = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateOnce/ThreadCreateOnce.vcxproj b/src_proiect/Usermode/ThreadCreateOnce/ThreadCreateOnce.vcxproj
new file mode 100644
index 0000000..6e8b93e
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateOnce/ThreadCreateOnce.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{dc6da37b-b2eb-466d-b0f4-d2bee6f86890}</ProjectGuid>
+    <RootNamespace>ThreadCreateOnce</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateOnce/ThreadCreateOnce.vcxproj.filters b/src_proiect/Usermode/ThreadCreateOnce/ThreadCreateOnce.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateOnce/ThreadCreateOnce.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateOnce/main.c b/src_proiect/Usermode/ThreadCreateOnce/main.c
new file mode 100644
index 0000000..cbc2440
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateOnce/main.c
@@ -0,0 +1,49 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = UmThreadCreate(_ThreadFunc, NULL, &hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hThread != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallThreadCloseHandle(hThread);
+            hThread = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateWithArguments/ThreadCreateWithArguments.vcxproj b/src_proiect/Usermode/ThreadCreateWithArguments/ThreadCreateWithArguments.vcxproj
new file mode 100644
index 0000000..6a9634e
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateWithArguments/ThreadCreateWithArguments.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{39d761cb-fd1f-4a0a-8be1-db1f30a6ba5a}</ProjectGuid>
+    <RootNamespace>ThreadCreateWithArguments</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateWithArguments/ThreadCreateWithArguments.vcxproj.filters b/src_proiect/Usermode/ThreadCreateWithArguments/ThreadCreateWithArguments.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateWithArguments/ThreadCreateWithArguments.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadCreateWithArguments/main.c b/src_proiect/Usermode/ThreadCreateWithArguments/main.c
new file mode 100644
index 0000000..98a645f
--- /dev/null
+++ b/src_proiect/Usermode/ThreadCreateWithArguments/main.c
@@ -0,0 +1,63 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    if (Context != _ThreadFunc)
+    {
+        LOG_ERROR("Context value should be 0x%X, but it is 0x%X\n",
+                  _ThreadFunc, Context);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    STATUS status;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        //  warning C4054: 'type cast': from function pointer 'STATUS (__cdecl *)(const PVOID)' to data pointer 'PVOID'
+#pragma warning(suppress:4054)
+        status = UmThreadCreate(_ThreadFunc, (PVOID)_ThreadFunc, &hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        status = SyscallThreadWaitForTermination(hThread, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hThread != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallThreadCloseHandle(hThread);
+            hThread = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadExit/ThreadExit.vcxproj b/src_proiect/Usermode/ThreadExit/ThreadExit.vcxproj
new file mode 100644
index 0000000..8190f10
--- /dev/null
+++ b/src_proiect/Usermode/ThreadExit/ThreadExit.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{1983bdd5-fb4a-4400-9d69-cd8156541622}</ProjectGuid>
+    <RootNamespace>ThreadExit</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadExit/ThreadExit.vcxproj.filters b/src_proiect/Usermode/ThreadExit/ThreadExit.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadExit/ThreadExit.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadExit/main.c b/src_proiect/Usermode/ThreadExit/main.c
new file mode 100644
index 0000000..de2ec9a
--- /dev/null
+++ b/src_proiect/Usermode/ThreadExit/main.c
@@ -0,0 +1,18 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    SyscallThreadExit(STATUS_SUCCESS);
+    LOG_ERROR("The exit function should not return!\n");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadGetTid/ThreadGetTid.vcxproj b/src_proiect/Usermode/ThreadGetTid/ThreadGetTid.vcxproj
new file mode 100644
index 0000000..8167133
--- /dev/null
+++ b/src_proiect/Usermode/ThreadGetTid/ThreadGetTid.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{b3d30950-51c0-44a6-84b3-afe6203e8851}</ProjectGuid>
+    <RootNamespace>ThreadGetTid</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadGetTid/ThreadGetTid.vcxproj.filters b/src_proiect/Usermode/ThreadGetTid/ThreadGetTid.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadGetTid/ThreadGetTid.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadGetTid/main.c b/src_proiect/Usermode/ThreadGetTid/main.c
new file mode 100644
index 0000000..8ec2df5
--- /dev/null
+++ b/src_proiect/Usermode/ThreadGetTid/main.c
@@ -0,0 +1,131 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static QWORD m_secondaryThTid;
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    STATUS status;
+    TID tid;
+
+    UNREFERENCED_PARAMETER(Context);
+
+    status = SyscallThreadGetTid(UM_INVALID_HANDLE_VALUE, &tid);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+    }
+    else
+    {
+        m_secondaryThTid = tid;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    STATUS status;
+    TID tid1;
+    TID tid2;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = SyscallThreadGetTid(UM_INVALID_HANDLE_VALUE, &tid1);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+            __leave;
+        }
+
+        status = SyscallThreadGetTid(UM_INVALID_HANDLE_VALUE, &tid2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+            __leave;
+        }
+
+        if (tid1 != tid2)
+        {
+            LOG_ERROR("The thread should not randomly change its TID, tid1: 0x%X, tid2: 0x%X!\n",
+                      tid1, tid2);
+            __leave;
+        }
+
+        status = UmThreadCreate(_ThreadFunc, NULL, &hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        status = SyscallThreadGetTid(UM_INVALID_HANDLE_VALUE, &tid2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+            __leave;
+        }
+
+        if (tid1 != tid2)
+        {
+            LOG_ERROR("The thread should not change its TID after it spawned a thread, tid1: 0x%X, tid2: 0x%X!\n",
+                      tid1, tid2);
+            __leave;
+        }
+
+        status = SyscallThreadGetTid(hThread, &tid2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadGetTid", status);
+            __leave;
+        }
+
+        if (tid1 == tid2)
+        {
+            LOG_ERROR("Two threads should not have equal TIDs, tid1: 0x%X, tid2: 0x%X!\n",
+                      tid1, tid2);
+            __leave;
+        }
+
+        status = SyscallThreadWaitForTermination(hThread, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            __leave;
+        }
+
+        if (tid2 != m_secondaryThTid)
+        {
+            LOG_ERROR("The TID determined by the main thread for the secondary thread differs from the one determined"
+                      "by the secondary thread, tid from primary: 0x%X, tid from secondary: 0x%X\n",
+                      tid2, m_secondaryThTid);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hThread != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallThreadCloseHandle(hThread);
+            hThread = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitBadHandle/ThreadWaitBadHandle.vcxproj b/src_proiect/Usermode/ThreadWaitBadHandle/ThreadWaitBadHandle.vcxproj
new file mode 100644
index 0000000..1c2fffc
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitBadHandle/ThreadWaitBadHandle.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{31d6ee61-177e-4cfb-a8e6-b16015c12e04}</ProjectGuid>
+    <RootNamespace>ThreadWaitBadHandle</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitBadHandle/ThreadWaitBadHandle.vcxproj.filters b/src_proiect/Usermode/ThreadWaitBadHandle/ThreadWaitBadHandle.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitBadHandle/ThreadWaitBadHandle.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitBadHandle/main.c b/src_proiect/Usermode/ThreadWaitBadHandle/main.c
new file mode 100644
index 0000000..87d4d96
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitBadHandle/main.c
@@ -0,0 +1,24 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallThreadWaitForTermination(0x700, &terminationStatus);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallThreadWaitForTermination should have failed for invalid handle!\n");
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitClosedHandle/ThreadWaitClosedHandle.vcxproj b/src_proiect/Usermode/ThreadWaitClosedHandle/ThreadWaitClosedHandle.vcxproj
new file mode 100644
index 0000000..a4de9e7
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitClosedHandle/ThreadWaitClosedHandle.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{aff37a3e-e5ca-4a99-bdf1-1735c1254d86}</ProjectGuid>
+    <RootNamespace>ThreadWaitClosedHandle</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitClosedHandle/ThreadWaitClosedHandle.vcxproj.filters b/src_proiect/Usermode/ThreadWaitClosedHandle/ThreadWaitClosedHandle.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitClosedHandle/ThreadWaitClosedHandle.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitClosedHandle/main.c b/src_proiect/Usermode/ThreadWaitClosedHandle/main.c
new file mode 100644
index 0000000..55bc73f
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitClosedHandle/main.c
@@ -0,0 +1,59 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    STATUS status;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = UmThreadCreate(_ThreadFunc, NULL, &hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        status = SyscallThreadCloseHandle(hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadCloseHandle", status);
+            __leave;
+        }
+
+        status = SyscallThreadWaitForTermination(hThread, &terminationStatus);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallThreadWaitForTermination should have failed because thread handle was closed!");
+        }
+    }
+    __finally
+    {
+
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitNormal/ThreadWaitNormal.vcxproj b/src_proiect/Usermode/ThreadWaitNormal/ThreadWaitNormal.vcxproj
new file mode 100644
index 0000000..2baf613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitNormal/ThreadWaitNormal.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{68f29f2c-efbd-472b-9b5e-d8fd4ea782c5}</ProjectGuid>
+    <RootNamespace>ThreadWaitNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitNormal/ThreadWaitNormal.vcxproj.filters b/src_proiect/Usermode/ThreadWaitNormal/ThreadWaitNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitNormal/ThreadWaitNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitNormal/main.c b/src_proiect/Usermode/ThreadWaitNormal/main.c
new file mode 100644
index 0000000..bb06050
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitNormal/main.c
@@ -0,0 +1,112 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    LOG("Hello from secondary thread!");
+
+    return STATUS_SUCCESS;
+}
+
+static
+STATUS
+(__cdecl _ThreadFailFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    LOG("Hello from secondary thread!");
+
+    return STATUS_UNSUCCESSFUL;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread1;
+    UM_HANDLE hThread2;
+    STATUS status;
+    STATUS terminationStatus;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread1 = UM_INVALID_HANDLE_VALUE;
+    hThread2 = UM_INVALID_HANDLE_VALUE;
+
+    __try
+    {
+        status = UmThreadCreate(_ThreadFunc, NULL, &hThread1);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        status = SyscallThreadWaitForTermination(hThread1, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            __leave;
+        }
+
+        LOG("First secondary thread has finished execution!");
+
+        if (terminationStatus != STATUS_SUCCESS)
+        {
+            LOG_ERROR("Thread should have terminated with status 0x%x, however it terminated with status 0x%x\n",
+                      STATUS_SUCCESS, terminationStatus);
+            __leave;
+        }
+
+        status = UmThreadCreate(_ThreadFailFunc, NULL, &hThread2);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        status = SyscallThreadWaitForTermination(hThread2, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            __leave;
+        }
+
+        LOG("Second secondary thread has finished execution!");
+
+        if (terminationStatus != STATUS_UNSUCCESSFUL)
+        {
+            LOG_ERROR("Thread should have terminated with status 0x%x, however it terminated with status 0x%x\n",
+                      STATUS_UNSUCCESSFUL, terminationStatus);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hThread1 != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallThreadCloseHandle(hThread1);
+            hThread1 = UM_INVALID_HANDLE_VALUE;
+        }
+
+        if (hThread2 != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallThreadCloseHandle(hThread2);
+            hThread2 = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitTerminated/ThreadWaitTerminated.vcxproj b/src_proiect/Usermode/ThreadWaitTerminated/ThreadWaitTerminated.vcxproj
new file mode 100644
index 0000000..540d364
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitTerminated/ThreadWaitTerminated.vcxproj
@@ -0,0 +1,139 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{343e7816-3e2e-4a46-9500-730e5cc7ccb5}</ProjectGuid>
+    <RootNamespace>ThreadWaitTerminated</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <SDLCheck>
+      </SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <StringPooling>false</StringPooling>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BufferSecurityCheck />
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <Link>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitTerminated/ThreadWaitTerminated.vcxproj.filters b/src_proiect/Usermode/ThreadWaitTerminated/ThreadWaitTerminated.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitTerminated/ThreadWaitTerminated.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/ThreadWaitTerminated/main.c b/src_proiect/Usermode/ThreadWaitTerminated/main.c
new file mode 100644
index 0000000..10e466e
--- /dev/null
+++ b/src_proiect/Usermode/ThreadWaitTerminated/main.c
@@ -0,0 +1,76 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+static
+STATUS
+(__cdecl _ThreadFunc)(
+    IN_OPT      PVOID       Context
+    )
+{
+    UNREFERENCED_PARAMETER(Context);
+
+    LOG("Hello from secondary thread!");
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    UM_HANDLE hThread;
+    STATUS status;
+    STATUS terminationStatus;
+    volatile QWORD test;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    hThread = UM_INVALID_HANDLE_VALUE;
+    test = 0;
+
+    __try
+    {
+        status = UmThreadCreate(_ThreadFunc, NULL, &hThread);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("UmThreadCreate", status);
+            __leave;
+        }
+
+        // wait for a period of time to make sure the newly spawned thread has terminated
+        for (DWORD i = 0; i < 0x10000; ++i)
+        {
+            test += i * i;
+        }
+
+        status = SyscallThreadWaitForTermination(hThread, &terminationStatus);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallThreadWaitForTermination", status);
+            __leave;
+        }
+
+        LOG("Secondary thread has finished execution!");
+
+        if (terminationStatus != STATUS_SUCCESS)
+        {
+            LOG_ERROR("Thread should have terminated with status 0x%x, however it terminated with status 0x%x\n",
+                      STATUS_SUCCESS, terminationStatus);
+            __leave;
+        }
+    }
+    __finally
+    {
+        if (hThread != UM_INVALID_HANDLE_VALUE)
+        {
+            SyscallThreadCloseHandle(hThread);
+            hThread = UM_INVALID_HANDLE_VALUE;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj b/src_proiect/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj
new file mode 100644
index 0000000..0944e78
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj
@@ -0,0 +1,138 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0866C84E-30D1-441A-A1EF-3FCAF0A1D319}</ProjectGuid>
+    <RootNamespace>UsermodeLibrary</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.props" />
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\..\shared\common;inc;headers</AdditionalIncludeDirectories>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <CreateHotpatchableImage>false</CreateHotpatchableImage>
+      <OpenMPSupport>false</OpenMPSupport>
+    </ClCompile>
+    <YASM>
+      <Debug>true</Debug>
+      <Defines>DEBUG</Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\..\shared\common;inc;headers</AdditionalIncludeDirectories>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <CreateHotpatchableImage>false</CreateHotpatchableImage>
+      <OpenMPSupport>false</OpenMPSupport>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+    </ClCompile>
+    <YASM>
+      <Debug>true</Debug>
+      <Defines>DEBUG</Defines>
+      <AdditionalOptions>-f x64 -X vc %(AdditionalOptions)</AdditionalOptions>
+    </YASM>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\syscall_if.c" />
+    <ClCompile Include="src\um_lib.c" />
+    <ClCompile Include="src\um_lib_helper.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\um_lib_base.h" />
+    <ClInclude Include="inc\syscall_if.h" />
+    <ClInclude Include="inc\um_lib_helper.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_syscall.yasm">
+      <FileType>Document</FileType>
+    </YASM>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+    <Import Project="$(SolutionDir)..\tools\vsyasm\vsyasm.targets" />
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj.filters b/src_proiect/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj.filters
new file mode 100644
index 0000000..f4f9b03
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/UsermodeLibrary.vcxproj.filters
@@ -0,0 +1,45 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{4ef5b33f-1451-434e-af45-e84bff235c25}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\um_lib.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\um_lib_helper.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\syscall_if.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\um_lib_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\um_lib_helper.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="inc\syscall_if.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <YASM Include="src\_syscall.yasm" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/UsermodeLibrary/headers/um_lib_base.h b/src_proiect/Usermode/UsermodeLibrary/headers/um_lib_base.h
new file mode 100644
index 0000000..bbaa1fe
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/headers/um_lib_base.h
@@ -0,0 +1,5 @@
+#pragma once
+
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
\ No newline at end of file
diff --git a/src_proiect/Usermode/UsermodeLibrary/inc/syscall_if.h b/src_proiect/Usermode/UsermodeLibrary/inc/syscall_if.h
new file mode 100644
index 0000000..a045204
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/inc/syscall_if.h
@@ -0,0 +1,6 @@
+#pragma once
+
+#include "syscall_defs.h"
+#include "thread_defs.h"
+#include "process_defs.h"
+#include "syscall_func.h"
\ No newline at end of file
diff --git a/src_proiect/Usermode/UsermodeLibrary/inc/um_lib_helper.h b/src_proiect/Usermode/UsermodeLibrary/inc/um_lib_helper.h
new file mode 100644
index 0000000..9b0a37e
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/inc/um_lib_helper.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "native/string.h"
+
+#define LOG(buf,...)                            LogBuffer(buf,__VA_ARGS__)
+#define LOGL(buf,...)                           LOG("[%s][%d]"##buf, strrchr(__FILE__,'\\') + 1, __LINE__, __VA_ARGS__)
+
+#define LOG_WARNING(buf,...)                    LOGL("[WARNING]"##buf, __VA_ARGS__ )
+#define LOG_ERROR(buf,...)                      LOGL("[ERROR]"##buf, __VA_ARGS__ )
+#define LOG_FUNC_ERROR(func,status)             LOG_ERROR("Function %s failed with status 0x%x\n", (func), (status) )
+#define LOG_FUNC_ERROR_ALLOC(func,size)         LOG_ERROR("Function %s failed alloc for size 0x%x\n", (func), (size))
+
+#define LOG_TEST_PASS                           LOG("\n[PASS]\n");
+
+void
+LogBuffer(
+    IN_Z    char*                   FormatBuffer,
+    ...
+    );
+
+STATUS
+UmThreadCreate(
+    IN      PFUNC_ThreadStart       StartFunction,
+    IN_OPT  PVOID                   Context,
+    OUT     UM_HANDLE*              ThreadHandle
+    );
diff --git a/src_proiect/Usermode/UsermodeLibrary/src/_syscall.yasm b/src_proiect/Usermode/UsermodeLibrary/src/_syscall.yasm
new file mode 100644
index 0000000..52ecd91
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/src/_syscall.yasm
@@ -0,0 +1,35 @@
+
+global SyscallEntry
+
+
+align 0x10, db 0x0
+[bits 64]
+; STATUS __cdecl* Syscall( IN SyscallNumber, Arg0, ..., Argn )
+SyscallEntry:
+    ; rcx and r11 (used in syscall) can be both clobbered => it's ok
+
+    push rbp
+
+    ; this should point to the start of the parameters
+    lea  rbp, [rsp + 0x10]
+
+    ; Place all the parameters on the stack, this is the
+    ; way in which the C code expects to take them
+    mov  [rbp],         rcx
+    mov  [rbp+0x8],     rdx
+    mov  [rbp+0x10],    r8
+    mov  [rbp+0x18],    r9
+
+    ; move syscall number in R8 as well
+    mov  r8,            rcx
+
+    push rdi
+
+    ; we need to preserve rax after syscall returns (will hold result)
+    syscall
+
+    pop rdi
+
+    pop rbp
+
+    ret
diff --git a/src_proiect/Usermode/UsermodeLibrary/src/syscall_if.c b/src_proiect/Usermode/UsermodeLibrary/src/syscall_if.c
new file mode 100644
index 0000000..43f23dd
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/src/syscall_if.c
@@ -0,0 +1,198 @@
+#include "um_lib_base.h"
+#include "syscall_if.h"
+#include "syscall_no.h"
+
+extern
+STATUS
+SyscallEntry(
+    IN      SYSCALL_ID              SyscallId,
+    ...
+    );
+
+// SyscallIdIdentifyVersion
+STATUS
+SyscallValidateInterface(
+    IN  SYSCALL_IF_VERSION          InterfaceVersion
+    )
+{
+    return SyscallEntry(SyscallIdIdentifyVersion, InterfaceVersion);
+}
+
+// SyscallIdThreadExit
+STATUS
+SyscallThreadExit(
+    IN  STATUS                      ExitStatus
+    )
+{
+    return SyscallEntry(SyscallIdThreadExit, ExitStatus);
+}
+
+// SyscallIdThreadCreate
+STATUS
+SyscallThreadCreate(
+    IN      PFUNC_ThreadStart       StartFunction,
+    IN_OPT  PVOID                   Context,
+    OUT     UM_HANDLE*              ThreadHandle
+    )
+{
+    return SyscallEntry(SyscallIdThreadCreate, StartFunction, Context, ThreadHandle);
+}
+
+// SyscallIdThreadGetTid
+STATUS
+SyscallThreadGetTid(
+    IN_OPT  UM_HANDLE               ThreadHandle,
+    OUT     TID*                    ThreadId
+    )
+{
+    return SyscallEntry(SyscallIdThreadGetTid, ThreadHandle, ThreadId);
+}
+
+// SyscallIdThreadWaitForTermination
+STATUS
+SyscallThreadWaitForTermination(
+    IN      UM_HANDLE               ThreadHandle,
+    OUT     STATUS*                 TerminationStatus
+    )
+{
+    return SyscallEntry(SyscallIdThreadWaitForTermination, ThreadHandle, TerminationStatus);
+}
+
+// SyscallIdThreadCloseHandle
+STATUS
+SyscallThreadCloseHandle(
+    IN      UM_HANDLE               ThreadHandle
+    )
+{
+    return SyscallEntry(SyscallIdThreadCloseHandle, ThreadHandle);
+}
+
+// SyscallIdProcessExit
+STATUS
+SyscallProcessExit(
+    IN      STATUS                  ExitStatus
+    )
+{
+    return SyscallEntry(SyscallIdProcessExit, ExitStatus);
+}
+
+// SyscallIdProcessCreate
+STATUS
+SyscallProcessCreate(
+    IN_READS_Z(PathLength)
+                char*               ProcessPath,
+    IN          QWORD               PathLength,
+    IN_READS_OPT_Z(ArgLength)
+                char*               Arguments,
+    IN          QWORD               ArgLength,
+    OUT         UM_HANDLE*          ProcessHandle
+    )
+{
+    return SyscallEntry(SyscallIdProcessCreate, ProcessPath, PathLength, Arguments, ArgLength, ProcessHandle);
+}
+
+// SyscallIdProcessGetPid
+STATUS
+SyscallProcessGetPid(
+    IN_OPT  UM_HANDLE               ProcessHandle,
+    OUT     PID*                    ProcessId
+    )
+{
+    return SyscallEntry(SyscallIdProcessGetPid, ProcessHandle, ProcessId);
+}
+
+// SyscallIdProcessWaitForTermination
+STATUS
+SyscallProcessWaitForTermination(
+    IN      UM_HANDLE               ProcessHandle,
+    OUT     STATUS*                 TerminationStatus
+    )
+{
+    return SyscallEntry(SyscallIdProcessWaitForTermination, ProcessHandle, TerminationStatus);
+}
+
+// SyscallIdProcessCloseHandle
+STATUS
+SyscallProcessCloseHandle(
+    IN      UM_HANDLE               ProcessHandle
+    )
+{
+    return SyscallEntry(SyscallIdProcessCloseHandle, ProcessHandle);
+}
+
+// SyscallIdVirtualAlloc
+STATUS
+SyscallVirtualAlloc(
+    IN_OPT      PVOID                   BaseAddress,
+    IN          QWORD                   Size,
+    IN          VMM_ALLOC_TYPE          AllocType,
+    IN          PAGE_RIGHTS             PageRights,
+    IN_OPT      UM_HANDLE               FileHandle,
+    IN_OPT      QWORD                   Key,
+    OUT         PVOID*                  AllocatedAddress
+    )
+{
+    return SyscallEntry(SyscallIdVirtualAlloc, BaseAddress, Size, AllocType, PageRights, FileHandle, Key, AllocatedAddress);
+}
+
+// SyscallIdVirtualFree
+STATUS
+SyscallVirtualFree(
+    IN          PVOID                   Address,
+    _When_(VMM_FREE_TYPE_RELEASE == FreeType, _Reserved_)
+    _When_(VMM_FREE_TYPE_RELEASE != FreeType, IN)
+                QWORD                   Size,
+    IN          VMM_FREE_TYPE           FreeType
+    )
+{
+    return SyscallEntry(SyscallIdVirtualFree, Address, Size, FreeType);
+}
+
+// SyscallIdFileCreate
+STATUS
+SyscallFileCreate(
+    IN_READS_Z(PathLength)
+                char*                   Path,
+    IN          QWORD                   PathLength,
+    IN          BOOLEAN                 Directory,
+    IN          BOOLEAN                 Create,
+    OUT         UM_HANDLE*              FileHandle
+    )
+{
+    return SyscallEntry(SyscallIdFileCreate, Path, PathLength, Directory, Create, FileHandle);
+}
+
+// SyscallIdFileClose
+STATUS
+SyscallFileClose(
+    IN          UM_HANDLE               FileHandle
+    )
+{
+    return SyscallEntry(SyscallIdFileClose, FileHandle);
+}
+
+// SyscallIdFileRead
+STATUS
+SyscallFileRead(
+    IN  UM_HANDLE                   FileHandle,
+    OUT_WRITES_BYTES(BytesToRead)
+        PVOID                       Buffer,
+    IN  QWORD                       BytesToRead,
+    OUT QWORD*                      BytesRead
+    )
+{
+    return SyscallEntry(SyscallIdFileRead, FileHandle, Buffer, BytesToRead, BytesRead);
+}
+
+// SyscallIdFileWrite
+STATUS
+SyscallFileWrite(
+    IN  UM_HANDLE                   FileHandle,
+    IN_READS_BYTES(BytesToWrite)
+        PVOID                       Buffer,
+    IN  QWORD                       BytesToWrite,
+    OUT QWORD*                      BytesWritten
+    )
+{
+    return SyscallEntry(SyscallIdFileWrite, FileHandle, Buffer, BytesToWrite, BytesWritten);
+}
diff --git a/src_proiect/Usermode/UsermodeLibrary/src/um_lib.c b/src_proiect/Usermode/UsermodeLibrary/src/um_lib.c
new file mode 100644
index 0000000..9ed4a99
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/src/um_lib.c
@@ -0,0 +1,102 @@
+#include "um_lib_base.h"
+
+#define RFLAGS_DIRECTION_BIT            ((QWORD)1<<10)
+
+extern
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+    );
+
+static FUNC_AssertFunction _UmLibAssert;
+static BOOLEAN m_syscallIfVerified;
+
+extern
+void
+__start(
+    DWORD       argc,
+    char**      argv
+    )
+{
+    STATUS status;
+    COMMON_LIB_INIT libInit;
+
+    status = STATUS_SUCCESS;
+    memzero(&libInit, sizeof(COMMON_LIB_INIT));
+
+    __try
+    {
+
+        libInit.Size = sizeof(COMMON_LIB_INIT);
+        libInit.MonitorSupport = FALSE; // we do not support MONITOR in UM
+        libInit.AssertFunction = _UmLibAssert;
+
+        // Setup common lib
+        status = CommonLibInit(&libInit);
+        if (!SUCCEEDED(status))
+        {
+            __leave;
+        }
+
+        CHECK_STACK_ALIGNMENT;
+
+        // Validate syscall interface
+        status = SyscallValidateInterface(SYSCALL_IMPLEMENTED_IF_VERSION);
+        if (!SUCCEEDED(status))
+        {
+            __leave;
+        }
+        // We can only start logging from here
+
+        m_syscallIfVerified = TRUE;
+        LOG("Successfully validated the interface!");
+
+        // Setup Heap
+
+        // Call actual function
+        status = __main(argc, argv);
+
+        LOG("Returned from main function, will call ThreadExit with status 0x%x!",
+             status);
+
+        SyscallThreadExit(status);
+    }
+    __finally
+    {
+    }
+
+    NOT_REACHED;
+}
+
+void
+(__cdecl _UmLibAssert)(
+    IN_Z            char*           Message
+    )
+{
+    UNREFERENCED_PARAMETER(Message);
+
+    if (!m_syscallIfVerified)
+    {
+        __writemsr(0xDEADBEEF, 0x0);
+
+    }
+    else
+    {
+        LOG_ERROR("%s\n", Message);
+
+        SyscallProcessExit(STATUS_ASSERTION_FAILURE);
+    }
+
+    NOT_REACHED;
+}
+
+__forceinline
+extern
+void
+CpuClearDirectionFlag(
+    void
+    )
+{
+    __writeeflags(__readeflags() & (~RFLAGS_DIRECTION_BIT));
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/UsermodeLibrary/src/um_lib_helper.c b/src_proiect/Usermode/UsermodeLibrary/src/um_lib_helper.c
new file mode 100644
index 0000000..10088b7
--- /dev/null
+++ b/src_proiect/Usermode/UsermodeLibrary/src/um_lib_helper.c
@@ -0,0 +1,94 @@
+#include "um_lib_base.h"
+#include "um_lib_helper.h"
+
+#define LOG_BUF_MAX_SIZE                512
+
+#define UM_MAX_NO_OF_THREADS            128
+
+typedef struct _UM_START_THREAD_CTX
+{
+    PFUNC_ThreadStart           StartFunction;
+    PVOID                       OriginalContext;
+} UM_START_THREAD_CTX, *PUM_START_THREAD_CTX;
+
+UM_START_THREAD_CTX m_thStartContext[UM_MAX_NO_OF_THREADS];
+
+_Interlocked_
+volatile DWORD m_freeStartCtxIdx;
+
+static FUNC_ThreadStart __start_thread;
+
+// Temporal hack to avoid linker optimization of marking data section to initialized in the case where everything is 0 inside the data section
+// TODO: fix HAL9000 PE loader to check the section property and to initialize the data section in memory to 0
+volatile QWORD m_dummyNonZeroData = 0x0D15EA5E;
+
+void
+LogBuffer(
+    IN_Z    char*                   FormatBuffer,
+    ...
+    )
+{
+    char logBuffer[LOG_BUF_MAX_SIZE];
+    va_list va;
+    STATUS status;
+    QWORD bytesWritten;
+
+    // Temporal hack
+    ASSERT(m_dummyNonZeroData == 0x0D15EA5E);
+
+    va_start(va, FormatBuffer);
+
+    // resolve formatted buffer
+    status = vsnprintf(logBuffer, LOG_BUF_MAX_SIZE, FormatBuffer, va);
+    ASSERT(SUCCEEDED(status));
+
+    status = SyscallFileWrite(UM_FILE_HANDLE_STDOUT,
+                              logBuffer,
+                              strlen(logBuffer) + 1,
+                              &bytesWritten);
+    ASSERT(SUCCEEDED(status));
+    ASSERT(bytesWritten == strlen(logBuffer) + 1);
+}
+
+STATUS
+UmThreadCreate(
+    IN      PFUNC_ThreadStart       StartFunction,
+    IN_OPT  PVOID                   Context,
+    OUT     UM_HANDLE*              ThreadHandle
+    )
+{
+    DWORD thCtxIdx = _InterlockedIncrement(&m_freeStartCtxIdx) - 1;
+    PUM_START_THREAD_CTX pCtx;
+
+    if (thCtxIdx >= UM_MAX_NO_OF_THREADS)
+    {
+        return STATUS_LIMIT_REACHED;
+    }
+
+    pCtx = &m_thStartContext[thCtxIdx];
+
+    pCtx->StartFunction = StartFunction;
+    pCtx->OriginalContext = Context;
+
+    return SyscallThreadCreate(__start_thread, pCtx, ThreadHandle);
+}
+
+static
+STATUS
+(__cdecl __start_thread)(
+    IN_OPT      PVOID       Context
+    )
+{
+    PUM_START_THREAD_CTX pCtx;
+    STATUS status;
+
+    pCtx = (PUM_START_THREAD_CTX)Context;
+    ASSERT(pCtx != NULL);
+
+    status = pCtx->StartFunction(pCtx->OriginalContext);
+
+    SyscallThreadExit(status);
+    NOT_REACHED;
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj b/src_proiect/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj
new file mode 100644
index 0000000..218a274
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{e1bc4f68-4192-4408-b94d-b161c6133c73}</ProjectGuid>
+    <RootNamespace>VirtualAllocAccessFail</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj.filters b/src_proiect/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocAccessFail/VirtualAllocAccessFail.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocAccessFail/main.c b/src_proiect/Usermode/VirtualAllocAccessFail/main.c
new file mode 100644
index 0000000..0feaf04
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocAccessFail/main.c
@@ -0,0 +1,38 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+
+    status = SyscallVirtualAlloc(NULL,
+                                 PAGE_SIZE,
+                                 VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                 PAGE_RIGHTS_READ,
+                                 UM_INVALID_HANDLE_VALUE,
+                                 0,
+                                 (PVOID*) &pAllocatedAddress);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+        return status;
+    }
+
+    *pAllocatedAddress = VALUE_TO_WRITE;
+    LOG_ERROR("We were able to write in a read-only page!\n");
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj b/src_proiect/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj
new file mode 100644
index 0000000..fd4ea84
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{f91940c3-0684-4512-b3c1-d68ecea7d4e0}</ProjectGuid>
+    <RootNamespace>VirtualAllocHugeEager</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj.filters b/src_proiect/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocHugeEager/VirtualAllocHugeEager.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocHugeEager/main.c b/src_proiect/Usermode/VirtualAllocHugeEager/main.c
new file mode 100644
index 0000000..8bcfa7f
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocHugeEager/main.c
@@ -0,0 +1,68 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+#define EAGER_ALLOC_SIZE            (16 * MB_SIZE)
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     EAGER_ALLOC_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_NOT_LAZY,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*) &pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        *pAllocatedAddress = VALUE_TO_WRITE;
+        if (*pAllocatedAddress != VALUE_TO_WRITE)
+        {
+            LOG_ERROR("Unable to write value to virtual memory allocated\n");
+            __leave;
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj b/src_proiect/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj
new file mode 100644
index 0000000..dd087a9
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{a2cf4462-c6e6-441b-add4-352e0d0871b2}</ProjectGuid>
+    <RootNamespace>VirtualAllocHugeLazy</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj.filters b/src_proiect/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocHugeLazy/VirtualAllocHugeLazy.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocHugeLazy/main.c b/src_proiect/Usermode/VirtualAllocHugeLazy/main.c
new file mode 100644
index 0000000..b8f0f4a
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocHugeLazy/main.c
@@ -0,0 +1,76 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+#define LAZY_ALLOC_SIZE             (1 * GB_SIZE)
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     LAZY_ALLOC_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*) &pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        *pAllocatedAddress = VALUE_TO_WRITE;
+        if (*pAllocatedAddress != VALUE_TO_WRITE)
+        {
+            LOG_ERROR("Unable to write value to virtual memory allocated\n");
+            __leave;
+        }
+
+
+        *PtrOffset(pAllocatedAddress, LAZY_ALLOC_SIZE - 1) = VALUE_TO_WRITE;
+        if (*PtrOffset(pAllocatedAddress, LAZY_ALLOC_SIZE - 1) != VALUE_TO_WRITE)
+        {
+            LOG_ERROR("Unable to write value to virtual memory allocated\n");
+            __leave;
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj b/src_proiect/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj
new file mode 100644
index 0000000..4bfcf95
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj
@@ -0,0 +1,87 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <SubType>
+      </SubType>
+    </ClCompile>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{2ecd668b-a99f-4c8a-b2fc-1fdbf1b6f25a}</ProjectGuid>
+    <RootNamespace>VirtualAllocNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj.filters b/src_proiect/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocNormal/VirtualAllocNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocNormal/main.c b/src_proiect/Usermode/VirtualAllocNormal/main.c
new file mode 100644
index 0000000..7a2a241
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocNormal/main.c
@@ -0,0 +1,67 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     PAGE_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*) &pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        *pAllocatedAddress = VALUE_TO_WRITE;
+        if (*pAllocatedAddress != VALUE_TO_WRITE)
+        {
+            LOG_ERROR("Unable to write value to virtual memory allocated\n");
+            __leave;
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj b/src_proiect/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj
new file mode 100644
index 0000000..6d48fef
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{d6919c57-7503-4f41-914e-4f0a5642d795}</ProjectGuid>
+    <RootNamespace>VirtualAllocWriteExec</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj.filters b/src_proiect/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocWriteExec/VirtualAllocWriteExec.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocWriteExec/main.c b/src_proiect/Usermode/VirtualAllocWriteExec/main.c
new file mode 100644
index 0000000..249bfd8
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocWriteExec/main.c
@@ -0,0 +1,37 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+
+    status = SyscallVirtualAlloc(NULL,
+                                 PAGE_SIZE,
+                                 VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                 PAGE_RIGHTS_ALL,
+                                 UM_INVALID_HANDLE_VALUE,
+                                 0,
+                                 (PVOID*) &pAllocatedAddress);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("We shouldn't be able to allocate write + execute memory!\n");
+        return status;
+    }
+
+    LOG_TEST_PASS;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj b/src_proiect/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj
new file mode 100644
index 0000000..c134aa4
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{c26bfeee-6078-400e-ad95-cc25b351ba4d}</ProjectGuid>
+    <RootNamespace>VirtualAllocZeros</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj.filters b/src_proiect/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocZeros/VirtualAllocZeros.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualAllocZeros/main.c b/src_proiect/Usermode/VirtualAllocZeros/main.c
new file mode 100644
index 0000000..8dff6c3
--- /dev/null
+++ b/src_proiect/Usermode/VirtualAllocZeros/main.c
@@ -0,0 +1,73 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+#define ZERO_ALLOC_SIZE             (2 * GB_SIZE)
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     ZERO_ALLOC_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT | VMM_ALLOC_TYPE_ZERO,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*) &pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        if (*pAllocatedAddress != 0x0)
+        {
+            LOG_ERROR("Allocated zero memory, but it isn't zero!\n");
+            __leave;
+        }
+
+        if (*PtrOffset(pAllocatedAddress, ZERO_ALLOC_SIZE - 1) != 0x0)
+        {
+            LOG_ERROR("Allocated zero memory, but it isn't zero!\n");
+            __leave;
+        }
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj b/src_proiect/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj
new file mode 100644
index 0000000..cc6a7ac
--- /dev/null
+++ b/src_proiect/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{833f5049-d661-4297-842c-d9c9ac8469c0}</ProjectGuid>
+    <RootNamespace>VirtualFreeInvalid</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj.filters b/src_proiect/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualFreeInvalid/VirtualFreeInvalid.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualFreeInvalid/main.c b/src_proiect/Usermode/VirtualFreeInvalid/main.c
new file mode 100644
index 0000000..049a850
--- /dev/null
+++ b/src_proiect/Usermode/VirtualFreeInvalid/main.c
@@ -0,0 +1,56 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    status = SyscallVirtualFree(_AddressOfReturnAddress(),
+                                0,
+                                VMM_FREE_TYPE_DECOMMIT | VMM_FREE_TYPE_RELEASE);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallVirtualFree succeeded for memory which was not allocated through SyscallVirtualAlloc!\n");
+        return status;
+    }
+
+    status = SyscallVirtualFree(_AddressOfReturnAddress(),
+                                0,
+                                VMM_FREE_TYPE_DECOMMIT);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallVirtualFree succeeded for memory which was not allocated through SyscallVirtualAlloc!\n");
+        return status;
+    }
+
+    status = SyscallVirtualFree(_AddressOfReturnAddress(),
+                                0,
+                                VMM_FREE_TYPE_RELEASE);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallVirtualFree succeeded for memory which was not allocated through SyscallVirtualAlloc!\n");
+        return status;
+    }
+
+    status = SyscallVirtualFree(_AddressOfReturnAddress(),
+                                0,
+                                0);
+    if (SUCCEEDED(status))
+    {
+        LOG_ERROR("SyscallVirtualFree succeeded for memory which was not allocated through SyscallVirtualAlloc!\n");
+        return status;
+    }
+
+
+    LOG_TEST_PASS;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj b/src_proiect/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj
new file mode 100644
index 0000000..a89fcab
--- /dev/null
+++ b/src_proiect/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{e6b41356-895b-419d-93a4-8746c086f7e8}</ProjectGuid>
+    <RootNamespace>VirtualFreeMore</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj.filters b/src_proiect/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualFreeMore/VirtualFreeMore.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualFreeMore/main.c b/src_proiect/Usermode/VirtualFreeMore/main.c
new file mode 100644
index 0000000..fe96833
--- /dev/null
+++ b/src_proiect/Usermode/VirtualFreeMore/main.c
@@ -0,0 +1,70 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+
+#define VALUE_TO_WRITE              0x37U
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile BYTE* pAllocatedAddress;
+    BOOLEAN bPassed;
+
+    UNREFERENCED_PARAMETER(argc);
+    UNREFERENCED_PARAMETER(argv);
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     PAGE_SIZE,
+                                     VMM_ALLOC_TYPE_RESERVE | VMM_ALLOC_TYPE_COMMIT,
+                                     PAGE_RIGHTS_READWRITE,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     0,
+                                     (PVOID*) &pAllocatedAddress);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+            __leave;
+        }
+
+        status = SyscallVirtualFree((PVOID)pAllocatedAddress,
+                                    2 * PAGE_SIZE,
+                                    VMM_FREE_TYPE_DECOMMIT);
+        if (SUCCEEDED(status))
+        {
+            LOG_ERROR("SyscallVirtualFree succeeded to free a virtual memory region larger than the one we allocated!\n");
+            __leave;
+        }
+
+
+        bPassed = TRUE;
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0, VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj b/src_proiect/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj
new file mode 100644
index 0000000..386b306
--- /dev/null
+++ b/src_proiect/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj
@@ -0,0 +1,84 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{0b6872be-9637-45b8-8404-287173bf8b35}</ProjectGuid>
+    <RootNamespace>VirtualSharedNormal</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Application</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <LinkIncremental>false</LinkIncremental>
+    <EmbedManifest>false</EmbedManifest>
+    <GenerateManifest>false</GenerateManifest>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>$(SolutionDir)commonlib\inc;..\UsermodeLibrary\inc;..\..\shared\common</AdditionalIncludeDirectories>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <CompileAsManaged>false</CompileAsManaged>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <StringPooling>false</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <FunctionLevelLinking>false</FunctionLevelLinking>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <FloatingPointExceptions>false</FloatingPointExceptions>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+    </ClCompile>
+    <Link>
+      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
+      <AdditionalLibraryDirectories>$(SolutionDir)..\bin\$(PlatformName)\$(ConfigurationName)NoLocks\CommonLib;$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\UserMode\UsermodeLibrary</AdditionalLibraryDirectories>
+      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
+      <AdditionalDependencies>CommonLib.lib;UsermodeLibrary.lib</AdditionalDependencies>
+      <NoEntryPoint>false</NoEntryPoint>
+      <EntryPointSymbol>__start</EntryPointSymbol>
+      <SubSystem>Native</SubSystem>
+      <ForceFileOutput>
+      </ForceFileOutput>
+      <AdditionalOptions>/ALIGN:0x1000 /FILEALIGN:0x1000 /IGNORE:4108 %(AdditionalOptions)</AdditionalOptions>
+      <BaseAddress>0x140000000</BaseAddress>
+      <RandomizedBaseAddress>false</RandomizedBaseAddress>
+      <FixedBaseAddress>true</FixedBaseAddress>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj.filters b/src_proiect/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj.filters
new file mode 100644
index 0000000..6827613
--- /dev/null
+++ b/src_proiect/Usermode/VirtualSharedNormal/VirtualSharedNormal.vcxproj.filters
@@ -0,0 +1,22 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="main.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Usermode/VirtualSharedNormal/main.c b/src_proiect/Usermode/VirtualSharedNormal/main.c
new file mode 100644
index 0000000..3df1b27
--- /dev/null
+++ b/src_proiect/Usermode/VirtualSharedNormal/main.c
@@ -0,0 +1,240 @@
+#include "common_lib.h"
+#include "syscall_if.h"
+#include "um_lib_helper.h"
+#include "strutils.h"
+
+#define SHARED_KEY_VALUE            0x7391'3921'0231'3922ULL
+
+typedef enum _SCENARIO_IDX
+{
+    ScenarioIdxNormal       = 0,
+    ScenarioIdxLessAccess,
+    ScenarioIdxMoreAccess,
+    ScenarioIdxDifferentSize,
+    ScenarioIdxEager,
+    ScenarioIdxLazy
+} SCENARIO_IDX;
+
+STATUS
+__main(
+    DWORD       argc,
+    char**      argv
+)
+{
+    STATUS status;
+    volatile QWORD* pAllocatedAddress;
+    BOOLEAN bPassed;
+    BOOLEAN bFirstProcess;
+    UM_HANDLE hProcess;
+    DWORD processIdx;
+    PAGE_RIGHTS pageRights;
+    QWORD sizeToAllocate;
+    DWORD sizeInPages;
+    SCENARIO_IDX scenario;
+
+    if (argc != 5)
+    {
+        LOG_ERROR("Program usage is %s $PROCESS_IDX $ACCESS_RIGHTS $NO_OF_PAGES $SCENARIO_IDX\n", argv[0]);
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    pAllocatedAddress = NULL;
+    bPassed = FALSE;
+    hProcess = UM_INVALID_HANDLE_VALUE;
+
+    atoi32(&processIdx, argv[1], BASE_TEN);
+    bFirstProcess = (processIdx == 0);
+
+    atoi32(&pageRights, argv[2], BASE_HEXA);
+    atoi32(&sizeInPages, argv[3], BASE_HEXA);
+
+    sizeToAllocate = sizeInPages * PAGE_SIZE;
+
+    atoi32(&scenario, argv[4], BASE_TEN);
+
+    LOG("First process is %u\n", bFirstProcess);
+    LOG("Page rights is 0x%x\n", pageRights);
+    LOG("Size to allocate is 0x%x\n", sizeToAllocate);
+    LOG("Scenario is %u\n", scenario);
+
+
+    __try
+    {
+        status = SyscallVirtualAlloc(NULL,
+                                     sizeToAllocate,
+                                     VMM_ALLOC_TYPE_RESERVE |
+                                     VMM_ALLOC_TYPE_COMMIT  |
+                                     ((scenario == ScenarioIdxEager) ? VMM_ALLOC_TYPE_NOT_LAZY : 0),
+                                     pageRights,
+                                     UM_INVALID_HANDLE_VALUE,
+                                     SHARED_KEY_VALUE,
+                                     (PVOID*) &pAllocatedAddress);
+        if (bFirstProcess)
+        {
+            STATUS termStatus;
+            char buffer[MAX_PATH];
+            PAGE_RIGHTS childRights;
+
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualAlloc", status);
+                __leave;
+            }
+
+            if (IsBooleanFlagOn(pageRights, PAGE_RIGHTS_WRITE) && scenario != ScenarioIdxLazy)
+            {
+                for (DWORD i = 0; i < sizeToAllocate / sizeof(*pAllocatedAddress); ++i)
+                {
+                    pAllocatedAddress[i] = i;
+                }
+            }
+
+            if (scenario == ScenarioIdxLessAccess)
+            {
+                childRights = pageRights & (~PAGE_RIGHTS_WRITE);
+            }
+            else if (scenario == ScenarioIdxMoreAccess)
+            {
+                childRights = pageRights | PAGE_RIGHTS_WRITE;
+            }
+            else
+            {
+                childRights = pageRights;
+            }
+
+            status = snprintf(buffer, MAX_PATH, "%u %u %u %u",
+                              1,
+                              childRights,
+                              (scenario == ScenarioIdxDifferentSize) ? sizeInPages * 2 : sizeInPages,
+                              scenario);
+            ASSERT(SUCCEEDED(status));
+
+            // create a new reincarcanation of itself
+            status = SyscallProcessCreate(argv[0],
+                                          strlen(argv[0]) + 1,
+                                          buffer,
+                                          strlen(buffer) + 1,
+                                          &hProcess);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessCreate", status);
+                __leave;
+            }
+
+
+            status = SyscallProcessWaitForTermination(hProcess, &termStatus);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallProcessWaitForTermination", status);
+                __leave;
+            }
+
+            if (   scenario == ScenarioIdxLessAccess
+                || scenario == ScenarioIdxDifferentSize)
+            {
+                // we expect to find the values with which we initialized the memory
+                for (DWORD i = 0; i < sizeToAllocate / sizeof(*pAllocatedAddress); ++i)
+                {
+                    if (pAllocatedAddress[i] != i)
+                    {
+                        // fail here
+                        LOG_ERROR("We have preivously written 0x%X at offset 0x%X, but now we have 0x%X",
+                                  i, PtrDiff(pAllocatedAddress + i, pAllocatedAddress), pAllocatedAddress[i]);
+                        __leave;
+                    }
+                }
+            }
+            else if (scenario != ScenarioIdxMoreAccess)
+            {
+                // we expect to see the double value of what we wrote
+                // in the case of the more scenario the mapping failed and we only had read access to it => noone wrote
+                // anything => garbage data
+                for (DWORD i = 0; i < sizeToAllocate / sizeof(*pAllocatedAddress); ++i)
+                {
+                    if (pAllocatedAddress[i] != i * 2)
+                    {
+                        // fail here
+                        LOG_ERROR("We have preivously written 0x%X at offset 0x%X, but now we have 0x%X",
+                                  i * 2, PtrDiff(pAllocatedAddress + i, pAllocatedAddress), pAllocatedAddress[i]);
+                        __leave;
+                    }
+                }
+            }
+
+            bPassed = TRUE;
+        }
+        else
+        {
+            if (scenario == ScenarioIdxDifferentSize || scenario == ScenarioIdxMoreAccess)
+            {
+                // must have failed
+                if (SUCCEEDED(status))
+                {
+                    LOG_ERROR("We shouldn't have been able to open the shared memory with a different size of 0x%X or"
+                              "With more access rights 0x%x!",
+                              sizeToAllocate, pageRights);
+                }
+
+                __leave;
+            }
+
+            // if we're here we succeeded in obtaining the shared memory address
+
+            if (scenario == ScenarioIdxLazy)
+            {
+                // If the scenario is the lazy one => the parent process didn't cause the physical frames to be
+                // reserved yet, it's the child's job to do so
+                for (DWORD i = 0; i < sizeToAllocate / sizeof(*pAllocatedAddress); ++i)
+                {
+                    pAllocatedAddress[i] = i * 2;
+                }
+                __leave;
+            }
+
+            // We check if the parent wrote i's to the buffer
+            for (DWORD i = 0; i < sizeToAllocate / sizeof(*pAllocatedAddress); ++i)
+            {
+                if (pAllocatedAddress[i] != i)
+                {
+                    // fail here
+                    LOG_ERROR("We have preivously written 0x%X at offset 0x%X, but now we have 0x%X",
+                              i, PtrDiff(pAllocatedAddress + i, pAllocatedAddress), pAllocatedAddress[i]);
+                    __leave;
+                }
+            }
+
+            for (DWORD i = 0; i < sizeToAllocate / sizeof(*pAllocatedAddress); ++i)
+            {
+                pAllocatedAddress[i] *= 2;
+            }
+
+            if (scenario == ScenarioIdxLessAccess)
+            {
+                // fail
+                LOG_ERROR("We shouldn't have been able to get here, we only requested read rights: 0x%x", pageRights);
+                __leave;
+            }
+        }
+
+    }
+    __finally
+    {
+        if (pAllocatedAddress != NULL)
+        {
+            status = SyscallVirtualFree((PVOID)pAllocatedAddress, 0,  VMM_FREE_TYPE_RELEASE);
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("SyscallVirtualFree", status);
+                bPassed = FALSE;
+            }
+            pAllocatedAddress = NULL;
+        }
+
+        if (bPassed)
+        {
+            LOG_TEST_PASS;
+        }
+    }
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/Utils/RemoveAllTests/RemoveAllTests.vcxproj b/src_proiect/Utils/RemoveAllTests/RemoveAllTests.vcxproj
new file mode 100644
index 0000000..aa8bf6d
--- /dev/null
+++ b/src_proiect/Utils/RemoveAllTests/RemoveAllTests.vcxproj
@@ -0,0 +1,49 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{6CAFB378-993C-4078-B545-9D8636F383DC}</ProjectGuid>
+    <RootNamespace>RemoveAllTests</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>"$(SolutionDir)..\postbuild\remove_tests.cmd" Tests.module</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Utils/RemoveAllTests/RemoveAllTests.vcxproj.filters b/src_proiect/Utils/RemoveAllTests/RemoveAllTests.vcxproj.filters
new file mode 100644
index 0000000..9cd8510
--- /dev/null
+++ b/src_proiect/Utils/RemoveAllTests/RemoveAllTests.vcxproj.filters
@@ -0,0 +1,2 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
\ No newline at end of file
diff --git a/src_proiect/Utils/RunTests/RunTests.vcxproj b/src_proiect/Utils/RunTests/RunTests.vcxproj
new file mode 100644
index 0000000..3240ba9
--- /dev/null
+++ b/src_proiect/Utils/RunTests/RunTests.vcxproj
@@ -0,0 +1,107 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Threads|x64">
+      <Configuration>Threads</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Userprog|x64">
+      <Configuration>Userprog</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="VirtualMemory|x64">
+      <Configuration>VirtualMemory</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{291C9D17-6BA7-404F-8664-C60F38E061C7}</ProjectGuid>
+    <RootNamespace>RunTests</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Threads|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Userprog|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'" Label="Configuration">
+    <ConfigurationType>Utility</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Threads|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Userprog|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Threads|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Userprog|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Threads|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>"$(SolutionDir)..\postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\threads" Tests.module /run /16 180</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Userprog|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>"$(SolutionDir)..\postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\userprog" Tests.module /proctest / 180</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='VirtualMemory|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>"$(SolutionDir)..\postbuild\run_tests.cmd" "$(SolutionDir)" "$(SolutionDir)..\TESTS\virtualmemory" Tests.module /proctest / 180</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <None Include="..\..\..\tests\check_tests.pl" />
+    <None Include="..\..\..\tests\execute_tests.pl" />
+    <None Include="..\..\..\tests\generate_modules.pl" />
+    <None Include="..\..\..\tests\vm_operations.pl" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Utils/RunTests/RunTests.vcxproj.filters b/src_proiect/Utils/RunTests/RunTests.vcxproj.filters
new file mode 100644
index 0000000..ec9c135
--- /dev/null
+++ b/src_proiect/Utils/RunTests/RunTests.vcxproj.filters
@@ -0,0 +1,9 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <None Include="..\..\..\tests\check_tests.pl" />
+    <None Include="..\..\..\tests\execute_tests.pl" />
+    <None Include="..\..\..\tests\generate_modules.pl" />
+    <None Include="..\..\..\tests\vm_operations.pl" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Volume/Volume.vcxproj b/src_proiect/Volume/Volume.vcxproj
new file mode 100644
index 0000000..cba800f
--- /dev/null
+++ b/src_proiect/Volume/Volume.vcxproj
@@ -0,0 +1,132 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{642F9F32-68EC-40AD-BAAF-3436DA0B66A8}</ProjectGuid>
+    <RootNamespace>Volume</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>MultiByte</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="Shared">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <OutDir>$(SolutionDir)..\bin\$(PlatformName)\$(Configuration)\$(ProjectName)\</OutDir>
+    <IntDir>$(SolutionDir)..\temp\$(PlatformName)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetExt>.lib</TargetExt>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <RunCodeAnalysis>true</RunCodeAnalysis>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <OmitFramePointers>true</OmitFramePointers>
+      <PreprocessorDefinitions>DEBUG;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>MaxSpeed</Optimization>
+      <SDLCheck>true</SDLCheck>
+      <AdditionalIncludeDirectories>headers;inc;..\commonlib\inc;..\shared\common;..\shared\kernel;..\HAL\inc</AdditionalIncludeDirectories>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <CompileAsManaged>false</CompileAsManaged>
+      <TreatWarningAsError>true</TreatWarningAsError>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
+      <OmitFramePointers>
+      </OmitFramePointers>
+      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <StringPooling>true</StringPooling>
+      <MinimalRebuild>false</MinimalRebuild>
+      <ExceptionHandling>false</ExceptionHandling>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <BufferSecurityCheck>true</BufferSecurityCheck>
+      <ControlFlowGuard>false</ControlFlowGuard>
+      <EnableParallelCodeGeneration>false</EnableParallelCodeGeneration>
+      <RuntimeTypeInfo>false</RuntimeTypeInfo>
+      <OpenMPSupport>false</OpenMPSupport>
+      <EnablePREfast>true</EnablePREfast>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <FunctionLevelLinking>true</FunctionLevelLinking>
+    </ClCompile>
+    <PostBuildEvent>
+      <Command>..\..\postbuild\place_files.cmd $(ProjectName) $(SolutionDir) $(PlatformName) $(ConfigurationName) $(SolutionName) $(TargetName) $(TargetExt)</Command>
+    </PostBuildEvent>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="src\volume.c" />
+    <ClCompile Include="src\volume_dispatch.c" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="headers\volume_base.h" />
+    <ClInclude Include="headers\volume_dispatch.h" />
+    <ClInclude Include="headers\volume_structures.h" />
+    <ClInclude Include="inc\volume.h" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Volume/Volume.vcxproj.filters b/src_proiect/Volume/Volume.vcxproj.filters
new file mode 100644
index 0000000..c60ce78
--- /dev/null
+++ b/src_proiect/Volume/Volume.vcxproj.filters
@@ -0,0 +1,42 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\inc">
+      <UniqueIdentifier>{312d2c6f-ca1e-4b8f-9e54-c4d63e6d57c9}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="src\volume.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="src\volume_dispatch.c">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="inc\volume.h">
+      <Filter>Header Files\inc</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\volume_base.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\volume_structures.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="headers\volume_dispatch.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/src_proiect/Volume/headers/volume_base.h b/src_proiect/Volume/headers/volume_base.h
new file mode 100644
index 0000000..d888255
--- /dev/null
+++ b/src_proiect/Volume/headers/volume_base.h
@@ -0,0 +1,7 @@
+#pragma once
+
+#include "common_lib.h"
+#include "io.h"
+#include "ex.h"
+#include "log.h"
+#include "volume_structures.h"
\ No newline at end of file
diff --git a/src_proiect/Volume/headers/volume_dispatch.h b/src_proiect/Volume/headers/volume_dispatch.h
new file mode 100644
index 0000000..86c4dc3
--- /dev/null
+++ b/src_proiect/Volume/headers/volume_dispatch.h
@@ -0,0 +1,4 @@
+#pragma once
+
+FUNC_DriverDispatch              VolDispatchReadWrite;
+FUNC_DriverDispatch              VolDispatchDeviceControl;
\ No newline at end of file
diff --git a/src_proiect/Volume/headers/volume_structures.h b/src_proiect/Volume/headers/volume_structures.h
new file mode 100644
index 0000000..e668527
--- /dev/null
+++ b/src_proiect/Volume/headers/volume_structures.h
@@ -0,0 +1,6 @@
+#pragma once
+
+typedef struct _VOLUME {
+    PDEVICE_OBJECT          DiskDevice;
+    PARTITION_INFORMATION   PartitionInformation;
+} VOLUME, *PVOLUME;
\ No newline at end of file
diff --git a/src_proiect/Volume/inc/volume.h b/src_proiect/Volume/inc/volume.h
new file mode 100644
index 0000000..6b4795f
--- /dev/null
+++ b/src_proiect/Volume/inc/volume.h
@@ -0,0 +1,3 @@
+#pragma once
+
+FUNC_DriverEntry                        VolDriverEntry;
\ No newline at end of file
diff --git a/src_proiect/Volume/src/volume.c b/src_proiect/Volume/src/volume.c
new file mode 100644
index 0000000..2514030
--- /dev/null
+++ b/src_proiect/Volume/src/volume.c
@@ -0,0 +1,214 @@
+#include "volume_base.h"
+#include "volume.h"
+#include "volume_dispatch.h"
+
+static
+STATUS
+_VolInitialize(
+    IN          PDEVICE_OBJECT          Disk,
+    IN          PPARTITION_INFORMATION  PartitionInformation,
+    INOUT       PDRIVER_OBJECT          DriverObject
+    );
+
+STATUS
+(__cdecl VolDriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    )
+{
+    STATUS status;
+    PDEVICE_OBJECT* pDiskDevices;
+    DWORD noOfDisks;
+    DWORD i;
+    DWORD j;
+    PIRP pIrp;
+    DWORD structureSize;
+    PDISK_LAYOUT_INFORMATION pDiskLayout;
+
+    ASSERT(NULL != DriverObject);
+
+    status = STATUS_SUCCESS;
+    pDiskDevices = NULL;
+    noOfDisks = 0;
+    pIrp = NULL;
+    structureSize = 0;
+    pDiskLayout = NULL;
+
+    DriverObject->DispatchFunctions[IRP_MJ_READ] = VolDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_WRITE] = VolDispatchReadWrite;
+    DriverObject->DispatchFunctions[IRP_MJ_DEVICE_CONTROL] = VolDispatchDeviceControl;
+
+    status = IoGetDevicesByType(DeviceTypeDisk, &pDiskDevices, &noOfDisks);
+    if (!SUCCEEDED(status))
+    {
+        LOG_FUNC_ERROR("IoGetDevicesByType\n", status);
+        return status;
+    }
+
+    __try
+    {
+        for (i = 0; i < noOfDisks; ++i)
+        {
+            PDEVICE_OBJECT pCurDisk = pDiskDevices[i];
+
+            do
+            {
+                if (NULL != pDiskLayout)
+                {
+                    LOGL("Calling HeapFreePoolWithTag for pDiskLayout: 0x%X\n", pDiskLayout);
+
+                    ExFreePoolWithTag(pDiskLayout, HEAP_TEMP_TAG);
+                    pDiskLayout = NULL;
+                }
+
+                if (0 != structureSize)
+                {
+                    pDiskLayout = ExAllocatePoolWithTag(PoolAllocateZeroMemory, structureSize, HEAP_TEMP_TAG, 0);
+                    if (NULL == pDiskLayout)
+                    {
+                        status = STATUS_HEAP_NO_MORE_MEMORY;
+                        LOG_FUNC_ERROR_ALLOC("HeapALllocatePoolWithTag", structureSize);
+                        __leave;
+                    }
+
+                    LOGL("pDiskLayout has address: 0x%X\n", pDiskLayout);
+                }
+
+                if (NULL != pIrp)
+                {
+                    IoFreeIrp(pIrp);
+                    pIrp = NULL;
+                }
+
+                pIrp = IoBuildDeviceIoControlRequest(IOCTL_DISK_LAYOUT_INFO,
+                                                     pCurDisk,
+                                                     NULL,
+                                                     0,
+                                                     pDiskLayout,
+                                                     structureSize
+                );
+                ASSERT(NULL != pIrp);
+
+                LOG_TRACE_IO("Successfully built IRP for device control\n");
+
+                status = IoCallDriver(pCurDisk, pIrp);
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("IoCallDriver", status);
+                    __leave;
+                }
+
+                status = pIrp->IoStatus.Status;
+
+                ASSERT(pIrp->IoStatus.Information <= MAX_DWORD);
+                structureSize = (DWORD)pIrp->IoStatus.Information;
+            } while (STATUS_BUFFER_TOO_SMALL == status);
+
+            if (!SUCCEEDED(status))
+            {
+                LOG_FUNC_ERROR("IoCallDriver", status);
+                __leave;
+            }
+
+            ASSERT(NULL != pDiskLayout);
+
+            for (j = 0; j < pDiskLayout->NumberOfPartitions; ++j)
+            {
+                status = _VolInitialize(pCurDisk,
+                                        &pDiskLayout->Partitions[j],
+                                        DriverObject
+                );
+                if (!SUCCEEDED(status))
+                {
+                    LOG_FUNC_ERROR("VolInitialize", status);
+                    __leave;
+                }
+                LOG("[%d][%d] Volume successfully initialized\n", i, j);
+            }
+        }
+
+        
+    }
+    __finally
+    {
+        if (NULL != pDiskLayout)
+        {
+            LOGL("Calling HeapFreePoolWithTag for pDiskLayout: 0x%X\n", pDiskLayout);
+
+            ExFreePoolWithTag(pDiskLayout, HEAP_TEMP_TAG);
+            pDiskLayout = NULL;
+        }
+
+        if (NULL != pDiskDevices)
+        {
+            IoFreeTemporaryData(pDiskDevices);
+            pDiskDevices = NULL;
+        }
+
+        if (NULL != pIrp)
+        {
+            IoFreeIrp(pIrp);
+            pIrp = NULL;
+        }
+
+        LOG_FUNC_END;
+    }
+
+    return status;
+}
+
+STATUS
+_VolInitialize(
+    IN          PDEVICE_OBJECT          Disk,
+    IN          PPARTITION_INFORMATION  PartitionInformation,
+    INOUT       PDRIVER_OBJECT          DriverObject
+    )
+{
+    STATUS status;
+    PVOLUME pVolumeData;
+    PDEVICE_OBJECT pVolumeDevice;
+    
+
+    if (NULL == Disk)
+    {
+        return STATUS_INVALID_PARAMETER1;
+    }
+
+    status = STATUS_SUCCESS;
+    pVolumeData = NULL;
+    pVolumeDevice = NULL;
+
+    __try
+    {
+        pVolumeDevice = IoCreateDevice(DriverObject, sizeof(VOLUME), DeviceTypeVolume);
+        if (NULL == pVolumeDevice)
+        {
+            LOG_FUNC_ERROR_ALLOC("IoCreateDevice", sizeof(VOLUME));
+            status = STATUS_DEVICE_COULD_NOT_BE_CREATED;
+            __leave;
+        }
+        pVolumeDevice->DeviceAlignment = Disk->DeviceAlignment;
+
+        // get volume object
+        pVolumeData = (PVOLUME)IoGetDeviceExtension(pVolumeDevice);
+        ASSERT(NULL != pVolumeData);
+
+        pVolumeData->DiskDevice = Disk;
+        memcpy(&pVolumeData->PartitionInformation, PartitionInformation, sizeof(PARTITION_INFORMATION));
+
+        // attach to disk
+        IoAttachDevice(pVolumeDevice, Disk);
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            if (NULL != pVolumeDevice)
+            {
+                IoDeleteDevice(pVolumeDevice);
+                pVolumeDevice = NULL;
+            }
+        }
+    }
+
+    return status;
+}
\ No newline at end of file
diff --git a/src_proiect/Volume/src/volume_dispatch.c b/src_proiect/Volume/src/volume_dispatch.c
new file mode 100644
index 0000000..93eee7c
--- /dev/null
+++ b/src_proiect/Volume/src/volume_dispatch.c
@@ -0,0 +1,160 @@
+#include "volume_base.h"
+#include "volume_dispatch.h"
+
+__forceinline
+static
+STATUS
+_VolCheckIOParameters(
+    IN                                          PVOLUME         Volume,
+    IN                                          QWORD           SectorIndex,
+    IN                                          QWORD           SectorCount
+    )
+{
+    ASSERT(NULL != Volume);
+
+    if (SectorIndex >= Volume->PartitionInformation.PartitionSize)
+    {
+        // how can we read at an index higher than our total sector count?
+        return STATUS_DEVICE_SECTOR_OFFSET_EXCEEDED;
+    }
+
+    if (Volume->PartitionInformation.PartitionSize - SectorIndex < SectorCount)
+    {
+        // sorry, we really don't have that much
+        return STATUS_DEVICE_SECTOR_COUNT_EXCEEDED;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl VolDispatchReadWrite)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PVOLUME pVolume;
+    PIO_STACK_LOCATION pStackLocation;
+    QWORD lengthInSectors;
+    QWORD offsetInSectors;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pVolume = NULL;
+    pStackLocation = NULL;
+    lengthInSectors = 0;
+    offsetInSectors = 0;
+
+    pVolume = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pVolume);
+
+    // validate parameters
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_READ == pStackLocation->MajorFunction || IRP_MJ_WRITE == pStackLocation->MajorFunction);
+
+    lengthInSectors = pStackLocation->Parameters.ReadWrite.Length / SECTOR_SIZE;
+    offsetInSectors = pStackLocation->Parameters.ReadWrite.Offset / SECTOR_SIZE;
+
+    __try
+    {
+        status = _VolCheckIOParameters(pVolume, offsetInSectors, lengthInSectors);
+        if (!SUCCEEDED(status))
+        {
+            __leave;
+        }
+
+        // copy stack location
+        // this function also advances the current stack location
+        IoCopyCurrentStackLocationToNext(Irp);
+
+        // we need to modify offset to be disk relative
+        pStackLocation = IoGetNextIrpStackLocation(Irp);
+
+        pStackLocation->Parameters.ReadWrite.Offset = (offsetInSectors + pVolume->PartitionInformation.OffsetInDisk) * SECTOR_SIZE;
+
+        LOG_TRACE_STORAGE("Copied current IRP stack location\n");
+
+        // call disk device
+        status = IoCallDriver(pVolume->DiskDevice, Irp);
+        if (!SUCCEEDED(status))
+        {
+            LOG_FUNC_ERROR("IoCalLDriver", status);
+            __leave;
+        }
+        Irp = NULL;
+    }
+    __finally
+    {
+        if (!SUCCEEDED(status))
+        {
+            // if we succeeded => lower driver will set status and information
+            Irp->IoStatus.Status = status;
+
+            IoCompleteIrp(Irp);
+            Irp = NULL;
+        }
+
+        ASSERT(NULL == Irp);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+STATUS
+(__cdecl VolDispatchDeviceControl)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    )
+{
+    STATUS status;
+    PVOLUME pVolume;
+    PIO_STACK_LOCATION pStackLocation;
+    QWORD lengthInSectors;
+    QWORD offsetInSectors;
+    DWORD information;
+
+    ASSERT(NULL != DeviceObject);
+    ASSERT(NULL != Irp);
+
+    status = STATUS_SUCCESS;
+    pVolume = NULL;
+    pStackLocation = NULL;
+    lengthInSectors = 0;
+    offsetInSectors = 0;
+    information = 0;
+
+    pVolume = IoGetDeviceExtension(DeviceObject);
+    ASSERT(NULL != pVolume);
+
+    // validate parameters
+    pStackLocation = IoGetCurrentIrpStackLocation(Irp);
+    ASSERT(IRP_MJ_DEVICE_CONTROL == pStackLocation->MajorFunction);
+
+    switch (pStackLocation->Parameters.DeviceControl.IoControlCode)
+    {
+    case IOCTL_VOLUME_PARTITION_INFO:
+        {
+            information = sizeof(PARTITION_INFORMATION);
+
+            if (pStackLocation->Parameters.DeviceControl.OutputBufferLength < information)
+            {
+                status = STATUS_BUFFER_TOO_SMALL;
+                break;
+            }
+
+            memcpy(pStackLocation->Parameters.DeviceControl.OutputBuffer, &pVolume->PartitionInformation, information);
+        }
+        break;
+    default:
+        status = STATUS_UNSUPPORTED;
+    }
+
+    IoCompleteIrp(Irp);
+    Irp->IoStatus.Status = status;
+    Irp->IoStatus.Information = information;
+
+    return STATUS_SUCCESS;
+}
\ No newline at end of file
diff --git a/src_proiect/shared/common/mem_structures.h b/src_proiect/shared/common/mem_structures.h
new file mode 100644
index 0000000..bb18115
--- /dev/null
+++ b/src_proiect/shared/common/mem_structures.h
@@ -0,0 +1,23 @@
+#pragma once
+
+typedef DWORD                       PAGE_RIGHTS;
+
+#define PAGE_RIGHTS_READ            0
+#define PAGE_RIGHTS_WRITE           1
+#define PAGE_RIGHTS_EXECUTE         2
+
+#define PAGE_RIGHTS_READWRITE       (PAGE_RIGHTS_READ | PAGE_RIGHTS_WRITE )
+#define PAGE_RIGHTS_READEXEC        (PAGE_RIGHTS_READ | PAGE_RIGHTS_EXECUTE )
+#define PAGE_RIGHTS_ALL             (PAGE_RIGHTS_READ | PAGE_RIGHTS_WRITE | PAGE_RIGHTS_EXECUTE )
+
+typedef DWORD                       VMM_ALLOC_TYPE;
+
+#define VMM_ALLOC_TYPE_RESERVE      0x1
+#define VMM_ALLOC_TYPE_COMMIT       0x2
+#define VMM_ALLOC_TYPE_NOT_LAZY     0x4
+#define VMM_ALLOC_TYPE_ZERO         0x8
+
+typedef DWORD                       VMM_FREE_TYPE;
+
+#define VMM_FREE_TYPE_DECOMMIT      0x1
+#define VMM_FREE_TYPE_RELEASE       0x2
diff --git a/src_proiect/shared/common/process_defs.h b/src_proiect/shared/common/process_defs.h
new file mode 100644
index 0000000..8e458e0
--- /dev/null
+++ b/src_proiect/shared/common/process_defs.h
@@ -0,0 +1,3 @@
+#pragma once
+
+typedef QWORD       PID, *PPID;
\ No newline at end of file
diff --git a/src_proiect/shared/common/syscall_defs.h b/src_proiect/shared/common/syscall_defs.h
new file mode 100644
index 0000000..46c9cc8
--- /dev/null
+++ b/src_proiect/shared/common/syscall_defs.h
@@ -0,0 +1,15 @@
+#pragma once
+
+typedef DWORD SYSCALL_IF_VERSION;
+
+#define SYSCALL_IMPLEMENTED_IF_VERSION      0x1
+
+#define UM_INVALID_HANDLE_VALUE             0
+
+#define UM_FILE_HANDLE_STDOUT               (UM_HANDLE)0x1
+
+typedef QWORD UM_HANDLE;
+
+#include "mem_structures.h"
+#include "thread_defs.h"
+#include "process_defs.h"
diff --git a/src_proiect/shared/common/syscall_func.h b/src_proiect/shared/common/syscall_func.h
new file mode 100644
index 0000000..30b3223
--- /dev/null
+++ b/src_proiect/shared/common/syscall_func.h
@@ -0,0 +1,308 @@
+#pragma once
+
+// SyscallIdIdentifyVersion
+//******************************************************************************
+// Function:     SyscallValidateInterface
+// Description:  Validates that the kernel is at the same system call interface
+//               version as the user land counterpart.
+// Returns:      STATUS - STATUS_SUCCESS if InterfaceVersion is equal to
+//               SYSCALL_IF_VERSION_KM.
+// Parameter:    IN SYSCALL_IF_VERSION InterfaceVersion
+//******************************************************************************
+STATUS
+SyscallValidateInterface(
+    IN  SYSCALL_IF_VERSION          InterfaceVersion
+    );
+
+// SyscallIdThreadExit
+//******************************************************************************
+// Function:     SyscallThreadExit
+// Description:  Causes the executing thread to exit with ExitStatus.
+// Returns:      STATUS
+// Parameter:    IN STATUS ExitStatus
+//******************************************************************************
+STATUS
+SyscallThreadExit(
+    IN      STATUS                  ExitStatus
+    );
+
+// SyscallIdThreadCreate
+//******************************************************************************
+// Function:     SyscallThreadCreate
+// Description:  Creates a new thread in the context of the current process to
+//               execute StartFunction with context Context.
+// Returns:      STATUS
+// Parameter:    IN PFUNC_ThreadStart StartFunction
+// Parameter:    IN_OPT PVOID Context
+// Parameter:    OUT UM_HANDLE* ThreadHandle - user handle to the newly created
+//               thread.
+//******************************************************************************
+STATUS
+SyscallThreadCreate(
+    IN      PFUNC_ThreadStart       StartFunction,
+    IN_OPT  PVOID                   Context,
+    OUT     UM_HANDLE*              ThreadHandle
+    );
+
+// SyscallIdThreadGetTid
+//******************************************************************************
+// Function:     SyscallThreadGetTid
+// Description:  Returns the thread ID for ThreadHandle. If ThreadHandle is
+//               UM_INVALID_HANDLE_VALUE the TID of the current thread is
+//               retrieved.
+// Returns:      STATUS
+// Parameter:    IN_OPT UM_HANDLE ThreadHandle
+// Parameter:    OUT TID * ThreadId
+//******************************************************************************
+STATUS
+SyscallThreadGetTid(
+    IN_OPT  UM_HANDLE               ThreadHandle,
+    OUT     TID*                    ThreadId
+    );
+
+// SyscallIdThreadWaitForTermination
+//******************************************************************************
+// Function:     SyscallThreadWaitForTermination
+// Description:  Waits for process ThreadHandle to terminate and returns the
+//               termination status in TerminationStatus.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE ThreadHandle
+// Parameter:    OUT STATUS * TerminationStatus
+//******************************************************************************
+STATUS
+SyscallThreadWaitForTermination(
+    IN      UM_HANDLE               ThreadHandle,
+    OUT     STATUS*                 TerminationStatus
+    );
+
+// SyscallIdThreadCloseHandle
+//******************************************************************************
+// Function:     SyscallThreadCloseHandle
+// Description:  Closes the handle to ThreadHandle.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE ThreadHandle
+//******************************************************************************
+STATUS
+SyscallThreadCloseHandle(
+    IN      UM_HANDLE               ThreadHandle
+    );
+
+// SyscallIdProcessExit
+//******************************************************************************
+// Function:     SyscallProcessExit
+// Description:  Terminates the currently executing process with ExitStatus
+//               status.
+// Returns:      STATUS
+// Parameter:    IN STATUS ExitStatus
+//******************************************************************************
+STATUS
+SyscallProcessExit(
+    IN      STATUS                  ExitStatus
+    );
+
+// SyscallIdProcessCreate
+//******************************************************************************
+// Function:     SyscallProcessCreate
+// Description:  Creates a new process to execute the code from ProcessPath with
+//               arguments Arguments.
+// Returns:      STATUS
+// Parameter:    IN_READS_Z(PathLength) char* ProcessPath - the process path may
+//               be a absolute path (starting with X:\) or a relative path to
+//               %SYSTEMDRIVE%\APPLIC~1\.
+// Parameter:    IN DWORD PathLength
+// Parameter:    IN_READS_OPT_Z(ArgLength) char* Arguments - may be NULL
+// Parameter:    IN DWORD ArgLength
+// Parameter:    OUT UM_HANDLE* ProcessHandle - user handle to the newly created
+//               process.
+//
+// The following usage examples are valid
+// Spawn a process to execute the file found at %SYSTEMDRIVE%\APPLIC~1\App.exe
+// SyscallProcessCreate("App.exe", sizeof("App.exe"), NULL, 0, &handle);
+//
+// Spawn a process to execute the file found at D:\Sample.exe
+// SyscallProcessCreate("D:\Sample.exe", sizeof("D:\Sample.exe"), NULL, 0, &handle);
+//******************************************************************************
+STATUS
+SyscallProcessCreate(
+    IN_READS_Z(PathLength)
+                char*               ProcessPath,
+    IN          QWORD               PathLength,
+    IN_READS_OPT_Z(ArgLength)
+                char*               Arguments,
+    IN          QWORD               ArgLength,
+    OUT         UM_HANDLE*          ProcessHandle
+    );
+
+// SyscallIdProcessGetPid
+//******************************************************************************
+// Function:     SyscallProcessGetPid
+// Description:  Retrieves the process identifier for ProcessHandle. If the
+//               handle value is UM_INVALID_HANDLE_VALUE the PID for the
+//               executing process will be returned.
+// Returns:      STATUS
+// Parameter:    IN_OPT UM_HANDLE ProcessHandle
+// Parameter:    OUT PID * ProcessId
+//******************************************************************************
+STATUS
+SyscallProcessGetPid(
+    IN_OPT  UM_HANDLE               ProcessHandle,
+    OUT     PID*                    ProcessId
+    );
+
+// SyscallIdProcessWaitForTermination
+//******************************************************************************
+// Function:     SyscallProcessWaitForTermination
+// Description:  Waits for process ProcessHandle to terminate and returns the
+//               termination status in TerminationStatus.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE ProcessHandle
+// Parameter:    OUT STATUS * TerminationStatus
+//******************************************************************************
+STATUS
+SyscallProcessWaitForTermination(
+    IN      UM_HANDLE               ProcessHandle,
+    OUT     STATUS*                 TerminationStatus
+    );
+
+// SyscallIdProcessCloseHandle
+//******************************************************************************
+// Function:     SyscallProcessCloseHandle
+// Description:  Closes the handle to ProcessHandle.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE ProcessHandle
+//******************************************************************************
+STATUS
+SyscallProcessCloseHandle(
+    IN      UM_HANDLE               ProcessHandle
+    );
+
+// SyscallIdVirtualAlloc
+//******************************************************************************
+// Function:     SyscallVirtualAlloc
+// Description:  Allocates a virtual address range, this can be used for mapping
+//               a file in memory by specifying a valid FileHandle. When Key is
+//               non-zero this creates or accesses an already existing shared
+//               memory range.
+// Returns:      STATUS
+// Parameter:    IN_OPT PVOID BaseAddress - Provides a hint on where to place
+//                                          the virtual allocation.
+// Parameter:    IN QWORD Size
+// Parameter:    IN VMM_ALLOC_TYPE AllocType
+// Parameter:    IN PAGE_RIGHTS PageRights
+// Parameter:    IN_OPT UM_HANDLE FileHandle - When non-NULL the range will be
+//                                             backed up by a file.
+// Parameter:    IN_OPT QWORD Key - When non-zero creates or accesses a system
+//                                  wide shared memory region.
+// Parameter:    OUT PVOID* AllocatedAddress - The virtual address allocated
+//******************************************************************************
+STATUS
+SyscallVirtualAlloc(
+    IN_OPT      PVOID                   BaseAddress,
+    IN          QWORD                   Size,
+    IN          VMM_ALLOC_TYPE          AllocType,
+    IN          PAGE_RIGHTS             PageRights,
+    IN_OPT      UM_HANDLE               FileHandle,
+    IN_OPT      QWORD                   Key,
+    OUT         PVOID*                  AllocatedAddress
+    );
+
+// SyscallIdVirtualFree
+//******************************************************************************
+// Function:     SyscallVirtualFree
+// Description:  Frees a previously allocated virtual address range.
+// Returns:      STATUS
+// Parameter:    IN PVOID Address
+// Parameter:    QWORD Size
+// Parameter:    IN VMM_FREE_TYPE FreeType
+//******************************************************************************
+STATUS
+SyscallVirtualFree(
+    IN          PVOID                   Address,
+    _When_(VMM_FREE_TYPE_RELEASE == FreeType, _Reserved_)
+    _When_(VMM_FREE_TYPE_RELEASE != FreeType, IN)
+                QWORD                   Size,
+    IN          VMM_FREE_TYPE           FreeType
+    );
+
+// SyscallIdFileCreate
+//******************************************************************************
+// Function:     SyscallFileCreate
+// Description:  Depending on the Create parameter creates a new file or opens
+//               an existing one.
+// Returns:      STATUS
+// Parameter:    IN_READS_Z(PathLength) char* path  the file path may
+//               be a absolute path (starting with X:\) or a relative path to
+//               %SYSTEMDRIVE%\.
+// Parameter:    IN DWORD PathLength
+// Parameter:    IN BOOLEAN Directory
+// Parameter:    IN BOOLEAN Create
+// Parameter:    OUT UM_HANDLE* FileHandle
+//
+// The following usage examples are valid
+// Open the file found at %SYSTEMDRIVE%\myfile
+// SyscallFileCreate("myfile", sizeof("myfile"), FALSE, FALSE, &handle);
+//
+// Create a new directory on partition E:\ named new_dir
+// SyscallFileCreate("E:\new_dir", sizeof("E:\new_dir"), TRUE, TRUE, &handle);
+//******************************************************************************
+STATUS
+SyscallFileCreate(
+    IN_READS_Z(PathLength)
+                char*                   Path,
+    IN          QWORD                   PathLength,
+    IN          BOOLEAN                 Directory,
+    IN          BOOLEAN                 Create,
+    OUT         UM_HANDLE*              FileHandle
+    );
+
+// SyscallIdFileClose
+//******************************************************************************
+// Function:     SyscallFileClose
+// Description:  Closes a previously opened file.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE FileHandle
+//******************************************************************************
+STATUS
+SyscallFileClose(
+    IN          UM_HANDLE               FileHandle
+    );
+
+// SyscallIdFileRead
+//******************************************************************************
+// Function:     SyscallFileRead
+// Description:  Reads the content of file FileHandle into Buffer.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE FileHandle
+// Parameter:    OUT_WRITES_BYTES(BytesToRead) PVOID Buffer
+// Parameter:    IN QWORD BytesToRead - Bytes to read.
+// Parameter:    OUT QWORD * BytesRead - Actualy number of bytes read from the
+//               file. This value may be lower than BytesToRead if the EOF was
+//               detected.
+//******************************************************************************
+STATUS
+SyscallFileRead(
+    IN  UM_HANDLE                   FileHandle,
+    OUT_WRITES_BYTES(BytesToRead)
+        PVOID                       Buffer,
+    IN  QWORD                       BytesToRead,
+    OUT QWORD*                      BytesRead
+    );
+
+// SyscallIdFileWrite
+//******************************************************************************
+// Function:     SyscallFileWrite
+// Description:  Writes the content of Buffer into the FileHandle file.
+// Returns:      STATUS
+// Parameter:    IN UM_HANDLE FileHandle
+// Parameter:    IN_READS_BYTES(BytesToWrite) PVOID Buffer
+// Parameter:    IN QWORD BytesToWrite
+// Parameter:    OUT QWORD* BytesWritten
+//******************************************************************************
+STATUS
+SyscallFileWrite(
+    IN  UM_HANDLE                   FileHandle,
+    IN_READS_BYTES(BytesToWrite)
+        PVOID                       Buffer,
+    IN  QWORD                       BytesToWrite,
+    OUT QWORD*                      BytesWritten
+    );
diff --git a/src_proiect/shared/common/syscall_no.h b/src_proiect/shared/common/syscall_no.h
new file mode 100644
index 0000000..6dbafea
--- /dev/null
+++ b/src_proiect/shared/common/syscall_no.h
@@ -0,0 +1,32 @@
+#pragma once
+
+typedef enum _SYSCALL_ID
+{
+    SyscallIdIdentifyVersion,
+
+    // Thread Management
+    SyscallIdThreadExit,
+    SyscallIdThreadCreate,
+    SyscallIdThreadGetTid,
+    SyscallIdThreadWaitForTermination,
+    SyscallIdThreadCloseHandle,
+
+    // Process Management
+    SyscallIdProcessExit,
+    SyscallIdProcessCreate,
+    SyscallIdProcessGetPid,
+    SyscallIdProcessWaitForTermination,
+    SyscallIdProcessCloseHandle,
+
+    // Memory management 
+    SyscallIdVirtualAlloc,
+    SyscallIdVirtualFree,
+
+    // File management
+    SyscallIdFileCreate,
+    SyscallIdFileClose,
+    SyscallIdFileRead,
+    SyscallIdFileWrite,
+
+    SyscallIdReserved = SyscallIdFileWrite + 1
+} SYSCALL_ID;
diff --git a/src_proiect/shared/common/thread_defs.h b/src_proiect/shared/common/thread_defs.h
new file mode 100644
index 0000000..9f58142
--- /dev/null
+++ b/src_proiect/shared/common/thread_defs.h
@@ -0,0 +1,21 @@
+#pragma once
+
+typedef QWORD       TID, *PTID;
+
+typedef enum _THREAD_PRIORITY
+{
+    ThreadPriorityLowest            = 0,
+    ThreadPriorityDefault           = 16,
+    ThreadPriorityMaximum           = 31,
+    ThreadPriorityReserved          = ThreadPriorityMaximum + 1
+} THREAD_PRIORITY;
+
+typedef struct _THREAD* PTHREAD;
+
+typedef
+STATUS
+(__cdecl FUNC_ThreadStart)(
+    IN_OPT      PVOID       Context
+    );
+
+typedef FUNC_ThreadStart*   PFUNC_ThreadStart;
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/cpu_structures.h b/src_proiect/shared/kernel/cpu_structures.h
new file mode 100644
index 0000000..08bc97d
--- /dev/null
+++ b/src_proiect/shared/kernel/cpu_structures.h
@@ -0,0 +1,23 @@
+#pragma once
+
+typedef enum _IRQL
+{
+    IrqlApcLevel                = 0x2,
+    IrqlDispatchLevel           = 0x3,
+
+    // device interrupts
+    IrqlUserInputLevel          = 0x4, // keyboard, mouse, touchpad, etc...
+    IrqlStorageLevel            = 0x5,
+    IrqlNetworkLevel            = 0x6,
+
+    // device interrupts end
+    IrqlErrorLevel              = 0xC, // used only by spurious interrupts
+    IrqlClockLevel              = 0xD,
+    IrqlIpiLevel                = 0xE,
+    IrqlAssertLevel             = 0xF,
+    IrqlMaxLevel                = IrqlAssertLevel
+} IRQL;
+
+#define IRQL_TO_VECTOR(irql)    ((BYTE)((irql)<<4))
+#define VECTOR_TO_IRQL(vec)     ((IRQL)((vec)>>4))
+#define VECTORS_PER_IRQL        0x10
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/ex.h b/src_proiect/shared/kernel/ex.h
new file mode 100644
index 0000000..e216942
--- /dev/null
+++ b/src_proiect/shared/kernel/ex.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include "cl_heap.h"
+#include "heap_tags.h"
+
+typedef struct _SYSTEM_INFORMATION
+{
+    QWORD                           SystemUptimeUs;
+    QWORD                           CpuFrequency;
+    QWORD                           TotalPhysicalMemory;
+    PHYSICAL_ADDRESS                HighestPhysicalAddress;
+} SYSTEM_INFORMATION, *PSYSTEM_INFORMATION;
+
+_Always_(_When_(IsBooleanFlagOn(Flags, PoolAllocatePanicIfFail), RET_NOT_NULL))
+PTR_SUCCESS
+PVOID
+ExAllocatePoolWithTag(
+    IN      DWORD                   Flags,
+    IN      DWORD                   AllocationSize,
+    IN      DWORD                   Tag,
+    IN      DWORD                   AllocationAlignment
+    );
+
+void
+ExFreePoolWithTag(
+    _Pre_notnull_ _Post_ptr_invalid_
+            PVOID                   MemoryAddress,
+    IN      DWORD                   Tag
+    );
+
+void
+ExGetSystemInformation(
+    OUT     PSYSTEM_INFORMATION     SystemInformation
+    );
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/ex_event.h b/src_proiect/shared/kernel/ex_event.h
new file mode 100644
index 0000000..935b654
--- /dev/null
+++ b/src_proiect/shared/kernel/ex_event.h
@@ -0,0 +1,72 @@
+#pragma once
+
+#include "list.h"
+#include "lock_common.h"
+
+typedef enum _EX_EVT_TYPE
+{
+    ExEventTypeNotification,        // notifies all threads
+    ExEventTypeSynchronization,     // notifies only one thread
+
+    ExEventTypeReserved
+} EX_EVT_TYPE;
+
+typedef struct _EX_EVENT
+{
+    LOCK                EventLock;
+    LIST_ENTRY          WaitingList;
+    EX_EVT_TYPE         EventType;
+    volatile BYTE       Signaled;
+} EX_EVENT, *PEX_EVENT;
+
+//******************************************************************************
+// Function:     ExEventInit
+// Description:  Initializes an executive event. As in the case of primitive
+//               events, these may be notification or synchronization events.
+// Returns:      STATUS
+// Parameter:    OUT EX_EVENT * Event
+// Parameter:    IN EX_EVT_TYPE EventType
+// Parameter:    IN BOOLEAN Signaled
+//******************************************************************************
+STATUS
+ExEventInit(
+    OUT     EX_EVENT*     Event,
+    IN      EX_EVT_TYPE   EventType,
+    IN      BOOLEAN       Signaled
+    );
+
+//******************************************************************************
+// Function:     ExEventSignal
+// Description:  Signals an event. If the waiting list is not empty it will
+//               wakeup one or multiple threads depending on the event type.
+// Returns:      void
+// Parameter:    INOUT EX_EVENT * Event
+//******************************************************************************
+void
+ExEventSignal(
+    INOUT   EX_EVENT*      Event
+    );
+
+//******************************************************************************
+// Function:     ExEventClearSignal
+// Description:  Clears an event signal.
+// Returns:      void
+// Parameter:    INOUT EX_EVENT * Event
+//******************************************************************************
+void
+ExEventClearSignal(
+    INOUT   EX_EVENT*      Event
+    );
+
+//******************************************************************************
+// Function:     ExEventWaitForSignal
+// Description:  Waits for an event to be signaled. If the event is not signaled
+//               the calling thread will be placed in a waiting list and its
+//               execution will be blocked.
+// Returns:      void
+// Parameter:    INOUT EX_EVENT * Event
+//******************************************************************************
+void
+ExEventWaitForSignal(
+    INOUT   EX_EVENT*      Event
+    );
diff --git a/src_proiect/shared/kernel/filesystem.h b/src_proiect/shared/kernel/filesystem.h
new file mode 100644
index 0000000..3537de2
--- /dev/null
+++ b/src_proiect/shared/kernel/filesystem.h
@@ -0,0 +1,55 @@
+#pragma once
+
+typedef struct _FILE_OBJECT_FLAGS
+{
+    // if set => IoManager will update file offset
+    DWORD                   Asynchronous     :    1;
+
+    // if set => file will be created
+    // else   => file will be opened
+    DWORD                   Create          :    1;
+
+    // if set => file is a directory
+    // else   => file is a normal file
+    DWORD                   DirectoryFile   :    1;
+
+    DWORD                   Reserved        :   29;
+} FILE_OBJECT_FLAGS, *PFILE_OBJECT_FLAGS;
+
+typedef struct _FILE_OBJECT
+{
+    // file system to which it belongs
+    struct _DEVICE_OBJECT*  FileSystemDevice;
+    FILE_OBJECT_FLAGS       Flags;
+
+    /// must not be touched, used only by the
+    /// filesystem to keep internal structure
+    PVOID                   FsContext2;
+
+    char*                   FileName;
+    struct _FILE_OBJECT*    RelatedFileObject;
+
+    QWORD                   CurrentByteOffset;
+
+    // real file size
+    QWORD                   FileSize;
+} FILE_OBJECT, *PFILE_OBJECT;
+
+typedef struct _VPB_FLAGS
+{
+    DWORD               Mounted     :    1;
+    DWORD               SwapSpace   :    1;
+    DWORD               Reserved    :   30;
+} VPB_FLAGS, *PVPB_FLAGS;
+
+// Provides an association between a logical volume
+// and the corresponding file system
+typedef struct _VPB
+{
+    struct _DEVICE_OBJECT*  FilesystemDevice;
+    struct _DEVICE_OBJECT*  VolumeDevice;
+    VPB_FLAGS               Flags;
+
+    char                    VolumeLetter;
+    LIST_ENTRY              NextVpb;
+} VPB, *PVPB;
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/heap_tags.h b/src_proiect/shared/kernel/heap_tags.h
new file mode 100644
index 0000000..c6075a8
--- /dev/null
+++ b/src_proiect/shared/kernel/heap_tags.h
@@ -0,0 +1,35 @@
+#pragma once
+
+#define HEAP_IDT_TAG                    ':TDI'
+#define HEAP_PAGE_TAG                   'EGAP'
+#define HEAP_CPU_TAG                    ':UPC'
+#define HEAP_IPC_TAG                    ':CPI'
+#define HEAP_GDT_TAG                    ':TDG'
+#define HEAP_TEST_TAG                   ':TST'
+#define HEAP_STACK_TAG                  ':KTS'
+#define HEAP_PCI_TAG                    ':ICP'
+#define HEAP_DISK_TAG                   ':KSD'
+#define HEAP_VOLUME_TAG                 ':LOV'
+#define HEAP_DEVICE_TAG                 ':VED'
+#define HEAP_DEVICE_EXT_TAG             ':TXE'
+#define HEAP_DRIVER_TAG                 ':VRD'
+#define HEAP_IRP_TAG                    ':PRI'
+#define HEAP_VPB_TAG                    ':BPV'
+#define HEAP_TEMP_TAG                   ':PMT'
+#define HEAP_FS_TAG                     ':SF '
+#define HEAP_FILE_OBJECT_TAG            ':LIF'
+#define HEAP_ACPICA_TAG                 'ACCA'
+#define HEAP_ACPIIF_TAG                 'FICA'
+#define HEAP_APIC_TAG                   'CIPA'
+#define HEAP_THREAD_TAG                 ':RHT'
+#define HEAP_MDL_TAG                    ':LMD'
+#define HEAP_ATA_TAG                    ':ATA'
+#define HEAP_IOMU_TAG                   ':MOI'
+#define HEAP_MMU_TAG                    ':UMM'
+#define HEAP_CORE_TAG                   ':ROC'
+#define HEAP_NET_TAG                    ':TEN'
+#define HEAP_ETH_TAG                    ':HTE'
+#define HEAP_PORT_TAG                   ':TRP'
+#define HEAP_EXECUTIVE_TAG              ':XE '
+#define HEAP_PROCESS_TAG                ':CRP'
+#define HEAP_BOOT_TAG                   'TOOB'
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/io.h b/src_proiect/shared/kernel/io.h
new file mode 100644
index 0000000..80d789b
--- /dev/null
+++ b/src_proiect/shared/kernel/io.h
@@ -0,0 +1,291 @@
+#pragma once
+
+#include "list.h"
+#include "pci_system.h"
+#include "filesystem.h"
+#include "network.h"
+#include "cpu_structures.h"
+#include "io_structures.h"
+#include "mem_structures.h"
+
+PTR_SUCCESS
+PDEVICE_OBJECT
+IoCreateDevice(
+    INOUT   PDRIVER_OBJECT  DriverObject,
+    IN      DWORD           DeviceExtensionSize,
+    IN      DEVICE_TYPE     DeviceType
+    );
+
+PVOID
+IoGetDeviceExtension(
+    IN      PDEVICE_OBJECT      Device
+    );
+
+void
+IoDeleteDevice(
+    INOUT   PDEVICE_OBJECT      Device
+    );
+
+PTR_SUCCESS
+PDRIVER_OBJECT
+IoCreateDriver(
+    IN_Z        char*                   DriverName,
+    IN          PFUNC_DriverEntry       DriverEntry
+    );
+
+PVOID
+IoGetDriverExtension(
+    IN          PDEVICE_OBJECT  Device
+    );
+
+void
+IoAttachDevice(
+    INOUT   PDEVICE_OBJECT  SourceDevice,
+    IN      PDEVICE_OBJECT  TargetDevice
+    );
+
+PTR_SUCCESS
+PIRP
+IoAllocateIrp(
+    IN      BYTE            StackSize
+    );
+
+void
+IoFreeIrp(
+    IN      PIRP            Irp
+    );
+
+PTR_SUCCESS
+PIO_STACK_LOCATION
+IoGetCurrentIrpStackLocation(
+    IN      PIRP            Irp
+    );
+
+PTR_SUCCESS
+PIO_STACK_LOCATION
+IoGetNextIrpStackLocation(
+    IN      PIRP            Irp
+    );
+
+void
+IoCopyCurrentStackLocationToNext(
+    INOUT   PIRP            Irp
+    );
+
+STATUS
+IoCallDriver(
+    IN      PDEVICE_OBJECT  Device,
+    INOUT   PIRP            Irp
+    );
+
+void
+IoCompleteIrp(
+    INOUT   PIRP            Irp
+    );
+
+#define IoIsIrpComplete(irp)        (TRUE==((irp)->Flags.Completed))
+
+STATUS
+IoGetPciDevicesMatchingSpecification(
+    IN          PCI_SPEC        Specification,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+                PPCI_DEVICE_DESCRIPTION**    PciDevices,
+    OUT         DWORD*           NumberOfDevices
+    );
+
+STATUS
+IoGetPciDevicesMatchingLocation(
+    IN          PCI_SPEC_LOCATION           Specification,
+    _When_(*NumberOfDevices > 0, OUT_PTR)
+    _When_(*NumberOfDevices == 0, OUT_PTR_MAYBE_NULL)
+                PPCI_DEVICE_DESCRIPTION**   PciDevices,
+    OUT         DWORD*                      NumberOfDevices
+    );
+
+STATUS
+IoGetPciSecondaryBusForBridge(
+    IN          PCI_DEVICE_LOCATION         DeviceLocation,
+    OUT         BYTE*                       Bus
+    );
+
+STATUS
+IoGetDevicesByType(
+    IN                      DEVICE_TYPE         DeviceType,
+    _When_(*NumberOfDevices>0,OUT_PTR)
+    _When_(*NumberOfDevices==0, OUT_PTR_MAYBE_NULL)
+                            PDEVICE_OBJECT**    DeviceObjects,
+    OUT                     DWORD*              NumberOfDevices
+    );
+
+void
+IoFreeTemporaryData(
+    IN          PVOID               Data
+    );
+
+PTR_SUCCESS
+PIRP
+IoBuildDeviceIoControlRequest(
+    IN          DWORD               IoControlCode,
+    IN          PDEVICE_OBJECT      DeviceObject,
+    IN_OPT      PVOID               InputBuffer,
+    IN          DWORD               InputBufferLength,
+    OUT_OPT     PVOID               OutputBuffer,
+    IN          DWORD               OutputBufferLength
+    );
+
+STATUS
+IoReadDeviceEx(
+    IN                          PDEVICE_OBJECT          DeviceObject,
+    OUT_WRITES_BYTES(*Length)   PVOID                   Buffer,
+    INOUT                       QWORD*                  Length,
+    IN                          QWORD                   Offset,
+    IN                          BOOLEAN                 Asynchronous
+    );
+
+#define IoReadDevice(Dev,Buf,Len,Off)                  IoReadDeviceEx((Dev),(Buf),(Len),(Off),FALSE)
+
+STATUS
+IoWriteDeviceEx(
+    IN                          PDEVICE_OBJECT          DeviceObject,
+    IN_READS_BYTES(*Length)     PVOID                   Buffer,
+    INOUT                       QWORD*                  Length,
+    IN                          QWORD                   Offset,
+    IN                          BOOLEAN                 Asynchronous
+    );
+
+#define IoWriteDevice(Dev,Buf,Len,Off)                  IoWriteDeviceEx((Dev),(Buf),(Len),(Off),FALSE)
+
+STATUS
+IoAllocateMdl(
+    IN          PVOID           VirtualAddress,
+    IN          DWORD           Length,
+    IN_OPT      PIRP            Irp,
+    OUT_PTR     struct _MDL**           Mdl
+    );
+
+void
+IoFreeMdl(
+    INOUT       struct _MDL*            Mdl
+    );
+
+SIZE_SUCCESS
+DWORD
+IoMdlGetNumberOfPairs(
+    IN          PMDL            Mdl
+    );
+
+PTR_SUCCESS
+PMDL_TRANSLATION_PAIR
+IoMdlGetTranslationPair(
+    IN          PMDL            Mdl,
+    IN          DWORD           Index
+    );
+
+STATUS
+IoRegisterInterruptEx(
+    IN          PIO_INTERRUPT           Interrupt,
+    IN_OPT      PDEVICE_OBJECT          DeviceObject,
+    OUT_OPT     PBYTE                   Vector
+    );
+
+#define IoRegisterInterrupt(Int,Dev)    IoRegisterInterruptEx((Int),(Dev),NULL)
+
+PTR_SUCCESS
+PVOID
+IoMapMemory(
+    IN      PHYSICAL_ADDRESS        PhysicalAddress,
+    IN      DWORD                   Size,
+    IN      PAGE_RIGHTS             PageRights
+    );
+
+void
+IoUnmapMemory(
+    IN      PVOID                   VirtualAddress,
+    IN      DWORD                   Size
+    );
+
+PTR_SUCCESS
+PHYSICAL_ADDRESS
+IoGetPhysicalAddress(
+    IN      PVOID                   VirtualAddress
+    );
+
+#define IoAllocateContinuousMemory(Size)    IoAllocateContinuousMemoryEx((Size),FALSE)
+
+PTR_SUCCESS
+PVOID
+IoAllocateContinuousMemoryEx(
+    IN      DWORD                   AllocationSize,
+    IN      BOOLEAN                 Uncacheable
+    );
+
+void
+IoFreeContinuousMemory(
+    IN      PVOID                   VirtualAddress
+    );
+
+DATETIME
+IoGetCurrentDateTime(
+    void
+    );
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                        FILE OPERATIONS                                        /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+STATUS
+IoCreateFile(
+    OUT_PTR     PFILE_OBJECT*           Handle,
+    IN_Z        char*                   FileName,
+    IN          BOOLEAN                 Directory,
+    IN          BOOLEAN                 Create,
+    IN          BOOLEAN                 Asynchronous
+    );
+
+STATUS
+IoCloseFile(
+    IN          PFILE_OBJECT            FileHandle
+    );
+
+STATUS
+IoReadFile(
+    IN          PFILE_OBJECT            FileHandle,
+    IN          QWORD                   BytesToRead,
+    IN_OPT      QWORD*                  FileOffset,
+    OUT_WRITES_BYTES(BytesToRead)
+                PVOID                   Buffer,
+    OUT         QWORD*                  BytesRead
+    );
+
+STATUS
+IoWriteFile(
+    IN          PFILE_OBJECT            FileHandle,
+    IN          QWORD                   BytesToWrite,
+    IN_OPT      QWORD*                  FileOffset,
+    IN_READS_BYTES(BytesToWrite)
+                PVOID                   Buffer,
+    OUT         QWORD*                  BytesWritten
+    );
+
+STATUS
+IoGetFileSize(
+    IN          PFILE_OBJECT            FileHandle,
+    OUT         QWORD*                  FileSize
+    );
+
+STATUS
+IoQueryInformationFile(
+    IN          PFILE_OBJECT            FileHandle,
+    OUT         PFILE_INFORMATION       FileInformation
+    );
+
+STATUS
+IoQueryDirectoryFile(
+    IN          PFILE_OBJECT                    FileHandle,
+    IN          DWORD                           BufferSize,
+    _When_(0==BufferSize,OUT_OPT)
+    _When_(0!=BufferSize,OUT)
+                PFILE_DIRECTORY_INFORMATION     DirectoryInformation,
+    OUT         DWORD*                          SizeRequired
+    );
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/io_structures.h b/src_proiect/shared/kernel/io_structures.h
new file mode 100644
index 0000000..65b74fe
--- /dev/null
+++ b/src_proiect/shared/kernel/io_structures.h
@@ -0,0 +1,338 @@
+#pragma once
+
+#include "time.h"
+
+/// never do this at home kids
+#include "..\..\HAL9000\headers\mutex.h"
+
+#define SHORT_NAME_MAX_LENGTH       16
+
+// common packing
+#pragma pack(push,8)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                        IRP_MJ_QUERY_INFORMATION                               /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+// IRP_MN_INFORMATION_FILE_INFORMATION
+#define FILE_ATTRIBUTE_NORMAL       0x01
+#define FILE_ATTRIBUTE_DIRECTORY    0x02
+#define FILE_ATTRIBUTE_VOLUME       0x04
+
+typedef struct _FILE_INFORMATION
+{
+    DATETIME                        CreationTime;
+    DATETIME                        LastWriteTime;
+
+    // file size on disk
+    QWORD                           FileSize;
+    DWORD                           FileAttributes;
+} FILE_INFORMATION, *PFILE_INFORMATION;
+
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                        IRP_MJ_DIRECTORY_CONTROL                               /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+// IRP_MN_QUERY_DIRECTORY
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+typedef
+_Struct_size_bytes_(sizeof(FILE_DIRECTORY_INFORMATION) + FilenameLength)
+struct _FILE_DIRECTORY_INFORMATION
+{
+    DWORD                           NextEntryOffset;
+    FILE_INFORMATION                BasicFileInformation;
+    char                            ShortFilename[SHORT_NAME_MAX_LENGTH];
+    DWORD                           FilenameLength;
+    char                            Filename[0];
+} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                        FUNDAMENTAL STRUCTURES                                 /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+#define IRP_MJ_CREATE                               0
+#define IRP_MJ_CLOSE                                1
+#define IRP_MJ_READ                                 2
+#define IRP_MJ_WRITE                                3
+#define IRP_MJ_QUERY_INFORMATION                    4
+#define IRP_MJ_DIRECTORY_CONTROL                    5
+#define IRP_MJ_DEVICE_CONTROL                       6
+#define IRP_MJ_MAX                                  IRP_MJ_DEVICE_CONTROL+1
+
+// used with  IRP_MJ_QUERY_INFORMATION
+#define IRP_MN_INFORMATION_FILE_INFORMATION         0
+
+// used with IRP_MJ_DIRECTORY_CONTROL
+#define IRP_MN_QUERY_DIRECTORY                      0
+
+typedef enum _DEVICE_TYPE
+{
+    DeviceTypeMin,
+    DeviceTypeSystem = DeviceTypeMin,
+    DeviceTypeHarddiskController,
+    DeviceTypeDisk,
+    DeviceTypeVolume,
+    DeviceTypeFilesystem,
+    DeviceTypePhysicalNetcard,
+    DeviceTypeMax = DeviceTypePhysicalNetcard
+} DEVICE_TYPE;
+
+typedef struct _DEVICE_OBJECT
+{
+    struct _DRIVER_OBJECT*  DriverObject;
+    PVOID                   DeviceExtension;
+    DWORD                   DeviceExtensionSize;
+    DEVICE_TYPE             DeviceType;
+
+    BYTE                    StackSize;
+
+    // The alignment the device requires for
+    // the R/W parameters (length and offset)
+    DWORD                   DeviceAlignment;
+
+    MUTEX                   DeviceLock;
+
+    // valid only for volume and file system devices
+    struct _VPB*            Vpb;
+
+    // Next device belonging to this driver
+    LIST_ENTRY              NextDevice;
+
+    // device to which we are attached
+    struct _DEVICE_OBJECT*  AttachedDevice;
+} DEVICE_OBJECT, *PDEVICE_OBJECT;
+
+typedef
+BOOLEAN
+(__cdecl FUNC_InterruptFunction)(
+    IN      PDEVICE_OBJECT  Device
+    );
+
+typedef FUNC_InterruptFunction*        PFUNC_InterruptFunction;
+
+typedef enum _IO_INTERRUPT_TYPE
+{
+    IoInterruptTypeLegacy,
+    IoInterruptTypeLapic,
+    IoInterruptTypePci
+} IO_INTERRUPT_TYPE;
+
+typedef struct _IO_INTERRUPT
+{
+    IO_INTERRUPT_TYPE           Type;
+    IRQL                        Irql;
+    BOOLEAN                     Exclusive;
+    PFUNC_InterruptFunction     ServiceRoutine;
+    BOOLEAN                     BroadcastInterrupt;
+    union
+    {
+        struct
+        {
+            BYTE                Irq;
+        } Legacy;
+        struct
+        {
+            BYTE                __Reserved0;
+        } Lapic;
+        struct
+        {
+            PPCI_DEVICE_DESCRIPTION         PciDevice;
+        } Pci;
+    };
+} IO_INTERRUPT, *PIO_INTERRUPT;
+
+typedef struct _IO_STACK_LOCATION
+{
+    BYTE            MajorFunction;
+    BYTE            MinorFunction;
+    union {
+        struct {
+            QWORD               Length;
+            QWORD               Offset;
+        } ReadWrite;
+        struct {
+            DWORD               IoControlCode;
+
+            // the Buffer stored in the IRP structure
+            // is used for input
+            DWORD               InputBufferLength;
+            DWORD               OutputBufferLength;
+            PVOID               OutputBuffer;
+        } DeviceControl;
+        struct {
+            DWORD               Length;
+        } QueryFile;
+        struct {
+            DWORD               Length;
+            DWORD               FileIndex;
+        } QueryDirectory;
+    } Parameters;
+
+    PDEVICE_OBJECT  DeviceObject;
+    PFILE_OBJECT    FileObject;
+} IO_STACK_LOCATION, *PIO_STACK_LOCATION;
+
+typedef struct _IRP_FLAGS
+{
+    DWORD           Completed       :  1;
+    DWORD           Asynchronous    :  1;
+    DWORD           Reserved        : 30;
+} IRP_FLAGS, *PIRP_FLAGS;
+
+typedef struct _IO_STATUS_BLOCK
+{
+    QWORD           Information;
+    STATUS          Status;
+} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+typedef struct _IRP
+{
+    PVOID               Buffer;
+    IO_STATUS_BLOCK     IoStatus;
+    IRP_FLAGS           Flags;
+    BYTE                CurrentStackLocation;
+
+    struct _MDL*        Mdl;
+
+    IO_STACK_LOCATION   StackLocations[0];
+} IRP, *PIRP;
+
+typedef struct _MDL_TRANSLATION_PAIR
+{
+    PHYSICAL_ADDRESS    Address;
+    DWORD               NumberOfBytes;
+} MDL_TRANSLATION_PAIR, *PMDL_TRANSLATION_PAIR;
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+typedef
+_Struct_size_bytes_(sizeof(MDL) + NumberOfTranslationPairs * sizeof(MDL_TRANSLATION_PAIR))
+struct _MDL
+{
+    PBYTE                       StartVa;
+
+    DWORD                       ByteCount;
+    DWORD                       ByteOffset;
+
+    DWORD                       NumberOfTranslationPairs;
+
+    MDL_TRANSLATION_PAIR        Translations[0];
+} MDL, *PMDL;
+
+typedef
+STATUS
+(__cdecl FUNC_DriverDispatch)(
+    INOUT       PDEVICE_OBJECT      DeviceObject,
+    INOUT       PIRP                Irp
+    );
+
+typedef FUNC_DriverDispatch*        PFUNC_DriverDispatch;
+
+typedef struct _DRIVER_OBJECT
+{
+    PVOID                   DriverExtension;
+    char*                   DriverName;
+
+    DWORD                   NoOfDevices;
+    LIST_ENTRY              DeviceList;
+
+    LIST_ENTRY              NextDriver;
+
+    PFUNC_DriverDispatch    DispatchFunctions[IRP_MJ_MAX];
+} DRIVER_OBJECT, *PDRIVER_OBJECT;
+
+typedef
+STATUS
+(__cdecl FUNC_DriverEntry)(
+    INOUT       PDRIVER_OBJECT      DriverObject
+    );
+
+typedef FUNC_DriverEntry*           PFUNC_DriverEntry;
+
+/////////////////////////////////////////////////////////////////////////////////////////////////
+/////////                        IRP_MJ_DEVICE_CONTROL                                  /////////
+/////////////////////////////////////////////////////////////////////////////////////////////////
+
+#pragma warning(disable:4200)
+
+// IOCTL_DISK_GET_LENGTH_INFO
+typedef struct _GET_LENGTH_INFORMATION
+{
+    QWORD           Length;
+} GET_LENGTH_INFORMATION, *PGET_LENGTH_INFORMATION;
+
+#define PARTITION_TYPE_NTFS                         0x7
+#define PARTITION_TYPE_FAT_CHS                      0xB
+#define PARTITION_TYPE_FAT_LBA                      0xC
+#define PARTITION_TYPE_FAT16_LBA                    0xE
+#define PARTITION_TYPE_LINUX_SWAP                   0x82
+#define PARTITION_TYPE_LINUX_NATIVE                 0x83
+#define PARTITION_TYPE_MICROSOFT_PROTECTIVE_MBR     0xEE
+#define PARTITION_TYPE_INTEL_PROTECTIVE_MBR         0xEF
+
+// IOCTL_VOLUME_PARTITION_INFO
+typedef struct _PARTITION_INFORMATION
+{
+    QWORD           OffsetInDisk;
+
+    // Partition size in sectors
+    QWORD           PartitionSize;
+    BYTE            PartitionType;
+    BOOLEAN         Bootable;
+} PARTITION_INFORMATION, *PPARTITION_INFORMATION;
+
+// IOCTL_DISK_LAYOUT_INFO
+typedef
+_Struct_size_bytes_(sizeof(DISK_LAYOUT_INFORMATION) + NumberOfPartitions * sizeof(PARTITION_INFORMATION))
+struct _DISK_LAYOUT_INFORMATION
+{
+    DWORD                   NumberOfPartitions;
+    PARTITION_INFORMATION   Partitions[0];
+} DISK_LAYOUT_INFORMATION, *PDISK_LAYOUT_INFORMATION;
+
+
+// IOCTL_NET_RECEIVE_FRAME
+typedef struct _NET_RECEIVE_FRAME_OUTPUT
+{
+    ETHERNET_FRAME          Buffer;
+} NET_RECEIVE_FRAME_OUTPUT, *PNET_RECEIVE_FRAME_OUTPUT;
+
+typedef struct _NET_GET_SET_PHYSICAL_ADDRESS
+{
+    MAC_ADDRESS             Address;
+} NET_GET_SET_PHYSICAL_ADDRESS, *PNET_GET_SET_PHYSICAL_ADDRESS;
+
+typedef struct _NET_GET_SET_DEVICE_STATUS
+{
+    NETWORK_DEVICE_STATUS   DeviceStatus;
+} NET_GET_SET_DEVICE_STATUS, *PNET_GET_SET_DEVICE_STATUS;
+
+typedef struct _NET_GET_LINK_STATUS
+{
+    BOOLEAN                 LinkUp;
+} NET_GET_LINK_STATUS, *PNET_GET_LINK_STATUS;
+
+#define IOCTL_DISK_GET_LENGTH_INFO          0x0
+#define IOCTL_DISK_LAYOUT_INFO              0x1
+#define IOCTL_VOLUME_PARTITION_INFO         0x2
+#define IOCTL_NET_RECEIVE_FRAME             0x3
+#define IOCTL_NET_GET_PHYSICAL_ADDRESS      0x4
+#define IOCTL_NET_SET_PHYSICAL_ADDRESS      0x5
+#define IOCTL_NET_SEND_FRAME                0x6
+#define IOCTL_NET_GET_DEVICE_STATUS         0x7
+#define IOCTL_NET_SET_DEVICE_STATUS         0x8
+#define IOCTL_NET_GET_LINK_STATUS           0x9
+
+// end of common packing
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/shared/kernel/log.h b/src_proiect/shared/kernel/log.h
new file mode 100644
index 0000000..fc96838
--- /dev/null
+++ b/src_proiect/shared/kernel/log.h
@@ -0,0 +1,187 @@
+#pragma once
+
+#include "native/string.h"
+#include "cpu.h"
+//#define NO_COMM
+
+#ifndef NO_COMM
+
+#define LOG_ATC(lvl,comp,buf,...)               LogEx((lvl),(comp),buf,__VA_ARGS__)
+
+#define LOG_AT(lvl,buf,...)                     LOG_ATC((lvl),LogComponentGeneric,(buf),__VA_ARGS__)
+#define LOG_ATLC(lvl,comp,buf,...)              LOG_ATC((lvl),(comp),"[%s][%d]"##buf, strrchr(__FILE__,'\\') + 1, __LINE__, __VA_ARGS__)
+
+#define LOG(buf,...)                            LOG_AT(LogLevelInfo, buf, __VA_ARGS__)
+#define LOGP(buf,...)                           LOG_AT(LogLevelInfo, "[CPU:%02x]"##buf, CpuGetApicId(), __VA_ARGS__ )
+#define LOGP_WARNING(buf,...)                   LOG_ATLC(LogLevelWarning, LogComponentGeneric, "[CPU:%02x]"##buf, CpuGetApicId(), __VA_ARGS__ )
+#define LOGP_ERROR(buf,...)                     LOG_ATLC(LogLevelError, LogComponentGeneric, "[CPU:%02x]"##buf, CpuGetApicId(), __VA_ARGS__ )
+
+#define LOGL(buf,...)                           LOG_ATLC( LogLevelInfo, LogComponentGeneric, buf, __VA_ARGS__ )
+#define LOGPL(buf,...)                          LOG_ATLC( LogLevelInfo, LogComponentGeneric, "[CPU:%02x]"##buf, CpuGetApicId(), __VA_ARGS__ )
+#define LOGTPL(buf,...)                         LOGPL("[TH:%s]"##buf, ThreadGetName(NULL), __VA_ARGS__)
+
+#define LOG_TRACE(buf,...)                      LOG_ATLC( LogLevelTrace, LogComponentGeneric, "[CPU:%02x]"##buf, CpuGetApicId(), __VA_ARGS__ )
+#define LOG_TRACE_COMP(comp,buf,...)            LOG_ATLC( LogLevelTrace, (comp), "[CPU:%02x][" #comp "]" ##buf, CpuGetApicId(), __VA_ARGS__ )
+
+#define LOG_TRACE_IO(buf,...)                   LOG_TRACE_COMP(LogComponentIo, buf, __VA_ARGS__ )
+#define LOG_TRACE_EXCEPTION(buf,...)            LOG_TRACE_COMP(LogComponentException, buf, __VA_ARGS__ )
+#define LOG_TRACE_INTERRUPT(buf,...)            LOG_TRACE_COMP(LogComponentInterrupt, buf, __VA_ARGS__ )
+#define LOG_TRACE_VMM(buf,...)                  LOG_TRACE_COMP(LogComponentVmm, buf, __VA_ARGS__ )
+#define LOG_TRACE_MMU(buf,...)                  LOG_TRACE_COMP(LogComponentMmu, buf, __VA_ARGS__ )
+#define LOG_TRACE_CPU(buf,...)                  LOG_TRACE_COMP(LogComponentCpu, buf, __VA_ARGS__ )
+#define LOG_TRACE_ACPI(buf,...)                 LOG_TRACE_COMP(LogComponentAcpi, buf, __VA_ARGS__ )
+#define LOG_TRACE_THREAD(buf,...)               LOG_TRACE_COMP(LogComponentThread, buf, __VA_ARGS__ )
+#define LOG_TRACE_STORAGE(buf,...)              LOG_TRACE_COMP(LogComponentStorage, buf, __VA_ARGS__ )
+#define LOG_TRACE_FILESYSTEM(buf,...)           LOG_TRACE_COMP(LogComponentFileSystem, buf, __VA_ARGS__ )
+#define LOG_TRACE_NETWORK(buf,...)              LOG_TRACE_COMP(LogComponentNetwork, buf, __VA_ARGS__ )
+#define LOG_TRACE_USERMODE(buf,...)             LOG_TRACE_COMP(LogComponentUserMode, buf, __VA_ARGS__ )
+#define LOG_TRACE_PROCESS(buf,...)              LOG_TRACE_COMP(LogComponentProcess, buf, __VA_ARGS__)
+#define LOG_TRACE_PCI(buf,...)                  LOG_TRACE_COMP(LogComponentPci, buf, __VA_ARGS__)
+
+#define LOG_WARNING(buf,...)                    LOG_ATLC( LogLevelWarning, LogComponentGeneric, buf, __VA_ARGS__ )
+
+#define LOG_ERROR(buf,...)                      LOG_ATLC( LogLevelError, LogComponentGeneric, buf, __VA_ARGS__ )
+#define LOG_FUNC_ERROR(func,status)             LOG_ERROR("Function %s failed with status 0x%x\n", (func), (status) )
+#define LOG_FUNC_ERROR_ALLOC(func,size)         LOG_ERROR("Function %s failed alloc for size 0x%x\n", (func), (size))
+
+#define LOG_FUNC_START                          LOG_TRACE("Entering function %s\n", __FUNCTION__)
+#define LOG_FUNC_END                            LOG_TRACE("Leaving function %s\n", __FUNCTION__)
+
+#define LOG_FUNC_START_CPU                      LOG_FUNC_START
+#define LOG_FUNC_END_CPU                        LOG_FUNC_END
+
+#define LOG_FUNC_START_THREAD                   LOG_TRACE("[TH:%s]Entering function %s\n", ThreadGetName(NULL), __FUNCTION__)
+#define LOG_FUNC_END_THREAD                     LOG_TRACE("[TH:%s]Leaving function %s\n", ThreadGetName(NULL), __FUNCTION__)
+#else
+#define LOG_AT(lvl,buf,...)
+#define LOG_ATL(lvl,buf,...)
+
+#define LOG(buf,...)
+#define LOGP(buf,...)
+#define LOGP_ERROR(buf,...)
+
+#define LOGL(buf,...)
+#define LOGPL(buf,...)
+#define LOGTPL(buf,...)
+
+#define LOG_TRACE(buf,...)
+#define LOG_TRACE_COMP(comp,buf,...)
+
+#define LOG_TRACE_IO(buf,...)
+#define LOG_TRACE_EXCEPTION(buf,...)
+#define LOG_TRACE_INTERRUPT(buf,...)
+#define LOG_TRACE_VMM(buf,...)
+#define LOG_TRACE_MMU(buf,...)
+#define LOG_TRACE_CPU(buf,...)
+#define LOG_TRACE_ACPI(buf,...)
+#define LOG_TRACE_THREAD(buf,...)
+#define LOG_TRACE_STORAGE(buf,...)
+#define LOG_TRACE_FILESYSTEM(buf,...)
+#define LOG_TRACE_NETWORK(buf,...)
+#define LOG_TRACE_USERMODE(buf,...)
+#define LOG_TRACE_PROCESS(buf,...)
+#define LOG_TRACE_PCI(buf,...)
+
+#define LOG_WARNING(buf,...)
+
+#define LOG_ERROR(buf,...)
+#define LOG_FUNC_ERROR(func,status)
+#define LOG_FUNC_ERROR_ALLOC(func,size)
+
+#define LOG_FUNC_START
+#define LOG_FUNC_END
+
+#define LOG_FUNC_START_CPU
+#define LOG_FUNC_END_CPU
+
+#define LOG_FUNC_START_THREAD
+#define LOG_FUNC_END_THREAD
+
+#endif
+
+typedef enum _LOG_LEVEL
+{
+    LogLevelTrace,
+    LogLevelInfo,
+    LogLevelWarning,
+    LogLevelError
+} LOG_LEVEL;
+STATIC_ASSERT_INFO(sizeof(LOG_LEVEL) == sizeof(DWORD), "We are using _InterlockedExchange for levels!");
+
+typedef enum _LOG_COMPONENT
+{
+    LogComponentGeneric     = 0b0000'0000'0000'0000'0000'0000'0000'0001,
+    LogComponentIo          = 0b0000'0000'0000'0000'0000'0000'0000'0010,
+    LogComponentException   = 0b0000'0000'0000'0000'0000'0000'0000'0100,
+    LogComponentInterrupt   = 0b0000'0000'0000'0000'0000'0000'0000'1000,
+    LogComponentVmm         = 0b0000'0000'0000'0000'0000'0000'0001'0000,
+    LogComponentMmu         = 0b0000'0000'0000'0000'0000'0000'0010'0000,
+    LogComponentCpu         = 0b0000'0000'0000'0000'0000'0000'0100'0000,
+    LogComponentAcpi        = 0b0000'0000'0000'0000'0000'0000'1000'0000,
+    LogComponentThread      = 0b0000'0000'0000'0000'0000'0001'0000'0000,
+    LogComponentStorage     = 0b0000'0000'0000'0000'0000'0010'0000'0000,
+    LogComponentFileSystem  = 0b0000'0000'0000'0000'0000'0100'0000'0000,
+    LogComponentNetwork     = 0b0000'0000'0000'0000'0000'1000'0000'0000,
+    LogComponentUserMode    = 0b0000'0000'0000'0000'0001'0000'0000'0000,
+    LogComponentProcess     = 0b0000'0000'0000'0000'0010'0000'0000'0000,
+    LogComponentPci         = 0b0000'0000'0000'0000'0100'0000'0000'0000,
+    LogComponentTest        = 0b0000'0000'0000'0000'1000'0000'0000'0000,
+
+    LogComponentAll         = 0b1111'1111'1111'1111'1111'1111'1111'1111
+} _Enum_is_bitflag_ LOG_COMPONENT;
+STATIC_ASSERT_INFO(sizeof(LOG_COMPONENT) == sizeof(DWORD), "We are using _InterlockedExchange for components!");
+
+_No_competing_thread_
+void
+LogSystemPreinit(
+    void
+    );
+
+_No_competing_thread_
+void
+LogSystemInit(
+    IN _Strict_type_match_
+                LOG_LEVEL       LogLevel,
+    IN
+                LOG_COMPONENT   LogComponenets,
+    IN          BOOLEAN         Enable
+    );
+
+#define Log(lvl,buf,...)        LogEx((lvl),LogComponentGeneric,(buf), __VA_ARGS__)
+
+void
+LogEx(
+    IN _Strict_type_match_
+                LOG_LEVEL       LogLevel,
+    IN
+                LOG_COMPONENT   LogComponent,
+    IN_Z        char*           FormatBuffer,
+    ...
+    );
+
+BOOLEAN
+LogSetState(
+    IN          BOOLEAN     Enable
+    );
+
+LOG_LEVEL
+LogGetLevel(
+    void
+    );
+
+LOG_LEVEL
+LogSetLevel(
+    IN          LOG_LEVEL   NewLogLevel
+    );
+
+LOG_COMPONENT
+LogGetTracedComponents(
+    void
+    );
+
+LOG_COMPONENT
+LogSetTracedComponents(
+    IN          LOG_COMPONENT   Components
+    );
+
+#define LogIsComponentTraced(Comp)      (LogGetLevel() <= LogLevelTrace && IsFlagOn(LogGetTracedComponents(), (Comp)))
diff --git a/src_proiect/shared/kernel/network.h b/src_proiect/shared/kernel/network.h
new file mode 100644
index 0000000..99087de
--- /dev/null
+++ b/src_proiect/shared/kernel/network.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include "network_packets.h"
+#include "network_device.h"
+
+STATUS
+NetSendFrame(
+    IN                      BOOLEAN         SendOnAllInterfaces,
+    _When_(SendOnAllInterfaces, _Reserved_)
+    _When_(!SendOnAllInterfaces, IN)
+                            DEVICE_ID       DeviceId,
+    IN_READS_BYTES(Size)    PVOID           Buffer,
+    IN                      DWORD           Size,
+    IN                      MAC_ADDRESS     DestinationAddress
+    );
+
+STATUS
+NetReceiveFrame(
+    IN                      DEVICE_ID       DeviceId,
+    OUT_WRITES_BYTES(Size)  PVOID           Buffer,
+    IN                      DWORD           Size,
+    OUT                     DWORD*          BytesWritten
+    );
+
+STATUS
+NetGetNetworkDevices(
+    OUT_WRITES_OPT(*NumberOfDevices)
+                    PNETWORK_DEVICE_INFO            DeviceObjects,
+    _When_(NULL == DeviceObjects, OUT)
+    _When_(NULL != DeviceObjects, INOUT)
+                    DWORD*                          NumberOfDevices
+    );
+
+STATUS
+NetChangeDeviceStatus(
+    IN              DEVICE_ID                       DeviceId,
+    IN              PNETWORK_DEVICE_STATUS          DeviceStatus
+    );
+
+STATUS
+NetGetNetworkDeviceStatistics(
+    IN              DEVICE_ID                       DeviceId,
+    OUT             PNETWORK_DEVICE_STATS           Statistics
+    );
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/network_device.h b/src_proiect/shared/kernel/network_device.h
new file mode 100644
index 0000000..7fbaaa6
--- /dev/null
+++ b/src_proiect/shared/kernel/network_device.h
@@ -0,0 +1,33 @@
+#pragma once
+
+typedef DWORD DEVICE_ID;
+
+typedef struct _NETWORK_DEVICE_STATUS
+{
+    BOOLEAN                         RxEnabled;
+    BOOLEAN                         TxEnabled;
+} NETWORK_DEVICE_STATUS, *PNETWORK_DEVICE_STATUS;
+
+typedef struct _NETWORK_DEVICE_INFO
+{
+    DEVICE_ID               DeviceId;
+
+    MAC_ADDRESS             PhysicalAddress;
+
+    NETWORK_DEVICE_STATUS   DeviceStatus;
+    BOOLEAN                 LinkStatus;
+} NETWORK_DEVICE_INFO, *PNETWORK_DEVICE_INFO;
+
+typedef struct _NETWORK_FRAME_STATS
+{
+    QWORD                   NumberOfFrames;
+    QWORD                   TotalBytes;
+    QWORD                   SmallestPacket;
+    QWORD                   LargestPacket;
+} NETWORK_FRAME_STATS, *PNETWORK_FRAME_STATS;
+
+typedef struct _NETWORK_DEVICE_STATS
+{
+    NETWORK_FRAME_STATS     RxStats;
+    NETWORK_FRAME_STATS     TxStats;
+} NETWORK_DEVICE_STATS, *PNETWORK_DEVICE_STATS;
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/network_packets.h b/src_proiect/shared/kernel/network_packets.h
new file mode 100644
index 0000000..8d41cbe
--- /dev/null
+++ b/src_proiect/shared/kernel/network_packets.h
@@ -0,0 +1,204 @@
+#pragma once
+
+#pragma pack(push,1)
+
+#pragma warning(push)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+// warning C4200: nonstandard extension used: zero-sized array in struct/union
+#pragma warning(disable:4200)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                               Address Types                             ///////
+//////////////////////////////////////////////////////////////////////////////////////
+#define MAC_ADDRESS_SIZE            6
+#define IP4_ADDRESS_SIZE            4
+#define IP6_ADDRESS_SIZE            16
+
+typedef struct _MAC_ADDRESS
+{
+    BYTE                    Value[MAC_ADDRESS_SIZE];
+} MAC_ADDRESS, *PMAC_ADDRESS;
+STATIC_ASSERT(sizeof(MAC_ADDRESS) == MAC_ADDRESS_SIZE );
+
+extern const MAC_ADDRESS MAC_BROADCAST;
+
+typedef union _IP4_ADDRESS
+{
+    struct
+    {
+        BYTE                ByteAddress[IP4_ADDRESS_SIZE];
+    };
+    DWORD                   DwordAddress;
+} IP4_ADDRESS, *PIP4_ADDRESS;
+STATIC_ASSERT(sizeof(IP4_ADDRESS) == IP4_ADDRESS_SIZE);
+
+typedef struct _IP6_ADDRESS
+{
+    BYTE            Address[IP6_ADDRESS_SIZE];
+} IP6_ADDRESS, *PIP6_ADDRESS;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                             Layer 2 Structures                          ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+#define ETHERNET_FRAME_SIZE                 14
+#define ARP_PACKET_SIZE                     28
+#define IEEE_802_3_MINIMUM_FRAME_SIZE       64
+
+typedef WORD        ETHERNET_FRAME_TYPE;
+
+#define ETHERNET_FRAME_TYPE_IP4         __pragma(warning(suppress: 4310)) ((WORD)0x0800ui16)
+#define ETHERNET_FRAME_TYPE_ARP         __pragma(warning(suppress: 4310)) ((WORD)0x0806ui16)
+#define ETHERNET_FRAME_TYPE_RARP        __pragma(warning(suppress: 4310)) ((WORD)0x8035ui16)
+#define ETHERNET_FRAME_TYPE_VLAN        __pragma(warning(suppress: 4310)) ((WORD)0x8100ui16)
+#define ETHERNET_FRAME_TYPE_IP6         __pragma(warning(suppress: 4310)) ((WORD)0x86DDui16)
+#define ETHERNET_FRAME_TYPE_LLDP        __pragma(warning(suppress: 4310)) ((WORD)0x88CCui16)
+
+typedef struct _ETHERNET_FRAME
+{
+    MAC_ADDRESS             Destination;
+    MAC_ADDRESS             Source;
+
+    ETHERNET_FRAME_TYPE     Type;
+    BYTE                    Data[0];
+} ETHERNET_FRAME, *PETHERNET_FRAME;
+STATIC_ASSERT(sizeof(ETHERNET_FRAME) == ETHERNET_FRAME_SIZE);
+
+typedef WORD        HARDWARE_TYPE;
+
+#define HARDWARE_TYPE_ETHERNET          1
+
+typedef WORD        ARP_OPERATION;
+
+#define ARP_OPERATION_REQUEST           1
+#define ARP_OPERATION_REPLY             2
+
+typedef struct _ARP_PACKET
+{
+    HARDWARE_TYPE           HardwareType;
+
+    ETHERNET_FRAME_TYPE     ProtocolType;
+
+    BYTE                    HardwareAddressLength;
+    BYTE                    ProtocolAddressLength;
+
+    ARP_OPERATION           Operation;
+
+    MAC_ADDRESS             SenderHardwareAddress;
+    IP4_ADDRESS             SenderProtocolAddress;
+
+    MAC_ADDRESS             TargetHardwareAddress;
+    IP4_ADDRESS             TargetProtocolAddress;
+} ARP_PACKET, *PARP_PACKET;
+STATIC_ASSERT(sizeof(ARP_PACKET) == ARP_PACKET_SIZE);
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                             Layer 3 Structures                          ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+#define IP4_PACKET_SIZE             20
+#define IP6_PACKET_SIZE             40
+
+typedef BYTE        IP_PROTOCOL;
+
+#define IP_PROTOCOL_ICMP                1
+#define IP_PROTOCOL_IGMP                2
+#define IP_PROTOCOL_TCP                 6
+#define IP_PROTOCOL_UDP                 17
+
+typedef struct _IP4_PACKET
+{
+    // size in DWORDs
+    BYTE            InternetHeaderLength    : 4;
+
+    BYTE            Version                 : 4;
+
+    BYTE            QoS;
+
+    WORD            Length;
+
+    WORD            Id;
+
+    WORD            __Reserved0;
+
+    BYTE            TimeToLive;
+
+    IP_PROTOCOL     Protocol;
+
+    WORD            Checksum;
+
+    IP4_ADDRESS     Source;
+
+    IP4_ADDRESS     Destination;
+} IP4_PACKET, *PIP4_PACKET;
+STATIC_ASSERT(sizeof(IP4_PACKET) == IP4_PACKET_SIZE);
+
+typedef struct _IP6_PACKET
+{
+    DWORD           Version                 : 4;
+    DWORD           TrafficClass            : 8;
+    DWORD           FlowLabel               : 20;
+
+    WORD            PayloadLength;
+    BYTE            NextHeader;
+    BYTE            HopLimit;
+    IP6_ADDRESS     Source;
+    IP6_ADDRESS     Destination;
+} IP6_PACKET, *PIP6_PACKET;
+STATIC_ASSERT(sizeof(IP6_PACKET) == IP6_PACKET_SIZE);
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////                             Layer 4 Structures                          ///////
+//////////////////////////////////////////////////////////////////////////////////////
+
+#define UDP_DATAGRAM_SIZE               8
+#define TCP_SEGMENT_SIZE                20
+
+typedef WORD    PORT_NUMBER;
+
+typedef struct _UDP_DATAGRAM
+{
+    PORT_NUMBER         Source;
+    PORT_NUMBER         Destination;
+    WORD                Length;
+    WORD                Checksum;
+} UDP_DATAGRAM, *PUDP_DATAGRAM;
+STATIC_ASSERT(sizeof(UDP_DATAGRAM) == UDP_DATAGRAM_SIZE);
+
+typedef struct _TCP_SEGMENT
+{
+    PORT_NUMBER         Source;
+    PORT_NUMBER         Destination;
+    DWORD               SequenceNumber;
+    DWORD               AckNumber;
+    struct
+    {
+        // 1st byte
+        BYTE            CWR             : 1;
+        BYTE            ECE             : 1;
+        BYTE            URG             : 1;
+        BYTE            ACK             : 1;
+        BYTE            PSH             : 1;
+        BYTE            RST             : 1;
+        BYTE            SYN             : 1;
+        BYTE            FIN             : 1;
+
+        // 2nd byte
+        BYTE            DataOffset      : 4;
+        BYTE            __Reserved0     : 3;
+        BYTE            NS              : 1;
+    };
+    WORD                WindowSize;
+    WORD                Checksum;
+    WORD                UrgentPointer;
+} TCP_SEGMENT, *PTCP_SEGMENT;
+STATIC_ASSERT(sizeof(TCP_SEGMENT) == TCP_SEGMENT_SIZE);
+
+#pragma warning(pop)
+#pragma pack(pop)
diff --git a/src_proiect/shared/kernel/network_utils.h b/src_proiect/shared/kernel/network_utils.h
new file mode 100644
index 0000000..d80bb0d
--- /dev/null
+++ b/src_proiect/shared/kernel/network_utils.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "network.h"
+
+#define TEXT_MAC_ADDRESS_CHARS_REQUIRED             18
+#define TEXT_IP4_ADDRESS_CHARS_REQUIRED             16
+#define TEXT_IP6_ADDRESS_CHARS_REQUIRED             40
+
+char*
+NetUtilMacAddressToText(
+    IN                                                          MAC_ADDRESS         Address,
+    OUT_WRITES_BYTES_ALL(TEXT_MAC_ADDRESS_CHARS_REQUIRED)       char*               Buffer
+    );
+
+char*
+NetUtilIp4AddressToText(
+    IN                                                          IP4_ADDRESS         Address,
+    OUT_WRITES_BYTES_ALL(TEXT_IP4_ADDRESS_CHARS_REQUIRED)       char*               Buffer
+    );
\ No newline at end of file
diff --git a/src_proiect/shared/kernel/pci_system.h b/src_proiect/shared/kernel/pci_system.h
new file mode 100644
index 0000000..58fa40f
--- /dev/null
+++ b/src_proiect/shared/kernel/pci_system.h
@@ -0,0 +1,109 @@
+#pragma once
+
+#include "pci_device.h"
+#include "list.h"
+
+#pragma warning(push)
+
+// warning C4214: nonstandard extension used: bit field types other than int
+#pragma warning(disable:4214)
+
+// warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable:4201)
+
+typedef struct _PCI_DEVICE_LIST_ENTRY
+{
+    LIST_ENTRY              ListEntry;
+    PCI_DEVICE_DESCRIPTION  PciDevice;
+
+    // valid only for bridges
+    LIST_ENTRY              BridgeEntry;
+} PCI_DEVICE_LIST_ENTRY, *PPCI_DEVICE_LIST_ENTRY;
+
+
+typedef struct _PCI_DESCRIPTION
+{
+    WORD    VendorId;
+    WORD    DeviceId;
+    BYTE    Subclass;
+    BYTE    ClassCode;
+} PCI_DESCRIPTION, *PPCI_DESCRIPTION;
+
+typedef struct _PCI_SPEC
+{
+    PCI_DESCRIPTION     Description;
+
+    BOOLEAN             MatchClass      : 1;
+    BOOLEAN             MatchSubclass   : 1;
+    BOOLEAN             MatchVendor     : 1;
+    BOOLEAN             MatchDevice     : 1;
+} PCI_SPEC, *PPCI_SPEC;
+
+typedef struct _PCI_SPEC_LOCATION
+{
+    PCI_DEVICE_LOCATION Location;
+
+    BOOLEAN             MatchBus        : 1;
+    BOOLEAN             MatchDevice     : 1;
+    BOOLEAN             MatchFunction   : 1;
+} PCI_SPEC_LOCATION, *PPCI_SPEC_LOCATION;
+#pragma warning(pop)
+
+void
+PciSystemPreinit(
+    void
+    );
+
+STATUS
+PciSystemInit(
+    void
+    );
+
+STATUS
+PciSystemRetrieveDevices(
+    INOUT   PLIST_ENTRY     PciDeviceList
+    );
+
+void
+PciSystemEstablishHierarchy(
+    IN      PLIST_ENTRY     PciDeviceList,
+    INOUT   PLIST_ENTRY     PciBridgeList
+    );
+
+STATUS
+PciSystemFindDevicesMatchingSpecification(
+    IN      PLIST_ENTRY     PciDeviceList,
+    IN      PCI_SPEC        Specification,
+    OUT_WRITES_OPT(*NumberOfDevices)
+            PPCI_DEVICE_DESCRIPTION*    PciDevices,
+    _When_(NULL == PciDevices, OUT)
+    _When_(NULL != PciDevices, INOUT)
+            DWORD*          NumberOfDevices
+    );
+
+STATUS
+PciSystemFindDevicesMatchingLocation(
+    IN      PLIST_ENTRY                 PciDeviceList,
+    IN      PCI_SPEC_LOCATION           Specification,
+    OUT_WRITES_OPT(*NumberOfDevices)
+            PPCI_DEVICE_DESCRIPTION*    PciDevices,
+    _When_(NULL == PciDevices, OUT)
+    _When_(NULL != PciDevices, INOUT)
+            DWORD*                      NumberOfDevices
+    );
+
+STATUS
+PciSystemReadConfigurationSpaceGeneric(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      BYTE                    Width,
+    OUT     QWORD*                  Value
+    );
+
+STATUS
+PciSystemWriteConfigurationSpaceGeneric(
+    IN      PCI_DEVICE_LOCATION     DeviceLocation,
+    IN      WORD                    Register,
+    IN      BYTE                    Width,
+    IN      QWORD                   Value
+    );
diff --git a/src_proiect/shared/kernel/thread.h b/src_proiect/shared/kernel/thread.h
new file mode 100644
index 0000000..05efb4a
--- /dev/null
+++ b/src_proiect/shared/kernel/thread.h
@@ -0,0 +1,121 @@
+#pragma once
+
+#include "thread_defs.h"
+
+//******************************************************************************
+// Function:     ThreadCreate
+// Description:  Spawns a new thread named Name with priority Function which
+//               will execute the function Function which will receive as its
+//               single parameter Context. The function returns a pointer
+//               (handle) to the thread structure.
+// Returns:      STATUS
+// Parameter:    IN_Z char * Name
+// Parameter:    IN THREAD_PRIORITY Priority
+// Parameter:    IN PFUNC_ThreadStart Function
+// Parameter:    IN_OPT PVOID Context
+// Parameter:    OUT_PTR PTHREAD * Thread
+// NOTE:         The thread may terminate at any time, but its data structure
+//               will not be un-allocated until the handle receive in Thread is
+//               closed with ThreadCloseHandle.
+//******************************************************************************
+STATUS
+ThreadCreate(
+    IN_Z        char*               Name,
+    IN          THREAD_PRIORITY     Priority,
+    IN          PFUNC_ThreadStart   Function,
+    IN_OPT      PVOID               Context,
+    OUT_PTR     PTHREAD*            Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadYield
+// Description:  Yields the CPU to the scheduler, which picks a new thread to
+//               run. The new thread might be the current thread, so you can't
+//               depend on this function to keep this thread from running for
+//               any particular length of time.
+// Returns:      void
+// Parameter:    void
+//******************************************************************************
+void
+ThreadYield(
+    void
+    );
+
+//******************************************************************************
+// Function:     ThreadExit
+// Description:  Causes the current thread to exit. Never returns.
+// Returns:      void
+// Parameter:    IN STATUS ExitStatus
+//******************************************************************************
+void
+ThreadExit(
+    IN      STATUS              ExitStatus
+    );
+
+//******************************************************************************
+// Function:     ThreadWaitForTermination
+// Description:  Waits for a thread to terminate. The exit status of the thread
+//               will be placed in ExitStatus.
+// Returns:      void
+// Parameter:    IN PTHREAD Thread
+// Parameter:    OUT STATUS * ExitStatus
+//******************************************************************************
+void
+ThreadWaitForTermination(
+    IN      PTHREAD             Thread,
+    OUT     STATUS*             ExitStatus
+    );
+
+//******************************************************************************
+// Function:     ThreadCloseHandle
+// Description:  Closes a thread handle received from ThreadCreate. This is
+//               necessary for the structure to be destroyed when it is no
+//               longer needed.
+// Returns:      void
+// Parameter:    INOUT PTHREAD Thread
+// NOTE:         If you need to wait for a thread to terminate or find out its
+//               termination status call this function only after you called
+//               ThreadWaitForTermination.
+//******************************************************************************
+void
+ThreadCloseHandle(
+    INOUT   PTHREAD             Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadGetName
+// Description:  Returns the thread's name.
+// Returns:      const char*
+// Parameter:    IN_OPT PTHREAD Thread If NULL returns the name of the
+//               current thread.
+//******************************************************************************
+const
+char*
+ThreadGetName(
+    IN_OPT  PTHREAD             Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadGetId
+// Description:  Returns the thread's ID.
+// Returns:      TID
+// Parameter:    IN_OPT PTHREAD Thread - If NULL returns the ID of the
+//               current thread.
+//******************************************************************************
+TID
+ThreadGetId(
+    IN_OPT  PTHREAD             Thread
+    );
+
+//******************************************************************************
+// Function:     ThreadGetPriority
+// Description:  Returns the thread's priority. In the presence of
+//               priority donation, returns the higher(donated) priority.
+// Returns:      THREAD_PRIORITY
+// Parameter:    IN_OPT PTHREAD Thread - If NULL returns the priority of the
+//               current thread.
+//******************************************************************************
+THREAD_PRIORITY
+ThreadGetPriority(
+    IN_OPT  PTHREAD             Thread
+    );
